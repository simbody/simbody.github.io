<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::UnitVec&lt; P, S &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1UnitVec.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1UnitVec-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::UnitVec&lt; P, S &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class is a Vec3 plus an ironclad guarantee either that:  
 <a href="classSimTK_1_1UnitVec.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::UnitVec&lt; P, S &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1UnitVec.png" usemap="#SimTK::UnitVec_3C_20P_2C_20S_20_3E_map" alt=""/>
  <map id="SimTK::UnitVec_3C_20P_2C_20S_20_3E_map" name="SimTK::UnitVec_3C_20P_2C_20S_20_3E_map">
<area href="classSimTK_1_1Vec.html" alt="SimTK::Vec&lt; 3, P, S &gt;" shape="rect" coords="0,0,146,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc8a07343261e22409fc61416f549c6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a></td></tr>
<tr class="separator:abc8a07343261e22409fc61416f549c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a0813acda5a13e55b70a419f86a365"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt; P, S &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a></td></tr>
<tr class="separator:a00a0813acda5a13e55b70a419f86a365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1Vec"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1Vec')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec&lt; 3, P, S &gt;</a></td></tr>
<tr class="memitem:ac68d02035e9fb29b2b7c810a8d3554fc inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><tr class="memdesc:ac68d02035e9fb29b2b7c810a8d3554fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac68d02035e9fb29b2b7c810a8d3554fc inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4f863a54b68343ab160d46a4dfa107 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef P&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a></td></tr>
<tr class="memdesc:a1c4f863a54b68343ab160d46a4dfa107 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this Vec.  <a href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">More...</a><br /></td></tr>
<tr class="separator:a1c4f863a54b68343ab160d46a4dfa107 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180db0a856dcd33f438ff607fb2d578e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a></td></tr>
<tr class="memdesc:a180db0a856dcd33f438ff607fb2d578e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated version of this Vec's element type; ENeg==negator&lt; E &gt;.  <a href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">More...</a><br /></td></tr>
<tr class="separator:a180db0a856dcd33f438ff607fb2d578e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1688fa5889391ca2510ec85af32c4d27 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a></td></tr>
<tr class="memdesc:a1688fa5889391ca2510ec85af32c4d27 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type, stripped of negator&lt;&gt; if it has one.  <a href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">More...</a><br /></td></tr>
<tr class="separator:a1688fa5889391ca2510ec85af32c4d27 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe820179fbd756adb31a21ea1635c1b inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a></td></tr>
<tr class="memdesc:a9fe820179fbd756adb31a21ea1635c1b inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing just the real part of an element of this Vec if elements are complex; otherwise just the element type.  <a href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">More...</a><br /></td></tr>
<tr class="separator:a9fe820179fbd756adb31a21ea1635c1b inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960a48f176aa0870f267e6555489969 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a></td></tr>
<tr class="memdesc:ac960a48f176aa0870f267e6555489969 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing the imaginary part of an element of this Vec as real, if elements are complex; otherwise a type that can hold a zero of the element type.  <a href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">More...</a><br /></td></tr>
<tr class="separator:ac960a48f176aa0870f267e6555489969 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7122a7babdc45b6559fcfb2bcc5ba3e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a></td></tr>
<tr class="memdesc:aa7122a7babdc45b6559fcfb2bcc5ba3e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that elements would have if complex, if E is currently real; otherwise just the element type E.  <a href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">More...</a><br /></td></tr>
<tr class="separator:aa7122a7babdc45b6559fcfb2bcc5ba3e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a6fe2fbd6109e110319dde19ef8080 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a></td></tr>
<tr class="memdesc:af1a6fe2fbd6109e110319dde19ef8080 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Hermitian transpose of an element of this Vec.  <a href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">More...</a><br /></td></tr>
<tr class="separator:af1a6fe2fbd6109e110319dde19ef8080 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf724f6707ea5d622a8218c8c7d0a47a inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">EPosTrans</a></td></tr>
<tr class="memdesc:aaf724f6707ea5d622a8218c8c7d0a47a inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a <em>positional</em> transpose of an element of this Vec.  <a href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">More...</a><br /></td></tr>
<tr class="separator:aaf724f6707ea5d622a8218c8c7d0a47a inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e03a89cd7d90f90d2b77996912f7cf3 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a></td></tr>
<tr class="memdesc:a9e03a89cd7d90f90d2b77996912f7cf3 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression ~E*E (default vector and matrix square; symmetric).  <a href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">More...</a><br /></td></tr>
<tr class="separator:a9e03a89cd7d90f90d2b77996912f7cf3 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f65810f2f99f99286c4de7526944c inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a></td></tr>
<tr class="memdesc:aed4f65810f2f99f99286c4de7526944c inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression E*~E ("row square"; symmetric).  <a href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">More...</a><br /></td></tr>
<tr class="separator:aed4f65810f2f99f99286c4de7526944c inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7edbf8f2b7e6318eb98feadb1498e6e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a></td></tr>
<tr class="memdesc:ad7edbf8f2b7e6318eb98feadb1498e6e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of sqrt(E).  <a href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">More...</a><br /></td></tr>
<tr class="separator:ad7edbf8f2b7e6318eb98feadb1498e6e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9328f6e879f0bce93ae861ed3830adfd inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a></td></tr>
<tr class="memdesc:a9328f6e879f0bce93ae861ed3830adfd inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of abs(E).  <a href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">More...</a><br /></td></tr>
<tr class="separator:a9328f6e879f0bce93ae861ed3830adfd inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc83b9c25967c098119f0e604c15e3c inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a></td></tr>
<tr class="memdesc:a0cc83b9c25967c098119f0e604c15e3c inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of standardize(E) method; a packed type that can hold the value of an element after eliminating negator and conjugate types.  <a href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">More...</a><br /></td></tr>
<tr class="separator:a0cc83b9c25967c098119f0e604c15e3c inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec08218c1b188793e64d47c3d1b8d87 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a></td></tr>
<tr class="memdesc:aeec08218c1b188793e64d47c3d1b8d87 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from invert(E), the inverse type of an element.  <a href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">More...</a><br /></td></tr>
<tr class="separator:aeec08218c1b188793e64d47c3d1b8d87 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074ef8ddf4b5863b9c9aa73d08b0b51 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a></td></tr>
<tr class="memdesc:a5074ef8ddf4b5863b9c9aa73d08b0b51 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from normalize(E).  <a href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">More...</a><br /></td></tr>
<tr class="separator:a5074ef8ddf4b5863b9c9aa73d08b0b51 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c170f161ab33a760c6abed022c4e5 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a></td></tr>
<tr class="memdesc:afb0c170f161ab33a760c6abed022c4e5 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">More...</a><br /></td></tr>
<tr class="separator:afb0c170f161ab33a760c6abed022c4e5 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa9b9db155c966ec374279b11f7ec8 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a></td></tr>
<tr class="memdesc:a43fa9b9db155c966ec374279b11f7ec8 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">More...</a><br /></td></tr>
<tr class="separator:a43fa9b9db155c966ec374279b11f7ec8 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e9c638c3725abee10ac8c0a0416938 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a></td></tr>
<tr class="memdesc:a16e9c638c3725abee10ac8c0a0416938 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">More...</a><br /></td></tr>
<tr class="separator:a16e9c638c3725abee10ac8c0a0416938 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd99fd4db282175335f6b70a09c42d3 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a></td></tr>
<tr class="memdesc:a2dd99fd4db282175335f6b70a09c42d3 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">More...</a><br /></td></tr>
<tr class="separator:a2dd99fd4db282175335f6b70a09c42d3 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a2b3875ce3ab44712d2b46c7c8c48f inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a></td></tr>
<tr class="memdesc:ab6a2b3875ce3ab44712d2b46c7c8c48f inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">More...</a><br /></td></tr>
<tr class="separator:ab6a2b3875ce3ab44712d2b46c7c8c48f inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9df16575296931169e80790f8180ee inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a></td></tr>
<tr class="memdesc:abb9df16575296931169e80790f8180ee inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">More...</a><br /></td></tr>
<tr class="separator:abb9df16575296931169e80790f8180ee inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226b3621ca279d62533bf2c2bc1494cf inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">T</a></td></tr>
<tr class="memdesc:a226b3621ca279d62533bf2c2bc1494cf inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this Vec.  <a href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">More...</a><br /></td></tr>
<tr class="separator:a226b3621ca279d62533bf2c2bc1494cf inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad810229be85191609884e56063b788ce inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a></td></tr>
<tr class="memdesc:ad810229be85191609884e56063b788ce inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type this Vec would have if its elements were interpreted as negated.  <a href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">More...</a><br /></td></tr>
<tr class="separator:ad810229be85191609884e56063b788ce inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f18f1a887b7a31eaab12703b2d56eb5 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a></td></tr>
<tr class="memdesc:a5f18f1a887b7a31eaab12703b2d56eb5 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this Vec with negator removed from its element type, if the element is negated.  <a href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">More...</a><br /></td></tr>
<tr class="separator:a5f18f1a887b7a31eaab12703b2d56eb5 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbc25b0f0f1f9226dfe5796f30d459 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a>, STRIDE *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a></td></tr>
<tr class="memdesc:aebcbc25b0f0f1f9226dfe5796f30d459 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this Vec cast to show only the real part of its element; this might affect the stride.  <a href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">More...</a><br /></td></tr>
<tr class="separator:aebcbc25b0f0f1f9226dfe5796f30d459 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a11445fddc280dd6a1b3f9a54d4d3 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a>, STRIDE *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a></td></tr>
<tr class="memdesc:acf0a11445fddc280dd6a1b3f9a54d4d3 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this Vec cast to show only the imaginary part of its element; this might affect the stride.  <a href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">More...</a><br /></td></tr>
<tr class="separator:acf0a11445fddc280dd6a1b3f9a54d4d3 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac8c95d23ac09084c957db9e0807af4 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a></td></tr>
<tr class="memdesc:a3ac8c95d23ac09084c957db9e0807af4 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">More...</a><br /></td></tr>
<tr class="separator:a3ac8c95d23ac09084c957db9e0807af4 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664440ae833e25958fb6006815b93df inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a></td></tr>
<tr class="memdesc:a1664440ae833e25958fb6006815b93df inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this Vec after casting to its Hermitian transpose; that is, the Vec turns into a Row and each element turns into <em>its</em> Hermitian transpose.  <a href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">More...</a><br /></td></tr>
<tr class="separator:a1664440ae833e25958fb6006815b93df inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c96e0dda112e02745075e8bb727651 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a></td></tr>
<tr class="memdesc:a21c96e0dda112e02745075e8bb727651 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this Vec after casting to its positional transpose; that is, the Vec turns into a Row but the element type remains unchanged.  <a href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">More...</a><br /></td></tr>
<tr class="separator:a21c96e0dda112e02745075e8bb727651 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a8e6c01acbd2f6f27769abe6f1fb8 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">TElement</a></td></tr>
<tr class="memdesc:a306a8e6c01acbd2f6f27769abe6f1fb8 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this Vec.  <a href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">More...</a><br /></td></tr>
<tr class="separator:a306a8e6c01acbd2f6f27769abe6f1fb8 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee9814da9f07edf05e10aa8bf5b52a7 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">TRow</a></td></tr>
<tr class="memdesc:adee9814da9f07edf05e10aa8bf5b52a7 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a row of this CNT object (for a Vec, just its element type).  <a href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">More...</a><br /></td></tr>
<tr class="separator:adee9814da9f07edf05e10aa8bf5b52a7 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bea93707d0d519f3bc680520ed6dba8 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">TCol</a></td></tr>
<tr class="memdesc:a3bea93707d0d519f3bc680520ed6dba8 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a column of this CNT object (for a Vec, the whole thing).  <a href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">More...</a><br /></td></tr>
<tr class="separator:a3bea93707d0d519f3bc680520ed6dba8 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d723146f29d99138956fe3b0d71ea6f inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a></td></tr>
<tr class="memdesc:a6d723146f29d99138956fe3b0d71ea6f inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">More...</a><br /></td></tr>
<tr class="separator:a6d723146f29d99138956fe3b0d71ea6f inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429ca3d609af5044f8be5243dfba714b inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a></td></tr>
<tr class="memdesc:a429ca3d609af5044f8be5243dfba714b inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">More...</a><br /></td></tr>
<tr class="separator:a429ca3d609af5044f8be5243dfba714b inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f95f01fde583b2d46c9ef7a31e582e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a></td></tr>
<tr class="memdesc:ad1f95f01fde583b2d46c9ef7a31e582e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">More...</a><br /></td></tr>
<tr class="separator:ad1f95f01fde583b2d46c9ef7a31e582e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee68a1b3427cdc2a096be35d8b3f1f6 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a></td></tr>
<tr class="memdesc:adee68a1b3427cdc2a096be35d8b3f1f6 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">More...</a><br /></td></tr>
<tr class="separator:adee68a1b3427cdc2a096be35d8b3f1f6 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4d20cd03be610a163f04985d74822d inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a></td></tr>
<tr class="memdesc:a5f4d20cd03be610a163f04985d74822d inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">More...</a><br /></td></tr>
<tr class="separator:a5f4d20cd03be610a163f04985d74822d inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba33f5ae46bd5406b8bead75d3225e08 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a></td></tr>
<tr class="memdesc:aba33f5ae46bd5406b8bead75d3225e08 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">More...</a><br /></td></tr>
<tr class="separator:aba33f5ae46bd5406b8bead75d3225e08 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af941dd81c240827a807b59925f9353ae inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a></td></tr>
<tr class="memdesc:af941dd81c240827a807b59925f9353ae inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">More...</a><br /></td></tr>
<tr class="separator:af941dd81c240827a807b59925f9353ae inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747df15d62910c4e106267ff6a6456c inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a></td></tr>
<tr class="memdesc:a2747df15d62910c4e106267ff6a6456c inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">More...</a><br /></td></tr>
<tr class="separator:a2747df15d62910c4e106267ff6a6456c inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d06bc21666d641e6e8fc1d2348474 inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a></td></tr>
<tr class="memdesc:acd8d06bc21666d641e6e8fc1d2348474 inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">More...</a><br /></td></tr>
<tr class="separator:acd8d06bc21666d641e6e8fc1d2348474 inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dcbe4f4c13eab6d32664b39c53067e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a></td></tr>
<tr class="memdesc:ad2dcbe4f4c13eab6d32664b39c53067e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">More...</a><br /></td></tr>
<tr class="separator:ad2dcbe4f4c13eab6d32664b39c53067e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3382cfdf59b23ac5fe16a359b9800e inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a></td></tr>
<tr class="memdesc:aed3382cfdf59b23ac5fe16a359b9800e inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">More...</a><br /></td></tr>
<tr class="separator:aed3382cfdf59b23ac5fe16a359b9800e inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41c74dcba45cbeccdafdc3c9276048d inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a></td></tr>
<tr class="memdesc:af41c74dcba45cbeccdafdc3c9276048d inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">More...</a><br /></td></tr>
<tr class="separator:af41c74dcba45cbeccdafdc3c9276048d inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5410fb3fc14453b32ced2e8134ad36c inherit pub_types_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a></td></tr>
<tr class="memdesc:ac5410fb3fc14453b32ced2e8134ad36c inherit pub_types_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (CNT).  <a href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">More...</a><br /></td></tr>
<tr class="separator:ac5410fb3fc14453b32ced2e8134ad36c inherit pub_types_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73d73693191a8a61c3cc7a97cf3a5d90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a73d73693191a8a61c3cc7a97cf3a5d90">UnitVec</a> ()</td></tr>
<tr class="memdesc:a73d73693191a8a61c3cc7a97cf3a5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes to all-NaN even in Release mode so that we maintain the above-promised contract.  <a href="#a73d73693191a8a61c3cc7a97cf3a5d90">More...</a><br /></td></tr>
<tr class="separator:a73d73693191a8a61c3cc7a97cf3a5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb60e996d4a98e4e46d653ed6390fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a12fb60e996d4a98e4e46d653ed6390fc">UnitVec</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> &amp;u)</td></tr>
<tr class="memdesc:a12fb60e996d4a98e4e46d653ed6390fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor does not require normalization since we know the source is a unit vector.  <a href="#a12fb60e996d4a98e4e46d653ed6390fc">More...</a><br /></td></tr>
<tr class="separator:a12fb60e996d4a98e4e46d653ed6390fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6b45877344851eb2b0a82467772973"><td class="memTemplParams" colspan="2">template&lt;int S2&gt; </td></tr>
<tr class="memitem:a9a6b45877344851eb2b0a82467772973"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a9a6b45877344851eb2b0a82467772973">UnitVec</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;u)</td></tr>
<tr class="memdesc:a9a6b45877344851eb2b0a82467772973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic conversion from <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> with different stride; no computation required.  <a href="#a9a6b45877344851eb2b0a82467772973">More...</a><br /></td></tr>
<tr class="separator:a9a6b45877344851eb2b0a82467772973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da37a5763ddcb9ac2cd134feecd039c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a8da37a5763ddcb9ac2cd134feecd039c">UnitVec</a> (const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a> &amp;v)</td></tr>
<tr class="memdesc:a8da37a5763ddcb9ac2cd134feecd039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion from <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> to <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a>, requiring expensive normalization.  <a href="#a8da37a5763ddcb9ac2cd134feecd039c">More...</a><br /></td></tr>
<tr class="separator:a8da37a5763ddcb9ac2cd134feecd039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915d564bb48a436429ad3e2448184a85"><td class="memTemplParams" colspan="2">template&lt;int S2&gt; </td></tr>
<tr class="memitem:a915d564bb48a436429ad3e2448184a85"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a915d564bb48a436429ad3e2448184a85">UnitVec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a915d564bb48a436429ad3e2448184a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion from <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> of any stride to this <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a>, requiring expensive normalization.  <a href="#a915d564bb48a436429ad3e2448184a85">More...</a><br /></td></tr>
<tr class="separator:a915d564bb48a436429ad3e2448184a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b7b8b209e66dfad70e01d2e0e9324e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#ae5b7b8b209e66dfad70e01d2e0e9324e">UnitVec</a> (const P &amp;x, const P &amp;y, const P &amp;z)</td></tr>
<tr class="memdesc:ae5b7b8b209e66dfad70e01d2e0e9324e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unit vector in the direction of the vector (x,y,z) whose measure numbers are supplied &ndash; this requires an expensive normalization since we don't know that the supplied vector is normalized.  <a href="#ae5b7b8b209e66dfad70e01d2e0e9324e">More...</a><br /></td></tr>
<tr class="separator:ae5b7b8b209e66dfad70e01d2e0e9324e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6a8daeb3fbbfb03ddd1839f73587fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#afd6a8daeb3fbbfb03ddd1839f73587fc">UnitVec</a> (const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis)</td></tr>
<tr class="memdesc:afd6a8daeb3fbbfb03ddd1839f73587fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from a coordinate axis XAxis, YAxis, or ZAxis to a UnitVec3. Does not require any computation.  <a href="#afd6a8daeb3fbbfb03ddd1839f73587fc">More...</a><br /></td></tr>
<tr class="separator:afd6a8daeb3fbbfb03ddd1839f73587fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5650655c4c6d07b74f6282f85d01810"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#aa5650655c4c6d07b74f6282f85d01810">UnitVec</a> (const <a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a> &amp;dir)</td></tr>
<tr class="memdesc:aa5650655c4c6d07b74f6282f85d01810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion from a coordinate axis direction to a UnitVec3. The axis direction is given by one of XAxis, YAxis, ZAxis or NegXAxis, NegYAxis, NegZAxis. Does not require any computation.  <a href="#aa5650655c4c6d07b74f6282f85d01810">More...</a><br /></td></tr>
<tr class="separator:aa5650655c4c6d07b74f6282f85d01810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4bece487167338cbd2b8f8e1e4225c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#aba4bece487167338cbd2b8f8e1e4225c">UnitVec</a> (int axis)</td></tr>
<tr class="memdesc:aba4bece487167338cbd2b8f8e1e4225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unit axis vector 100 010 001 given 0,1, or 2; this is not an implicit conversion.  <a href="#aba4bece487167338cbd2b8f8e1e4225c">More...</a><br /></td></tr>
<tr class="separator:aba4bece487167338cbd2b8f8e1e4225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaabfb8fb4c3abdfd066721f6c5b8e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#abaabfb8fb4c3abdfd066721f6c5b8e11">operator=</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> &amp;u)</td></tr>
<tr class="memdesc:abaabfb8fb4c3abdfd066721f6c5b8e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment does not require normalization.  <a href="#abaabfb8fb4c3abdfd066721f6c5b8e11">More...</a><br /></td></tr>
<tr class="separator:abaabfb8fb4c3abdfd066721f6c5b8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa161e02139d0d3918d9de7b1a14c0d"><td class="memTemplParams" colspan="2">template&lt;int S2&gt; </td></tr>
<tr class="memitem:a9aa161e02139d0d3918d9de7b1a14c0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a9aa161e02139d0d3918d9de7b1a14c0d">operator=</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;u)</td></tr>
<tr class="memdesc:a9aa161e02139d0d3918d9de7b1a14c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> whose stride differs from this one; no normalization required.  <a href="#a9aa161e02139d0d3918d9de7b1a14c0d">More...</a><br /></td></tr>
<tr class="separator:a9aa161e02139d0d3918d9de7b1a14c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57cd82a11b9175709fc0c9eb5894d2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#aa57cd82a11b9175709fc0c9eb5894d2e">asVec3</a> () const</td></tr>
<tr class="memdesc:aa57cd82a11b9175709fc0c9eb5894d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the underlying Vec3 (no copying here).  <a href="#aa57cd82a11b9175709fc0c9eb5894d2e">More...</a><br /></td></tr>
<tr class="separator:aa57cd82a11b9175709fc0c9eb5894d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b4573bf0a7a7322c7abc5cdfaddc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#aa5b4573bf0a7a7322c7abc5cdfaddc75">negate</a> () const</td></tr>
<tr class="memdesc:aa5b4573bf0a7a7322c7abc5cdfaddc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new unit vector pointing in the opposite direction from this one; does <em>not</em> modify this <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> object.  <a href="#aa5b4573bf0a7a7322c7abc5cdfaddc75">More...</a><br /></td></tr>
<tr class="separator:aa5b4573bf0a7a7322c7abc5cdfaddc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810dc4b53752cc44de3a588e8d65216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a5810dc4b53752cc44de3a588e8d65216">operator-</a> () const</td></tr>
<tr class="memdesc:a5810dc4b53752cc44de3a588e8d65216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new unit vector pointing in the opposite direction from this one.  <a href="#a5810dc4b53752cc44de3a588e8d65216">More...</a><br /></td></tr>
<tr class="separator:a5810dc4b53752cc44de3a588e8d65216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84f438d644cd63bc9c20ce96f939cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a7e84f438d644cd63bc9c20ce96f939cc">operator~</a> () const</td></tr>
<tr class="memdesc:a7e84f438d644cd63bc9c20ce96f939cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to this unit vector re-expressed as a unit row; no computational cost.  <a href="#a7e84f438d644cd63bc9c20ce96f939cc">More...</a><br /></td></tr>
<tr class="separator:a7e84f438d644cd63bc9c20ce96f939cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652eee30279596142606524844c66791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a652eee30279596142606524844c66791">operator~</a> ()</td></tr>
<tr class="memdesc:a652eee30279596142606524844c66791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to this unit vector re-expressed as a unit row; no computational cost.  <a href="#a652eee30279596142606524844c66791">More...</a><br /></td></tr>
<tr class="separator:a652eee30279596142606524844c66791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ecf6cf67437bccdb4dcca41654b819"><td class="memItemLeft" align="right" valign="top">const P &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a55ecf6cf67437bccdb4dcca41654b819">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a55ecf6cf67437bccdb4dcca41654b819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one element of this unit vector as a const reference; there is no corresponding writable index function since changing a single element of a unit vector would violate the contract that it has unit length at all times.  <a href="#a55ecf6cf67437bccdb4dcca41654b819">More...</a><br /></td></tr>
<tr class="separator:a55ecf6cf67437bccdb4dcca41654b819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0eb9a093970e07829e648aacc5b7f3"><td class="memItemLeft" align="right" valign="top">const P &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a1e0eb9a093970e07829e648aacc5b7f3">operator()</a> (int i) const</td></tr>
<tr class="memdesc:a1e0eb9a093970e07829e648aacc5b7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one element of this unit vector as a const reference; there is no corresponding writable index function since changing a single element of a unit vector would violate the contract that it has unit length at all times.  <a href="#a1e0eb9a093970e07829e648aacc5b7f3">More...</a><br /></td></tr>
<tr class="separator:a1e0eb9a093970e07829e648aacc5b7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881cc1140d712731ea642b91ee8b50b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a881cc1140d712731ea642b91ee8b50b5">abs</a> () const</td></tr>
<tr class="memdesc:a881cc1140d712731ea642b91ee8b50b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new unit vector whose measure numbers are the absolute values of the ones here.  <a href="#a881cc1140d712731ea642b91ee8b50b5">More...</a><br /></td></tr>
<tr class="separator:a881cc1140d712731ea642b91ee8b50b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ab0e607e9508f6a4944dd40afea781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a20ab0e607e9508f6a4944dd40afea781">perp</a> () const</td></tr>
<tr class="memdesc:a20ab0e607e9508f6a4944dd40afea781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new unit vector perpendicular to this one but otherwise arbitrary.  <a href="#a20ab0e607e9508f6a4944dd40afea781">More...</a><br /></td></tr>
<tr class="separator:a20ab0e607e9508f6a4944dd40afea781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9391c4529db05af4f2a03cd4233233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a6f9391c4529db05af4f2a03cd4233233">UnitVec</a> (const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a> &amp;v, bool)</td></tr>
<tr class="memdesc:a6f9391c4529db05af4f2a03cd4233233"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This constructor is only for our friends whom we trust to give us an already-normalized vector which we simply accept as normalized without checking.  <a href="#a6f9391c4529db05af4f2a03cd4233233">More...</a><br /></td></tr>
<tr class="separator:a6f9391c4529db05af4f2a03cd4233233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8174397397a48a6029fb911f76259fc9"><td class="memTemplParams" colspan="2">template&lt;int S2&gt; </td></tr>
<tr class="memitem:a8174397397a48a6029fb911f76259fc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a8174397397a48a6029fb911f76259fc9">UnitVec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S2 &gt; &amp;v, bool)</td></tr>
<tr class="memdesc:a8174397397a48a6029fb911f76259fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This constructor is only for our friends whom we trust to give us an already-normalized vector which we simply accept as normalized without checking (this version accepts an input vector of any stride).  <a href="#a8174397397a48a6029fb911f76259fc9">More...</a><br /></td></tr>
<tr class="separator:a8174397397a48a6029fb911f76259fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Vec"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Vec')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec&lt; 3, P, S &gt;</a></td></tr>
<tr class="memitem:a747f871a631bccf9d68920ba56f018a0 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a747f871a631bccf9d68920ba56f018a0">scalarNormSqr</a> () const</td></tr>
<tr class="memdesc:a747f871a631bccf9d68920ba56f018a0 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar norm square is sum( conjugate squares of all underlying scalars ), where conjugate square of scalar s is conj(s)*s.  <a href="classSimTK_1_1Vec.html#a747f871a631bccf9d68920ba56f018a0">More...</a><br /></td></tr>
<tr class="separator:a747f871a631bccf9d68920ba56f018a0 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ffe18d1f595f9d81cb3c72da5b4ca7 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a07ffe18d1f595f9d81cb3c72da5b4ca7">sqrt</a> () const</td></tr>
<tr class="memdesc:a07ffe18d1f595f9d81cb3c72da5b4ca7 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root; that is, the return value has the same length as this Vec but with each element replaced by whatever it thinks its square root is.  <a href="classSimTK_1_1Vec.html#a07ffe18d1f595f9d81cb3c72da5b4ca7">More...</a><br /></td></tr>
<tr class="separator:a07ffe18d1f595f9d81cb3c72da5b4ca7 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad9ab24a37f7ea85a7be2c9028ea64f inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adad9ab24a37f7ea85a7be2c9028ea64f">abs</a> () const</td></tr>
<tr class="memdesc:adad9ab24a37f7ea85a7be2c9028ea64f inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise absolute value; that is, the return value has the same dimension as this Vec but with each element replaced by whatever it thinks its absolute value is.  <a href="classSimTK_1_1Vec.html#adad9ab24a37f7ea85a7be2c9028ea64f">More...</a><br /></td></tr>
<tr class="separator:adad9ab24a37f7ea85a7be2c9028ea64f inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb922c2a37e56725cb226221ce92435 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8cb922c2a37e56725cb226221ce92435">standardize</a> () const</td></tr>
<tr class="memdesc:a8cb922c2a37e56725cb226221ce92435 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this Vec but with the underlying scalar type converted (if necessary) to one of the C++ standard real or complex floating point types.  <a href="classSimTK_1_1Vec.html#a8cb922c2a37e56725cb226221ce92435">More...</a><br /></td></tr>
<tr class="separator:a8cb922c2a37e56725cb226221ce92435 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca2304d09b049f21877d43f4e942598 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8ca2304d09b049f21877d43f4e942598">sum</a> () const</td></tr>
<tr class="memdesc:a8ca2304d09b049f21877d43f4e942598 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum just adds up all the elements into a single return element that is the same type as this Vec's elements except standardized to use one of the C++ built-in real or complex types as its underlying scalars.  <a href="classSimTK_1_1Vec.html#a8ca2304d09b049f21877d43f4e942598">More...</a><br /></td></tr>
<tr class="separator:a8ca2304d09b049f21877d43f4e942598 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d52d8c3207d1fd68197233c4a60029c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d52d8c3207d1fd68197233c4a60029c">Vec</a> ()</td></tr>
<tr class="memdesc:a7d52d8c3207d1fd68197233c4a60029c inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction initializes Vec's elements to NaN when debugging but leaves them uninitialized garbage otherwise, so declarations have zero cost in Release builds.  <a href="classSimTK_1_1Vec.html#a7d52d8c3207d1fd68197233c4a60029c">More...</a><br /></td></tr>
<tr class="separator:a7d52d8c3207d1fd68197233c4a60029c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c3d97a17ed494e9f0e5b2829ae419 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad34c3d97a17ed494e9f0e5b2829ae419">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr class="memdesc:ad34c3d97a17ed494e9f0e5b2829ae419 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="classSimTK_1_1Vec.html#ad34c3d97a17ed494e9f0e5b2829ae419">More...</a><br /></td></tr>
<tr class="separator:ad34c3d97a17ed494e9f0e5b2829ae419 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd4b510a548add1477a13a1c99cc87 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad6fd4b510a548add1477a13a1c99cc87">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:ad6fd4b510a548add1477a13a1c99cc87 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and element type but with a different stride.  <a href="classSimTK_1_1Vec.html#ad6fd4b510a548add1477a13a1c99cc87">More...</a><br /></td></tr>
<tr class="separator:ad6fd4b510a548add1477a13a1c99cc87 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5678f4109bde28c1c7829f030a752 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a57a5678f4109bde28c1c7829f030a752">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:a57a5678f4109bde28c1c7829f030a752 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and <em>negated</em> element type (possibly with a different stride).  <a href="classSimTK_1_1Vec.html#a57a5678f4109bde28c1c7829f030a752">More...</a><br /></td></tr>
<tr class="separator:a57a5678f4109bde28c1c7829f030a752 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9220ca15fa8c7647bb0d5a7aaeb83b5 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad9220ca15fa8c7647bb0d5a7aaeb83b5">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:ad9220ca15fa8c7647bb0d5a7aaeb83b5 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Vec from a Vec of the same length, with any stride.  <a href="classSimTK_1_1Vec.html#ad9220ca15fa8c7647bb0d5a7aaeb83b5">More...</a><br /></td></tr>
<tr class="separator:ad9220ca15fa8c7647bb0d5a7aaeb83b5 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe343569bdc62601e22eddccb9b76fa3 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e)</td></tr>
<tr class="memdesc:abe343569bdc62601e22eddccb9b76fa3 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's element type assigns that value to each element.  <a href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3">More...</a><br /></td></tr>
<tr class="separator:abe343569bdc62601e22eddccb9b76fa3 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54996ceb0ffdaaf35c0b42d13ffb22 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0d54996ceb0ffdaaf35c0b42d13ffb22">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a> &amp;ne)</td></tr>
<tr class="memdesc:a0d54996ceb0ffdaaf35c0b42d13ffb22 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's negated element type assigns that value to each element, requiring floating point negation to be performed once to compute the type-E representation of the type negator&lt;E&gt; value provided.  <a href="classSimTK_1_1Vec.html#a0d54996ceb0ffdaaf35c0b42d13ffb22">More...</a><br /></td></tr>
<tr class="separator:a0d54996ceb0ffdaaf35c0b42d13ffb22 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a2921791ea75c7022fb593b45c43f7 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a58a2921791ea75c7022fb593b45c43f7">Vec</a> (int i)</td></tr>
<tr class="memdesc:a58a2921791ea75c7022fb593b45c43f7 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an int value, turn it into a suitable floating point number, convert that to element type E and then feed that to the above single-element constructor.  <a href="classSimTK_1_1Vec.html#a58a2921791ea75c7022fb593b45c43f7">More...</a><br /></td></tr>
<tr class="separator:a58a2921791ea75c7022fb593b45c43f7 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d2b0d02e91efc5547af4678d3535c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a594d2b0d02e91efc5547af4678d3535c">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1)</td></tr>
<tr class="memdesc:a594d2b0d02e91efc5547af4678d3535c inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Vec&lt;2,E&gt; from two elements of type E, etc.  <a href="classSimTK_1_1Vec.html#a594d2b0d02e91efc5547af4678d3535c">More...</a><br /></td></tr>
<tr class="separator:a594d2b0d02e91efc5547af4678d3535c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0a194f6ca013c9026ff72f461bfc46 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e0a194f6ca013c9026ff72f461bfc46">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2)</td></tr>
<tr class="separator:a6e0a194f6ca013c9026ff72f461bfc46 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c9a675a80482caf12e02a34b399bb1 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a71c9a675a80482caf12e02a34b399bb1">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3)</td></tr>
<tr class="separator:a71c9a675a80482caf12e02a34b399bb1 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e82ed4bb90e65fee729e2082e413b inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a774e82ed4bb90e65fee729e2082e413b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4)</td></tr>
<tr class="separator:a774e82ed4bb90e65fee729e2082e413b inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcac91cb1609810fac49da700e70e77 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4dcac91cb1609810fac49da700e70e77">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5)</td></tr>
<tr class="separator:a4dcac91cb1609810fac49da700e70e77 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978f046474cf4481a5f0470f9558a29 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5978f046474cf4481a5f0470f9558a29">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6)</td></tr>
<tr class="separator:a5978f046474cf4481a5f0470f9558a29 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae204f1902d2834ff3f47f3c84db23385 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae204f1902d2834ff3f47f3c84db23385">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7)</td></tr>
<tr class="separator:ae204f1902d2834ff3f47f3c84db23385 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f80f6ed39b2a75521423d25b23835b inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad4f80f6ed39b2a75521423d25b23835b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e8)</td></tr>
<tr class="separator:ad4f80f6ed39b2a75521423d25b23835b inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66f56b1930d82c36f90142af7fb536 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9c66f56b1930d82c36f90142af7fb536">Vec</a> (const EE *p)</td></tr>
<tr class="memdesc:a9c66f56b1930d82c36f90142af7fb536 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="classSimTK_1_1Vec.html#a9c66f56b1930d82c36f90142af7fb536">More...</a><br /></td></tr>
<tr class="separator:a9c66f56b1930d82c36f90142af7fb536 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee6e2f4bad2e772e4ad019b28c591a inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a96ee6e2f4bad2e772e4ad019b28c591a">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr class="memdesc:a96ee6e2f4bad2e772e4ad019b28c591a inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="classSimTK_1_1Vec.html#a96ee6e2f4bad2e772e4ad019b28c591a">More...</a><br /></td></tr>
<tr class="separator:a96ee6e2f4bad2e772e4ad019b28c591a inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf45d78264b6e333d79985c371efbf4 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1bf45d78264b6e333d79985c371efbf4">operator=</a> (const EE *p)</td></tr>
<tr class="memdesc:a1bf45d78264b6e333d79985c371efbf4 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="classSimTK_1_1Vec.html#a1bf45d78264b6e333d79985c371efbf4">More...</a><br /></td></tr>
<tr class="separator:a1bf45d78264b6e333d79985c371efbf4 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced2e90bb014a4c09f2e830846b73ac inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9ced2e90bb014a4c09f2e830846b73ac">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;vv)</td></tr>
<tr class="memdesc:a9ced2e90bb014a4c09f2e830846b73ac inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a conforming Vec, of any element type and stride, provided that the element types are assignment-compatible.  <a href="classSimTK_1_1Vec.html#a9ced2e90bb014a4c09f2e830846b73ac">More...</a><br /></td></tr>
<tr class="separator:a9ced2e90bb014a4c09f2e830846b73ac inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace53cca908837b6b13de05a6bbda540 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aace53cca908837b6b13de05a6bbda540">operator=</a> (const EE &amp;e)</td></tr>
<tr class="separator:aace53cca908837b6b13de05a6bbda540 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8255aebddddbcdb4aaae12736a1b05 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2a8255aebddddbcdb4aaae12736a1b05">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a2a8255aebddddbcdb4aaae12736a1b05 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="classSimTK_1_1Vec.html#a2a8255aebddddbcdb4aaae12736a1b05">More...</a><br /></td></tr>
<tr class="separator:a2a8255aebddddbcdb4aaae12736a1b05 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cc4c59703b5544ac71bc5e57cc0b19 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51cc4c59703b5544ac71bc5e57cc0b19">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a51cc4c59703b5544ac71bc5e57cc0b19 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="classSimTK_1_1Vec.html#a51cc4c59703b5544ac71bc5e57cc0b19">More...</a><br /></td></tr>
<tr class="separator:a51cc4c59703b5544ac71bc5e57cc0b19 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6459937f78236c913e2ec50d328d8d inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d6459937f78236c913e2ec50d328d8d">operator+=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a6d6459937f78236c913e2ec50d328d8d inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b643762736321072c6bd58ba141841 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a46b643762736321072c6bd58ba141841">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a46b643762736321072c6bd58ba141841 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="classSimTK_1_1Vec.html#a46b643762736321072c6bd58ba141841">More...</a><br /></td></tr>
<tr class="separator:a46b643762736321072c6bd58ba141841 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee444801ca472095d6fc0ff1a103718f inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aee444801ca472095d6fc0ff1a103718f">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:aee444801ca472095d6fc0ff1a103718f inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="classSimTK_1_1Vec.html#aee444801ca472095d6fc0ff1a103718f">More...</a><br /></td></tr>
<tr class="separator:aee444801ca472095d6fc0ff1a103718f inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b247dbd3a71bdcef1a0a4af1cece4c7 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b247dbd3a71bdcef1a0a4af1cece4c7">operator-=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a4b247dbd3a71bdcef1a0a4af1cece4c7 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a5c35ca633c4cf585c67b53678a3a9 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Add &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae0a5c35ca633c4cf585c67b53678a3a9">conformingAdd</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const</td></tr>
<tr class="memdesc:ae0a5c35ca633c4cf585c67b53678a3a9 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector addition &ndash; use operator+ instead.  <a href="classSimTK_1_1Vec.html#ae0a5c35ca633c4cf585c67b53678a3a9">More...</a><br /></td></tr>
<tr class="separator:ae0a5c35ca633c4cf585c67b53678a3a9 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7468860ab11c47757426c81564824aa inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Sub &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab7468860ab11c47757426c81564824aa">conformingSubtract</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const</td></tr>
<tr class="memdesc:ab7468860ab11c47757426c81564824aa inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subtraction &ndash; use operator- instead.  <a href="classSimTK_1_1Vec.html#ab7468860ab11c47757426c81564824aa">More...</a><br /></td></tr>
<tr class="separator:ab7468860ab11c47757426c81564824aa inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f0698115292e99449173d2fe00963e inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af4f0698115292e99449173d2fe00963e">conformingMultiply</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, EE, SS &gt; &amp;r) const</td></tr>
<tr class="memdesc:af4f0698115292e99449173d2fe00963e inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as outer product (m = col*row) &ndash; use operator* or <a class="el" href="namespaceSimTK.html#a0fd293cad29bd6fa0405ccffca69c738">outer()</a> instead.  <a href="classSimTK_1_1Vec.html#af4f0698115292e99449173d2fe00963e">More...</a><br /></td></tr>
<tr class="separator:af4f0698115292e99449173d2fe00963e inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b08538184864a9c7cf792bd98445d2 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a36b08538184864a9c7cf792bd98445d2">elementwiseMultiply</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const</td></tr>
<tr class="memdesc:a36b08538184864a9c7cf792bd98445d2 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (Matlab " .* " operator).  <a href="classSimTK_1_1Vec.html#a36b08538184864a9c7cf792bd98445d2">More...</a><br /></td></tr>
<tr class="separator:a36b08538184864a9c7cf792bd98445d2 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5374f8ff762d019502efa085552269 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc5374f8ff762d019502efa085552269">elementwiseDivide</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const</td></tr>
<tr class="memdesc:adc5374f8ff762d019502efa085552269 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise divide (Matlab " ./ " operator).  <a href="classSimTK_1_1Vec.html#adc5374f8ff762d019502efa085552269">More...</a><br /></td></tr>
<tr class="separator:adc5374f8ff762d019502efa085552269 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeea716c9b179b8faf2da76084fe64e inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7aeea716c9b179b8faf2da76084fe64e">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a7aeea716c9b179b8faf2da76084fe64e inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a const reference to it.  <a href="classSimTK_1_1Vec.html#a7aeea716c9b179b8faf2da76084fe64e">More...</a><br /></td></tr>
<tr class="separator:a7aeea716c9b179b8faf2da76084fe64e inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a011242e15a9188acf63a6625e6cc inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae44a011242e15a9188acf63a6625e6cc">operator[]</a> (int i)</td></tr>
<tr class="memdesc:ae44a011242e15a9188acf63a6625e6cc inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a writable reference to it.  <a href="classSimTK_1_1Vec.html#ae44a011242e15a9188acf63a6625e6cc">More...</a><br /></td></tr>
<tr class="separator:ae44a011242e15a9188acf63a6625e6cc inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec84e2bc0a2b50246a7026949b1fd53 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acec84e2bc0a2b50246a7026949b1fd53">operator()</a> (int i) const</td></tr>
<tr class="memdesc:acec84e2bc0a2b50246a7026949b1fd53 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const operator[] above.  <a href="classSimTK_1_1Vec.html#acec84e2bc0a2b50246a7026949b1fd53">More...</a><br /></td></tr>
<tr class="separator:acec84e2bc0a2b50246a7026949b1fd53 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918c06d3f0b353076c5fa9ce8019509 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2918c06d3f0b353076c5fa9ce8019509">operator()</a> (int i)</td></tr>
<tr class="memdesc:a2918c06d3f0b353076c5fa9ce8019509 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator[] above.  <a href="classSimTK_1_1Vec.html#a2918c06d3f0b353076c5fa9ce8019509">More...</a><br /></td></tr>
<tr class="separator:a2918c06d3f0b353076c5fa9ce8019509 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5e60706dd33f7d26db8039579b0587 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8c5e60706dd33f7d26db8039579b0587">normSqr</a> () const</td></tr>
<tr class="separator:a8c5e60706dd33f7d26db8039579b0587 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7121b9463a507d8da9b5ab26c77bdfdc inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7121b9463a507d8da9b5ab26c77bdfdc">norm</a> () const</td></tr>
<tr class="separator:a7121b9463a507d8da9b5ab26c77bdfdc inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958589c2ac3bafeb9e4f5be32fa1f18 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7958589c2ac3bafeb9e4f5be32fa1f18">normalize</a> () const</td></tr>
<tr class="memdesc:a7958589c2ac3bafeb9e4f5be32fa1f18 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the elements of this Vec are scalars, the result is what you get by dividing each element by the <a class="el" href="classSimTK_1_1Vec.html#a7121b9463a507d8da9b5ab26c77bdfdc">norm()</a> calculated above.  <a href="classSimTK_1_1Vec.html#a7958589c2ac3bafeb9e4f5be32fa1f18">More...</a><br /></td></tr>
<tr class="separator:a7958589c2ac3bafeb9e4f5be32fa1f18 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3363bff3ddf952e7138481e701657d3c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3363bff3ddf952e7138481e701657d3c">invert</a> () const</td></tr>
<tr class="memdesc:a3363bff3ddf952e7138481e701657d3c inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is not supported for Vec objects.  <a href="classSimTK_1_1Vec.html#a3363bff3ddf952e7138481e701657d3c">More...</a><br /></td></tr>
<tr class="separator:a3363bff3ddf952e7138481e701657d3c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14deed593a84de5882b821c0e63aea5 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa14deed593a84de5882b821c0e63aea5">operator+</a> () const</td></tr>
<tr class="memdesc:aa14deed593a84de5882b821c0e63aea5 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus does nothing.  <a href="classSimTK_1_1Vec.html#aa14deed593a84de5882b821c0e63aea5">More...</a><br /></td></tr>
<tr class="separator:aa14deed593a84de5882b821c0e63aea5 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0cb960e5fc1dc212c590760efbeb23 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c0cb960e5fc1dc212c590760efbeb23">operator-</a> () const</td></tr>
<tr class="memdesc:a1c0cb960e5fc1dc212c590760efbeb23 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus recasts this Vec to a type that has the opposite interpretation of the sign but is otherwise identical, so no computation or copying is performed here.  <a href="classSimTK_1_1Vec.html#a1c0cb960e5fc1dc212c590760efbeb23">More...</a><br /></td></tr>
<tr class="separator:a1c0cb960e5fc1dc212c590760efbeb23 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52644eefd67080b80bba767e5affceb8 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a52644eefd67080b80bba767e5affceb8">operator-</a> ()</td></tr>
<tr class="memdesc:a52644eefd67080b80bba767e5affceb8 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to negated type and return a writable reference; writing to this will cause the negated result to be placed in the original Vec.  <a href="classSimTK_1_1Vec.html#a52644eefd67080b80bba767e5affceb8">More...</a><br /></td></tr>
<tr class="separator:a52644eefd67080b80bba767e5affceb8 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2fd130a10327f10ea11197adcc1211 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5b2fd130a10327f10ea11197adcc1211">operator~</a> () const</td></tr>
<tr class="memdesc:a5b2fd130a10327f10ea11197adcc1211 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hermitian transpose operator recasts this Vec to a type that specifies the opposite storage order (row vs. column) then returns a reference, so no computation or copying is performed here.  <a href="classSimTK_1_1Vec.html#a5b2fd130a10327f10ea11197adcc1211">More...</a><br /></td></tr>
<tr class="separator:a5b2fd130a10327f10ea11197adcc1211 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055c47346d5b16b0a7ced839b91a9aa4 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a055c47346d5b16b0a7ced839b91a9aa4">operator~</a> ()</td></tr>
<tr class="memdesc:a055c47346d5b16b0a7ced839b91a9aa4 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to Hermitian transposed type and return a writable reference; the effect is that writing to elements of the result affects the transposed element of the original Vec.  <a href="classSimTK_1_1Vec.html#a055c47346d5b16b0a7ced839b91a9aa4">More...</a><br /></td></tr>
<tr class="separator:a055c47346d5b16b0a7ced839b91a9aa4 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4036b8ad3ad541613f642c1d595edf94 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4036b8ad3ad541613f642c1d595edf94">negate</a> () const</td></tr>
<tr class="memdesc:a4036b8ad3ad541613f642c1d595edf94 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; just a recast.  <a href="classSimTK_1_1Vec.html#a4036b8ad3ad541613f642c1d595edf94">More...</a><br /></td></tr>
<tr class="separator:a4036b8ad3ad541613f642c1d595edf94 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5108f85c423f5e00e51a198734ed17c3 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5108f85c423f5e00e51a198734ed17c3">updNegate</a> ()</td></tr>
<tr class="memdesc:a5108f85c423f5e00e51a198734ed17c3 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; recasts and returns a writable reference.  <a href="classSimTK_1_1Vec.html#a5108f85c423f5e00e51a198734ed17c3">More...</a><br /></td></tr>
<tr class="separator:a5108f85c423f5e00e51a198734ed17c3 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14300bfc73a74ac271076193855dd502 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a14300bfc73a74ac271076193855dd502">transpose</a> () const</td></tr>
<tr class="memdesc:a14300bfc73a74ac271076193855dd502 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; just a recast.  <a href="classSimTK_1_1Vec.html#a14300bfc73a74ac271076193855dd502">More...</a><br /></td></tr>
<tr class="separator:a14300bfc73a74ac271076193855dd502 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e181c0844930d9dbec8afb613f762d7 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3e181c0844930d9dbec8afb613f762d7">updTranspose</a> ()</td></tr>
<tr class="memdesc:a3e181c0844930d9dbec8afb613f762d7 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; recasts and returns a writable reference.  <a href="classSimTK_1_1Vec.html#a3e181c0844930d9dbec8afb613f762d7">More...</a><br /></td></tr>
<tr class="separator:a3e181c0844930d9dbec8afb613f762d7 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfd8a363498a10d981f7374a650e09 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a73cfd8a363498a10d981f7374a650e09">positionalTranspose</a> () const</td></tr>
<tr class="memdesc:a73cfd8a363498a10d981f7374a650e09 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose turns this Vec into a Row but does not transpose the individual elements.  <a href="classSimTK_1_1Vec.html#a73cfd8a363498a10d981f7374a650e09">More...</a><br /></td></tr>
<tr class="separator:a73cfd8a363498a10d981f7374a650e09 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021a62d22537c7ad406b7a1c1ca0761 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6021a62d22537c7ad406b7a1c1ca0761">updPositionalTranspose</a> ()</td></tr>
<tr class="memdesc:a6021a62d22537c7ad406b7a1c1ca0761 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose returning a writable reference.  <a href="classSimTK_1_1Vec.html#a6021a62d22537c7ad406b7a1c1ca0761">More...</a><br /></td></tr>
<tr class="separator:a6021a62d22537c7ad406b7a1c1ca0761 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2618d77aed1113bb9379c63dbead9d5 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad2618d77aed1113bb9379c63dbead9d5">real</a> () const</td></tr>
<tr class="memdesc:ad2618d77aed1113bb9379c63dbead9d5 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the real portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="classSimTK_1_1Vec.html#ad2618d77aed1113bb9379c63dbead9d5">More...</a><br /></td></tr>
<tr class="separator:ad2618d77aed1113bb9379c63dbead9d5 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc792ec3e435535fc8fe4ad3810d54fe inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc792ec3e435535fc8fe4ad3810d54fe">real</a> ()</td></tr>
<tr class="memdesc:adc792ec3e435535fc8fe4ad3810d54fe inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the real portion of this Vec and return a writable reference.  <a href="classSimTK_1_1Vec.html#adc792ec3e435535fc8fe4ad3810d54fe">More...</a><br /></td></tr>
<tr class="separator:adc792ec3e435535fc8fe4ad3810d54fe inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7102e6ada12c77447a07dfc182ff099d inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7102e6ada12c77447a07dfc182ff099d">imag</a> () const</td></tr>
<tr class="memdesc:a7102e6ada12c77447a07dfc182ff099d inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the imaginary portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="classSimTK_1_1Vec.html#a7102e6ada12c77447a07dfc182ff099d">More...</a><br /></td></tr>
<tr class="separator:a7102e6ada12c77447a07dfc182ff099d inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ecf2380f493c8b48ad6d0d50695f8 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b3ecf2380f493c8b48ad6d0d50695f8">imag</a> ()</td></tr>
<tr class="memdesc:a4b3ecf2380f493c8b48ad6d0d50695f8 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the imaginary portion of this Vec and return a writable reference.  <a href="classSimTK_1_1Vec.html#a4b3ecf2380f493c8b48ad6d0d50695f8">More...</a><br /></td></tr>
<tr class="separator:a4b3ecf2380f493c8b48ad6d0d50695f8 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cad9e1543f94a43394af393dedfcfd9 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0cad9e1543f94a43394af393dedfcfd9">castAwayNegatorIfAny</a> () const</td></tr>
<tr class="memdesc:a0cad9e1543f94a43394af393dedfcfd9 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present; this is handy for simplifying operations where we know the sign can be ignored such as squaring.  <a href="classSimTK_1_1Vec.html#a0cad9e1543f94a43394af393dedfcfd9">More...</a><br /></td></tr>
<tr class="separator:a0cad9e1543f94a43394af393dedfcfd9 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2467300a636639eb7195ca7ea37d5ee8 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2467300a636639eb7195ca7ea37d5ee8">updCastAwayNegatorIfAny</a> ()</td></tr>
<tr class="memdesc:a2467300a636639eb7195ca7ea37d5ee8 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present and return a writable reference.  <a href="classSimTK_1_1Vec.html#a2467300a636639eb7195ca7ea37d5ee8">More...</a><br /></td></tr>
<tr class="separator:a2467300a636639eb7195ca7ea37d5ee8 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562f92bd008581701a235a927515d56d inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a562f92bd008581701a235a927515d56d">scalarMultiply</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a562f92bd008581701a235a927515d56d inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a71a80f86c7639a71c0aa37924e870 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab4a71a80f86c7639a71c0aa37924e870">scalarMultiplyFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:ab4a71a80f86c7639a71c0aa37924e870 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500a66948a7449a8328549c962954e2c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a500a66948a7449a8328549c962954e2c">scalarDivide</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a500a66948a7449a8328549c962954e2c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec8db121c7783a96a0dec6c12c2af1 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Dvd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa7ec8db121c7783a96a0dec6c12c2af1">scalarDivideFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:aa7ec8db121c7783a96a0dec6c12c2af1 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaafd72048697c4b24f1c9d49923b66d inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Add &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#afaafd72048697c4b24f1c9d49923b66d">scalarAdd</a> (const EE &amp;e) const</td></tr>
<tr class="separator:afaafd72048697c4b24f1c9d49923b66d inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b3fef20c6b6f627a72b16ef71329a6 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template Result&lt; EE &gt;::Sub &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a06b3fef20c6b6f627a72b16ef71329a6">scalarSubtract</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a06b3fef20c6b6f627a72b16ef71329a6 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281121462fcbb6c20cf4f1ac3aad0fac inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Sub &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a281121462fcbb6c20cf4f1ac3aad0fac">scalarSubtractFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a281121462fcbb6c20cf4f1ac3aad0fac inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c865e00508d708562c21012f0cb66e1 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c865e00508d708562c21012f0cb66e1">operator*=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a1c865e00508d708562c21012f0cb66e1 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273abdf63fc3f9e8d720b6b1c9ebd047 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a273abdf63fc3f9e8d720b6b1c9ebd047">operator/=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a273abdf63fc3f9e8d720b6b1c9ebd047 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc5ea1fc0e6db75f4fe78c85772179 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a47cc5ea1fc0e6db75f4fe78c85772179">scalarEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a47cc5ea1fc0e6db75f4fe78c85772179 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18982d1fac249ed0050b0497fc1b5fff inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a18982d1fac249ed0050b0497fc1b5fff">scalarEq</a> (int ee)</td></tr>
<tr class="separator:a18982d1fac249ed0050b0497fc1b5fff inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9a9f23aeaf38da791ec0173f5b49d8 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d9a9f23aeaf38da791ec0173f5b49d8">scalarPlusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a7d9a9f23aeaf38da791ec0173f5b49d8 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e47b406661090c6bbb580bb32f613b6 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e47b406661090c6bbb580bb32f613b6">scalarPlusEq</a> (int ee)</td></tr>
<tr class="separator:a6e47b406661090c6bbb580bb32f613b6 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ecc870150f4bbaddacf812bf3a55a4 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1ecc870150f4bbaddacf812bf3a55a4">scalarMinusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:af1ecc870150f4bbaddacf812bf3a55a4 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402c2238f2821d55a97dcdfb36ad0ba inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab402c2238f2821d55a97dcdfb36ad0ba">scalarMinusEq</a> (int ee)</td></tr>
<tr class="separator:ab402c2238f2821d55a97dcdfb36ad0ba inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d049de83f163743bc576395746f0e6 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a11d049de83f163743bc576395746f0e6">scalarMinusEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a11d049de83f163743bc576395746f0e6 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07b8dc8c7690f71f6a2a7232c06f8b9 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab07b8dc8c7690f71f6a2a7232c06f8b9">scalarMinusEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:ab07b8dc8c7690f71f6a2a7232c06f8b9 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f25b932993267cacda311724882b90 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af8f25b932993267cacda311724882b90">scalarTimesEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:af8f25b932993267cacda311724882b90 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba57628dc553c6155205ba7ebd0330 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7bba57628dc553c6155205ba7ebd0330">scalarTimesEq</a> (int ee)</td></tr>
<tr class="separator:a7bba57628dc553c6155205ba7ebd0330 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1549f7c02c5f35b6ae02f3a384ba0461 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1549f7c02c5f35b6ae02f3a384ba0461">scalarTimesEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a1549f7c02c5f35b6ae02f3a384ba0461 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695383084e4311219d9c1d86330bc3fa inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a695383084e4311219d9c1d86330bc3fa">scalarTimesEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:a695383084e4311219d9c1d86330bc3fa inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec0b452d52d289345c333b6b1f61c1b inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5ec0b452d52d289345c333b6b1f61c1b">scalarDivideEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a5ec0b452d52d289345c333b6b1f61c1b inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb7930483190b14571c043ccb33ce0 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeafb7930483190b14571c043ccb33ce0">scalarDivideEq</a> (int ee)</td></tr>
<tr class="separator:aeafb7930483190b14571c043ccb33ce0 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6c34551dd57324842f2e630ac5798 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a68d6c34551dd57324842f2e630ac5798">scalarDivideEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a68d6c34551dd57324842f2e630ac5798 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45beaad82e2504367de24345f1b7f60c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a45beaad82e2504367de24345f1b7f60c">scalarDivideEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:a45beaad82e2504367de24345f1b7f60c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b11014a0ad910e4254a26d39f013565 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0b11014a0ad910e4254a26d39f013565">setToNaN</a> ()</td></tr>
<tr class="memdesc:a0b11014a0ad910e4254a26d39f013565 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to NaN; this is the default initial value in Debug builds, but not in Release.  <a href="classSimTK_1_1Vec.html#a0b11014a0ad910e4254a26d39f013565">More...</a><br /></td></tr>
<tr class="separator:a0b11014a0ad910e4254a26d39f013565 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25018475a82b7f1c61956d824104b300 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a25018475a82b7f1c61956d824104b300">setToZero</a> ()</td></tr>
<tr class="memdesc:a25018475a82b7f1c61956d824104b300 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to zero.  <a href="classSimTK_1_1Vec.html#a25018475a82b7f1c61956d824104b300">More...</a><br /></td></tr>
<tr class="separator:a25018475a82b7f1c61956d824104b300 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d931cb68cd2b220c3a8d299911d96e inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, P, STRIDE &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a38d931cb68cd2b220c3a8d299911d96e">getSubVec</a> (int i) const</td></tr>
<tr class="memdesc:a38d931cb68cd2b220c3a8d299911d96e inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a const reference to a sub-Vec with size known at compile time.  <a href="classSimTK_1_1Vec.html#a38d931cb68cd2b220c3a8d299911d96e">More...</a><br /></td></tr>
<tr class="separator:a38d931cb68cd2b220c3a8d299911d96e inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085715471acf42722ddd05eb8028e13c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, P, STRIDE &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">updSubVec</a> (int i)</td></tr>
<tr class="memdesc:a085715471acf42722ddd05eb8028e13c inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a writable reference to a sub-Vec with size known at compile time.  <a href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">More...</a><br /></td></tr>
<tr class="separator:a085715471acf42722ddd05eb8028e13c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae272c1a1aa53ab16a515f0ac561a9c26 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M-1, P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae272c1a1aa53ab16a515f0ac561a9c26">drop1</a> (int p) const</td></tr>
<tr class="memdesc:ae272c1a1aa53ab16a515f0ac561a9c26 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one smaller than this one by dropping the element at the indicated position p.  <a href="classSimTK_1_1Vec.html#ae272c1a1aa53ab16a515f0ac561a9c26">More...</a><br /></td></tr>
<tr class="separator:ae272c1a1aa53ab16a515f0ac561a9c26 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b072d9469f6d38929529923ba34d417 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8b072d9469f6d38929529923ba34d417">append1</a> (const EE &amp;v) const</td></tr>
<tr class="memdesc:a8b072d9469f6d38929529923ba34d417 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by adding an element to the end.  <a href="classSimTK_1_1Vec.html#a8b072d9469f6d38929529923ba34d417">More...</a><br /></td></tr>
<tr class="separator:a8b072d9469f6d38929529923ba34d417 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a182509b052ece985fdc0300fc6551 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a98a182509b052ece985fdc0300fc6551">insert1</a> (int p, const EE &amp;v) const</td></tr>
<tr class="memdesc:a98a182509b052ece985fdc0300fc6551 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by inserting an element <em>before</em> the indicated one.  <a href="classSimTK_1_1Vec.html#a98a182509b052ece985fdc0300fc6551">More...</a><br /></td></tr>
<tr class="separator:a98a182509b052ece985fdc0300fc6551 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cc465f75e6e66015c2eda0c280eeeb inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a27cc465f75e6e66015c2eda0c280eeeb">isNaN</a> () const</td></tr>
<tr class="memdesc:a27cc465f75e6e66015c2eda0c280eeeb inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this Vec contains a NaN anywhere.  <a href="classSimTK_1_1Vec.html#a27cc465f75e6e66015c2eda0c280eeeb">More...</a><br /></td></tr>
<tr class="separator:a27cc465f75e6e66015c2eda0c280eeeb inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1969823ba071a4eb00e5cae3fca927e8 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1969823ba071a4eb00e5cae3fca927e8">isInf</a> () const</td></tr>
<tr class="memdesc:a1969823ba071a4eb00e5cae3fca927e8 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this Vec contains a +Infinity or -Infinity somewhere but no element contains a NaN anywhere.  <a href="classSimTK_1_1Vec.html#a1969823ba071a4eb00e5cae3fca927e8">More...</a><br /></td></tr>
<tr class="separator:a1969823ba071a4eb00e5cae3fca927e8 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477f13ea4dfac05eeaeb7c960fed2b95 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a477f13ea4dfac05eeaeb7c960fed2b95">isFinite</a> () const</td></tr>
<tr class="memdesc:a477f13ea4dfac05eeaeb7c960fed2b95 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if no element of this Vec contains an Infinity or a NaN anywhere.  <a href="classSimTK_1_1Vec.html#a477f13ea4dfac05eeaeb7c960fed2b95">More...</a><br /></td></tr>
<tr class="separator:a477f13ea4dfac05eeaeb7c960fed2b95 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a05709d3922fb15956e15597048acc6 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8a05709d3922fb15956e15597048acc6">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v, double tol) const</td></tr>
<tr class="memdesc:a8a05709d3922fb15956e15597048acc6 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a specified tolerance.  <a href="classSimTK_1_1Vec.html#a8a05709d3922fb15956e15597048acc6">More...</a><br /></td></tr>
<tr class="separator:a8a05709d3922fb15956e15597048acc6 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc064a1757622f58c507b665e912992b inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc064a1757622f58c507b665e912992b">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v) const</td></tr>
<tr class="memdesc:adc064a1757622f58c507b665e912992b inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared.  <a href="classSimTK_1_1Vec.html#adc064a1757622f58c507b665e912992b">More...</a><br /></td></tr>
<tr class="separator:adc064a1757622f58c507b665e912992b inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893b1cf07c0886f857106a3df491a57 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0893b1cf07c0886f857106a3df491a57">isNumericallyEqual</a> (const P &amp;e, double tol=<a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a>()) const</td></tr>
<tr class="memdesc:a0893b1cf07c0886f857106a3df491a57 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether every element of this vector is numerically equal to the given element, using either a specified tolerance or the vector's default tolerance (which is always the same or looser than the default tolerance for one of its elements).  <a href="classSimTK_1_1Vec.html#a0893b1cf07c0886f857106a3df491a57">More...</a><br /></td></tr>
<tr class="separator:a0893b1cf07c0886f857106a3df491a57 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29702139e99707093a95e66d2d6dc2b3 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a29702139e99707093a95e66d2d6dc2b3">toString</a> () const</td></tr>
<tr class="memdesc:a29702139e99707093a95e66d2d6dc2b3 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print Vec into a string and return it.  <a href="classSimTK_1_1Vec.html#a29702139e99707093a95e66d2d6dc2b3">More...</a><br /></td></tr>
<tr class="separator:a29702139e99707093a95e66d2d6dc2b3 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907c5d98e3f7b29f858c5f56c6e38738 inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a907c5d98e3f7b29f858c5f56c6e38738">set</a> (int i, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;value)</td></tr>
<tr class="memdesc:a907c5d98e3f7b29f858c5f56c6e38738 inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to set ith entry.  <a href="classSimTK_1_1Vec.html#a907c5d98e3f7b29f858c5f56c6e38738">More...</a><br /></td></tr>
<tr class="separator:a907c5d98e3f7b29f858c5f56c6e38738 inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af9169b3294676b19d3f0ac6be4c60c inherit pub_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9af9169b3294676b19d3f0ac6be4c60c">get</a> (int i) const</td></tr>
<tr class="memdesc:a9af9169b3294676b19d3f0ac6be4c60c inherit pub_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to get const reference to ith entry.  <a href="classSimTK_1_1Vec.html#a9af9169b3294676b19d3f0ac6be4c60c">More...</a><br /></td></tr>
<tr class="separator:a9af9169b3294676b19d3f0ac6be4c60c inherit pub_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8528f4c817ce5f7b5b20d28fc3bbbf64"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a8528f4c817ce5f7b5b20d28fc3bbbf64">getAs</a> (const P *p)</td></tr>
<tr class="memdesc:a8528f4c817ce5f7b5b20d28fc3bbbf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Reinterpret a given memory location as a UnitVec like this one, without checking &ndash; don't use this if you aren't absolutely certain that the memory location actually <em>does</em> contain a unit vector, with the correct stride! This overrides the base <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> class method of the same name.  <a href="#a8528f4c817ce5f7b5b20d28fc3bbbf64">More...</a><br /></td></tr>
<tr class="separator:a8528f4c817ce5f7b5b20d28fc3bbbf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSimTK_1_1Vec"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSimTK_1_1Vec')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec&lt; 3, P, S &gt;</a></td></tr>
<tr class="memitem:adc9ccbb5060fdbbf1e4446337217b699 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc9ccbb5060fdbbf1e4446337217b699">size</a> ()</td></tr>
<tr class="memdesc:adc9ccbb5060fdbbf1e4446337217b699 inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in this Vec (note that stride does not affect this number.)  <a href="classSimTK_1_1Vec.html#adc9ccbb5060fdbbf1e4446337217b699">More...</a><br /></td></tr>
<tr class="separator:adc9ccbb5060fdbbf1e4446337217b699 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8825fc5c6297c9e0d804f3471d1f1 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a99f8825fc5c6297c9e0d804f3471d1f1">nrow</a> ()</td></tr>
<tr class="memdesc:a99f8825fc5c6297c9e0d804f3471d1f1 inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows in a Vec is the number of elements.  <a href="classSimTK_1_1Vec.html#a99f8825fc5c6297c9e0d804f3471d1f1">More...</a><br /></td></tr>
<tr class="separator:a99f8825fc5c6297c9e0d804f3471d1f1 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51574e7c675a4662b23b24ba6e430492 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51574e7c675a4662b23b24ba6e430492">ncol</a> ()</td></tr>
<tr class="memdesc:a51574e7c675a4662b23b24ba6e430492 inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns in a Vec is always 1.  <a href="classSimTK_1_1Vec.html#a51574e7c675a4662b23b24ba6e430492">More...</a><br /></td></tr>
<tr class="separator:a51574e7c675a4662b23b24ba6e430492 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ac248ba601828531ca324917dc3ef inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a250ac248ba601828531ca324917dc3ef">getSubVec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, P, STRIDE &gt; &amp;v, int i)</td></tr>
<tr class="memdesc:a250ac248ba601828531ca324917dc3ef inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a const reference to the selected subsequence.  <a href="classSimTK_1_1Vec.html#a250ac248ba601828531ca324917dc3ef">More...</a><br /></td></tr>
<tr class="separator:a250ac248ba601828531ca324917dc3ef inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d2b34d4c58321ddd8ebbc997877dc inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6c3d2b34d4c58321ddd8ebbc997877dc">updSubVec</a> (<a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, P, STRIDE &gt; &amp;v, int i)</td></tr>
<tr class="memdesc:a6c3d2b34d4c58321ddd8ebbc997877dc inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a writable reference to the selected subsequence.  <a href="classSimTK_1_1Vec.html#a6c3d2b34d4c58321ddd8ebbc997877dc">More...</a><br /></td></tr>
<tr class="separator:a6c3d2b34d4c58321ddd8ebbc997877dc inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8283cc8bb6cccd44287e439811198d inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abf8283cc8bb6cccd44287e439811198d">getAs</a> (const P *p)</td></tr>
<tr class="memdesc:abf8283cc8bb6cccd44287e439811198d inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast an ordinary C++ array E[] to a const Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="classSimTK_1_1Vec.html#abf8283cc8bb6cccd44287e439811198d">More...</a><br /></td></tr>
<tr class="separator:abf8283cc8bb6cccd44287e439811198d inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb89a98c7696e0a5fa04a17924e19f7 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#affb89a98c7696e0a5fa04a17924e19f7">updAs</a> (P *p)</td></tr>
<tr class="memdesc:affb89a98c7696e0a5fa04a17924e19f7 inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable ordinary C++ array E[] to a writable Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="classSimTK_1_1Vec.html#affb89a98c7696e0a5fa04a17924e19f7">More...</a><br /></td></tr>
<tr class="separator:affb89a98c7696e0a5fa04a17924e19f7 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1b06280e2190f1d4317a04355f12ee inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ade1b06280e2190f1d4317a04355f12ee">getNaN</a> ()</td></tr>
<tr class="memdesc:ade1b06280e2190f1d4317a04355f12ee inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vec of the same length and element type as this one but with all elements set to NaN.  <a href="classSimTK_1_1Vec.html#ade1b06280e2190f1d4317a04355f12ee">More...</a><br /></td></tr>
<tr class="separator:ade1b06280e2190f1d4317a04355f12ee inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781827a50ebc3d83a0736738bc2e2784 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a> ()</td></tr>
<tr class="memdesc:a781827a50ebc3d83a0736738bc2e2784 inherit pub_static_methods_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">For approximate comparisons, the default tolerance to use for a vector is the same as its elements' default tolerance.  <a href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">More...</a><br /></td></tr>
<tr class="separator:a781827a50ebc3d83a0736738bc2e2784 inherit pub_static_methods_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4b67369ce57496d919e2e644324ed3d4"><td class="memTemplParams" colspan="2">template&lt;class P , int S1, int S2&gt; </td></tr>
<tr class="memitem:a4b67369ce57496d919e2e644324ed3d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a4b67369ce57496d919e2e644324ed3d4">operator==</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S1 &gt; &amp;u1, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;u2)</td></tr>
<tr class="memdesc:a4b67369ce57496d919e2e644324ed3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UnitVec3 objects for exact, bitwise equality (not very useful).  <a href="#a4b67369ce57496d919e2e644324ed3d4">More...</a><br /></td></tr>
<tr class="separator:a4b67369ce57496d919e2e644324ed3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb319207d0f3cc936c647f423170c3f"><td class="memTemplParams" colspan="2">template&lt;class P , int S1, int S2&gt; </td></tr>
<tr class="memitem:a2bb319207d0f3cc936c647f423170c3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitVec.html#a2bb319207d0f3cc936c647f423170c3f">operator!=</a> (const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S1 &gt; &amp;u1, const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;u2)</td></tr>
<tr class="memdesc:a2bb319207d0f3cc936c647f423170c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two UnitVec3 objects and return true unless they are exactly bitwise equal (not very useful).  <a href="#a2bb319207d0f3cc936c647f423170c3f">More...</a><br /></td></tr>
<tr class="separator:a2bb319207d0f3cc936c647f423170c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1Vec"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Vec')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec&lt; 3, P, S &gt;</a></td></tr>
<tr class="memitem:gaea19f36902b9e41b3774e3103718dab5 inherit related_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr class="memdesc:gaea19f36902b9e41b3774e3103718dab5 inherit related_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5">More...</a><br /></td></tr>
<tr class="separator:gaea19f36902b9e41b3774e3103718dab5 inherit related_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b4dd0ea98de6059b13e98cabbefb82 inherit related_classSimTK_1_1Vec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr class="memdesc:ga75b4dd0ea98de6059b13e98cabbefb82 inherit related_classSimTK_1_1Vec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82">More...</a><br /></td></tr>
<tr class="separator:ga75b4dd0ea98de6059b13e98cabbefb82 inherit related_classSimTK_1_1Vec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P, int S&gt;<br />
class SimTK::UnitVec&lt; P, S &gt;</h3>

<p>This class is a Vec3 plus an ironclad guarantee either that: </p>
<ul>
<li>the length is one (to within a very small tolerance), or</li>
<li>all components are NaN. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abc8a07343261e22409fc61416f549c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8a07343261e22409fc61416f549c6a">&#9670;&nbsp;</a></span>BaseVec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P,S&gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00a0813acda5a13e55b70a419f86a365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0813acda5a13e55b70a419f86a365">&#9670;&nbsp;</a></span>TransposeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt;P,S&gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a73d73693191a8a61c3cc7a97cf3a5d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d73693191a8a61c3cc7a97cf3a5d90">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor initializes to all-NaN even in Release mode so that we maintain the above-promised contract. </p>

</div>
</div>
<a id="a12fb60e996d4a98e4e46d653ed6390fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fb60e996d4a98e4e46d653ed6390fc">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor does not require normalization since we know the source is a unit vector. </p>

</div>
</div>
<a id="a9a6b45877344851eb2b0a82467772973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6b45877344851eb2b0a82467772973">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<div class="memtemplate">
template&lt;int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatic conversion from <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> with different stride; no computation required. </p>

</div>
</div>
<a id="a8da37a5763ddcb9ac2cd134feecd039c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da37a5763ddcb9ac2cd134feecd039c">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion from <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> to <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a>, requiring expensive normalization. </p>

</div>
</div>
<a id="a915d564bb48a436429ad3e2448184a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915d564bb48a436429ad3e2448184a85">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<div class="memtemplate">
template&lt;int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion from <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> of any stride to this <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a>, requiring expensive normalization. </p>

</div>
</div>
<a id="ae5b7b8b209e66dfad70e01d2e0e9324e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b7b8b209e66dfad70e01d2e0e9324e">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a unit vector in the direction of the vector (x,y,z) whose measure numbers are supplied &ndash; this requires an expensive normalization since we don't know that the supplied vector is normalized. </p>

</div>
</div>
<a id="afd6a8daeb3fbbfb03ddd1839f73587fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6a8daeb3fbbfb03ddd1839f73587fc">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from a coordinate axis XAxis, YAxis, or ZAxis to a UnitVec3. Does not require any computation. </p>

</div>
</div>
<a id="aa5650655c4c6d07b74f6282f85d01810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5650655c4c6d07b74f6282f85d01810">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion from a coordinate axis direction to a UnitVec3. The axis direction is given by one of XAxis, YAxis, ZAxis or NegXAxis, NegYAxis, NegZAxis. Does not require any computation. </p>

</div>
</div>
<a id="aba4bece487167338cbd2b8f8e1e4225c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4bece487167338cbd2b8f8e1e4225c">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a unit axis vector 100 010 001 given 0,1, or 2; this is not an implicit conversion. </p>

</div>
</div>
<a id="a6f9391c4529db05af4f2a03cd4233233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9391c4529db05af4f2a03cd4233233">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) This constructor is only for our friends whom we trust to give us an already-normalized vector which we simply accept as normalized without checking. </p>

</div>
</div>
<a id="a8174397397a48a6029fb911f76259fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8174397397a48a6029fb911f76259fc9">&#9670;&nbsp;</a></span>UnitVec() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<div class="memtemplate">
template&lt;int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::<a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) This constructor is only for our friends whom we trust to give us an already-normalized vector which we simply accept as normalized without checking (this version accepts an input vector of any stride). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abaabfb8fb4c3abdfd066721f6c5b8e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaabfb8fb4c3abdfd066721f6c5b8e11">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment does not require normalization. </p>

</div>
</div>
<a id="a9aa161e02139d0d3918d9de7b1a14c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa161e02139d0d3918d9de7b1a14c0d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<div class="memtemplate">
template&lt;int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> whose stride differs from this one; no normalization required. </p>

</div>
</div>
<a id="aa57cd82a11b9175709fc0c9eb5894d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57cd82a11b9175709fc0c9eb5894d2e">&#9670;&nbsp;</a></span>asVec3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitVec.html#abc8a07343261e22409fc61416f549c6a">BaseVec</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::asVec3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the underlying Vec3 (no copying here). </p>

</div>
</div>
<a id="aa5b4573bf0a7a7322c7abc5cdfaddc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b4573bf0a7a7322c7abc5cdfaddc75">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,1&gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new unit vector pointing in the opposite direction from this one; does <em>not</em> modify this <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> object. </p>
<p>Cost is 3 flops. </p>

</div>
</div>
<a id="a5810dc4b53752cc44de3a588e8d65216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810dc4b53752cc44de3a588e8d65216">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,1&gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new unit vector pointing in the opposite direction from this one. </p>
<p>Cost is 3 flops. </p>

</div>
</div>
<a id="a7e84f438d644cd63bc9c20ce96f939cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e84f438d644cd63bc9c20ce96f939cc">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to this unit vector re-expressed as a unit row; no computational cost. </p>

</div>
</div>
<a id="a652eee30279596142606524844c66791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652eee30279596142606524844c66791">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html#a00a0813acda5a13e55b70a419f86a365">TransposeType</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to this unit vector re-expressed as a unit row; no computational cost. </p>

</div>
</div>
<a id="a55ecf6cf67437bccdb4dcca41654b819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ecf6cf67437bccdb4dcca41654b819">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const P&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one element of this unit vector as a const reference; there is no corresponding writable index function since changing a single element of a unit vector would violate the contract that it has unit length at all times. </p>

</div>
</div>
<a id="a1e0eb9a093970e07829e648aacc5b7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0eb9a093970e07829e648aacc5b7f3">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const P&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one element of this unit vector as a const reference; there is no corresponding writable index function since changing a single element of a unit vector would violate the contract that it has unit length at all times. </p>

</div>
</div>
<a id="a881cc1140d712731ea642b91ee8b50b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881cc1140d712731ea642b91ee8b50b5">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,1&gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new unit vector whose measure numbers are the absolute values of the ones here. </p>
<p>This will still have unit length but will be a reflection of this unit vector into the first octant (+x,+y,+z). Note that we are returning the packed form of <a class="el" href="classSimTK_1_1UnitVec.html" title="This class is a Vec3 plus an ironclad guarantee either that: ">UnitVec</a> regardless of our stride here. </p>

</div>
</div>
<a id="a20ab0e607e9508f6a4944dd40afea781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ab0e607e9508f6a4944dd40afea781">&#9670;&nbsp;</a></span>perp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::perp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new unit vector perpendicular to this one but otherwise arbitrary. </p>
<p>Some care is taken to ensure good numerical conditioning for the result regardless of what goes in. Cost is about 50 flops. </p>

</div>
</div>
<a id="a8528f4c817ce5f7b5b20d28fc3bbbf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8528f4c817ce5f7b5b20d28fc3bbbf64">&#9670;&nbsp;</a></span>getAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P, int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&amp; <a class="el" href="classSimTK_1_1UnitVec.html">SimTK::UnitVec</a>&lt; P, S &gt;::getAs </td>
          <td>(</td>
          <td class="paramtype">const P *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Reinterpret a given memory location as a UnitVec like this one, without checking &ndash; don't use this if you aren't absolutely certain that the memory location actually <em>does</em> contain a unit vector, with the correct stride! This overrides the base <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> class method of the same name. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4b67369ce57496d919e2e644324ed3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b67369ce57496d919e2e644324ed3d4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S1, int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two UnitVec3 objects for exact, bitwise equality (not very useful). </p>

</div>
</div>
<a id="a2bb319207d0f3cc936c647f423170c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb319207d0f3cc936c647f423170c3f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S1, int S2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, S2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two UnitVec3 objects and return true unless they are exactly bitwise equal (not very useful). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="UnitVec_8h_source.html">UnitVec.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:19 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
