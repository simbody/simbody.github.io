<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Array_&lt; T, X &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Array__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Array__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Array_&lt; T, X &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library (STL) std::vector&lt;T&gt; class, but with some important advantages in performance, and functionality, and binary compatibility.  
 <a href="classSimTK_1_1Array__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Array_&lt; T, X &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Array__.png" usemap="#SimTK::Array_5F_3C_20T_2C_20X_20_3E_map" alt=""/>
  <map id="SimTK::Array_5F_3C_20T_2C_20X_20_3E_map" name="SimTK::Array_5F_3C_20T_2C_20X_20_3E_map">
<area href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t..." alt="SimTK::ArrayView_&lt; T, X &gt;" shape="rect" coords="0,56,202,80"/>
<area href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we..." alt="SimTK::ArrayViewConst_&lt; T, X &gt;" shape="rect" coords="0,0,202,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types required of STL containers, plus index_type which is an extension, and packed_size_type which is an implementation detail.</p>
</div></td></tr>
<tr class="memitem:ac67020459c021a6a6e076839105b1dd8"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac67020459c021a6a6e076839105b1dd8">value_type</a></td></tr>
<tr class="separator:ac67020459c021a6a6e076839105b1dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aed3ed93a6d406a35da0225352694b1"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3aed3ed93a6d406a35da0225352694b1">index_type</a></td></tr>
<tr class="separator:a3aed3ed93a6d406a35da0225352694b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe40f48092df9a7deafe32ef1ec39fb"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adfe40f48092df9a7deafe32ef1ec39fb">pointer</a></td></tr>
<tr class="separator:adfe40f48092df9a7deafe32ef1ec39fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e344836dca88d0070ee505da9a628bb"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1e344836dca88d0070ee505da9a628bb">const_pointer</a></td></tr>
<tr class="separator:a1e344836dca88d0070ee505da9a628bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5efd5cd3092babe7a107b8efa664204"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae5efd5cd3092babe7a107b8efa664204">reference</a></td></tr>
<tr class="separator:ae5efd5cd3092babe7a107b8efa664204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e967f4929d463e32202d34158f3e22f"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e967f4929d463e32202d34158f3e22f">const_reference</a></td></tr>
<tr class="separator:a3e967f4929d463e32202d34158f3e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05144fefe932d1c76e2e0dcaedddcd03"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03">iterator</a></td></tr>
<tr class="separator:a05144fefe932d1c76e2e0dcaedddcd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a140d8babac3edb92ff620e77245d0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a47a140d8babac3edb92ff620e77245d0">const_iterator</a></td></tr>
<tr class="separator:a47a140d8babac3edb92ff620e77245d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9e2010641fb5df3c7e47c62a6db774"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9a9e2010641fb5df3c7e47c62a6db774">reverse_iterator</a></td></tr>
<tr class="separator:a9a9e2010641fb5df3c7e47c62a6db774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b19c88ae09eec0ff5288e8e824d498"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a96b19c88ae09eec0ff5288e8e824d498">const_reverse_iterator</a></td></tr>
<tr class="separator:a96b19c88ae09eec0ff5288e8e824d498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed205f5372aad3ca9a8366441b16913"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7ed205f5372aad3ca9a8366441b16913">size_type</a></td></tr>
<tr class="separator:a7ed205f5372aad3ca9a8366441b16913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5ca3b32f612044bed7552b7dc96164"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3a5ca3b32f612044bed7552b7dc96164">difference_type</a></td></tr>
<tr class="separator:a3a5ca3b32f612044bed7552b7dc96164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b7dc77f42cab3244ec808e5d4d3ee3"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab1b7dc77f42cab3244ec808e5d4d3ee3">packed_size_type</a></td></tr>
<tr class="separator:ab1b7dc77f42cab3244ec808e5d4d3ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:aeb29ff328a71341945e442234f50e253 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253">value_type</a></td></tr>
<tr class="separator:aeb29ff328a71341945e442234f50e253 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79baa909a71d2f8c75b1120776ccca3 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3">index_type</a></td></tr>
<tr class="separator:ae79baa909a71d2f8c75b1120776ccca3 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fd72f5f77716f823f8c0a9a87974 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974">pointer</a></td></tr>
<tr class="separator:a3950fd72f5f77716f823f8c0a9a87974 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8dabb125276c7fcdaa215b23f808f inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f">const_pointer</a></td></tr>
<tr class="separator:ad6e8dabb125276c7fcdaa215b23f808f inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b454ffabc27881011e3dcfea4014 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014">reference</a></td></tr>
<tr class="separator:ab4b4b454ffabc27881011e3dcfea4014 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611de0d81f0e43b256704e817d63ae47 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47">const_reference</a></td></tr>
<tr class="separator:a611de0d81f0e43b256704e817d63ae47 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566e08689eb53ae89a2b000ed4a4140 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140">iterator</a></td></tr>
<tr class="separator:a6566e08689eb53ae89a2b000ed4a4140 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14185eed75d43f044775a366c02590c0 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0">const_iterator</a></td></tr>
<tr class="separator:a14185eed75d43f044775a366c02590c0 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e9c961a4621efd1bfe21bf099ca77 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77">reverse_iterator</a></td></tr>
<tr class="separator:a704e9c961a4621efd1bfe21bf099ca77 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1232d267e9b8c139cca1512b412a6d1 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1">const_reverse_iterator</a></td></tr>
<tr class="separator:ac1232d267e9b8c139cca1512b412a6d1 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e901cbddbca41c54b22c6216ac804b inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b">size_type</a></td></tr>
<tr class="separator:ab6e901cbddbca41c54b22c6216ac804b inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad962ee7e4110ac6c20bdfa340f81dc inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc">difference_type</a></td></tr>
<tr class="separator:abad962ee7e4110ac6c20bdfa340f81dc inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536141dcc61cfc646bb1f2062e5e558 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558">packed_size_type</a></td></tr>
<tr class="separator:a9536141dcc61cfc646bb1f2062e5e558 inherit pub_types_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td></tr>
<tr class="memdesc:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored in this container.  <a href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">More...</a><br /></td></tr>
<tr class="separator:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td></tr>
<tr class="memdesc:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (an extension).  <a href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">More...</a><br /></td></tr>
<tr class="separator:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td></tr>
<tr class="memdesc:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable pointer to a value_type.  <a href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">More...</a><br /></td></tr>
<tr class="separator:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td></tr>
<tr class="memdesc:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const pointer to a value_type.  <a href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">More...</a><br /></td></tr>
<tr class="separator:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td></tr>
<tr class="memdesc:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable value_type reference.  <a href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">More...</a><br /></td></tr>
<tr class="separator:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td></tr>
<tr class="memdesc:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const value_type reference.  <a href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">More...</a><br /></td></tr>
<tr class="separator:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td></tr>
<tr class="memdesc:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable iterator for this container (same as pointer here).  <a href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">More...</a><br /></td></tr>
<tr class="separator:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td></tr>
<tr class="memdesc:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for this container (same as const_pointer here).  <a href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">More...</a><br /></td></tr>
<tr class="separator:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td></tr>
<tr class="memdesc:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable reverse iterator for this container.  <a href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">More...</a><br /></td></tr>
<tr class="separator:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reverse iterator for this container.  <a href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">More...</a><br /></td></tr>
<tr class="separator:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td></tr>
<tr class="memdesc:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integral type suitable for all indices and sizes for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">More...</a><br /></td></tr>
<tr class="separator:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td></tr>
<tr class="memdesc:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference between any two legitimate index values for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">More...</a><br /></td></tr>
<tr class="separator:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td></tr>
<tr class="memdesc:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type we actually use internally to store size_type values.  <a href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">More...</a><br /></td></tr>
<tr class="separator:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, conversion and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A variety of constructors are provided for this class, including all those required by the C++ standard for std::vector implementations, plus additional ones providing smooth conversions between Array_&lt;T&gt; and std::vector&lt;T&gt; objects. </p>
</div></td></tr>
<tr class="memitem:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adc75b3e8df6112d5ea6fd77ad024bcc3">Array_</a> ()</td></tr>
<tr class="memdesc:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#adc75b3e8df6112d5ea6fd77ad024bcc3">More...</a><br /></td></tr>
<tr class="separator:adc75b3e8df6112d5ea6fd77ad024bcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e625487e34b5255619a492514926d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7a9e625487e34b5255619a492514926d">Array_</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a7a9e625487e34b5255619a492514926d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array containing <em>n</em> default-constructed elements.  <a href="#a7a9e625487e34b5255619a492514926d">More...</a><br /></td></tr>
<tr class="separator:a7a9e625487e34b5255619a492514926d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758f8ef3bb565989a22c5456a34f3b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad758f8ef3bb565989a22c5456a34f3b6">Array_</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;initVal)</td></tr>
<tr class="memdesc:ad758f8ef3bb565989a22c5456a34f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array containing <em>n</em> elements each set to a copy of the given initial value.  <a href="#ad758f8ef3bb565989a22c5456a34f3b6">More...</a><br /></td></tr>
<tr class="separator:ad758f8ef3bb565989a22c5456a34f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730175ab17a18e5d87974ea97c712e3e"><td class="memTemplParams" colspan="2">template&lt;class InputIter &gt; </td></tr>
<tr class="memitem:a730175ab17a18e5d87974ea97c712e3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a730175ab17a18e5d87974ea97c712e3e">Array_</a> (const InputIter &amp;first, const InputIter &amp;last1)</td></tr>
<tr class="memdesc:a730175ab17a18e5d87974ea97c712e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of iterators.  <a href="#a730175ab17a18e5d87974ea97c712e3e">More...</a><br /></td></tr>
<tr class="separator:a730175ab17a18e5d87974ea97c712e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b385c4c710cf60fc4205371c7d5cc"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a782b385c4c710cf60fc4205371c7d5cc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a782b385c4c710cf60fc4205371c7d5cc">Array_</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a782b385c4c710cf60fc4205371c7d5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of ordinary pointers to elements of type T2 (where T2 might be the same as T but doesn't have to be).  <a href="#a782b385c4c710cf60fc4205371c7d5cc">More...</a><br /></td></tr>
<tr class="separator:a782b385c4c710cf60fc4205371c7d5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6e34513938cae73d83e8ec0325452e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#abc6e34513938cae73d83e8ec0325452e">Array_</a> (std::initializer_list&lt; T &gt; ilist)</td></tr>
<tr class="memdesc:abc6e34513938cae73d83e8ec0325452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; from an std::initializer_list whose elements were convertible to type T, provided that the number of source elements does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a>.  <a href="#abc6e34513938cae73d83e8ec0325452e">More...</a><br /></td></tr>
<tr class="separator:abc6e34513938cae73d83e8ec0325452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a40d3d7fccc13d4d892ce52ebccdf4acc">Array_</a> (const std::vector&lt; T2 &gt; &amp;v)</td></tr>
<tr class="memdesc:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by copying from an std::vector&lt;T2&gt;, where T2 may be the same type as T but doesn't have to be.  <a href="#a40d3d7fccc13d4d892ce52ebccdf4acc">More...</a><br /></td></tr>
<tr class="separator:a40d3d7fccc13d4d892ce52ebccdf4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe60949157ed425b6b81b7ff0e11ca29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#afe60949157ed425b6b81b7ff0e11ca29">Array_</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;src)</td></tr>
<tr class="memdesc:afe60949157ed425b6b81b7ff0e11ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor allocates exactly as much memory as is in use in the source (not its capacity) and copy constructs the elements so that T's copy constructor will be called exactly src.size() times.  <a href="#afe60949157ed425b6b81b7ff0e11ca29">More...</a><br /></td></tr>
<tr class="separator:afe60949157ed425b6b81b7ff0e11ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b67c7069d980ef974690db7aca3bf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af2b67c7069d980ef974690db7aca3bf1">Array_</a> (<a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:af2b67c7069d980ef974690db7aca3bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor swaps in the source and leaves the source default constructed.  <a href="#af2b67c7069d980ef974690db7aca3bf1">More...</a><br /></td></tr>
<tr class="separator:af2b67c7069d980ef974690db7aca3bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a2741c555a387d09742b9a5517314"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:af66a2741c555a387d09742b9a5517314"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af66a2741c555a387d09742b9a5517314">Array_</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:af66a2741c555a387d09742b9a5517314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this Array_&lt;T,X&gt; as a copy of another Array_&lt;T2,X2&gt; where T2!=T or X2!=X.  <a href="#af66a2741c555a387d09742b9a5517314">More...</a><br /></td></tr>
<tr class="separator:af66a2741c555a387d09742b9a5517314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d115efe0bc7dafba02b3d04562dd92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a53d115efe0bc7dafba02b3d04562dd92">Array_</a> (T *first, const T *last1, const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;)</td></tr>
<tr class="memdesc:a53d115efe0bc7dafba02b3d04562dd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data [first,last1), without copying that data; better to use the corresponding ArrayView_&lt;T&gt; constructor if you can.  <a href="#a53d115efe0bc7dafba02b3d04562dd92">More...</a><br /></td></tr>
<tr class="separator:a53d115efe0bc7dafba02b3d04562dd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3331ee7155535eeac08b7297da16ebe3"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a3331ee7155535eeac08b7297da16ebe3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3331ee7155535eeac08b7297da16ebe3">Array_</a> (std::vector&lt; T, A &gt; &amp;v, const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;)</td></tr>
<tr class="memdesc:a3331ee7155535eeac08b7297da16ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array_&lt;T&gt; by referencing (sharing) the data in an std::vector&lt;T&gt;, without copying the data; better to use the ArrayView_&lt;T&gt; constructor instead if you can.  <a href="#a3331ee7155535eeac08b7297da16ebe3">More...</a><br /></td></tr>
<tr class="separator:a3331ee7155535eeac08b7297da16ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad55d3b71e2acdaa0f2bb8be2617c894f">~Array_</a> ()</td></tr>
<tr class="memdesc:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor performs a <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> operation which may result in element destruction and freeing of heap space; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information.  <a href="#ad55d3b71e2acdaa0f2bb8be2617c894f">More...</a><br /></td></tr>
<tr class="separator:ad55d3b71e2acdaa0f2bb8be2617c894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38">deallocate</a> ()</td></tr>
<tr class="memdesc:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty this array of its contents, returning the array to its default-constructed, all-zero state.  <a href="#a67bc6c09d3ea513dfba42a5dfc42cd38">More...</a><br /></td></tr>
<tr class="separator:a67bc6c09d3ea513dfba42a5dfc42cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment methods and operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods put new data values in an existing array, but the meaning of assignment is subtly different for resizeable (owner) arrays and fixed (non-owner) arrays.</p>
<p>The standard std::vector type is always an owner so the non-owner description here is an extension applying only to <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>.</p>
<p>For the normal case of resizeable arrays, assignment does not have an elementwise definition because the source will typically have a different number of elements than the array's current size. So regardless of the actual numbers, assignment in the resizeable case is defined as it is for std::vector: first clear the array by erasing (destructing) all the current elements in the array, then reserve sufficient heap space to hold a copy of the source, then use appropriate constructors of type T (most commonly T's copy constructor T(T)) to initialize each element to be a copy of the corresponding source element. T's assignment operators are never used in this case.</p>
<p>For fixed arrays, the source must have the same number of elements as are currently in the array and the meaning is conventional elementwise assignment; that is, an appropriate assignment operator of type T (most commonly T's copy assignment operator T=T) is used to change the value of each existing element.</p>
<p>So there are different requirements on the value type T for owner and non-owner assignments to type T2: for owner assignment T must have a constructor T(T2) available; for non-owner assignment, T must have an assignment operator T=T2 available.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>When reallocating the destination array, we may reuse the existing heap allocation if it is sufficient and not <em>too</em> big; otherwise we'll reallocate before copying.</li>
<li>The <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> method here has elementwise assignment semantics regardless of whether the array is an owner or non-owner. </li>
</ul>
</dd></dl>
</div></td></tr>
<tr class="memitem:a136a03677c28d7ee697df7e09b7aa2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a136a03677c28d7ee697df7e09b7aa2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this array to be <em>n</em> copies of the supplied <em>fillValue</em>.  <a href="#a136a03677c28d7ee697df7e09b7aa2e2">More...</a><br /></td></tr>
<tr class="separator:a136a03677c28d7ee697df7e09b7aa2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc4a2796075ec7a3097bcc6d616bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a66cc4a2796075ec7a3097bcc6d616bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all current elements of the array to the same <em>fillValue</em>.  <a href="#a66cc4a2796075ec7a3097bcc6d616bab">More...</a><br /></td></tr>
<tr class="separator:a66cc4a2796075ec7a3097bcc6d616bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1614ce819a2a4221c0a072ffbc2a0935">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a1614ce819a2a4221c0a072ffbc2a0935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to to make it a copy of the elements in range [first,last1) given by ordinary pointers.  <a href="#a1614ce819a2a4221c0a072ffbc2a0935">More...</a><br /></td></tr>
<tr class="separator:a1614ce819a2a4221c0a072ffbc2a0935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab0fbbed70bc0fdb3ec5c188193503bb8">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this array from a range [first,last1) given by non-pointer iterators.  <a href="#ab0fbbed70bc0fdb3ec5c188193503bb8">More...</a><br /></td></tr>
<tr class="separator:ab0fbbed70bc0fdb3ec5c188193503bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a17aa8ec53fbbd5af9d8311040b4e215a">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;src)</td></tr>
<tr class="memdesc:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator destructs the current contents of this array and then makes it a copy of the source array by repeated calls to the element type's copy constructor.  <a href="#a17aa8ec53fbbd5af9d8311040b4e215a">More...</a><br /></td></tr>
<tr class="separator:a17aa8ec53fbbd5af9d8311040b4e215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82b083ea513ddfe43db268eca1cc39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac82b083ea513ddfe43db268eca1cc39f">operator=</a> (<a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:ac82b083ea513ddfe43db268eca1cc39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator swaps the contents of this <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> with the source <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>.  <a href="#ac82b083ea513ddfe43db268eca1cc39f">More...</a><br /></td></tr>
<tr class="separator:ac82b083ea513ddfe43db268eca1cc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31782606c119d1db301ef14a930abd22"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a31782606c119d1db301ef14a930abd22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a31782606c119d1db301ef14a930abd22">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a31782606c119d1db301ef14a930abd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is assignment from a source array whose element type T2 and/or index type X2 are different from this array's T and X.  <a href="#a31782606c119d1db301ef14a930abd22">More...</a><br /></td></tr>
<tr class="separator:a31782606c119d1db301ef14a930abd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abada82afde9d55dbde8b44052ce1fda1"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A &gt; </td></tr>
<tr class="memitem:abada82afde9d55dbde8b44052ce1fda1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#abada82afde9d55dbde8b44052ce1fda1">operator=</a> (const std::vector&lt; T2, A &gt; &amp;src)</td></tr>
<tr class="memdesc:abada82afde9d55dbde8b44052ce1fda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is assignment from a source std::vector&lt;T2&gt;.  <a href="#abada82afde9d55dbde8b44052ce1fda1">More...</a><br /></td></tr>
<tr class="separator:abada82afde9d55dbde8b44052ce1fda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c544ef3a4eee81c7580699e793e0f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92">swap</a> (<a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;other)</td></tr>
<tr class="memdesc:a4c544ef3a4eee81c7580699e793e0f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialized algorithm providing constant time exchange of data with another array that has identical element and index types.  <a href="#a4c544ef3a4eee81c7580699e793e0f92">More...</a><br /></td></tr>
<tr class="separator:a4c544ef3a4eee81c7580699e793e0f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5671ab71d22a14e65a149feea9c577a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a">adoptData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataCapacity)</td></tr>
<tr class="memdesc:ac5671ab71d22a14e65a149feea9c577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This dangerous extension allows you to supply your own already-allocated heap space for use by this array, which then becomes the owner of the supplied heap space.  <a href="#ac5671ab71d22a14e65a149feea9c577a">More...</a><br /></td></tr>
<tr class="separator:ac5671ab71d22a14e65a149feea9c577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37550aafe7e3c54f9604ff80479153e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a37550aafe7e3c54f9604ff80479153e9">adoptData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize)</td></tr>
<tr class="memdesc:a37550aafe7e3c54f9604ff80479153e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> that assumes the capacity is the same as the current size.  <a href="#a37550aafe7e3c54f9604ff80479153e9">More...</a><br /></td></tr>
<tr class="separator:a37550aafe7e3c54f9604ff80479153e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51e9d13453755cb0cce47af007d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7">shareData</a> (T *newData, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> dataSize)</td></tr>
<tr class="memdesc:a3e51e9d13453755cb0cce47af007d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This dangerous extension allows you to make this array handle refer to someone else's data without copying it.  <a href="#a3e51e9d13453755cb0cce47af007d3c7">More...</a><br /></td></tr>
<tr class="separator:a3e51e9d13453755cb0cce47af007d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780ca6f8edd609cd461b0a90fbbca64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa780ca6f8edd609cd461b0a90fbbca64">shareData</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:aa780ca6f8edd609cd461b0a90fbbca64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as shareData(data,size) but uses a pointer range [first,last1) to identify the data to be referenced.  <a href="#aa780ca6f8edd609cd461b0a90fbbca64">More...</a><br /></td></tr>
<tr class="separator:aa780ca6f8edd609cd461b0a90fbbca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods examine and alter the number of elements (size) or the amount of allocated heap space (capacity) or both.</p>
</div></td></tr>
<tr class="memitem:a8f820d2b0218c551e2d9ec4db5ce06e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0">size</a> () const</td></tr>
<tr class="memdesc:a8f820d2b0218c551e2d9ec4db5ce06e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="#a8f820d2b0218c551e2d9ec4db5ce06e0">More...</a><br /></td></tr>
<tr class="separator:a8f820d2b0218c551e2d9ec4db5ce06e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5065ed0d97dd73046429a808b975dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd">max_size</a> () const</td></tr>
<tr class="memdesc:add5065ed0d97dd73046429a808b975dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="#add5065ed0d97dd73046429a808b975dd">More...</a><br /></td></tr>
<tr class="separator:add5065ed0d97dd73046429a808b975dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc498823f6144cc7aea3a3c73b2f05fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#acc498823f6144cc7aea3a3c73b2f05fd">empty</a> () const</td></tr>
<tr class="memdesc:acc498823f6144cc7aea3a3c73b2f05fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="#acc498823f6144cc7aea3a3c73b2f05fd">More...</a><br /></td></tr>
<tr class="separator:acc498823f6144cc7aea3a3c73b2f05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7931f3efebaa00feb25d689df891312e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e">capacity</a> () const</td></tr>
<tr class="memdesc:a7931f3efebaa00feb25d689df891312e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="#a7931f3efebaa00feb25d689df891312e">More...</a><br /></td></tr>
<tr class="separator:a7931f3efebaa00feb25d689df891312e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4">resize</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of this Array, preserving all the elements that will still fit, and default constructing any new elements that are added.  <a href="#a3ef48cf9aac351db79f747c2ddd23bf4">More...</a><br /></td></tr>
<tr class="separator:a3ef48cf9aac351db79f747c2ddd23bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab839b023c760816f9580d4feea2c9136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab839b023c760816f9580d4feea2c9136">resize</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;initVal)</td></tr>
<tr class="memdesc:ab839b023c760816f9580d4feea2c9136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of this array, preserving all the elements that will still fit, and initializing any new elements that are added by repeatedly copy- constructing from the supplied value.  <a href="#ab839b023c760816f9580d4feea2c9136">More...</a><br /></td></tr>
<tr class="separator:ab839b023c760816f9580d4feea2c9136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a18b9cb15ea07f2da45d9b45a8f12429e">reserve</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n)</td></tr>
<tr class="memdesc:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that this array has enough allocated capacity to hold the indicated number of elements.  <a href="#a18b9cb15ea07f2da45d9b45a8f12429e">More...</a><br /></td></tr>
<tr class="separator:a18b9cb15ea07f2da45d9b45a8f12429e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5af2017b0c5a1a2160104d98a59294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aad5af2017b0c5a1a2160104d98a59294">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aad5af2017b0c5a1a2160104d98a59294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the capacity of this array be reduced to the minimum necessary to hold the number of elements currently in use.  <a href="#aad5af2017b0c5a1a2160104d98a59294">More...</a><br /></td></tr>
<tr class="separator:aad5af2017b0c5a1a2160104d98a59294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776f1653877f391bf4bca84bbcdaf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3776f1653877f391bf4bca84bbcdaf08">allocated</a> () const</td></tr>
<tr class="memdesc:a3776f1653877f391bf4bca84bbcdaf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="#a3776f1653877f391bf4bca84bbcdaf08">More...</a><br /></td></tr>
<tr class="separator:a3776f1653877f391bf4bca84bbcdaf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939d50fcf641771c66141cba7dbef20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae939d50fcf641771c66141cba7dbef20">isOwner</a> () const</td></tr>
<tr class="memdesc:ae939d50fcf641771c66141cba7dbef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="#ae939d50fcf641771c66141cba7dbef20">More...</a><br /></td></tr>
<tr class="separator:ae939d50fcf641771c66141cba7dbef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods deal in iterators, which are STL generalized pointers.</p>
<p>For this class, iterators are just ordinary pointers to T, and you may depend on that. By necessity, reverse iterators can't be just pointers; however, they contain an ordinary iterator (i.e. a pointer) that can be obtained by calling the reverse iterator's base() method. </p>
</div></td></tr>
<tr class="memitem:afcc6178c93196de7d6f78624cfe2a821"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#afcc6178c93196de7d6f78624cfe2a821">cbegin</a> () const</td></tr>
<tr class="memdesc:afcc6178c93196de7d6f78624cfe2a821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="#afcc6178c93196de7d6f78624cfe2a821">More...</a><br /></td></tr>
<tr class="separator:afcc6178c93196de7d6f78624cfe2a821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77732b6b0a3679081923826db10870ba"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a77732b6b0a3679081923826db10870ba">begin</a> () const</td></tr>
<tr class="memdesc:a77732b6b0a3679081923826db10870ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#afcc6178c93196de7d6f78624cfe2a821" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#a77732b6b0a3679081923826db10870ba">More...</a><br /></td></tr>
<tr class="separator:a77732b6b0a3679081923826db10870ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a252bd681eeb8d9e4075343263f1f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f">begin</a> ()</td></tr>
<tr class="memdesc:ab87a252bd681eeb8d9e4075343263f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>.  <a href="#ab87a252bd681eeb8d9e4075343263f1f">More...</a><br /></td></tr>
<tr class="separator:ab87a252bd681eeb8d9e4075343263f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392fc413a7e6957848172360af68efb9"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9">cend</a> () const</td></tr>
<tr class="memdesc:a392fc413a7e6957848172360af68efb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#a392fc413a7e6957848172360af68efb9">More...</a><br /></td></tr>
<tr class="separator:a392fc413a7e6957848172360af68efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a0ed3b9cfec01b45c49428f3e413a"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a564a0ed3b9cfec01b45c49428f3e413a">end</a> () const</td></tr>
<tr class="memdesc:a564a0ed3b9cfec01b45c49428f3e413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#a564a0ed3b9cfec01b45c49428f3e413a">More...</a><br /></td></tr>
<tr class="separator:a564a0ed3b9cfec01b45c49428f3e413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12efc66437667e7af14e54747433ec"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec">end</a> ()</td></tr>
<tr class="memdesc:a5a12efc66437667e7af14e54747433ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="#a5a12efc66437667e7af14e54747433ec">More...</a><br /></td></tr>
<tr class="separator:a5a12efc66437667e7af14e54747433ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bbcdacbcb1c051e86b9137eb23073f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae9bbcdacbcb1c051e86b9137eb23073f">crbegin</a> () const</td></tr>
<tr class="memdesc:ae9bbcdacbcb1c051e86b9137eb23073f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a8f747e785bf5492c949288dfcd3c3bcb" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#ae9bbcdacbcb1c051e86b9137eb23073f">More...</a><br /></td></tr>
<tr class="separator:ae9bbcdacbcb1c051e86b9137eb23073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c5052c882cd2987d08f0e637d1799a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad8c5052c882cd2987d08f0e637d1799a">rbegin</a> () const</td></tr>
<tr class="memdesc:ad8c5052c882cd2987d08f0e637d1799a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#ae9bbcdacbcb1c051e86b9137eb23073f" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#ad8c5052c882cd2987d08f0e637d1799a">More...</a><br /></td></tr>
<tr class="separator:ad8c5052c882cd2987d08f0e637d1799a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa">rbegin</a> ()</td></tr>
<tr class="memdesc:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="#aab002eb8f193aea7d6b4ab3683ff89aa">More...</a><br /></td></tr>
<tr class="separator:aab002eb8f193aea7d6b4ab3683ff89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f747e785bf5492c949288dfcd3c3bcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8f747e785bf5492c949288dfcd3c3bcb">crend</a> () const</td></tr>
<tr class="memdesc:a8f747e785bf5492c949288dfcd3c3bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a8f747e785bf5492c949288dfcd3c3bcb">More...</a><br /></td></tr>
<tr class="separator:a8f747e785bf5492c949288dfcd3c3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7f41a04a8ea0f5360684ed4c237cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9d7f41a04a8ea0f5360684ed4c237cfb">rend</a> () const</td></tr>
<tr class="memdesc:a9d7f41a04a8ea0f5360684ed4c237cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a8f747e785bf5492c949288dfcd3c3bcb" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#a9d7f41a04a8ea0f5360684ed4c237cfb">More...</a><br /></td></tr>
<tr class="separator:a9d7f41a04a8ea0f5360684ed4c237cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5973f198607a6531235df6877ab9979d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d">rend</a> ()</td></tr>
<tr class="memdesc:a5973f198607a6531235df6877ab9979d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a5973f198607a6531235df6877ab9979d">More...</a><br /></td></tr>
<tr class="separator:a5973f198607a6531235df6877ab9979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0361eed504c3f5db4921bd02c636265"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad0361eed504c3f5db4921bd02c636265">cdata</a> () const</td></tr>
<tr class="memdesc:ad0361eed504c3f5db4921bd02c636265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#ad0361eed504c3f5db4921bd02c636265">More...</a><br /></td></tr>
<tr class="separator:ad0361eed504c3f5db4921bd02c636265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e12831ee2fc61aea5d7e1144c20626d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e12831ee2fc61aea5d7e1144c20626d">data</a> () const</td></tr>
<tr class="memdesc:a3e12831ee2fc61aea5d7e1144c20626d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1Array__.html#ad0361eed504c3f5db4921bd02c636265" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#a3e12831ee2fc61aea5d7e1144c20626d">More...</a><br /></td></tr>
<tr class="separator:a3e12831ee2fc61aea5d7e1144c20626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05128fb7611eb19f884b1e742878277"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277">data</a> ()</td></tr>
<tr class="memdesc:af05128fb7611eb19f884b1e742878277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="#af05128fb7611eb19f884b1e742878277">More...</a><br /></td></tr>
<tr class="separator:af05128fb7611eb19f884b1e742878277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide read and write access to individual elements, or groups of elements, that are currently present in the array.</p>
</div></td></tr>
<tr class="memitem:ae53b1148637b73697f682031e5c4f87e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae53b1148637b73697f682031e5c4f87e">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:ae53b1148637b73697f682031e5c4f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#ae53b1148637b73697f682031e5c4f87e">More...</a><br /></td></tr>
<tr class="separator:ae53b1148637b73697f682031e5c4f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a52dc3c8d6816f2cc3d9e42caa2688993">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="#a52dc3c8d6816f2cc3d9e42caa2688993">More...</a><br /></td></tr>
<tr class="separator:a52dc3c8d6816f2cc3d9e42caa2688993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6484d35a4f3885e5dd9b53d72780c5b0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a6484d35a4f3885e5dd9b53d72780c5b0">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:a6484d35a4f3885e5dd9b53d72780c5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a6484d35a4f3885e5dd9b53d72780c5b0">More...</a><br /></td></tr>
<tr class="separator:a6484d35a4f3885e5dd9b53d72780c5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa8a43460f045aeb40cc0e1ca44aacbc1">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#aa8a43460f045aeb40cc0e1ca44aacbc1">More...</a><br /></td></tr>
<tr class="separator:aa8a43460f045aeb40cc0e1ca44aacbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613cf92a24e169554e2a829b631b193"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af613cf92a24e169554e2a829b631b193">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:af613cf92a24e169554e2a829b631b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#af613cf92a24e169554e2a829b631b193">More...</a><br /></td></tr>
<tr class="separator:af613cf92a24e169554e2a829b631b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa17ec9fa947bdc8b7aa75a0d09b36214">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#aa17ec9fa947bdc8b7aa75a0d09b36214">More...</a><br /></td></tr>
<tr class="separator:aa17ec9fa947bdc8b7aa75a0d09b36214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d59bf9348d5b75066d01970ecd4ca0"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa3d59bf9348d5b75066d01970ecd4ca0">front</a> () const</td></tr>
<tr class="memdesc:aa3d59bf9348d5b75066d01970ecd4ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="#aa3d59bf9348d5b75066d01970ecd4ca0">More...</a><br /></td></tr>
<tr class="separator:aa3d59bf9348d5b75066d01970ecd4ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e306ed9d706676046787b8f8c049480"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a3e306ed9d706676046787b8f8c049480">front</a> ()</td></tr>
<tr class="memdesc:a3e306ed9d706676046787b8f8c049480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="#a3e306ed9d706676046787b8f8c049480">More...</a><br /></td></tr>
<tr class="separator:a3e306ed9d706676046787b8f8c049480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e63e9cd875462bad8308f09f85c7a2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a09e63e9cd875462bad8308f09f85c7a2">back</a> () const</td></tr>
<tr class="memdesc:a09e63e9cd875462bad8308f09f85c7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="#a09e63e9cd875462bad8308f09f85c7a2">More...</a><br /></td></tr>
<tr class="separator:a09e63e9cd875462bad8308f09f85c7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af001d2418473e4e149969b0aea2ac96a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a">back</a> ()</td></tr>
<tr class="memdesc:af001d2418473e4e149969b0aea2ac96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="#af001d2418473e4e149969b0aea2ac96a">More...</a><br /></td></tr>
<tr class="separator:af001d2418473e4e149969b0aea2ac96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eea146d6440641b621056595b7be6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa0eea146d6440641b621056595b7be6a">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:aa0eea146d6440641b621056595b7be6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a subrange of this const array by starting index and length, and return a <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> referencing that data without copying it.  <a href="#aa0eea146d6440641b621056595b7be6a">More...</a><br /></td></tr>
<tr class="separator:aa0eea146d6440641b621056595b7be6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0aa0729350862986dc0a9c0652d9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a64d0aa0729350862986dc0a9c0652d9f">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:a64d0aa0729350862986dc0a9c0652d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a64d0aa0729350862986dc0a9c0652d9f">More...</a><br /></td></tr>
<tr class="separator:a64d0aa0729350862986dc0a9c0652d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd317755142dd7707305ba1dd36c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9cbd317755142dd7707305ba1dd36c4b">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a9cbd317755142dd7707305ba1dd36c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a subrange of this array by starting index and length, and return an <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> referencing that data without copying it.  <a href="#a9cbd317755142dd7707305ba1dd36c4b">More...</a><br /></td></tr>
<tr class="separator:a9cbd317755142dd7707305ba1dd36c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223502957a0d38152ea9bda9ac194829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a223502957a0d38152ea9bda9ac194829">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a223502957a0d38152ea9bda9ac194829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a223502957a0d38152ea9bda9ac194829">More...</a><br /></td></tr>
<tr class="separator:a223502957a0d38152ea9bda9ac194829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">ArrayView_</a> ()</td></tr>
<tr class="memdesc:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">More...</a><br /></td></tr>
<tr class="separator:aa8e89ce2da1f241ae70e38cfe63ba980 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">ArrayView_</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow.  <a href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">More...</a><br /></td></tr>
<tr class="separator:ad1ddf75311833fc599a934c3f3d5a57d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">ArrayView_</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a range of writable memory.  <a href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">More...</a><br /></td></tr>
<tr class="separator:a8e6104f869055379b0fbd146aeefa919 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">ArrayView_</a> (std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct to reference memory owned by a writable std::vector.  <a href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">More...</a><br /></td></tr>
<tr class="separator:a176653cfecc6ee9dd5cbb08f53725a34 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b1cc7aa9e01c80acc744ede6407cc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aed5b1cc7aa9e01c80acc744ede6407cc">operator const Array_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:aed5b1cc7aa9e01c80acc744ede6407cc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost).  <a href="classSimTK_1_1ArrayView__.html#aed5b1cc7aa9e01c80acc744ede6407cc">More...</a><br /></td></tr>
<tr class="separator:aed5b1cc7aa9e01c80acc744ede6407cc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">operator Array_&lt; T, X &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost).  <a href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">More...</a><br /></td></tr>
<tr class="separator:a6ef7f785e236628b37192a5380d0a479 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">disconnect</a> ()</td></tr>
<tr class="memdesc:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method  clears the handle without doing anything to the data...">disconnect()</a> method &ndash; clears the handle without doing anything to the data.  <a href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">More...</a><br /></td></tr>
<tr class="separator:a7848acb2e30474663b3d708e80f2b6bc inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">~ArrayView_</a> ()</td></tr>
<tr class="memdesc:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information.  <a href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">More...</a><br /></td></tr>
<tr class="separator:a509b38ff0b42a6ff6b38cd3b26f4096f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment; source must be the same size as this array.  <a href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">More...</a><br /></td></tr>
<tr class="separator:a1a3e84580379c69d92ab24d96fa6c180 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">More...</a><br /></td></tr>
<tr class="separator:a7f8826e1792377e63d47b9c9a3c53584 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">More...</a><br /></td></tr>
<tr class="separator:acb5dc46e5a1126a8e30882e53a86c62d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">More...</a><br /></td></tr>
<tr class="separator:a45bc77b91b7751a909ca6524346c9e8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">operator=</a> (const std::vector&lt; T2, A2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">More...</a><br /></td></tr>
<tr class="separator:a68daffa0f934e5f3d6f75adcb5d93367 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">operator=</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill assignment &ndash; all elements are set to fillValue.  <a href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">More...</a><br /></td></tr>
<tr class="separator:a29e6a21ecbf455765267d5d12bde8628 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element.  <a href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">More...</a><br /></td></tr>
<tr class="separator:a1dbebca5377888478d004f882a6c24e2 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size.  <a href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">More...</a><br /></td></tr>
<tr class="separator:a06a7d28c5d7a0586b39260b4a167f10c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array.  <a href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">More...</a><br /></td></tr>
<tr class="separator:a39312ebedf1ce457f129b39c69d4515a inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant).  <a href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">More...</a><br /></td></tr>
<tr class="separator:afb5c2516d03bb21d24ea4e87af777136 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b61bbc4573a1ceb006a2ce00eb9b1ee inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8b61bbc4573a1ceb006a2ce00eb9b1ee">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:a8b61bbc4573a1ceb006a2ce00eb9b1ee inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="classSimTK_1_1ArrayView__.html#a8b61bbc4573a1ceb006a2ce00eb9b1ee">More...</a><br /></td></tr>
<tr class="separator:a8b61bbc4573a1ceb006a2ce00eb9b1ee inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">More...</a><br /></td></tr>
<tr class="separator:a943c9a87081523151ddbf1d22a853e4e inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fb9c25420a0202ace54bf01a49a07 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee4fb9c25420a0202ace54bf01a49a07">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:aee4fb9c25420a0202ace54bf01a49a07 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayView__.html#aee4fb9c25420a0202ace54bf01a49a07">More...</a><br /></td></tr>
<tr class="separator:aee4fb9c25420a0202ace54bf01a49a07 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">More...</a><br /></td></tr>
<tr class="separator:ab93f3650f5d31037f0051431eb02b57b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9b2cd521db0ae0b2b56bd8b0e8838f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acf9b2cd521db0ae0b2b56bd8b0e8838f">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:acf9b2cd521db0ae0b2b56bd8b0e8838f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayView__.html#acf9b2cd521db0ae0b2b56bd8b0e8838f">More...</a><br /></td></tr>
<tr class="separator:acf9b2cd521db0ae0b2b56bd8b0e8838f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">More...</a><br /></td></tr>
<tr class="separator:a538c58736523ef56cafe9d926ec6e8f5 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05c55b3fe25b7cac1adb40415701cef inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac05c55b3fe25b7cac1adb40415701cef">front</a> () const</td></tr>
<tr class="memdesc:ac05c55b3fe25b7cac1adb40415701cef inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#ac05c55b3fe25b7cac1adb40415701cef">More...</a><br /></td></tr>
<tr class="separator:ac05c55b3fe25b7cac1adb40415701cef inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">front</a> ()</td></tr>
<tr class="memdesc:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">More...</a><br /></td></tr>
<tr class="separator:a1c3c26db7d7178a3e3c0b4603c7d0fcd inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2342c3da808e5da540ea5eea430cce inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb2342c3da808e5da540ea5eea430cce">back</a> () const</td></tr>
<tr class="memdesc:aeb2342c3da808e5da540ea5eea430cce inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#aeb2342c3da808e5da540ea5eea430cce">More...</a><br /></td></tr>
<tr class="separator:aeb2342c3da808e5da540ea5eea430cce inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">back</a> ()</td></tr>
<tr class="memdesc:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">More...</a><br /></td></tr>
<tr class="separator:abf707303e5e68fb5147fa36862c2bc57 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying).  <a href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">More...</a><br /></td></tr>
<tr class="separator:ab89285bb25b06bc6a1b53fca6e63e3b7 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">More...</a><br /></td></tr>
<tr class="separator:a33b3799cc9d10a4e4a6781292f7bdc15 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd0054fa1b411aa09edeb85b5f994a4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4">cbegin</a> () const</td></tr>
<tr class="memdesc:acfd0054fa1b411aa09edeb85b5f994a4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>, which may be null (0) in that case but does not have to be.  <a href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4">More...</a><br /></td></tr>
<tr class="separator:acfd0054fa1b411aa09edeb85b5f994a4 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385a3a9743c8965c9a00f77db978339 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0385a3a9743c8965c9a00f77db978339">begin</a> () const</td></tr>
<tr class="memdesc:a0385a3a9743c8965c9a00f77db978339 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="classSimTK_1_1ArrayView__.html#a0385a3a9743c8965c9a00f77db978339">More...</a><br /></td></tr>
<tr class="separator:a0385a3a9743c8965c9a00f77db978339 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">begin</a> ()</td></tr>
<tr class="memdesc:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>.  <a href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">More...</a><br /></td></tr>
<tr class="separator:aa468711f19b67b25232650df6eeea608 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b4d187de22f6b7f2575ec16fb4fed inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed">cend</a> () const</td></tr>
<tr class="memdesc:a854b4d187de22f6b7f2575ec16fb4fed inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed">More...</a><br /></td></tr>
<tr class="separator:a854b4d187de22f6b7f2575ec16fb4fed inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86675d5260136d99f837c137ce01d0c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad86675d5260136d99f837c137ce01d0c">end</a> () const</td></tr>
<tr class="memdesc:ad86675d5260136d99f837c137ce01d0c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="classSimTK_1_1ArrayView__.html#ad86675d5260136d99f837c137ce01d0c">More...</a><br /></td></tr>
<tr class="separator:ad86675d5260136d99f837c137ce01d0c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">end</a> ()</td></tr>
<tr class="memdesc:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">More...</a><br /></td></tr>
<tr class="separator:ace5b2a07f725b6e943d45ad786bf02cb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7e8546725ca792aa315054f7c92f24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24">crbegin</a> () const</td></tr>
<tr class="memdesc:a2f7e8546725ca792aa315054f7c92f24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24">More...</a><br /></td></tr>
<tr class="separator:a2f7e8546725ca792aa315054f7c92f24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfad5c666de9b4d50e4d68df3b3536b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#accfad5c666de9b4d50e4d68df3b3536b">rbegin</a> () const</td></tr>
<tr class="memdesc:accfad5c666de9b4d50e4d68df3b3536b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="classSimTK_1_1ArrayView__.html#accfad5c666de9b4d50e4d68df3b3536b">More...</a><br /></td></tr>
<tr class="separator:accfad5c666de9b4d50e4d68df3b3536b inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">rbegin</a> ()</td></tr>
<tr class="memdesc:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">More...</a><br /></td></tr>
<tr class="separator:add040a16da503b139f280a9e1a41c61d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee15eb401904198d43db394ebfa96c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c">crend</a> () const</td></tr>
<tr class="memdesc:acfee15eb401904198d43db394ebfa96c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c">More...</a><br /></td></tr>
<tr class="separator:acfee15eb401904198d43db394ebfa96c inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cda4c5af7c53c8ac0692a6ac19aa8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#af3cda4c5af7c53c8ac0692a6ac19aa8d">rend</a> () const</td></tr>
<tr class="memdesc:af3cda4c5af7c53c8ac0692a6ac19aa8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="classSimTK_1_1ArrayView__.html#af3cda4c5af7c53c8ac0692a6ac19aa8d">More...</a><br /></td></tr>
<tr class="separator:af3cda4c5af7c53c8ac0692a6ac19aa8d inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">rend</a> ()</td></tr>
<tr class="memdesc:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">More...</a><br /></td></tr>
<tr class="separator:a70fe28b711d20b58b18f5ad1bce34145 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac454dc1045c20cd273cc5e4f317e9045 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045">cdata</a> () const</td></tr>
<tr class="memdesc:ac454dc1045c20cd273cc5e4f317e9045 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045">More...</a><br /></td></tr>
<tr class="separator:ac454dc1045c20cd273cc5e4f317e9045 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcad040471afe709b30a4aea6e021fb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6dcad040471afe709b30a4aea6e021fb">data</a> () const</td></tr>
<tr class="memdesc:a6dcad040471afe709b30a4aea6e021fb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="classSimTK_1_1ArrayView__.html#a6dcad040471afe709b30a4aea6e021fb">More...</a><br /></td></tr>
<tr class="separator:a6dcad040471afe709b30a4aea6e021fb inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">data</a> ()</td></tr>
<tr class="memdesc:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">More...</a><br /></td></tr>
<tr class="separator:a318481efdb8fd67f17e28e67cc8cce24 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea9dee838be0641eaecfcd51683671f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size</a> () const</td></tr>
<tr class="separator:a8ea9dee838be0641eaecfcd51683671f inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215a3ff14686d94d053ecb9207974a58 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a215a3ff14686d94d053ecb9207974a58">max_size</a> () const</td></tr>
<tr class="separator:a215a3ff14686d94d053ecb9207974a58 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752461253da4daacbbfd1d864d5087e0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a752461253da4daacbbfd1d864d5087e0">empty</a> () const</td></tr>
<tr class="separator:a752461253da4daacbbfd1d864d5087e0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f99a02af36c8cf9507615c1b7ef640 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a52f99a02af36c8cf9507615c1b7ef640">capacity</a> () const</td></tr>
<tr class="separator:a52f99a02af36c8cf9507615c1b7ef640 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e7a0fba6f5e6196ce2b491b91379b0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac7e7a0fba6f5e6196ce2b491b91379b0">allocated</a> () const</td></tr>
<tr class="separator:ac7e7a0fba6f5e6196ce2b491b91379b0 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc533c835c84c95085708279bb4be17 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0dc533c835c84c95085708279bb4be17">isOwner</a> () const</td></tr>
<tr class="separator:a0dc533c835c84c95085708279bb4be17 inherit pub_methods_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">More...</a><br /></td></tr>
<tr class="separator:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">ArrayViewConst_</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> &amp;src)</td></tr>
<tr class="memdesc:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; the constructed const array object will be referencing the original source data.  <a href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">More...</a><br /></td></tr>
<tr class="separator:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">ArrayViewConst_</a> (const T *first, const T *last1)</td></tr>
<tr class="memdesc:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data.  <a href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">More...</a><br /></td></tr>
<tr class="separator:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">ArrayViewConst_</a> (const std::vector&lt; T, A &gt; &amp;src)</td></tr>
<tr class="memdesc:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion.  <a href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">More...</a><br /></td></tr>
<tr class="separator:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a47a95ec8a50e2dfacd78cffb8eb0f9e7">operator const ArrayView_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements.  <a href="classSimTK_1_1ArrayViewConst__.html#a47a95ec8a50e2dfacd78cffb8eb0f9e7">More...</a><br /></td></tr>
<tr class="separator:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ae20cb3a99db498fbb2734893e57edfd3">operator const Array_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data.  <a href="classSimTK_1_1ArrayViewConst__.html#ae20cb3a99db498fbb2734893e57edfd3">More...</a><br /></td></tr>
<tr class="separator:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">disconnect</a> ()</td></tr>
<tr class="memdesc:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed.  <a href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">More...</a><br /></td></tr>
<tr class="separator:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">~ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information.  <a href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">More...</a><br /></td></tr>
<tr class="separator:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5d385a525b7d9fa78d52ba03875a824a">size</a> () const</td></tr>
<tr class="memdesc:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a5d385a525b7d9fa78d52ba03875a824a">More...</a><br /></td></tr>
<tr class="separator:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a48443f6c8b0fdc38c59ac3093c952ab8">max_size</a> () const</td></tr>
<tr class="memdesc:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a48443f6c8b0fdc38c59ac3093c952ab8">More...</a><br /></td></tr>
<tr class="separator:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a117d86d441778646b7f0f374076804bb">empty</a> () const</td></tr>
<tr class="memdesc:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a117d86d441778646b7f0f374076804bb">More...</a><br /></td></tr>
<tr class="separator:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb">capacity</a> () const</td></tr>
<tr class="memdesc:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb">More...</a><br /></td></tr>
<tr class="separator:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a039a8a78c4f5c11942f20fd9b7aaed0a">allocated</a> () const</td></tr>
<tr class="memdesc:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="classSimTK_1_1ArrayViewConst__.html#a039a8a78c4f5c11942f20fd9b7aaed0a">More...</a><br /></td></tr>
<tr class="separator:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af5bce2a59ea7822c0cf96ee60edb42d0">isOwner</a> () const</td></tr>
<tr class="memdesc:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="classSimTK_1_1ArrayViewConst__.html#af5bce2a59ea7822c0cf96ee60edb42d0">More...</a><br /></td></tr>
<tr class="separator:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac84df26d2ab345b08523b9cf3257baa7">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="classSimTK_1_1ArrayViewConst__.html#ac84df26d2ab345b08523b9cf3257baa7">More...</a><br /></td></tr>
<tr class="separator:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a8036e2c7f024a76f591ad02aeb3471b2">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayViewConst__.html#a8036e2c7f024a76f591ad02aeb3471b2">More...</a><br /></td></tr>
<tr class="separator:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa636fb3c7cbfd76887e160dc0ec1e890">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayViewConst__.html#aa636fb3c7cbfd76887e160dc0ec1e890">More...</a><br /></td></tr>
<tr class="separator:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab831f9845265f592bf52958114494887">front</a> () const</td></tr>
<tr class="memdesc:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="classSimTK_1_1ArrayViewConst__.html#ab831f9845265f592bf52958114494887">More...</a><br /></td></tr>
<tr class="separator:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ae57850a4310fb369b204da2540ae9edb">back</a> () const</td></tr>
<tr class="memdesc:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="classSimTK_1_1ArrayViewConst__.html#ae57850a4310fb369b204da2540ae9edb">More...</a><br /></td></tr>
<tr class="separator:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab4a2d86c2282fbc047e3146a30460f02">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying).  <a href="classSimTK_1_1ArrayViewConst__.html#ab4a2d86c2282fbc047e3146a30460f02">More...</a><br /></td></tr>
<tr class="separator:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a19d89ea9ad91ddb6f982897831457e42">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="classSimTK_1_1ArrayViewConst__.html#a19d89ea9ad91ddb6f982897831457e42">More...</a><br /></td></tr>
<tr class="separator:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323">cbegin</a> () const</td></tr>
<tr class="memdesc:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323">More...</a><br /></td></tr>
<tr class="separator:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451">cend</a> () const</td></tr>
<tr class="memdesc:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451">More...</a><br /></td></tr>
<tr class="separator:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646">begin</a> () const</td></tr>
<tr class="memdesc:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646" title="The const version of begin() is the same as cbegin(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646">More...</a><br /></td></tr>
<tr class="separator:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b">end</a> () const</td></tr>
<tr class="memdesc:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b" title="The const version of end() is the same as cend(). ">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b">More...</a><br /></td></tr>
<tr class="separator:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059">crbegin</a> () const</td></tr>
<tr class="memdesc:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059">More...</a><br /></td></tr>
<tr class="separator:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15">crend</a> () const</td></tr>
<tr class="memdesc:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15">More...</a><br /></td></tr>
<tr class="separator:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9">rbegin</a> () const</td></tr>
<tr class="memdesc:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9" title="The const version of rbegin() is the same as crbegin(). ">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9">More...</a><br /></td></tr>
<tr class="separator:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab">rend</a> () const</td></tr>
<tr class="memdesc:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab" title="The const version of rend() is the same as crend(). ">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab">More...</a><br /></td></tr>
<tr class="separator:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108">cdata</a> () const</td></tr>
<tr class="memdesc:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108">More...</a><br /></td></tr>
<tr class="separator:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc">data</a> () const</td></tr>
<tr class="memdesc:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc" title="The const version of the data() method is identical to cdata(). ">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc">More...</a><br /></td></tr>
<tr class="separator:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a8a1771c28a26738d4e217ec67586f9c8"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a8a1771c28a26738d4e217ec67586f9c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8a1771c28a26738d4e217ec67586f9c8">swap</a> (<a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;a1, <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;a2)</td></tr>
<tr class="memdesc:a8a1771c28a26738d4e217ec67586f9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of the STL std::swap() algorithm which uses the constant time built-in <a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap()</a> member of the <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> class.  <a href="#a8a1771c28a26738d4e217ec67586f9c8">More...</a><br /></td></tr>
<tr class="separator:a8a1771c28a26738d4e217ec67586f9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2ecaa31633e2db5b375f3519e259c"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a41a2ecaa31633e2db5b375f3519e259c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a41a2ecaa31633e2db5b375f3519e259c">toXmlElement</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;thing, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a41a2ecaa31633e2db5b375f3519e259c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects.  <a href="#a41a2ecaa31633e2db5b375f3519e259c">More...</a><br /></td></tr>
<tr class="separator:a41a2ecaa31633e2db5b375f3519e259c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Array_&lt;T&gt; serialization and I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are at namespace scope but are logically part of the Array classes.</p>
<p>These deal with reading and writing Arrays from and to streams, which places an additional requirement on the element type T: the element must support the same operation you are trying to do on the Array as a whole. </p>
</div></td></tr>
<tr class="memitem:a015cef5d8e534e632955fcca6ea444f8"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a015cef5d8e534e632955fcca6ea444f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a015cef5d8e534e632955fcca6ea444f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8" title="Specialize writeUnformatted() for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating t...">writeUnformatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating the elements.  <a href="#a015cef5d8e534e632955fcca6ea444f8">More...</a><br /></td></tr>
<tr class="separator:a015cef5d8e534e632955fcca6ea444f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abedbcfc5b21bd9fa859208247aec72"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a6abedbcfc5b21bd9fa859208247aec72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72">writeFormatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a6abedbcfc5b21bd9fa859208247aec72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize <a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72" title="Specialize writeFormatted() for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parenthes...">writeFormatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parentheses and commas separating the elements.  <a href="#a6abedbcfc5b21bd9fa859208247aec72">More...</a><br /></td></tr>
<tr class="separator:a6abedbcfc5b21bd9fa859208247aec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8575e59ff1ed3dcb8e52d7dd44ebb426">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;a)</td></tr>
<tr class="memdesc:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a human readable representation of an array to an std::ostream (like std::cout).  <a href="#a8575e59ff1ed3dcb8e52d7dd44ebb426">More...</a><br /></td></tr>
<tr class="separator:a8575e59ff1ed3dcb8e52d7dd44ebb426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b300ce2032c6315983114f0b7e84e92"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a6b300ce2032c6315983114f0b7e84e92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a6b300ce2032c6315983114f0b7e84e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92" title="Specialization of readUnformatted() for variable-length Array_&lt;T,X&gt;; continues reading whitespace-sep...">readUnformatted()</a> for variable-length Array_&lt;T,X&gt;; continues reading whitespace-separated tokens until error or eof.  <a href="#a6b300ce2032c6315983114f0b7e84e92">More...</a><br /></td></tr>
<tr class="separator:a6b300ce2032c6315983114f0b7e84e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a8a24c48ad3dff0c852095f0347941"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a65a8a24c48ad3dff0c852095f0347941"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a65a8a24c48ad3dff0c852095f0347941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941" title="Specialization of readFormatted() for variable-length Array_&lt;T,X&gt;; uses readArrayFromStream() to cons...">readFormatted()</a> for variable-length Array_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> to consume an appropriately-formatted array until error, closing parenthesis or bracket, or eof.  <a href="#a65a8a24c48ad3dff0c852095f0347941">More...</a><br /></td></tr>
<tr class="separator:a65a8a24c48ad3dff0c852095f0347941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15">readArrayFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a0a452cab4756ae07c3ab22c155eb1b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values optionally surrounded by parentheses (), square brackets [], or curly braces {}.  <a href="#a0a452cab4756ae07c3ab22c155eb1b15">More...</a><br /></td></tr>
<tr class="separator:a0a452cab4756ae07c3ab22c155eb1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34546fb36b84171e76276a508121a3ce"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a34546fb36b84171e76276a508121a3ce"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce">fillArrayFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a34546fb36b84171e76276a508121a3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an Array.  <a href="#a34546fb36b84171e76276a508121a3ce">More...</a><br /></td></tr>
<tr class="separator:a34546fb36b84171e76276a508121a3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd40fd273bd41041bb7138a3268ca82"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:adbd40fd273bd41041bb7138a3268ca82"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:adbd40fd273bd41041bb7138a3268ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, brackets, or braces.  <a href="#adbd40fd273bd41041bb7138a3268ca82">More...</a><br /></td></tr>
<tr class="separator:adbd40fd273bd41041bb7138a3268ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These operators permit lexicographical comparisons between two comparable <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects, possibly with differing element and index types, and between an <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> object and a comparable std::vector object.</p>
</div></td></tr>
<tr class="memitem:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1e25d47eeb9e34faa78ee38812b194d8">operator==</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a1e25d47eeb9e34faa78ee38812b194d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2.  <a href="#a1e25d47eeb9e34faa78ee38812b194d8">More...</a><br /></td></tr>
<tr class="separator:a1e25d47eeb9e34faa78ee38812b194d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79b082dbed61adf809400e05027c595"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:aa79b082dbed61adf809400e05027c595"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa79b082dbed61adf809400e05027c595">operator!=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:aa79b082dbed61adf809400e05027c595"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#aa79b082dbed61adf809400e05027c595">More...</a><br /></td></tr>
<tr class="separator:aa79b082dbed61adf809400e05027c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1218fae627e26b17ed948a62e87cc8"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a0e1218fae627e26b17ed948a62e87cc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a0e1218fae627e26b17ed948a62e87cc8">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a0e1218fae627e26b17ed948a62e87cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter array (in which case the shorter one is "less than" the longer).  <a href="#a0e1218fae627e26b17ed948a62e87cc8">More...</a><br /></td></tr>
<tr class="separator:a0e1218fae627e26b17ed948a62e87cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80423b9a73fd93e07d8465c97e999af"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ad80423b9a73fd93e07d8465c97e999af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad80423b9a73fd93e07d8465c97e999af">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ad80423b9a73fd93e07d8465c97e999af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#ad80423b9a73fd93e07d8465c97e999af">More...</a><br /></td></tr>
<tr class="separator:ad80423b9a73fd93e07d8465c97e999af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ac93cc22c503f9f75f1be2cbbb2c97714">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ac93cc22c503f9f75f1be2cbbb2c97714">More...</a><br /></td></tr>
<tr class="separator:ac93cc22c503f9f75f1be2cbbb2c97714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822b4815845e58a47af6b5720791698"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a8822b4815845e58a47af6b5720791698"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a8822b4815845e58a47af6b5720791698">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a8822b4815845e58a47af6b5720791698"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#a8822b4815845e58a47af6b5720791698">More...</a><br /></td></tr>
<tr class="separator:a8822b4815845e58a47af6b5720791698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a39975ed123e3738da698ea6d0ddc7a4a">operator==</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a39975ed123e3738da698ea6d0ddc7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Array_&lt;T1&gt; and an std::vector&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2.  <a href="#a39975ed123e3738da698ea6d0ddc7a4a">More...</a><br /></td></tr>
<tr class="separator:a39975ed123e3738da698ea6d0ddc7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef2d3446751e985a922ecb0681653c"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a5bef2d3446751e985a922ecb0681653c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a5bef2d3446751e985a922ecb0681653c">operator==</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a5bef2d3446751e985a922ecb0681653c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::vector&lt;T1&gt; and an Array_&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T2==T1.  <a href="#a5bef2d3446751e985a922ecb0681653c">More...</a><br /></td></tr>
<tr class="separator:a5bef2d3446751e985a922ecb0681653c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688f8af308de34d0431205f7d854aee3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a688f8af308de34d0431205f7d854aee3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a688f8af308de34d0431205f7d854aee3">operator!=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a688f8af308de34d0431205f7d854aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#a688f8af308de34d0431205f7d854aee3">More...</a><br /></td></tr>
<tr class="separator:a688f8af308de34d0431205f7d854aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04f55c1a275128219e677a974254c9"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7d04f55c1a275128219e677a974254c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7d04f55c1a275128219e677a974254c9">operator!=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a7d04f55c1a275128219e677a974254c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The not equal operator is implemented using the equal operator.  <a href="#a7d04f55c1a275128219e677a974254c9">More...</a><br /></td></tr>
<tr class="separator:a7d04f55c1a275128219e677a974254c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbec0e1348a20404c060b9c5523544f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:addbec0e1348a20404c060b9c5523544f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#addbec0e1348a20404c060b9c5523544f">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:addbec0e1348a20404c060b9c5523544f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Array_&lt;T1&gt; and std::vector&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer).  <a href="#addbec0e1348a20404c060b9c5523544f">More...</a><br /></td></tr>
<tr class="separator:addbec0e1348a20404c060b9c5523544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa929813dea46bf41f7ffee7053566f86"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:aa929813dea46bf41f7ffee7053566f86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aa929813dea46bf41f7ffee7053566f86">operator&lt;</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:aa929813dea46bf41f7ffee7053566f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::vector&lt;T1&gt; and Array_&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer).  <a href="#aa929813dea46bf41f7ffee7053566f86">More...</a><br /></td></tr>
<tr class="separator:aa929813dea46bf41f7ffee7053566f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a81e151401cab82f28a4d2f6c43bdaeb0">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#a81e151401cab82f28a4d2f6c43bdaeb0">More...</a><br /></td></tr>
<tr class="separator:a81e151401cab82f28a4d2f6c43bdaeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1c9fc6fb86e0e02b422ea858ba216f94">operator&gt;=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than or equal operator is implemented using the less than operator.  <a href="#a1c9fc6fb86e0e02b422ea858ba216f94">More...</a><br /></td></tr>
<tr class="separator:a1c9fc6fb86e0e02b422ea858ba216f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad057e98ddbd0b80ab053519caa9dd2ea">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ad057e98ddbd0b80ab053519caa9dd2ea">More...</a><br /></td></tr>
<tr class="separator:ad057e98ddbd0b80ab053519caa9dd2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d14e73a05783839ed5c679278764d4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:ad7d14e73a05783839ed5c679278764d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad7d14e73a05783839ed5c679278764d4">operator&gt;</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:ad7d14e73a05783839ed5c679278764d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1.  <a href="#ad7d14e73a05783839ed5c679278764d4">More...</a><br /></td></tr>
<tr class="separator:ad7d14e73a05783839ed5c679278764d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memTemplParams" colspan="2">template&lt;class T1 , class X1 , class T2 , class A2 &gt; </td></tr>
<tr class="memitem:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad6219dc0d49e5f4d40d4a5d7954c5adb">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;a1, const std::vector&lt; T2, A2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#ad6219dc0d49e5f4d40d4a5d7954c5adb">More...</a><br /></td></tr>
<tr class="separator:ad6219dc0d49e5f4d40d4a5d7954c5adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memTemplParams" colspan="2">template&lt;class T1 , class A1 , class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a463986b88adfd8319e9a2ddcb7b21d0e">operator&lt;=</a> (const std::vector&lt; T1, A1 &gt; &amp;v1, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;a2)</td></tr>
<tr class="memdesc:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The less than or equal operator is implemented using the greater than operator.  <a href="#a463986b88adfd8319e9a2ddcb7b21d0e">More...</a><br /></td></tr>
<tr class="separator:a463986b88adfd8319e9a2ddcb7b21d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1ArrayView__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1ArrayView__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:addfc86d8a0833c34bdeb0369a43a478a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:addfc86d8a0833c34bdeb0369a43a478a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#addfc86d8a0833c34bdeb0369a43a478a">toXmlElement</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;thing, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:addfc86d8a0833c34bdeb0369a43a478a inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> objects.  <a href="classSimTK_1_1ArrayView__.html#addfc86d8a0833c34bdeb0369a43a478a">More...</a><br /></td></tr>
<tr class="separator:addfc86d8a0833c34bdeb0369a43a478a inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read.  <a href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">More...</a><br /></td></tr>
<tr class="separator:a2f916862f035a63e2406b6c47c57a2f3 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView. ">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array.  <a href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">More...</a><br /></td></tr>
<tr class="separator:aa87616be589a0d76e0461c1d7c869e91 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">fillArrayViewFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an ArrayView.  <a href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">More...</a><br /></td></tr>
<tr class="separator:a3c0c0d7769abbfe61b560361afe19f03 inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces.  <a href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">More...</a><br /></td></tr>
<tr class="separator:acc7c28435897527058bfecae5e2f407a inherit related_classSimTK_1_1ArrayView__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a07b335c7df6083df174eb52e12c98f0e">toXmlElement</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;thing, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> objects.  <a href="classSimTK_1_1ArrayViewConst__.html#a07b335c7df6083df174eb52e12c98f0e">More...</a><br /></td></tr>
<tr class="separator:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Element insertion and removal</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp04278d7a280cc864bdefd140f72675a7"></a>These are methods that change the number of elements in the array by insertion or erasure.</p>
</td></tr>
<tr class="memitem:a13b95bc701e5bd09dad7ee38e069b669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a13b95bc701e5bd09dad7ee38e069b669">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a13b95bc701e5bd09dad7ee38e069b669"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method increases the size of the Array by one element at the end and initializes that element by copy constructing it from the given value.  <a href="#a13b95bc701e5bd09dad7ee38e069b669">More...</a><br /></td></tr>
<tr class="separator:a13b95bc701e5bd09dad7ee38e069b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48419a1a62635e0f15fa56509a86dd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a48419a1a62635e0f15fa56509a86dd4f">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a48419a1a62635e0f15fa56509a86dd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the move form of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a>, taking an rvalue reference rather than an lvalue reference.  <a href="#a48419a1a62635e0f15fa56509a86dd4f">More...</a><br /></td></tr>
<tr class="separator:a48419a1a62635e0f15fa56509a86dd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5da768f427c750d280ddc570f7eb3ef"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad5da768f427c750d280ddc570f7eb3ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad5da768f427c750d280ddc570f7eb3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is similar to <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> but rather than copying, it constructs the element in place at the end of the array.  <a href="#ad5da768f427c750d280ddc570f7eb3ef">More...</a><br /></td></tr>
<tr class="separator:ad5da768f427c750d280ddc570f7eb3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b698ae20b857ce3de014b8996f3b1e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5">push_back</a> ()</td></tr>
<tr class="memdesc:a7b698ae20b857ce3de014b8996f3b1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated, use <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> instead) This is a non-standard version of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> that increases the size of the array by one default-constructed element at the end.  <a href="#a7b698ae20b857ce3de014b8996f3b1e5">More...</a><br /></td></tr>
<tr class="separator:a7b698ae20b857ce3de014b8996f3b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb31ef48594914eaef9ddcec92791c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c">raw_push_back</a> ()</td></tr>
<tr class="memdesc:a7ceb31ef48594914eaef9ddcec92791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated, use <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> instead) This dangerous non-standard method increases the Array's size by one element at the end but doesn't perform any construction so the memory is filled with garbage.  <a href="#a7ceb31ef48594914eaef9ddcec92791c">More...</a><br /></td></tr>
<tr class="separator:a7ceb31ef48594914eaef9ddcec92791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5b478c9ac203ed767eadf7828ffcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a54b5b478c9ac203ed767eadf7828ffcd">pop_back</a> ()</td></tr>
<tr class="memdesc:a54b5b478c9ac203ed767eadf7828ffcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last element from this array, which must not be empty.  <a href="#a54b5b478c9ac203ed767eadf7828ffcd">More...</a><br /></td></tr>
<tr class="separator:a54b5b478c9ac203ed767eadf7828ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a656cb3128af0259d85978a61b7e01"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01">erase</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a52a656cb3128af0259d85978a61b7e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements in range [first,last1), packing in any later elements into the newly-available space and reducing the array's size by the number of elements erased.  <a href="#a52a656cb3128af0259d85978a61b7e01">More...</a><br /></td></tr>
<tr class="separator:a52a656cb3128af0259d85978a61b7e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818361e237b91adc12d2122f119c579c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a818361e237b91adc12d2122f119c579c">erase</a> (T *p)</td></tr>
<tr class="memdesc:a818361e237b91adc12d2122f119c579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase just one element, moving all subsequent elements down one slot and reducing the array's size by one.  <a href="#a818361e237b91adc12d2122f119c579c">More...</a><br /></td></tr>
<tr class="separator:a818361e237b91adc12d2122f119c579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6">eraseFast</a> (T *p)</td></tr>
<tr class="memdesc:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Be careful with this non-standard extension; it erases one element and then moves the last one in its place which changes the element order from what it was before (unlike the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method).  <a href="#aea3f2ff76ae0b004c5e21c3aa170ebf6">More...</a><br /></td></tr>
<tr class="separator:aea3f2ff76ae0b004c5e21c3aa170ebf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95f49692c338895df4ddc36752b4baa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#af95f49692c338895df4ddc36752b4baa">clear</a> ()</td></tr>
<tr class="memdesc:af95f49692c338895df4ddc36752b4baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all the elements currently in this array without changing the capacity; equivalent to erase(<a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>,<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>) but a little faster.  <a href="#af95f49692c338895df4ddc36752b4baa">More...</a><br /></td></tr>
<tr class="separator:af95f49692c338895df4ddc36752b4baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6c04b85ed597b657f4cd244c02c52d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d">insert</a> (T *p, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;value)</td></tr>
<tr class="memdesc:a7c6c04b85ed597b657f4cd244c02c52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <em>n</em> copies of a given value at a particular location within this array, moving all following elements up by <em>n</em> positions.  <a href="#a7c6c04b85ed597b657f4cd244c02c52d">More...</a><br /></td></tr>
<tr class="separator:a7c6c04b85ed597b657f4cd244c02c52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a1de9710bd314b227b6d7fb9b1e2e5013">insert</a> (T *p, const T &amp;value)</td></tr>
<tr class="memdesc:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element at a given location within this array, initializing it to a copy of a given value and moving all following elements up one position.  <a href="#a1de9710bd314b227b6d7fb9b1e2e5013">More...</a><br /></td></tr>
<tr class="separator:a1de9710bd314b227b6d7fb9b1e2e5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbfcca9949bd6ad04d98e0030811c11"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aefbfcca9949bd6ad04d98e0030811c11"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#aefbfcca9949bd6ad04d98e0030811c11">emplace</a> (T *p, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aefbfcca9949bd6ad04d98e0030811c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new element at a given location within this array, by invoking T's constructor whose signature matches the supplied arguments.  <a href="#aefbfcca9949bd6ad04d98e0030811c11">More...</a><br /></td></tr>
<tr class="separator:aefbfcca9949bd6ad04d98e0030811c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e597a8ecd02706680bf8920c5a15f29"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a9e597a8ecd02706680bf8920c5a15f29"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#a9e597a8ecd02706680bf8920c5a15f29">insert</a> (T *p, const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a9e597a8ecd02706680bf8920c5a15f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements in a range [first,last1) into this array at a given position <em>p</em>, moving all following elements up by n=(last1-first) positions.  <a href="#a9e597a8ecd02706680bf8920c5a15f29">More...</a><br /></td></tr>
<tr class="separator:a9e597a8ecd02706680bf8920c5a15f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Array__.html#ae2abd8e9d2146f344a88f96d1f839db0">insert</a> (T *p, const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:ae2abd8e9d2146f344a88f96d1f839db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements in a range [first,last1) where the range is given by non-pointer iterators.  <a href="#ae2abd8e9d2146f344a88f96d1f839db0">More...</a><br /></td></tr>
<tr class="separator:ae2abd8e9d2146f344a88f96d1f839db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X&gt;<br />
class SimTK::Array_&lt; T, X &gt;</h3>

<p>The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library (STL) std::vector&lt;T&gt; class, but with some important advantages in performance, and functionality, and binary compatibility. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored in this container. </td></tr>
    <tr><td class="paramname">X</td><td>The type to be used for indexing this container, with default unsigned (not size_t). Any integral type may be used, as well as user types that satisfy the requirements discussed with class <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Performance:</dt><dd>There are several performance and memory footprint problems with the C++ standard STL design in general, and with Microsoft's implementation in particular, that are addressed here. Microsoft in its wisdom decided that STL containers should still do runtime range checks in Release builds for safety, but that makes them too slow for use in some high-performance contexts (and also breaks the promise of generic programming but that's another rant). In practice, VC++12 (2013) std::vector runs about half speed for simple operations like indexing and push_back (see Simbody's TestArray regression test for an executable performance comparison). Attempting to disable these runtime checks with <code>_SECURE_SCL</code> breaks binary compatibility with other code built with the same compiler but without the flag. In contrast the performance of this Array_&lt;T&gt; class on any platform is indistinguishable from what you would get by managing your own heap-allocated arrays. 64 bit compilers vary on how well they handle 32 bit integers though, so in some cases the default index type (32 bit unsigned) won't be as fast as if you use a 64 bit unsigned type as does std::vector.</dd></dl>
<dl class="section user"><dt></dt><dd>Regarding memory footprint, the typical implementation of std::vector uses three pointers: 12 bytes for 32 bit machines; 24 bytes for 64 bit machines. Microsoft somehow manages to trump this with 20 to 24 bytes on a 32 bit machine (last checked in VC++9); they are at 24 bytes for 64 bit Release builds in VC++12, 32 bytes in Debug builds. <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> instead uses one pointer and two lengths for a total size as little as 8 bytes on 32 bits and 16 on 64 bits; see below for details. The binary representation for <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> is the same in Release and Debug builds.</dd></dl>
<dl class="section user"><dt></dt><dd>Some nuts and bolts:</dd></dl>
<ul>
<li>We promise that no heap allocation occurs when an empty Array_&lt;T&gt; object is declared (that is, when an Array_&lt;T&gt; is default-constructed); in that case both <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> and <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> are null.</li>
<li>Array_&lt;T&gt; methods are extremely fast in Release builds with zero overhead, inline, unchecked methods. The implementations of inline methods are kept small to ensure that they are actually inlined in practice; and generated assembly code was examined to make sure.</li>
<li>There are some dangerous extensions provided that permit the expert user to construct objects directly into the array without having to copy them, a big win for complicated objects and even bigger for those that don't have copy constructors!</li>
<li>There is a constant-time <a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a> method you can use if you don't mind the array being reordered after the erase. This avoids the extremely expensive "compress" activity required by the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method.</li>
<li>The optional index-type template parameter can be used to reduce the memory footprint to as little as 8 bytes on a 32 bit machine (e.g., a 32 bit pointer and two shorts).</li>
<li>The default size_type for an Array_&lt;T&gt; is a 32-bit unsigned integer rather than a size_t. On a 64-bit machine that keeps the memory footprint down substantially since the structure is then one 64-bit pointer and two 32-bit integers, fitting tightly into a cleanly alignable 16 bytes.</li>
</ul>
<dl class="section user"><dt>Functionality:</dt><dd>For the most part Array_&lt;T&gt; is a plug-compatible replacement for std::vector&lt;T&gt;, and everything that both classes can do is done with an identical API. However, there are a few additions and subtractions:</dd></dl>
<ul>
<li>This class always uses the default new/delete allocator; there is no option to specify your own as there is in std::vector.</li>
<li>Instead of an allocator, the second template argument X to Array_&lt;T,X&gt; is an optional index type which can be used to provide type-safe indexing (i.e. the array can only be indexed by indices of a particular type, like <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>). This has zero performance cost if the index is an integral type or class consisting of only an integral value such as those produced by the SimTK_DEFINE_UNIQUE_INDEX_TYPE macro.</li>
<li>You can create uninitialized slots in the array and construct directly into them rather than having to construct a temporary object which must then be copied into the array.</li>
<li>You can create Array_&lt;T&gt; objects that reference existing data, including the contents of std::vectors.</li>
<li>This class implements the std::vector features from the C++11 standard (with a few exceptions; see below).</li>
</ul>
<dl class="section user"><dt>Compatibility:</dt><dd>Included here are binary compatibility issues and compatibility with the C++ standard STL objects.</dd></dl>
<ul>
<li>Most important, it is safe to pass an Array_&lt;T&gt; through an API to a binary library without worrying about compiler version or Release/Debug compatibility issues. For a given compiler (e.g. gcc or Microsoft cl) and word size (64 bit vs. 32 bit), Array_&lt;T&gt; has an extremely stable memory layout that is preserved across compiler versions, and between Release and Debug builds. This allows us to use Array_&lt;T&gt; in the <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> API where use of std::vector&lt;T&gt; would be desirable but problematic.</li>
<li>It supports all standard types, methods, iterators, and operators of the C++11 standard std::vector, so it works smoothly with all STL containers and algorithms. However, it does not provide the same guarantees of behavior when exceptions occur. In particular, when resizing <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> will use move construction if available even if the move constructor hasn't been marked "nothrow".</li>
<li>It is convertible to and from std::vector, usually without copying the elements. It is easy to provide APIs that accept either Array_&lt;T&gt; or std::vector&lt;T&gt;; the std::vector's data is referenced by an <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> handle that is used to convey the data across the API without binary compatibility problems.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>, <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac67020459c021a6a6e076839105b1dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67020459c021a6a6e076839105b1dd8">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aed3ed93a6d406a35da0225352694b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aed3ed93a6d406a35da0225352694b1">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfe40f48092df9a7deafe32ef1ec39fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe40f48092df9a7deafe32ef1ec39fb">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e344836dca88d0070ee505da9a628bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e344836dca88d0070ee505da9a628bb">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5efd5cd3092babe7a107b8efa664204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5efd5cd3092babe7a107b8efa664204">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e967f4929d463e32202d34158f3e22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e967f4929d463e32202d34158f3e22f">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05144fefe932d1c76e2e0dcaedddcd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05144fefe932d1c76e2e0dcaedddcd03">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47a140d8babac3edb92ff620e77245d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a140d8babac3edb92ff620e77245d0">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a9e2010641fb5df3c7e47c62a6db774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9e2010641fb5df3c7e47c62a6db774">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a>&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96b19c88ae09eec0ff5288e8e824d498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b19c88ae09eec0ff5288e8e824d498">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a>&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ed205f5372aad3ca9a8366441b16913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed205f5372aad3ca9a8366441b16913">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a5ca3b32f612044bed7552b7dc96164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5ca3b32f612044bed7552b7dc96164">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1b7dc77f42cab3244ec808e5d4d3ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b7dc77f42cab3244ec808e5d4d3ee3">&#9670;&nbsp;</a></span>packed_size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ArrayIndexPackType&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc75b3e8df6112d5ea6fd77ad024bcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc75b3e8df6112d5ea6fd77ad024bcc3">&#9670;&nbsp;</a></span>Array_() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor allocates no heap space and is very fast. </p>

</div>
</div>
<a id="a7a9e625487e34b5255619a492514926d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e625487e34b5255619a492514926d">&#9670;&nbsp;</a></span>Array_() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an array containing <em>n</em> default-constructed elements. </p>
<p>T's default constructor (if any) is called exactly <em>n</em> times. If <em>n</em> is zero no heap space will be allocated; although in that case it is preferable to use the default constructor if you can since that will be somewhat faster. </p>

</div>
</div>
<a id="ad758f8ef3bb565989a22c5456a34f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad758f8ef3bb565989a22c5456a34f3b6">&#9670;&nbsp;</a></span>Array_() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an array containing <em>n</em> elements each set to a copy of the given initial value. </p>
<p>T's copy constructor will be called exactly <em>n</em> times. If <em>n</em> is zero no space will be allocated. </p>

</div>
</div>
<a id="a730175ab17a18e5d87974ea97c712e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730175ab17a18e5d87974ea97c712e3e">&#9670;&nbsp;</a></span>Array_() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of iterators. </p>
<dl class="section note"><dt>Note</dt><dd>The standard requires that if an integral type matches this signature, it must behave as the Array_(size_type,value_type) constructor. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The performance of this constructor depends on the type of iterator:<ul>
<li>random_access_iterator: n=(last1-first); a single space allocation; n calls to T's copy constructor.</li>
<li>forward or bidirectional iterator: must increment from first to last1 to determine n; otherwise same as random access.</li>
<li>input iterator: can't determine n in advance; expect log n reallocations during construction as we "push back" one input element at a time. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a782b385c4c710cf60fc4205371c7d5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782b385c4c710cf60fc4205371c7d5cc">&#9670;&nbsp;</a></span>Array_() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; from a range [first,last1) of values identified by a pair of ordinary pointers to elements of type T2 (where T2 might be the same as T but doesn't have to be). </p>
<p>This is templatized so can be used with any source type T2 which is either T or implicitly convertible to T, provided that the number of source elements does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a>. </p>

</div>
</div>
<a id="abc6e34513938cae73d83e8ec0325452e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6e34513938cae73d83e8ec0325452e">&#9670;&nbsp;</a></span>Array_() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; from an std::initializer_list whose elements were convertible to type T, provided that the number of source elements does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a>. </p>
<p>Note that this constructor is not <code>explicit</code>, so a suitable std::initializer_list will implicitly convert to an Array_&lt;T&gt;. </p>

</div>
</div>
<a id="a40d3d7fccc13d4d892ce52ebccdf4acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d3d7fccc13d4d892ce52ebccdf4acc">&#9670;&nbsp;</a></span>Array_() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by copying from an std::vector&lt;T2&gt;, where T2 may be the same type as T but doesn't have to be. </p>
<p>This will work as long as the size of the vector does not exceed the array's <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a>, and provided there is a working T(T2) conversion constructor. </p>

</div>
</div>
<a id="afe60949157ed425b6b81b7ff0e11ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe60949157ed425b6b81b7ff0e11ca29">&#9670;&nbsp;</a></span>Array_() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor allocates exactly as much memory as is in use in the source (not its capacity) and copy constructs the elements so that T's copy constructor will be called exactly src.size() times. </p>
<p>If the source is empty, no heap space will be allocated. </p>

</div>
</div>
<a id="af2b67c7069d980ef974690db7aca3bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b67c7069d980ef974690db7aca3bf1">&#9670;&nbsp;</a></span>Array_() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor swaps in the source and leaves the source default constructed. </p>

</div>
</div>
<a id="af66a2741c555a387d09742b9a5517314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66a2741c555a387d09742b9a5517314">&#9670;&nbsp;</a></span>Array_() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct this Array_&lt;T,X&gt; as a copy of another Array_&lt;T2,X2&gt; where T2!=T or X2!=X. </p>
<p>This will work as long as the source is not larger than will fit here, and as long as the source element type T2 is assignment compatible with this array's element type T. One of T's constructors will be called exactly src.size() times; the particular constructor is whichever one best matches T(T2). </p>

</div>
</div>
<a id="a53d115efe0bc7dafba02b3d04562dd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d115efe0bc7dafba02b3d04562dd92">&#9670;&nbsp;</a></span>Array_() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by referencing (sharing) a given range of data [first,last1), without copying that data; better to use the corresponding ArrayView_&lt;T&gt; constructor if you can. </p>
<p>This is very fast but can be dangerous &ndash; it is most useful for argument passing where the array handle will be discarded immediately after use. Note that this is available only if you have write access to the data because there is no way to construct a non-writable array. This will work as long as the size of the data does not exceed the array's max_size. The resulting array object is not resizeable but can be used to read and write elements of the original data. The array is invalid if the original data is destructed or resized, but there is no way for the array class to detect that.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source data is empty, the resulting array will also be empty and will look just like a default-constructed array. It will therefore not have any connection to the source and will be an ordinary resizable array.</li>
<li>This is quite dangerous to use since the connection between the array and the data is tenuous and subject to the data remaining untouched during the lifetime of the array handle. There is no reference counting; destructing the original data would leave the array referring to garbage. Be careful!</li>
<li>You can break the connection between the array and the data it was constructed from by calling <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<a id="a3331ee7155535eeac08b7297da16ebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3331ee7155535eeac08b7297da16ebe3">&#9670;&nbsp;</a></span>Array_() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSimTK_1_1DontCopy.html">DontCopy</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array_&lt;T&gt; by referencing (sharing) the data in an std::vector&lt;T&gt;, without copying the data; better to use the ArrayView_&lt;T&gt; constructor instead if you can. </p>
<p>This is very fast but can be dangerous &ndash; it is most useful for argument passing where the array handle will be discarded immediately after use. Note that this is available only if you have write access to the std::vector because there is no way to construct a non-writable array. This will work as long as the size of the vector does not exceed the array's max_size. The resulting array object is not resizeable but can be used to read and write elements of the original std::vector. The array is invalid if the original std::vector is destructed or resized.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source std::vector is empty, the resulting array will also be empty and will look just like a default-constructed array. It will therefore not have any connection to the source vector and will be an ordinary resizable array.</li>
<li>This is quite dangerous to use since the connection between the array and the vector is tenuous and subject to the vector remaining untouched during the lifetime of the array handle. There is no reference counting; destructing the vector leaves the array referring to garbage. Be careful!</li>
<li>You can break the connection between the array and the vector it was constructed from by calling <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<a id="ad55d3b71e2acdaa0f2bb8be2617c894f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55d3b71e2acdaa0f2bb8be2617c894f">&#9670;&nbsp;</a></span>~Array_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::~<a class="el" href="classSimTK_1_1Array__.html">Array_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor performs a <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> operation which may result in element destruction and freeing of heap space; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a67bc6c09d3ea513dfba42a5dfc42cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bc6c09d3ea513dfba42a5dfc42cd38">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty this array of its contents, returning the array to its default-constructed, all-zero state. </p>
<p>If this array is the owner of its data, the destructor (if any) is called for each data element and the array's allocated heap space is freed. If it is a non-owner the array handle is cleaned out using <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method  clears the handle without doing anything to the data...">disconnect()</a> but the referenced data is untouched. </p><dl class="section note"><dt>Note</dt><dd>There is no equivalent to this method for std::vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the now-empty, default-constructed array, ready for reassignment. </dd></dl>

</div>
</div>
<a id="a136a03677c28d7ee697df7e09b7aa2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a03677c28d7ee697df7e09b7aa2e2">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this array to be <em>n</em> copies of the supplied <em>fillValue</em>. </p>
<p>Note that this serves to allow fill from an object whose type T2 is different from T, as long as there is a constructor T(T2) that works since that can be invoked (implicitly or explicitly) to convert the T2 object to type T prior to the call. If this is a non-owner array then <em>n</em> must be the same as the current <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>; consider using the <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> method instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements to be in the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillValue</td><td>The value to which to initialize each element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>n</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a> </dd>
<dd>
for non-owner, n==<a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>For a non-owner with <em>n==<a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a></em>, there will be exactly <em>n</em> calls to T's copy assignment operator. For an owner, there will be <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> calls to T's destructor (if it has one), possibly a heap reallocation (but with no element copying), followed by <em>n</em> calls to T's copy constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> </dd></dl>

</div>
</div>
<a id="a66cc4a2796075ec7a3097bcc6d616bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc4a2796075ec7a3097bcc6d616bab">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign all current elements of the array to the same <em>fillValue</em>. </p>
<p>This is similar to assign(size(),fillValue) but the semantics are subtly different. Here we use repeated application of T's copy assignment operator T=fillValue, whereas the <a class="el" href="classSimTK_1_1Array__.html#a136a03677c28d7ee697df7e09b7aa2e2" title="Set this array to be n copies of the supplied fillValue. ">assign()</a> semantics are to first destruct all the existing elements, then allocate if necessary, then use the copy constructor to initialize the new elements. Note that you can use this to fill from a source type T2 that is different from T as long as there exists a suitable constructor T(T2) that can be used to create the type T <em>fillValue</em> from the original T2 source. </p><dl class="section note"><dt>Note</dt><dd>Unlike other assignment methods, the behavior of <a class="el" href="classSimTK_1_1Array__.html#a66cc4a2796075ec7a3097bcc6d616bab" title="Assign all current elements of the array to the same fillValue. ">fill()</a> is identical for owner and non-owner arrays.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fillValue</td><td>The value to which all existing elements are set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Just <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> calls to T's copy assignment operator. </dd></dl>

</div>
</div>
<a id="a1614ce819a2a4221c0a072ffbc2a0935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1614ce819a2a4221c0a072ffbc2a0935">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to to make it a copy of the elements in range [first,last1) given by ordinary pointers. </p>
<p>It is not allowed for this range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a working constructor T(T2) (for owner arrays) or a working assignment operator T=T2 (for non-owner arrays). Note that although the source arguments are pointers, those may be iterators for some container depending on implementation details of the container. Specifically, any <a class="el" href="classSimTK_1_1Array__.html#a05144fefe932d1c76e2e0dcaedddcd03">Array_&lt;T2&gt;::iterator</a> or const_iterator is an ordinary pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>A pointer to the first source element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A pointer to one element past the last source element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>For non-owner arrays, n=last1-first must equal the current <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> in which case there will be exactly <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> calls to the T=T2 assignment operator. For owner arrays, say the array initially has capacity c, and the source provides n new elements. If type T has a destructor, it will be called exactly <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> times. Reallocation will then occur if c &lt; n and may occur if c &gt;&gt; n to avoid leaving a lot of unused space. Then the constructor T(T2) will be called exactly n times. </dd></dl>

</div>
</div>
<a id="ab0fbbed70bc0fdb3ec5c188193503bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fbbed70bc0fdb3ec5c188193503bb8">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this array from a range [first,last1) given by non-pointer iterators. </p>
<p>See the assign(first,last1) method with pointer arguments for a relevant discussion.</p>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>For a non-owner array this is only allowed if we can calculate the number of source elements, and if that number is exactly the same as the current <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>.</li>
<li>See Complexity discussion below for behavior for the different kinds of iterators that might be supplied.</li>
<li>It is not permitted for any of the source elements to overlap in memory with the initial contents of the array.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first source element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A iterator pointing one element past the last source element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1-first &lt;= <a class="el" href="classSimTK_1_1Array__.html#add5065ed0d97dd73046429a808b975dd" title="Return the maximum allowable size for this array. ">max_size()</a> </dd>
<dd>
for non-owner array, last1-first == <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>For a non-owner array, this is only allowed if n=last1-first equals the current <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>, in which case we'll perform exactly n calls to the appropriate assignment operator of element type T. For owner arrays, if we can determine how many elements n=last1-first the source contains in advance, we'll do only a single allocation here and call one of T's constructors exactly n times after just <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> destructor calls needed to erase the original data. If the iterators are random access iterators, calculating n is a fast constant-time operation. For forward or bidirectional iterators, we have to advance through the iterators once to count the source elements prior to allocating space, adding an O(n) cost. For input iterators, we can't count them in advance so we just have to add elements as we find them using <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> meaning we may need to reallocate log(n) times, calling the destructor and copy constructor each time to move the elements around. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>assign(T2* first, T2* last1) </dd></dl>

</div>
</div>
<a id="a17aa8ec53fbbd5af9d8311040b4e215a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17aa8ec53fbbd5af9d8311040b4e215a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator destructs the current contents of this array and then makes it a copy of the source array by repeated calls to the element type's copy constructor. </p>
<p>At most one reallocation of heap space occurs that may result in this array having a larger or smaller capacity, although of course it will be at least as large as the source. </p>

</div>
</div>
<a id="ac82b083ea513ddfe43db268eca1cc39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82b083ea513ddfe43db268eca1cc39f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator swaps the contents of this <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> with the source <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>. </p>

</div>
</div>
<a id="a31782606c119d1db301ef14a930abd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31782606c119d1db301ef14a930abd22">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is assignment from a source array whose element type T2 and/or index type X2 are different from this array's T and X. </p>
<p>This will work as long as this array can accommodate all the elements in the source and T2 is assignment compatible with T. See discussion for the copy assignment operator for more information. </p>

</div>
</div>
<a id="abada82afde9d55dbde8b44052ce1fda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abada82afde9d55dbde8b44052ce1fda1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is assignment from a source std::vector&lt;T2&gt;. </p>
<p>This will work as long as this array can accommodate all the elements in the source and T2 is assignment compatible with T. See discussion for the copy assignment operator for more information. </p>

</div>
</div>
<a id="a4c544ef3a4eee81c7580699e793e0f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c544ef3a4eee81c7580699e793e0f92">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialized algorithm providing constant time exchange of data with another array that has identical element and index types. </p>
<p>This is <em>much</em> faster than using the default std::swap() algorithm on the arrays since that would involve O(n) copying operations; we provide a specialization for std::swap() that uses the method here instead. This method makes no calls to any constructors or destructors. This is allowable even for non-owner arrays; the non-owner attribute will follow the non-owned data. </p>

</div>
</div>
<a id="ac5671ab71d22a14e65a149feea9c577a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5671ab71d22a14e65a149feea9c577a">&#9670;&nbsp;</a></span>adoptData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::adoptData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This dangerous extension allows you to supply your own already-allocated heap space for use by this array, which then becomes the owner of the supplied heap space. </p>
<p>Any memory currently associated with the array is deallocated; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>, <a class="el" href="classSimTK_1_1Array__.html#a3e51e9d13453755cb0cce47af007d3c7" title="This dangerous extension allows you to make this array handle refer to someone else&#39;s data without co...">shareData()</a> </dd></dl>

</div>
</div>
<a id="a37550aafe7e3c54f9604ff80479153e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37550aafe7e3c54f9604ff80479153e9">&#9670;&nbsp;</a></span>adoptData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::adoptData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> that assumes the capacity is the same as the current size. </p>
<dl class="section see"><dt>See also</dt><dd>adoptData(data,size,capacity) </dd></dl>

</div>
</div>
<a id="a3e51e9d13453755cb0cce47af007d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e51e9d13453755cb0cce47af007d3c7">&#9670;&nbsp;</a></span>shareData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shareData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This dangerous extension allows you to make this array handle refer to someone else's data without copying it. </p>
<p>Any memory currently associated with the array is deallocated; see <a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a> for more information. This method makes the array a fixed-size, non-owner array that cannot be reallocated, and no element destruction nor heap deallocation will occur when the handle is subsequently destructed or deallocated. </p><dl class="section note"><dt>Note</dt><dd><ul>
<li>A null (0) pointer is allowed for the pointer as long as <em>dataSize==0</em>, however in that case the array handle ends up deallocated (that is, indistinguishable from a default-constructed array) so is resizeable.</li>
<li>This is implemented by setting the nAllocated data member to zero while the nUsed data member is set to the given <em>dataSize</em>. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a67bc6c09d3ea513dfba42a5dfc42cd38" title="Empty this array of its contents, returning the array to its default-constructed, all-zero state...">deallocate()</a>, <a class="el" href="classSimTK_1_1Array__.html#ac5671ab71d22a14e65a149feea9c577a" title="This dangerous extension allows you to supply your own already-allocated heap space for use by this a...">adoptData()</a> </dd></dl>

</div>
</div>
<a id="aa780ca6f8edd609cd461b0a90fbbca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa780ca6f8edd609cd461b0a90fbbca64">&#9670;&nbsp;</a></span>shareData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shareData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as shareData(data,size) but uses a pointer range [first,last1) to identify the data to be referenced. </p>

</div>
</div>
<a id="a8f820d2b0218c551e2d9ec4db5ce06e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f820d2b0218c551e2d9ec4db5ce06e0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current number of elements stored in this array. </p>

</div>
</div>
<a id="add5065ed0d97dd73046429a808b975dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5065ed0d97dd73046429a808b975dd">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowable size for this array. </p>

</div>
</div>
<a id="acc498823f6144cc7aea3a3c73b2f05fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc498823f6144cc7aea3a3c73b2f05fd">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if there are no elements currently stored in this array. </p>
<p>This is equivalent to the tests <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> == <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> or <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>==0. </p>

</div>
</div>
<a id="a7931f3efebaa00feb25d689df891312e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7931f3efebaa00feb25d689df891312e">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements this array can currently hold without requiring reallocation. </p>
<p>The value returned by <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> is always greater than or equal to <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>, even if the data is not owned by this array in which case we have <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> == <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and the array is not reallocatable. </p>

</div>
</div>
<a id="a3ef48cf9aac351db79f747c2ddd23bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef48cf9aac351db79f747c2ddd23bf4">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of this Array, preserving all the elements that will still fit, and default constructing any new elements that are added. </p>
<p>This is not allowed for non-owner arrays unless the requested size is the same as the current size. </p>

</div>
</div>
<a id="ab839b023c760816f9580d4feea2c9136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab839b023c760816f9580d4feea2c9136">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of this array, preserving all the elements that will still fit, and initializing any new elements that are added by repeatedly copy- constructing from the supplied value. </p>
<p>This is not allowed for non-owner arrays unless the requested size is the same as the current size. </p>

</div>
</div>
<a id="a18b9cb15ea07f2da45d9b45a8f12429e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b9cb15ea07f2da45d9b45a8f12429e">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that this array has enough allocated capacity to hold the indicated number of elements. </p>
<p>No heap reallocation will occur after this until the array is grown beyond this capacity, meaning that adding elements will not invalidate any iterators or element addresses until that point. This method will never reduce the capacity of the array. It is OK to call this on a non-owner array as long as you are not asking for an increase in capacity. </p>

</div>
</div>
<a id="aad5af2017b0c5a1a2160104d98a59294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5af2017b0c5a1a2160104d98a59294">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the capacity of this array be reduced to the minimum necessary to hold the number of elements currently in use. </p>
<p>In practice no shrinkage will occur if the current size is just slightly too big, unless the current size is exactly zero in which case we guarantee to deallocate all heap space associated with this array leaving a null data pointer and <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>==<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>==0, exactly as though the array had just been default-constructed. Otherwise you can check <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> afterwards to see what happened. If the <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> is reduced by this method, then all the elements will have been moved to new locations so existing iterators and references into the array will become invalid.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This method matches the C++11 std::vector method, except for the guaranteed behavior for a zero-size container.</li>
<li>It is OK to call this on a non-owner array but it has no effect since <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a>==<a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> already in that case.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If the capacity is reduced, there will be one call to T's move constructor and destructor (if any) for each element currently in the array. Otherwise this is very fast. </dd></dl>

</div>
</div>
<a id="a3776f1653877f391bf4bca84bbcdaf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3776f1653877f391bf4bca84bbcdaf08">&#9670;&nbsp;</a></span>allocated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners. </p>
<dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a id="ae939d50fcf641771c66141cba7dbef20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae939d50fcf641771c66141cba7dbef20">&#9670;&nbsp;</a></span>isOwner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::isOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors. </p>
<p>If the array does not refer to <em>any</em> data it is considered to be an owner and it is resizeable. </p><dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a id="afcc6178c93196de7d6f78624cfe2a821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc6178c93196de7d6f78624cfe2a821">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be. </p>
<p>This method is from the C++11 standard; there is also an overloaded <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a id="a77732b6b0a3679081923826db10870ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77732b6b0a3679081923826db10870ba">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#afcc6178c93196de7d6f78624cfe2a821" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>. </p>

</div>
</div>
<a id="ab87a252bd681eeb8d9e4075343263f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87a252bd681eeb8d9e4075343263f1f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> == <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a id="a392fc413a7e6957848172360af68efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392fc413a7e6957848172360af68efb9">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be. </p>
<p>This method is from the C++11 standard; there is also an overloaded <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a id="a564a0ed3b9cfec01b45c49428f3e413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564a0ed3b9cfec01b45c49428f3e413a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>. </p>

</div>
</div>
<a id="a5a12efc66437667e7af14e54747433ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a12efc66437667e7af14e54747433ec">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to what would be the element just after the last one in this array. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>==<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a id="ae9bbcdacbcb1c051e86b9137eb23073f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bbcdacbcb1c051e86b9137eb23073f">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a8f747e785bf5492c949288dfcd3c3bcb" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty. </p>

</div>
</div>
<a id="ad8c5052c882cd2987d08f0e637d1799a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c5052c882cd2987d08f0e637d1799a">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#aab002eb8f193aea7d6b4ab3683ff89aa" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#ae9bbcdacbcb1c051e86b9137eb23073f" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>. </p>

</div>
</div>
<a id="aab002eb8f193aea7d6b4ab3683ff89aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab002eb8f193aea7d6b4ab3683ff89aa">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty. </p>

</div>
</div>
<a id="a8f747e785bf5492c949288dfcd3c3bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f747e785bf5492c949288dfcd3c3bcb">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a id="a9d7f41a04a8ea0f5360684ed4c237cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7f41a04a8ea0f5360684ed4c237cfb">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1Array__.html#a5973f198607a6531235df6877ab9979d" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1Array__.html#a8f747e785bf5492c949288dfcd3c3bcb" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>. </p>

</div>
</div>
<a id="a5973f198607a6531235df6877ab9979d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5973f198607a6531235df6877ab9979d">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a id="ad0361eed504c3f5db4921bd02c636265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0361eed504c3f5db4921bd02c636265">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ad0361eed504c3f5db4921bd02c636265" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a> is not in the C++11 standard although it would seem obvious in view of the <a class="el" href="classSimTK_1_1Array__.html#afcc6178c93196de7d6f78624cfe2a821" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a> and <a class="el" href="classSimTK_1_1Array__.html#a392fc413a7e6957848172360af68efb9" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a> methods that had to be added. The C++11 overloaded const <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is also available. </dd></dl>

</div>
</div>
<a id="a3e12831ee2fc61aea5d7e1144c20626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e12831ee2fc61aea5d7e1144c20626d">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of the <a class="el" href="classSimTK_1_1Array__.html#af05128fb7611eb19f884b1e742878277" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1Array__.html#ad0361eed504c3f5db4921bd02c636265" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the C++11 std::vector. </dd></dl>

</div>
</div>
<a id="af05128fb7611eb19f884b1e742878277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05128fb7611eb19f884b1e742878277">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the C++11 std::vector. </dd></dl>

</div>
</div>
<a id="ae53b1148637b73697f682031e5c4f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53b1148637b73697f682031e5c4f87e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a const reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a52dc3c8d6816f2cc3d9e42caa2688993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dc3c8d6816f2cc3d9e42caa2688993">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a writable (lvalue) reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a6484d35a4f3885e5dd9b53d72780c5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6484d35a4f3885e5dd9b53d72780c5b0">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="aa8a43460f045aeb40cc0e1ca44aacbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a43460f045aeb40cc0e1ca44aacbc1">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="af613cf92a24e169554e2a829b631b193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af613cf92a24e169554e2a829b631b193">&#9670;&nbsp;</a></span>getElt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::getElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a id="aa17ec9fa947bdc8b7aa75a0d09b36214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17ec9fa947bdc8b7aa75a0d09b36214">&#9670;&nbsp;</a></span>updElt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::updElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a id="aa3d59bf9348d5b75066d01970ecd4ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d59bf9348d5b75066d01970ecd4ca0">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a3e306ed9d706676046787b8f8c049480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e306ed9d706676046787b8f8c049480">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a09e63e9cd875462bad8308f09f85c7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e63e9cd875462bad8308f09f85c7a2">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="af001d2418473e4e149969b0aea2ac96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af001d2418473e4e149969b0aea2ac96a">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="aa0eea146d6440641b621056595b7be6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eea146d6440641b621056595b7be6a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a subrange of this const array by starting index and length, and return a <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> referencing that data without copying it. </p>

</div>
</div>
<a id="a64d0aa0729350862986dc0a9c0652d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d0aa0729350862986dc0a9c0652d9f">&#9670;&nbsp;</a></span>getSubArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::getSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a id="a9cbd317755142dd7707305ba1dd36c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd317755142dd7707305ba1dd36c4b">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a subrange of this array by starting index and length, and return an <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> referencing that data without copying it. </p>

</div>
</div>
<a id="a223502957a0d38152ea9bda9ac194829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223502957a0d38152ea9bda9ac194829">&#9670;&nbsp;</a></span>updSubArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt;T,X&gt; <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::updSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a id="a13b95bc701e5bd09dad7ee38e069b669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b95bc701e5bd09dad7ee38e069b669">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method increases the size of the Array by one element at the end and initializes that element by copy constructing it from the given value. </p>
<p>If <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> &gt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>, that's all that will happen. If <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a>==<a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>, there is no room for another element so we'll allocate more space and move all the elements there. A reference to the just-inserted element can be obtained using the <a class="el" href="classSimTK_1_1Array__.html#af001d2418473e4e149969b0aea2ac96a" title="Return a writable reference to the last element in this array, which must not be empty. ">back()</a> method after the call to <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>An object of type T from which the new element is copy-constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If you are appending a default-constructed object of type T, consider using the alternate non-standard but safe <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> method rather than push_back(T()). The non-standard method default-constructs the new element internally. That avoids a call to the copy constructor which can be expensive for some objects, and nonexistent for others.</li>
<li>If you are constructing the source object with a non-default constructor, and the object is expensive or impossible to default-construct and/or copy-construct, consider using the non-standard and dangerous method <a class="el" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c" title="(Deprecated, use emplace_back() instead) This dangerous non-standard method increases the Array&#39;s siz...">raw_push_back()</a> which enables you to construct the new element in place.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time if no reallocation is required; otherwise the current contents of the array must be moved to new space, costing one call to T's move constructor and destructor (if any) for each element currently in the array. Either way there is also one call to T's copy constructor to construct the new element from the supplied value. </dd></dl>

</div>
</div>
<a id="a48419a1a62635e0f15fa56509a86dd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48419a1a62635e0f15fa56509a86dd4f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the move form of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a>, taking an rvalue reference rather than an lvalue reference. </p>
<p>See the other signature for information, with move-construction instead of copy-construction (reallocation is the same in either case). </p>

</div>
</div>
<a id="ad5da768f427c750d280ddc570f7eb3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5da768f427c750d280ddc570f7eb3ef">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is similar to <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> but rather than copying, it constructs the element in place at the end of the array. </p>
<p>To do that it invokes the constructor of T whose signature matches the supplied argument pack. This has the same effect as <code>push_back(T(Args...))</code> would have but avoids the extra copy that would be required. Reallocation is handled the same as for <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method should be preferred to the nonstandard <a class="el" href="classSimTK_1_1Array__.html#a7ceb31ef48594914eaef9ddcec92791c" title="(Deprecated, use emplace_back() instead) This dangerous non-standard method increases the Array&#39;s siz...">raw_push_back()</a> method. </dd></dl>

</div>
</div>
<a id="a7b698ae20b857ce3de014b8996f3b1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b698ae20b857ce3de014b8996f3b1e5">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::push_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Deprecated, use <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> instead) This is a non-standard version of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> that increases the size of the array by one default-constructed element at the end. </p>
<p>This avoids having to default-construct the argument to the standard push_back(value) method which then has to copy-construct or move-construct it into the array. By carefully avoiding reallocation and using this form of <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a> you can use the Array_&lt;T&gt; class to hold objects of type T even if T has no copy or move constructor, which is prohibited by the standard std::vector&lt;T&gt; definition.</p>
<dl class="section note"><dt>Note</dt><dd>Since C++11 added <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> you can accomplish the same thing by calling <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> with no arguments.</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as the standard push_back(value) method except without the final call to T's copy constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a>, push_back(value) </dd></dl>

</div>
</div>
<a id="a7ceb31ef48594914eaef9ddcec92791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceb31ef48594914eaef9ddcec92791c">&#9670;&nbsp;</a></span>raw_push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::raw_push_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Deprecated, use <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> instead) This dangerous non-standard method increases the Array's size by one element at the end but doesn't perform any construction so the memory is filled with garbage. </p>
<p>You must immediately construct into this space, using code like: </p><div class="fragment"><div class="line"><span class="keyword">new</span>(a.raw_push_back()) MyConstructor(args...);       </div></div><!-- fragment --><p> This is a substantial performance improvement when the element type is something complicated since the constructor is called once and not copied; it can also be used for objects that have neither default nor copy constructors. </p><dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) pointing at the unconstructed element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since C++11 added <a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a> you can accomplish the same thing safely by calling emplace_back(args...) with the constructor arguments.</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as ordinary <a class="el" href="classSimTK_1_1Array__.html#a7b698ae20b857ce3de014b8996f3b1e5" title="(Deprecated, use emplace_back() instead) This is a non-standard version of push_back() that increases...">push_back()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ad5da768f427c750d280ddc570f7eb3ef" title="This is similar to push_back() but rather than copying, it constructs the element in place at the end...">emplace_back()</a>, push_back(value) </dd></dl>

</div>
</div>
<a id="a54b5b478c9ac203ed767eadf7828ffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b5b478c9ac203ed767eadf7828ffcd">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last element from this array, which must not be empty. </p>
<p>The element is destructed, not returned. The array's <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> is reduced by one. </p>

</div>
</div>
<a id="a52a656cb3128af0259d85978a61b7e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a656cb3128af0259d85978a61b7e01">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements in range [first,last1), packing in any later elements into the newly-available space and reducing the array's size by the number of elements erased. </p>
<p>Capacity is unchanged. If the range is empty nothing happens.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>first</em> &lt;= <em>last1</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Points to the first element that will be erased. </td></tr>
    <tr><td class="paramname">last1</td><td>Points one element past the last element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the new location of the element immediately following the erased ones, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if there are none. Either way, this is the same memory address as the passed-in <em>first</em> argument since there can be no reallocation here. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for each erased element and calls T's move constructor and destructor once for each element that has to be moved. </dd></dl>

</div>
</div>
<a id="a818361e237b91adc12d2122f119c579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818361e237b91adc12d2122f119c579c">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase just one element, moving all subsequent elements down one slot and reducing the array's size by one. </p>
<p>This is equivalent to erase(p,p+1) but faster; that means <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> because <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>+1 is not defined. Capacity is unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>If you don't mind the elements being reordered, you can erase an element in constant time using the non-standard extension <a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Points to the element that will be erased; <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element that replaced the one at <em>p</em>, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if <em>p</em> was the last element. Either way, this is the same memory address as the erased element had since there can be no reallocation here. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for the erased element and calls T's move constructor and destructor once for each element that has to be moved. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#aea3f2ff76ae0b004c5e21c3aa170ebf6" title="Be careful with this non-standard extension; it erases one element and then moves the last one in its...">eraseFast()</a> </dd></dl>

</div>
</div>
<a id="aea3f2ff76ae0b004c5e21c3aa170ebf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f2ff76ae0b004c5e21c3aa170ebf6">&#9670;&nbsp;</a></span>eraseFast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::eraseFast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Be careful with this non-standard extension; it erases one element and then moves the last one in its place which changes the element order from what it was before (unlike the standard <a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> method). </p>
<p>This avoids having to compress the elements so this runs in constant time: the element is destructed; then if it wasn't the last element the move constructor is used to move the last element into the vacated space, and the destructor is called to clear the last element. The size is reduced by 1 but the capacity does not change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Points to the element that will be erased; <em>p</em> cannot be <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element that replaced the one at <em>p</em>, or <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> if <em>p</em> was the last element. Either way, this is the same memory address as the erased element had since there can be no reallocation here. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt; <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calls T's destructor once for the erased element and calls T's move constructor and destructor once for each element that has to be moved. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a52a656cb3128af0259d85978a61b7e01" title="Erase elements in range [first,last1), packing in any later elements into the newly-available space a...">erase()</a> </dd></dl>

</div>
</div>
<a id="af95f49692c338895df4ddc36752b4baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95f49692c338895df4ddc36752b4baa">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all the elements currently in this array without changing the capacity; equivalent to erase(<a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>,<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>) but a little faster. </p>
<p>Size is zero after this call. T's destructor is called exactly once for each element in the array.</p>
<dl class="section user"><dt>Complexity:</dt><dd>O(n) if T has a destructor; constant time otherwise. </dd></dl>

</div>
</div>
<a id="a7c6c04b85ed597b657f4cd244c02c52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6c04b85ed597b657f4cd244c02c52d">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert <em>n</em> copies of a given value at a particular location within this array, moving all following elements up by <em>n</em> positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Where to insert the new elements. This must be an iterator (pointer) that is valid for this array, that is, <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>How many copies of the given <em>value</em> to insert. Nothing happens if <em>n</em> is zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A value of the element type that is copied into the newly-created elements using T's copy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first of the newly-created elements in the array. This will be different from <em>p</em> if reallocation occurred, otherwise it is the same as <em>p</em> was on entry.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> + <em>n</em> &gt; <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> then the array must be reallocated, resulting in <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> move constructor/destructor call pairs to move the old data to the new location. Otherwise, the m=(<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>-<em>p</em>) elements above the insertion point must be moved up <em>n</em> positions resulting in m move/destruct pairs. Then there are n copy constructor calls to construct the new elements from the given value. </dd></dl>

</div>
</div>
<a id="a1de9710bd314b227b6d7fb9b1e2e5013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de9710bd314b227b6d7fb9b1e2e5013">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new element at a given location within this array, initializing it to a copy of a given value and moving all following elements up one position. </p>
<p>This is identical to insert(<em>p</em>,1,<em>value</em>) but slightly faster; see that method for full documentation. </p>

</div>
</div>
<a id="aefbfcca9949bd6ad04d98e0030811c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbfcca9949bd6ad04d98e0030811c11">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new element at a given location within this array, by invoking T's constructor whose signature matches the supplied arguments. </p>
<p>All following elements are moved up one position. This is identical in effect to <code>insert(p,T(Args...))</code> but avoids the extra copy that would be required in that case. </p>

</div>
</div>
<a id="a9e597a8ecd02706680bf8920c5a15f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e597a8ecd02706680bf8920c5a15f29">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements in a range [first,last1) into this array at a given position <em>p</em>, moving all following elements up by n=(last1-first) positions. </p>
<p>This variant of <a class="el" href="classSimTK_1_1Array__.html#a7c6c04b85ed597b657f4cd244c02c52d" title="Insert n copies of a given value at a particular location within this array, moving all following ele...">insert()</a> takes iterators which are ordinary pointers, although the source elements do not have to be of type T as long as there is a constructor T(T2) that works.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Where to insert the new elements. This must be an iterator (pointer) that is valid for this array, that is, <a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>This is a pointer to the first element of the source to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>This points one element past the last element of the source to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first of the newly-created elements in the array. This will be different from <em>p</em> if reallocation occurred, otherwise it is the same as <em>p</em> was on entry.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classSimTK_1_1Array__.html#ab87a252bd681eeb8d9e4075343263f1f" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> &lt;= <em>p</em> &lt;= <a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> </dd>
<dd>
first &lt;= last1 </dd>
<dd>
The range [first,last1) does not include any of the current contents of this array. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>If <a class="el" href="classSimTK_1_1Array__.html#a7931f3efebaa00feb25d689df891312e" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> &lt; <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a>+n then the array must be reallocated, resulting in <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> calls to T's move constructor and destructor (if any) to move the old data to the new location. Otherwise, the m=(<a class="el" href="classSimTK_1_1Array__.html#a5a12efc66437667e7af14e54747433ec" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>-<em>p</em>) elements above the insertion point must be moved up n positions resulting in m move/destruct pairs. Then there are n T(T2) constructor calls to construct the new elements from the given value. </dd></dl>

</div>
</div>
<a id="ae2abd8e9d2146f344a88f96d1f839db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2abd8e9d2146f344a88f96d1f839db0">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements in a range [first,last1) where the range is given by non-pointer iterators. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a015cef5d8e534e632955fcca6ea444f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015cef5d8e534e632955fcca6ea444f8">&#9670;&nbsp;</a></span>writeUnformatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize <a class="el" href="classSimTK_1_1Array__.html#a015cef5d8e534e632955fcca6ea444f8" title="Specialize writeUnformatted() for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating t...">writeUnformatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with spaces separating the elements. </p>

</div>
</div>
<a id="a6abedbcfc5b21bd9fa859208247aec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abedbcfc5b21bd9fa859208247aec72">&#9670;&nbsp;</a></span>writeFormatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeFormatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialize <a class="el" href="classSimTK_1_1Array__.html#a6abedbcfc5b21bd9fa859208247aec72" title="Specialize writeFormatted() for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parenthes...">writeFormatted()</a> for Array_&lt;E,X&gt; to delegate to element type E, with surrounding parentheses and commas separating the elements. </p>

</div>
</div>
<a id="a8575e59ff1ed3dcb8e52d7dd44ebb426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8575e59ff1ed3dcb8e52d7dd44ebb426">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a human readable representation of an array to an std::ostream (like std::cout). </p>
<p>The format is ( <em>elements</em> ) where <em>elements</em> is a comma-separated list of the Array's contents output by invoking the "&lt;&lt;" operator on the elements. This function will not compile if the element type does not support the "&lt;&lt;" operator. No newline is issued before or after the output. </p>

</div>
</div>
<a id="a6b300ce2032c6315983114f0b7e84e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b300ce2032c6315983114f0b7e84e92">&#9670;&nbsp;</a></span>readUnformatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1Array__.html#a6b300ce2032c6315983114f0b7e84e92" title="Specialization of readUnformatted() for variable-length Array_&lt;T,X&gt;; continues reading whitespace-sep...">readUnformatted()</a> for variable-length Array_&lt;T,X&gt;; continues reading whitespace-separated tokens until error or eof. </p>

</div>
</div>
<a id="a65a8a24c48ad3dff0c852095f0347941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a8a24c48ad3dff0c852095f0347941">&#9670;&nbsp;</a></span>readFormatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readFormatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1Array__.html#a65a8a24c48ad3dff0c852095f0347941" title="Specialization of readFormatted() for variable-length Array_&lt;T,X&gt;; uses readArrayFromStream() to cons...">readFormatted()</a> for variable-length Array_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> to consume an appropriately-formatted array until error, closing parenthesis or bracket, or eof. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> for details </dd></dl>

</div>
</div>
<a id="a0a452cab4756ae07c3ab22c155eb1b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a452cab4756ae07c3ab22c155eb1b15">&#9670;&nbsp;</a></span>readArrayFromStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; readArrayFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values optionally surrounded by parentheses (), square brackets [], or curly braces {}. </p>
<p>We will continue to read elements of type T from the stream until we find a reason to stop, using type T's stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a> to read in each element and resizing the Array as necessary. If the data is bracketed, we'll read until we hit the closing bracket. If it is not bracketed, we'll read until we hit eof() or get an error such as the element extractor setting the stream's fail bit due to bad formatting. On successful return, the stream will be positioned right after the final read-in element or terminating bracket, and the stream's status will be good() or eof(). We will not consume trailing whitespace after bracketed elements; that means the stream might actually be empty even if we don't return eof(). If you want to know whether there is anything else in the stream, follow this call with the STL whitespace skipper std::ws() like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15">readArrayFromStream</a>(in,array) &amp;&amp; !in.eof()) </div><div class="line">    std::ws(in); <span class="comment">// might take us to eof</span></div><div class="line"><span class="keywordflow">if</span> (in.fail()) {...} <span class="comment">// probably a formatting error</span></div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">// Here if the stream is good() then there is more to read; if the</span></div><div class="line">    <span class="comment">// stream got used up the status is guaranteed to be eof().</span></div><div class="line">}</div></div><!-- fragment --><p> A compilation error will occur if you try to use this method on an Array_&lt;T&gt; for a type T for which there is no stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. </p><dl class="section note"><dt>Note</dt><dd>If you want to fill an owner Array_&lt;T&gt; with a fixed amount of data from the stream, <a class="el" href="classSimTK_1_1Array__.html#a3ef48cf9aac351db79f747c2ddd23bf4" title="Change the size of this Array, preserving all the elements that will still fit, and default construct...">resize()</a> the array to the appropriate length and then use <a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> </dd></dl>

</div>
</div>
<a id="a34546fb36b84171e76276a508121a3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34546fb36b84171e76276a508121a3ce">&#9670;&nbsp;</a></span>fillArrayFromStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; fillArrayFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a fixed number of elements from a stream into an Array. </p>
<p>We expect to read in exactly <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> elements of type T, using type T's stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. This will stop reading when we've read <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> elements, or set the fail bit in the stream if we run out of elements or if any element's extract operator sets the fail bit. On successful return, all <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> elements will have been set, the stream will be positioned right after the final read-in element or terminating bracket, and the stream's status will be good() or eof(). We will not consume trailing whitespace after reading all the elements; that means the stream might actually be empty even if we don't return eof(). If you want to know whether there is anything else in the stream, follow this call with std::ws() like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce">fillArrayFromStream</a>(in,array))</div><div class="line">    <span class="keywordflow">if</span> (!in.eof()) std::ws(in); <span class="comment">// might take us to eof</span></div><div class="line"><span class="keywordflow">if</span> (in.fail()) {...} <span class="comment">// deal with I/O or formatting error</span></div><div class="line"><span class="comment">// Here if the stream is good() then there is more to read; if the</span></div><div class="line"><span class="comment">// stream got used up the status is guaranteed to be eof().</span></div></div><!-- fragment --><p> A compilation error will occur if you try to use this method on an Array_&lt;T&gt; for a type T for which there is no stream extraction <a class="el" href="classSimTK_1_1Array__.html#adbd40fd273bd41041bb7138a3268ca82" title="Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T...">operator&gt;&gt;()</a>. </p><dl class="section note"><dt>Note</dt><dd>If you want to read in a variable number of elements and have the Array_&lt;T&gt; resized as needed, use <a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a0a452cab4756ae07c3ab22c155eb1b15" title="Read in an Array_&lt;T&gt; from a stream, as a sequence of space-separated or comma-separated values option...">readArrayFromStream()</a> </dd></dl>

</div>
</div>
<a id="adbd40fd273bd41041bb7138a3268ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd40fd273bd41041bb7138a3268ca82">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an Array_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, brackets, or braces. </p>
<p>The Array_&lt;T&gt; may be an owner (variable size) or a view (fixed size n). In the case of an owner, we'll read all the elements in brackets or until eof if there are no brackets. In the case of a view, there must be exactly n elements in brackets, or if there are no brackets we'll consume exactly n elements and then stop. Each element is read in with its own operator "&gt;&gt;" so this won't work if no such operator is defined for type T. </p>

</div>
</div>
<a id="a1e25d47eeb9e34faa78ee38812b194d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e25d47eeb9e34faa78ee38812b194d8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2. </p>

</div>
</div>
<a id="aa79b082dbed61adf809400e05027c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79b082dbed61adf809400e05027c595">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a id="a0e1218fae627e26b17ed948a62e87cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1218fae627e26b17ed948a62e87cc8">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter array (in which case the shorter one is "less than" the longer). </p>
<p>This depends on T1==T2 and T1&lt;T2 operators working. </p>

</div>
</div>
<a id="ad80423b9a73fd93e07d8465c97e999af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80423b9a73fd93e07d8465c97e999af">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a id="ac93cc22c503f9f75f1be2cbbb2c97714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93cc22c503f9f75f1be2cbbb2c97714">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a id="a8822b4815845e58a47af6b5720791698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8822b4815845e58a47af6b5720791698">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a id="a39975ed123e3738da698ea6d0ddc7a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39975ed123e3738da698ea6d0ddc7a4a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An Array_&lt;T1&gt; and an std::vector&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T1==T2. </p>

</div>
</div>
<a id="a5bef2d3446751e985a922ecb0681653c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bef2d3446751e985a922ecb0681653c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An std::vector&lt;T1&gt; and an Array_&lt;T2&gt; are equal if and only if they are the same <a class="el" href="classSimTK_1_1Array__.html#a8f820d2b0218c551e2d9ec4db5ce06e0" title="Return the current number of elements stored in this array. ">size()</a> and each element compares equal using an operator T2==T1. </p>

</div>
</div>
<a id="a688f8af308de34d0431205f7d854aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688f8af308de34d0431205f7d854aee3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a id="a7d04f55c1a275128219e677a974254c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d04f55c1a275128219e677a974254c9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The not equal operator is implemented using the equal operator. </p>

</div>
</div>
<a id="addbec0e1348a20404c060b9c5523544f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbec0e1348a20404c060b9c5523544f">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An Array_&lt;T1&gt; and std::vector&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer). </p>
<p>This depends on having working element operators T1==T2 and T1&lt;T2. </p>

</div>
</div>
<a id="aa929813dea46bf41f7ffee7053566f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa929813dea46bf41f7ffee7053566f86">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An std::vector&lt;T1&gt; and Array_&lt;T2&gt; are ordered lexicographically; that is, by first differing element or by length if there are no differing elements up to the length of the shorter container (in which case the shorter one is "less than" the longer). </p>
<p>This depends on having working element operators T1==T2 and T1&lt;T2. </p>

</div>
</div>
<a id="a81e151401cab82f28a4d2f6c43bdaeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e151401cab82f28a4d2f6c43bdaeb0">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a id="a1c9fc6fb86e0e02b422ea858ba216f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9fc6fb86e0e02b422ea858ba216f94">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than or equal operator is implemented using the less than operator. </p>

</div>
</div>
<a id="ad057e98ddbd0b80ab053519caa9dd2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad057e98ddbd0b80ab053519caa9dd2ea">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a id="ad7d14e73a05783839ed5c679278764d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d14e73a05783839ed5c679278764d4">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The greater than operator is implemented by using less than with the arguments reversed, meaning the elements must have working comparison operators of the form T2==T1 and T2&lt;T1. </p>

</div>
</div>
<a id="ad6219dc0d49e5f4d40d4a5d7954c5adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6219dc0d49e5f4d40d4a5d7954c5adb">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class X1 , class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T1, X1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a id="a463986b88adfd8319e9a2ddcb7b21d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463986b88adfd8319e9a2ddcb7b21d0e">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class A1 , class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T1, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The less than or equal operator is implemented using the greater than operator. </p>

</div>
</div>
<a id="a8a1771c28a26738d4e217ec67586f9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1771c28a26738d4e217ec67586f9c8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">SimTK::Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialization of the STL std::swap() algorithm which uses the constant time built-in <a class="el" href="classSimTK_1_1Array__.html#a4c544ef3a4eee81c7580699e793e0f92" title="This is a specialized algorithm providing constant time exchange of data with another array that has ...">swap()</a> member of the <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> class. </p>

</div>
</div>
<a id="a41a2ecaa31633e2db5b375f3519e259c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a2ecaa31633e2db5b375f3519e259c">&#9670;&nbsp;</a></span>toXmlElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> toXmlElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects. </p>
<p>The result is a single element with tag word <code>&lt;Array&gt;</code> with the given name (if any) and a version number as attributes. Then each entry is a subelement, as produced by type T's <code><a class="el" href="classSimTK_1_1Array__.html#a41a2ecaa31633e2db5b375f3519e259c" title="Partial specialization for XML serialization of Array_ objects. ">toXmlElement()</a></code> method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Array__.html">Array_</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:12 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
