<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::SpatialInertia_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1SpatialInertia__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1SpatialInertia__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::SpatialInertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body.  
 <a href="classSimTK_1_1SpatialInertia__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a18e7fd09141c51fbaa54258117ccdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a5a18e7fd09141c51fbaa54258117ccdb">SpatialInertia_</a> ()</td></tr>
<tr class="memdesc:a5a18e7fd09141c51fbaa54258117ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor fills everything with NaN, even in Release mode.  <a href="#a5a18e7fd09141c51fbaa54258117ccdb">More...</a><br /></td></tr>
<tr class="separator:a5a18e7fd09141c51fbaa54258117ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b284bdee64fb8b30f434bccb8b718f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ab5b284bdee64fb8b30f434bccb8b718f">SpatialInertia_</a> (RealP mass, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;com, const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;gyration)</td></tr>
<tr class="separator:ab5b284bdee64fb8b30f434bccb8b718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c076c62aa1294911c7ff7752394c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ad6c076c62aa1294911c7ff7752394c86">setMass</a> (RealP mass)</td></tr>
<tr class="separator:ad6c076c62aa1294911c7ff7752394c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b055dd19ea4987cdf9a88810543a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a04b055dd19ea4987cdf9a88810543a58">setMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;com)</td></tr>
<tr class="separator:a04b055dd19ea4987cdf9a88810543a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147ff1b0fe566a4b8c65988d41171315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a147ff1b0fe566a4b8c65988d41171315">setUnitInertia</a> (const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;gyration)</td></tr>
<tr class="separator:a147ff1b0fe566a4b8c65988d41171315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f88ea906eed408885a25363a5af0602"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a1f88ea906eed408885a25363a5af0602">getMass</a> () const</td></tr>
<tr class="separator:a1f88ea906eed408885a25363a5af0602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d3510e7bdd80b6057574a0c697b9d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#ad4d3510e7bdd80b6057574a0c697b9d7">getMassCenter</a> () const</td></tr>
<tr class="separator:ad4d3510e7bdd80b6057574a0c697b9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82484860b62bda56d36741169189fe30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a82484860b62bda56d36741169189fe30">getUnitInertia</a> () const</td></tr>
<tr class="separator:a82484860b62bda56d36741169189fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d2b050c52ba530001cb5ed2e10bfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a09d2b050c52ba530001cb5ed2e10bfc1">calcMassMoment</a> () const</td></tr>
<tr class="memdesc:a09d2b050c52ba530001cb5ed2e10bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the first mass moment (mass-weighted COM location) from the mass and COM vector.  <a href="#a09d2b050c52ba530001cb5ed2e10bfc1">More...</a><br /></td></tr>
<tr class="separator:a09d2b050c52ba530001cb5ed2e10bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9936c033332ce02ccaf47c4849f2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">InertiaP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a4a9936c033332ce02ccaf47c4849f2b5">calcInertia</a> () const</td></tr>
<tr class="memdesc:a4a9936c033332ce02ccaf47c4849f2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inertia matrix (second mass moment, mass-weighted gyration matrix) from the mass and unit inertia matrix.  <a href="#a4a9936c033332ce02ccaf47c4849f2b5">More...</a><br /></td></tr>
<tr class="separator:a4a9936c033332ce02ccaf47c4849f2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc7b7d2e8a3d7a17a7a6208efea9e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a7cc7b7d2e8a3d7a17a7a6208efea9e31">operator+=</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;src)</td></tr>
<tr class="memdesc:a7cc7b7d2e8a3d7a17a7a6208efea9e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a compatible SpatialInertia.  <a href="#a7cc7b7d2e8a3d7a17a7a6208efea9e31">More...</a><br /></td></tr>
<tr class="separator:a7cc7b7d2e8a3d7a17a7a6208efea9e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b3ffe93dd0a5b9a87651306f5f9137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a16b3ffe93dd0a5b9a87651306f5f9137">operator-=</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;src)</td></tr>
<tr class="memdesc:a16b3ffe93dd0a5b9a87651306f5f9137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a compatible SpatialInertia.  <a href="#a16b3ffe93dd0a5b9a87651306f5f9137">More...</a><br /></td></tr>
<tr class="separator:a16b3ffe93dd0a5b9a87651306f5f9137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1210e27aeaf4c729c0fa9f3b7504fb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a1210e27aeaf4c729c0fa9f3b7504fb35">operator*=</a> (const RealP &amp;s)</td></tr>
<tr class="memdesc:a1210e27aeaf4c729c0fa9f3b7504fb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a SpatialInertia by a scalar.  <a href="#a1210e27aeaf4c729c0fa9f3b7504fb35">More...</a><br /></td></tr>
<tr class="separator:a1210e27aeaf4c729c0fa9f3b7504fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c2d4d66bd4bbb6d843914181e93bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a27c2d4d66bd4bbb6d843914181e93bc4">operator/=</a> (const RealP &amp;s)</td></tr>
<tr class="memdesc:a27c2d4d66bd4bbb6d843914181e93bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a SpatialInertia by a scalar.  <a href="#a27c2d4d66bd4bbb6d843914181e93bc4">More...</a><br /></td></tr>
<tr class="separator:a27c2d4d66bd4bbb6d843914181e93bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9c4272162e7fa8778ce8ec3e6c4671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aaa9c4272162e7fa8778ce8ec3e6c4671">operator*</a> (const <a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> &amp;v) const</td></tr>
<tr class="memdesc:aaa9c4272162e7fa8778ce8ec3e6c4671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a SpatialInertia by a SpatialVec to produce a SpatialVec result; 45 flops.  <a href="#aaa9c4272162e7fa8778ce8ec3e6c4671">More...</a><br /></td></tr>
<tr class="separator:aaa9c4272162e7fa8778ce8ec3e6c4671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c938294812abcbfa1875922a2a880d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a5c938294812abcbfa1875922a2a880d5">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:a5c938294812abcbfa1875922a2a880d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one except re-expressed in another coordinate frame.  <a href="#a5c938294812abcbfa1875922a2a880d5">More...</a><br /></td></tr>
<tr class="separator:a5c938294812abcbfa1875922a2a880d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d67fd62ab5788aa286af03502265c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a2d67fd62ab5788aa286af03502265c92">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:a2d67fd62ab5788aa286af03502265c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a2d67fd62ab5788aa286af03502265c92">More...</a><br /></td></tr>
<tr class="separator:a2d67fd62ab5788aa286af03502265c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53418feeabe8460aa257c937bc4995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a8c53418feeabe8460aa257c937bc4995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this SpatialInertia in another frame, modifying the original object.  <a href="#a8c53418feeabe8460aa257c937bc4995">More...</a><br /></td></tr>
<tr class="separator:a8c53418feeabe8460aa257c937bc4995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb844974c0f911186c3e04eb773f55e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aeb844974c0f911186c3e04eb773f55e6">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:aeb844974c0f911186c3e04eb773f55e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#aeb844974c0f911186c3e04eb773f55e6">More...</a><br /></td></tr>
<tr class="separator:aeb844974c0f911186c3e04eb773f55e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9cd5ab38ea1844960431eb55799fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a9c9cd5ab38ea1844960431eb55799fa9">shift</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;S) const</td></tr>
<tr class="memdesc:a9c9cd5ab38ea1844960431eb55799fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one except the origin ("taken about" point) has changed from OF to OF+S.  <a href="#a9c9cd5ab38ea1844960431eb55799fa9">More...</a><br /></td></tr>
<tr class="separator:a9c9cd5ab38ea1844960431eb55799fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c47be818f2ff9a2e99317bf70dc6899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899">shiftInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;S)</td></tr>
<tr class="memdesc:a8c47be818f2ff9a2e99317bf70dc6899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change origin from OF to OF+S, modifying the original object in place.  <a href="#a8c47be818f2ff9a2e99317bf70dc6899">More...</a><br /></td></tr>
<tr class="separator:a8c47be818f2ff9a2e99317bf70dc6899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a37e224a46f3a19c06696309c83a4ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a7a37e224a46f3a19c06696309c83a4ab">transform</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:a7a37e224a46f3a19c06696309c83a4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new SpatialInertia object which is the same as this one but measured about and expressed in a new frame.  <a href="#a7a37e224a46f3a19c06696309c83a4ab">More...</a><br /></td></tr>
<tr class="separator:a7a37e224a46f3a19c06696309c83a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6e29d78b92ae6d555101be9c1a2449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a9b6e29d78b92ae6d555101be9c1a2449">transform</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:a9b6e29d78b92ae6d555101be9c1a2449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform using an inverse transform to avoid having to convert it.  <a href="#a9b6e29d78b92ae6d555101be9c1a2449">More...</a><br /></td></tr>
<tr class="separator:a9b6e29d78b92ae6d555101be9c1a2449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ed68773d8508b66b575860a6b8c7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1">transformInPlace</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_FB)</td></tr>
<tr class="memdesc:a70ed68773d8508b66b575860a6b8c7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this SpatialInertia object so that it is measured about and expressed in a new frame, modifying the object in place.  <a href="#a70ed68773d8508b66b575860a6b8c7d1">More...</a><br /></td></tr>
<tr class="separator:a70ed68773d8508b66b575860a6b8c7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730a21dc374eb7f7e5b230829c34ad32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a730a21dc374eb7f7e5b230829c34ad32">transformInPlace</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X_FB)</td></tr>
<tr class="memdesc:a730a21dc374eb7f7e5b230829c34ad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform using an inverse transform to avoid having to convert it.  <a href="#a730a21dc374eb7f7e5b230829c34ad32">More...</a><br /></td></tr>
<tr class="separator:a730a21dc374eb7f7e5b230829c34ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90961f898e20493becdbd6feac4919e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html">SpatialMatP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a90961f898e20493becdbd6feac4919e2">toSpatialMat</a> () const</td></tr>
<tr class="separator:a90961f898e20493becdbd6feac4919e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa8fbbb1b76326c2960f89c3cc17256e3"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa8fbbb1b76326c2960f89c3cc17256e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#aa8fbbb1b76326c2960f89c3cc17256e3">operator+</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:aa8fbbb1b76326c2960f89c3cc17256e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two compatible spatial inertias.  <a href="#aa8fbbb1b76326c2960f89c3cc17256e3">More...</a><br /></td></tr>
<tr class="separator:aa8fbbb1b76326c2960f89c3cc17256e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bcef8b2f22a45c06652f13976e1eec"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a28bcef8b2f22a45c06652f13976e1eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SpatialInertia__.html#a28bcef8b2f22a45c06652f13976e1eec">operator-</a> (const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:a28bcef8b2f22a45c06652f13976e1eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one compatible spatial inertia from another.  <a href="#a28bcef8b2f22a45c06652f13976e1eec">More...</a><br /></td></tr>
<tr class="separator:a28bcef8b2f22a45c06652f13976e1eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::SpatialInertia_&lt; P &gt;</h3>

<p>A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body. </p>
<p>This is 10 independent quantities altogether; however, inertia is mass-scaled making it linearly dependent on the mass. Here instead we represent inertia using a unit inertia matrix, which is equivalent to the inertia this body would have if it had unit mass. Then the actual inertia is given by mass*unitInertia. In this manner the mass, center of mass location, and inertia are completely independent so can be changed separately. That means if you double the mass, you'll also double the inertia as you would expect.</p>
<p>Spatial inertia may be usefully viewed as a symmetric spatial matrix, that is, a 6x6 symmetric matrix arranged as 2x2 blocks of 3x3 matrices. Although this class represents the spatial inertia in compact form, it supports methods and operators that allow it to behave as though it were a spatial matrix (except much faster to work with). In spatial matrix form, the matrix has the following interpretation: </p><pre>
              [  m*G   m*px ]
          M = [             ]
              [ -m*px  m*I  ]
</pre><p> Here m is mass, p is the vector from the body origin to the center of mass, G is the 3x3 symmetric unit inertia (gyration) matrix, and I is a 3x3 identity matrix. "px" indicates the skew symmetric cross product matrix formed from the vector p, so -px=~px.</p>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1SpatialInertia__.html" title="A spatial inertia contains the mass, center of mass point, and inertia matrix for a rigid body...">SpatialInertia_</a>&lt;P&gt;:</p><ul>
<li><a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#a9d341aa61d4a6e53db1e610ac22e39b5">fSpatialInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#a014e74e4b8e0c5775715942ad5086dea">dSpatialInertia</a> for double precision </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5a18e7fd09141c51fbaa54258117ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a18e7fd09141c51fbaa54258117ccdb">&#9670;&nbsp;</a></span>SpatialInertia_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor fills everything with NaN, even in Release mode. </p>

</div>
</div>
<a id="ab5b284bdee64fb8b30f434bccb8b718f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b284bdee64fb8b30f434bccb8b718f">&#9670;&nbsp;</a></span>SpatialInertia_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td>
          <td class="paramname"><em>gyration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6c076c62aa1294911c7ff7752394c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c076c62aa1294911c7ff7752394c86">&#9670;&nbsp;</a></span>setMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::setMass </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>mass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b055dd19ea4987cdf9a88810543a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b055dd19ea4987cdf9a88810543a58">&#9670;&nbsp;</a></span>setMassCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::setMassCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a147ff1b0fe566a4b8c65988d41171315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147ff1b0fe566a4b8c65988d41171315">&#9670;&nbsp;</a></span>setUnitInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a> &amp;&#160;</td>
          <td class="paramname"><em>gyration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f88ea906eed408885a25363a5af0602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f88ea906eed408885a25363a5af0602">&#9670;&nbsp;</a></span>getMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::getMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d3510e7bdd80b6057574a0c697b9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d3510e7bdd80b6057574a0c697b9d7">&#9670;&nbsp;</a></span>getMassCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::getMassCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82484860b62bda56d36741169189fe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82484860b62bda56d36741169189fe30">&#9670;&nbsp;</a></span>getUnitInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertiaP</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::getUnitInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09d2b050c52ba530001cb5ed2e10bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d2b050c52ba530001cb5ed2e10bfc1">&#9670;&nbsp;</a></span>calcMassMoment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::calcMassMoment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the first mass moment (mass-weighted COM location) from the mass and COM vector. </p>
<p>Cost is 3 inline flops. </p>

</div>
</div>
<a id="a4a9936c033332ce02ccaf47c4849f2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9936c033332ce02ccaf47c4849f2b5">&#9670;&nbsp;</a></span>calcInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">InertiaP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::calcInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the inertia matrix (second mass moment, mass-weighted gyration matrix) from the mass and unit inertia matrix. </p>
<p>Cost is 6 inline flops. </p>

</div>
</div>
<a id="a7cc7b7d2e8a3d7a17a7a6208efea9e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc7b7d2e8a3d7a17a7a6208efea9e31">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in a compatible SpatialInertia. </p>
<p>This is only valid if both SpatialInertias are expressed in the same frame and measured about the same point but there is no way for this method to check. Cost is about 40 flops. </p>

</div>
</div>
<a id="a16b3ffe93dd0a5b9a87651306f5f9137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b3ffe93dd0a5b9a87651306f5f9137">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract off a compatible SpatialInertia. </p>
<p>This is only valid if both SpatialInertias are expressed in the same frame and measured about the same point but there is no way for this method to check. Cost is about 40 flops. </p>

</div>
</div>
<a id="a1210e27aeaf4c729c0fa9f3b7504fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1210e27aeaf4c729c0fa9f3b7504fb35">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a SpatialInertia by a scalar. </p>
<p>Because we keep the mass factored out, this requires only a single multiply. </p>

</div>
</div>
<a id="a27c2d4d66bd4bbb6d843914181e93bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c2d4d66bd4bbb6d843914181e93bc4">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a SpatialInertia by a scalar. </p>
<p>Because we keep the mass factored out, this requires only a single divide. </p>

</div>
</div>
<a id="aaa9c4272162e7fa8778ce8ec3e6c4671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9c4272162e7fa8778ce8ec3e6c4671">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">SpatialVecP</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply a SpatialInertia by a SpatialVec to produce a SpatialVec result; 45 flops. </p>

</div>
</div>
<a id="a5c938294812abcbfa1875922a2a880d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c938294812abcbfa1875922a2a880d5">&#9670;&nbsp;</a></span>reexpress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one except re-expressed in another coordinate frame. </p>
<p>We consider this object to be expressed in some frame F and we're given a rotation matrix R_FB we can use to re-express in a new frame B. Cost is 72 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995" title="Re-express this SpatialInertia in another frame, modifying the original object. ">reexpressInPlace()</a> </dd></dl>

</div>
</div>
<a id="a2d67fd62ab5788aa286af03502265c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d67fd62ab5788aa286af03502265c92">&#9670;&nbsp;</a></span>reexpress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpress(Rotation) for information </dd></dl>

</div>
</div>
<a id="a8c53418feeabe8460aa257c937bc4995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c53418feeabe8460aa257c937bc4995">&#9670;&nbsp;</a></span>reexpressInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this SpatialInertia in another frame, modifying the original object. </p>
<p>We return a reference to the object so that you can chain this operation in the manner of assignment operators. Cost is 72 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a5c938294812abcbfa1875922a2a880d5" title="Return a new SpatialInertia object which is the same as this one except re-expressed in another coord...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a id="aeb844974c0f911186c3e04eb773f55e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb844974c0f911186c3e04eb773f55e6">&#9670;&nbsp;</a></span>reexpressInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

</div>
</div>
<a id="a9c9cd5ab38ea1844960431eb55799fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9cd5ab38ea1844960431eb55799fa9">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one except the origin ("taken about" point) has changed from OF to OF+S. </p>
<p>Cost is 37 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899" title="Change origin from OF to OF+S, modifying the original object in place. ">shiftInPlace()</a> </dd></dl>

</div>
</div>
<a id="a8c47be818f2ff9a2e99317bf70dc6899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c47be818f2ff9a2e99317bf70dc6899">&#9670;&nbsp;</a></span>shiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::shiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change origin from OF to OF+S, modifying the original object in place. </p>
<p>Returns a reference to the modified object so that you can chain this operation in the manner of assignment operators. Cost is 37 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a9c9cd5ab38ea1844960431eb55799fa9" title="Return a new SpatialInertia object which is the same as this one except the origin (&quot;taken about&quot; poi...">shift()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a id="a7a37e224a46f3a19c06696309c83a4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a37e224a46f3a19c06696309c83a4ab">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new SpatialInertia object which is the same as this one but measured about and expressed in a new frame. </p>
<p>We consider the current spatial inertia M to be measured (implicitly) in some frame F, that is, we have M=M_OF_F. We want M_OB_B for some new frame B, given the transform X_FB giving the location and orientation of B in F. This combines the <a class="el" href="classSimTK_1_1SpatialInertia__.html#a5c938294812abcbfa1875922a2a880d5" title="Return a new SpatialInertia object which is the same as this one except re-expressed in another coord...">reexpress()</a> and <a class="el" href="classSimTK_1_1SpatialInertia__.html#a9c9cd5ab38ea1844960431eb55799fa9" title="Return a new SpatialInertia object which is the same as this one except the origin (&quot;taken about&quot; poi...">shift()</a> operations available separately. Cost is 109 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a70ed68773d8508b66b575860a6b8c7d1" title="Transform this SpatialInertia object so that it is measured about and expressed in a new frame...">transformInPlace()</a> </dd></dl>

</div>
</div>
<a id="a9b6e29d78b92ae6d555101be9c1a2449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6e29d78b92ae6d555101be9c1a2449">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform using an inverse transform to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>transform(Transform) for information </dd></dl>

</div>
</div>
<a id="a70ed68773d8508b66b575860a6b8c7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ed68773d8508b66b575860a6b8c7d1">&#9670;&nbsp;</a></span>transformInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::transformInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform this SpatialInertia object so that it is measured about and expressed in a new frame, modifying the object in place. </p>
<p>We consider the current spatial inertia M to be measured (implicitly) in some frame F, that is, we have M=M_OF_F. We want to change it to M_OB_B for some new frame B, given the transform X_FB giving the location and orientation of B in F. This combines the <a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c53418feeabe8460aa257c937bc4995" title="Re-express this SpatialInertia in another frame, modifying the original object. ">reexpressInPlace()</a> and <a class="el" href="classSimTK_1_1SpatialInertia__.html#a8c47be818f2ff9a2e99317bf70dc6899" title="Change origin from OF to OF+S, modifying the original object in place. ">shiftInPlace()</a> operations available separately. Returns a reference to the modified object so that you can chain this operation in the manner of assignment operators. Cost is 109 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SpatialInertia__.html#a7a37e224a46f3a19c06696309c83a4ab" title="Return a new SpatialInertia object which is the same as this one but measured about and expressed in ...">transform()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a id="a730a21dc374eb7f7e5b230829c34ad32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730a21dc374eb7f7e5b230829c34ad32">&#9670;&nbsp;</a></span>transformInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&amp; <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::transformInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform using an inverse transform to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>transformInPlace(Transform) for information </dd></dl>

</div>
</div>
<a id="a90961f898e20493becdbd6feac4919e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90961f898e20493becdbd6feac4919e2">&#9670;&nbsp;</a></span>toSpatialMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Mat.html">SpatialMatP</a> <a class="el" href="classSimTK_1_1SpatialInertia__.html">SimTK::SpatialInertia_</a>&lt; P &gt;::toSpatialMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa8fbbb1b76326c2960f89c3cc17256e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fbbb1b76326c2960f89c3cc17256e3">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two compatible spatial inertias. </p>
<p>Cost is about 40 flops. </p>

</div>
</div>
<a id="a28bcef8b2f22a45c06652f13976e1eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bcef8b2f22a45c06652f13976e1eec">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract one compatible spatial inertia from another. </p>
<p>Cost is about 40 flops. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1SpatialInertia__.html">SpatialInertia_</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:18 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
