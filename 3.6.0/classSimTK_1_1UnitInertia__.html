<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::UnitInertia_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1UnitInertia__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSimTK_1_1UnitInertia__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::UnitInertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass.  
 <a href="classSimTK_1_1UnitInertia__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::UnitInertia_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1UnitInertia__.png" usemap="#SimTK::UnitInertia_5F_3C_20P_20_3E_map" alt=""/>
  <map id="SimTK::UnitInertia_5F_3C_20P_20_3E_map" name="SimTK::UnitInertia_5F_3C_20P_20_3E_map">
<area href="classSimTK_1_1Inertia__.html" title="The physical meaning of an inertia is the distribution of a rigid body&#39;s mass about a particular poin..." alt="SimTK::Inertia_&lt; P &gt;" shape="rect" coords="0,0,148,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ae99be8ef0c02a608415ac09cd4c08d9e">UnitInertia_</a> ()</td></tr>
<tr class="memdesc:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="#ae99be8ef0c02a608415ac09cd4c08d9e">More...</a><br /></td></tr>
<tr class="separator:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387d94e0b21d63c31abee6e38d13a3c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a387d94e0b21d63c31abee6e38d13a3c2">UnitInertia_</a> (const RealP &amp;moment)</td></tr>
<tr class="memdesc:a387d94e0b21d63c31abee6e38d13a3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix with identical diagonal elements.  <a href="#a387d94e0b21d63c31abee6e38d13a3c2">More...</a><br /></td></tr>
<tr class="separator:a387d94e0b21d63c31abee6e38d13a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428d474987b57e275010e899df64b634"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a428d474987b57e275010e899df64b634">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a428d474987b57e275010e899df64b634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="#a428d474987b57e275010e899df64b634">More...</a><br /></td></tr>
<tr class="separator:a428d474987b57e275010e899df64b634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acece1584634f71dc9d42338275358438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#acece1584634f71dc9d42338275358438">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:acece1584634f71dc9d42338275358438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix (only non-zero on diagonal).  <a href="#acece1584634f71dc9d42338275358438">More...</a><br /></td></tr>
<tr class="separator:acece1584634f71dc9d42338275358438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0c1914d9c3632de7777d1e14ccb24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af3a0c1914d9c3632de7777d1e14ccb24">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:af3a0c1914d9c3632de7777d1e14ccb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general unit inertia matrix.  <a href="#af3a0c1914d9c3632de7777d1e14ccb24">More...</a><br /></td></tr>
<tr class="separator:af3a0c1914d9c3632de7777d1e14ccb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e06c431d9332364cbd7a32055a452b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a2e06c431d9332364cbd7a32055a452b4">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a2e06c431d9332364cbd7a32055a452b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a symmetric 3x3 matrix.  <a href="#a2e06c431d9332364cbd7a32055a452b4">More...</a><br /></td></tr>
<tr class="separator:a2e06c431d9332364cbd7a32055a452b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd367dbd9f823d671489dca9d7f8a37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#adbd367dbd9f823d671489dca9d7f8a37">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:adbd367dbd9f823d671489dca9d7f8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a 3x3 symmetric matrix.  <a href="#adbd367dbd9f823d671489dca9d7f8a37">More...</a><br /></td></tr>
<tr class="separator:adbd367dbd9f823d671489dca9d7f8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a355a7e10746a3c18683b501a60e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a917a355a7e10746a3c18683b501a60e2">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a917a355a7e10746a3c18683b501a60e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia matrix from an Inertia matrix.  <a href="#a917a355a7e10746a3c18683b501a60e2">More...</a><br /></td></tr>
<tr class="separator:a917a355a7e10746a3c18683b501a60e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965913951efebcc88457a3fb2309e44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:a965913951efebcc88457a3fb2309e44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal).  <a href="#a965913951efebcc88457a3fb2309e44d">More...</a><br /></td></tr>
<tr class="separator:a965913951efebcc88457a3fb2309e44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941ff2a084bb33e57b81bb78f6792d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a941ff2a084bb33e57b81bb78f6792d8b">setUnitInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a941ff2a084bb33e57b81bb78f6792d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="#a941ff2a084bb33e57b81bb78f6792d8b">More...</a><br /></td></tr>
<tr class="separator:a941ff2a084bb33e57b81bb78f6792d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519b525445b103c7b97bec214c28788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af519b525445b103c7b97bec214c28788">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:af519b525445b103c7b97bec214c28788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this UnitInertia to a general matrix.  <a href="#af519b525445b103c7b97bec214c28788">More...</a><br /></td></tr>
<tr class="separator:af519b525445b103c7b97bec214c28788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35c30a8dcc69f3018cfd1577b16e58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af35c30a8dcc69f3018cfd1577b16e58c">shiftToCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF) const</td></tr>
<tr class="memdesc:af35c30a8dcc69f3018cfd1577b16e58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF.  <a href="#af35c30a8dcc69f3018cfd1577b16e58c">More...</a><br /></td></tr>
<tr class="separator:af35c30a8dcc69f3018cfd1577b16e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed">shiftToCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF)</td></tr>
<tr class="memdesc:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF.  <a href="#a86344e7cc8a70d606ba5a8c16511d4ed">More...</a><br /></td></tr>
<tr class="separator:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82798158796f6121bd121bee828c1529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a82798158796f6121bd121bee828c1529">shiftFromCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p) const</td></tr>
<tr class="memdesc:a82798158796f6121bd121bee828c1529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid.  <a href="#a82798158796f6121bd121bee828c1529">More...</a><br /></td></tr>
<tr class="separator:a82798158796f6121bd121bee828c1529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8">shiftFromCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr class="memdesc:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid.  <a href="#a9e4d4d72a9d1890c1f6a45067d5c88c8">More...</a><br /></td></tr>
<tr class="separator:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5596050b7d5c795826426a39c177b7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ae5596050b7d5c795826426a39c177b7b">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:ae5596050b7d5c795826426a39c177b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="#ae5596050b7d5c795826426a39c177b7b">More...</a><br /></td></tr>
<tr class="separator:ae5596050b7d5c795826426a39c177b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c69d19e18eea9243f9e7c49d43fc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a97c69d19e18eea9243f9e7c49d43fc9f">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:a97c69d19e18eea9243f9e7c49d43fc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a97c69d19e18eea9243f9e7c49d43fc9f">More...</a><br /></td></tr>
<tr class="separator:a97c69d19e18eea9243f9e7c49d43fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b820a2338b949af9816a70343940a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4b820a2338b949af9816a70343940a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#ae5596050b7d5c795826426a39c177b7b" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="#a4b820a2338b949af9816a70343940a07">More...</a><br /></td></tr>
<tr class="separator:a4b820a2338b949af9816a70343940a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b740b16c447193af134d6dcfc8a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9f0b740b16c447193af134d6dcfc8a29">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a9f0b740b16c447193af134d6dcfc8a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a9f0b740b16c447193af134d6dcfc8a29">More...</a><br /></td></tr>
<tr class="separator:a9f0b740b16c447193af134d6dcfc8a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b680c393d367cb675d71a4a96dc46e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af5b680c393d367cb675d71a4a96dc46e">operator const SymMat33P &amp;</a> () const</td></tr>
<tr class="memdesc:af5b680c393d367cb675d71a4a96dc46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const SymMat33.  <a href="#af5b680c393d367cb675d71a4a96dc46e">More...</a><br /></td></tr>
<tr class="separator:af5b680c393d367cb675d71a4a96dc46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8798d678c6ee98dee65a9554e4cf695d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a8798d678c6ee98dee65a9554e4cf695d">asUnitInertia</a> () const</td></tr>
<tr class="memdesc:a8798d678c6ee98dee65a9554e4cf695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast this UnitInertia matrix as a unit inertia matrix.  <a href="#a8798d678c6ee98dee65a9554e4cf695d">More...</a><br /></td></tr>
<tr class="separator:a8798d678c6ee98dee65a9554e4cf695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd0500e52f995dd5f11639a073969d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4fbd0500e52f995dd5f11639a073969d">setFromUnitInertia</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a4fbd0500e52f995dd5f11639a073969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from a unit inertia matrix.  <a href="#a4fbd0500e52f995dd5f11639a073969d">More...</a><br /></td></tr>
<tr class="separator:a4fbd0500e52f995dd5f11639a073969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa2b329d1fc62a9c7b952d1b3c88dff71">Inertia_</a> ()</td></tr>
<tr class="memdesc:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="classSimTK_1_1Inertia__.html#aa2b329d1fc62a9c7b952d1b3c88dff71">More...</a><br /></td></tr>
<tr class="separator:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c475dfffbac3e539aac075836b034a2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a9c475dfffbac3e539aac075836b034a2">Inertia_</a> (const P &amp;moment)</td></tr>
<tr class="memdesc:a9c475dfffbac3e539aac075836b034a2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix with identical diagonal elements, like a sphere where moment=2/5 m r^2, or a cube where moment=1/6 m s^2, with m the total mass, r the sphere's radius and s the length of a side of the cube.  <a href="classSimTK_1_1Inertia__.html#a9c475dfffbac3e539aac075836b034a2">More...</a><br /></td></tr>
<tr class="separator:a9c475dfffbac3e539aac075836b034a2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6a198ee753c0822eb9498de53a748f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a3c6a198ee753c0822eb9498de53a748f">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;p, const P &amp;mass)</td></tr>
<tr class="memdesc:a3c6a198ee753c0822eb9498de53a748f inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point mass at a given location, measured from the origin OF of the implicit frame F, and expressed in F.  <a href="classSimTK_1_1Inertia__.html#a3c6a198ee753c0822eb9498de53a748f">More...</a><br /></td></tr>
<tr class="separator:a3c6a198ee753c0822eb9498de53a748f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ba3eeff85eb274d1d567a7618f577 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a281ba3eeff85eb274d1d567a7618f577">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;(0))</td></tr>
<tr class="memdesc:a281ba3eeff85eb274d1d567a7618f577 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="classSimTK_1_1Inertia__.html#a281ba3eeff85eb274d1d567a7618f577">More...</a><br /></td></tr>
<tr class="separator:a281ba3eeff85eb274d1d567a7618f577 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c91884d263100ff2652e11b6b666f7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a79c91884d263100ff2652e11b6b666f7">Inertia_</a> (const P &amp;xx, const P &amp;yy, const P &amp;zz)</td></tr>
<tr class="memdesc:a79c91884d263100ff2652e11b6b666f7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix (only non-zero on diagonal).  <a href="classSimTK_1_1Inertia__.html#a79c91884d263100ff2652e11b6b666f7">More...</a><br /></td></tr>
<tr class="separator:a79c91884d263100ff2652e11b6b666f7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae151a53568330e59f578206b0d7968c8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae151a53568330e59f578206b0d7968c8">Inertia_</a> (const P &amp;xx, const P &amp;yy, const P &amp;zz, const P &amp;xy, const P &amp;xz, const P &amp;yz)</td></tr>
<tr class="memdesc:ae151a53568330e59f578206b0d7968c8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general inertia matrix.  <a href="classSimTK_1_1Inertia__.html#ae151a53568330e59f578206b0d7968c8">More...</a><br /></td></tr>
<tr class="separator:ae151a53568330e59f578206b0d7968c8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf45b6c6a4626427d128b44ea810dfe inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#abdf45b6c6a4626427d128b44ea810dfe">Inertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; 3, P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:abdf45b6c6a4626427d128b44ea810dfe inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia from a symmetric 3x3 matrix.  <a href="classSimTK_1_1Inertia__.html#abdf45b6c6a4626427d128b44ea810dfe">More...</a><br /></td></tr>
<tr class="separator:abdf45b6c6a4626427d128b44ea810dfe inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031bb2ef74998bd4362eb2e5ae61aeb inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2031bb2ef74998bd4362eb2e5ae61aeb">Inertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 3, P &gt; &amp;m)</td></tr>
<tr class="memdesc:a2031bb2ef74998bd4362eb2e5ae61aeb inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia matrix from a 3x3 symmetric matrix.  <a href="classSimTK_1_1Inertia__.html#a2031bb2ef74998bd4362eb2e5ae61aeb">More...</a><br /></td></tr>
<tr class="separator:a2031bb2ef74998bd4362eb2e5ae61aeb inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4cc0a3753e402ba65d40a4f87a085b inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aac4cc0a3753e402ba65d40a4f87a085b">setInertia</a> (const P &amp;xx, const P &amp;yy, const P &amp;zz)</td></tr>
<tr class="memdesc:aac4cc0a3753e402ba65d40a4f87a085b inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an inertia matrix to have only principal moments (that is, it will be diagonal).  <a href="classSimTK_1_1Inertia__.html#aac4cc0a3753e402ba65d40a4f87a085b">More...</a><br /></td></tr>
<tr class="separator:aac4cc0a3753e402ba65d40a4f87a085b inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd6969c69a6922227f89a7755e9f1ca inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5fd6969c69a6922227f89a7755e9f1ca">setInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;(0))</td></tr>
<tr class="memdesc:a5fd6969c69a6922227f89a7755e9f1ca inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="classSimTK_1_1Inertia__.html#a5fd6969c69a6922227f89a7755e9f1ca">More...</a><br /></td></tr>
<tr class="separator:a5fd6969c69a6922227f89a7755e9f1ca inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950971fc1c40dd7fbd6eda395af5f292 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a950971fc1c40dd7fbd6eda395af5f292">setInertia</a> (const P &amp;xx, const P &amp;yy, const P &amp;zz, const P &amp;xy, const P &amp;xz, const P &amp;yz)</td></tr>
<tr class="memdesc:a950971fc1c40dd7fbd6eda395af5f292 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this Inertia to a general matrix.  <a href="classSimTK_1_1Inertia__.html#a950971fc1c40dd7fbd6eda395af5f292">More...</a><br /></td></tr>
<tr class="separator:a950971fc1c40dd7fbd6eda395af5f292 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a232f2d580d93155eac72b30e1d5d4ea5">operator+=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in another inertia matrix.  <a href="classSimTK_1_1Inertia__.html#a232f2d580d93155eac72b30e1d5d4ea5">More...</a><br /></td></tr>
<tr class="separator:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af761fb58e427c6bbc9c1a1abd3d29a4e">operator-=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off another inertia matrix.  <a href="classSimTK_1_1Inertia__.html#af761fb58e427c6bbc9c1a1abd3d29a4e">More...</a><br /></td></tr>
<tr class="separator:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2b50d1bec66484957bb0ebe1be4d1736">operator*=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this inertia matrix by a scalar. Cost is 6 flops.  <a href="classSimTK_1_1Inertia__.html#a2b50d1bec66484957bb0ebe1be4d1736">More...</a><br /></td></tr>
<tr class="separator:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2d583c80cb337680c60b88dc455e8eed">operator/=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide this inertia matrix by a scalar.  <a href="classSimTK_1_1Inertia__.html#a2d583c80cb337680c60b88dc455e8eed">More...</a><br /></td></tr>
<tr class="separator:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af717f5cf370f6069daa3862cb0de85f5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af717f5cf370f6069daa3862cb0de85f5">shiftToMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;CF, const P &amp;mass) const</td></tr>
<tr class="memdesc:af717f5cf370f6069daa3862cb0de85f5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="classSimTK_1_1Inertia__.html#af717f5cf370f6069daa3862cb0de85f5">More...</a><br /></td></tr>
<tr class="separator:af717f5cf370f6069daa3862cb0de85f5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0213bda08863da98a50ccab3752b6cf0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0213bda08863da98a50ccab3752b6cf0">shiftToMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;CF, const P &amp;mass)</td></tr>
<tr class="memdesc:a0213bda08863da98a50ccab3752b6cf0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="classSimTK_1_1Inertia__.html#a0213bda08863da98a50ccab3752b6cf0">More...</a><br /></td></tr>
<tr class="separator:a0213bda08863da98a50ccab3752b6cf0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578901fe23c74623af457940b52ecb24 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a578901fe23c74623af457940b52ecb24">shiftFromMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;p, const P &amp;mass) const</td></tr>
<tr class="memdesc:a578901fe23c74623af457940b52ecb24 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="classSimTK_1_1Inertia__.html#a578901fe23c74623af457940b52ecb24">More...</a><br /></td></tr>
<tr class="separator:a578901fe23c74623af457940b52ecb24 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f2beebce31a6ba59e0a1a4ec2b0ec8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51f2beebce31a6ba59e0a1a4ec2b0ec8">shiftFromMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;p, const P &amp;mass)</td></tr>
<tr class="memdesc:a51f2beebce31a6ba59e0a1a4ec2b0ec8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="classSimTK_1_1Inertia__.html#a51f2beebce31a6ba59e0a1a4ec2b0ec8">More...</a><br /></td></tr>
<tr class="separator:a51f2beebce31a6ba59e0a1a4ec2b0ec8 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa491b359d72fb071f9ca514b08663d1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aaa491b359d72fb071f9ca514b08663d1">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:aaa491b359d72fb071f9ca514b08663d1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="classSimTK_1_1Inertia__.html#aaa491b359d72fb071f9ca514b08663d1">More...</a><br /></td></tr>
<tr class="separator:aaa491b359d72fb071f9ca514b08663d1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc612846d06b4f756de6d23623c88d6 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aabc612846d06b4f756de6d23623c88d6">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const</td></tr>
<tr class="memdesc:aabc612846d06b4f756de6d23623c88d6 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="classSimTK_1_1Inertia__.html#aabc612846d06b4f756de6d23623c88d6">More...</a><br /></td></tr>
<tr class="separator:aabc612846d06b4f756de6d23623c88d6 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1Inertia__.html#aaa491b359d72fb071f9ca514b08663d1" title="Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254">More...</a><br /></td></tr>
<tr class="separator:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4021fe4887710d1285fc6d1c5bd728aa">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress in place using an inverse rotation to avoid having to convert it.  <a href="classSimTK_1_1Inertia__.html#a4021fe4887710d1285fc6d1c5bd728aa">More...</a><br /></td></tr>
<tr class="separator:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d11dc0e27979346303fa6b89c26ddc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">P&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ac7d11dc0e27979346303fa6b89c26ddc">trace</a> () const</td></tr>
<tr class="separator:ac7d11dc0e27979346303fa6b89c26ddc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab794450446512558ff2e0c9ea3cf01fa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab794450446512558ff2e0c9ea3cf01fa">operator const SymMat&lt; 3, P &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:ab794450446512558ff2e0c9ea3cf01fa inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to a const SymMat33.  <a href="classSimTK_1_1Inertia__.html#ab794450446512558ff2e0c9ea3cf01fa">More...</a><br /></td></tr>
<tr class="separator:ab794450446512558ff2e0c9ea3cf01fa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beafcb65b0e5817d6cbb3c0c83cd786 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8beafcb65b0e5817d6cbb3c0c83cd786">asSymMat33</a> () const</td></tr>
<tr class="memdesc:a8beafcb65b0e5817d6cbb3c0c83cd786 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the underlying symmetric matrix type.  <a href="classSimTK_1_1Inertia__.html#a8beafcb65b0e5817d6cbb3c0c83cd786">More...</a><br /></td></tr>
<tr class="separator:a8beafcb65b0e5817d6cbb3c0c83cd786 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19347ebb46be0e6b5e4fd3e5bc71400 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ac19347ebb46be0e6b5e4fd3e5bc71400">toMat33</a> () const</td></tr>
<tr class="memdesc:ac19347ebb46be0e6b5e4fd3e5bc71400 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the internal packed representation into a full 3x3 symmetric matrix with all elements set.  <a href="classSimTK_1_1Inertia__.html#ac19347ebb46be0e6b5e4fd3e5bc71400">More...</a><br /></td></tr>
<tr class="separator:ac19347ebb46be0e6b5e4fd3e5bc71400 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bef252dd6ab82a1bb8c80a3c031727 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad5bef252dd6ab82a1bb8c80a3c031727">getMoments</a> () const</td></tr>
<tr class="memdesc:ad5bef252dd6ab82a1bb8c80a3c031727 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3 ordered xx, yy, zz.  <a href="classSimTK_1_1Inertia__.html#ad5bef252dd6ab82a1bb8c80a3c031727">More...</a><br /></td></tr>
<tr class="separator:ad5bef252dd6ab82a1bb8c80a3c031727 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f4ec618b2088f3258348d03ba155b0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa5f4ec618b2088f3258348d03ba155b0">getProducts</a> () const</td></tr>
<tr class="memdesc:aa5f4ec618b2088f3258348d03ba155b0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia products (off-diagonals of the Inertia matrix) as a Vec3 with elements ordered xy, xz, yz.  <a href="classSimTK_1_1Inertia__.html#aa5f4ec618b2088f3258348d03ba155b0">More...</a><br /></td></tr>
<tr class="separator:aa5f4ec618b2088f3258348d03ba155b0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bafd0fccafae6c15a8c494cc82454f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ac2bafd0fccafae6c15a8c494cc82454f">isNaN</a> () const</td></tr>
<tr class="separator:ac2bafd0fccafae6c15a8c494cc82454f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae43d24df270dc7dfc9c7c9a4e1aa470 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aae43d24df270dc7dfc9c7c9a4e1aa470">isInf</a> () const</td></tr>
<tr class="separator:aae43d24df270dc7dfc9c7c9a4e1aa470 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aab665ecdb011d4e6dc2e350ec3b0e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a84aab665ecdb011d4e6dc2e350ec3b0e">isFinite</a> () const</td></tr>
<tr class="separator:a84aab665ecdb011d4e6dc2e350ec3b0e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750596ea5a0620fcf0332d1909b10c3a inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a750596ea5a0620fcf0332d1909b10c3a">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other) const</td></tr>
<tr class="memdesc:a750596ea5a0620fcf0332d1909b10c3a inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a default numerical tolerance.  <a href="classSimTK_1_1Inertia__.html#a750596ea5a0620fcf0332d1909b10c3a">More...</a><br /></td></tr>
<tr class="separator:a750596ea5a0620fcf0332d1909b10c3a inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57be2b10046bf1d018a643a6d54f24d0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a57be2b10046bf1d018a643a6d54f24d0">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other, double tol) const</td></tr>
<tr class="memdesc:a57be2b10046bf1d018a643a6d54f24d0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a specified numerical tolerance.  <a href="classSimTK_1_1Inertia__.html#a57be2b10046bf1d018a643a6d54f24d0">More...</a><br /></td></tr>
<tr class="separator:a57be2b10046bf1d018a643a6d54f24d0 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0747db2089594f1958363401e7a75a3e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a0747db2089594f1958363401e7a75a3e">isValidUnitInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a0747db2089594f1958363401e7a75a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid UnitInertia matrix.  <a href="#a0747db2089594f1958363401e7a75a3e">More...</a><br /></td></tr>
<tr class="separator:a0747db2089594f1958363401e7a75a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UnitInertia matrix factories</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are UnitInertia matrix factories for some common 3D solids.</p>
<p>Each defines its own frame aligned (when possible) with principal moments. Each has unit mass and its center of mass located at the origin (usually). Use this with <a class="el" href="classSimTK_1_1UnitInertia__.html#a82798158796f6121bd121bee828c1529" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> to move it somewhere else, and with <a class="el" href="classSimTK_1_1UnitInertia__.html#ae5596050b7d5c795826426a39c177b7b" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> to express the UnitInertia matrix in another frame. </p>
</div></td></tr>
<tr class="memitem:a1e27445e87e048350c0733f282a14d4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a1e27445e87e048350c0733f282a14d4a">pointMassAtOrigin</a> ()</td></tr>
<tr class="memdesc:a1e27445e87e048350c0733f282a14d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point located at the origin &ndash; that is, an all-zero matrix.  <a href="#a1e27445e87e048350c0733f282a14d4a">More...</a><br /></td></tr>
<tr class="separator:a1e27445e87e048350c0733f282a14d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ad12590783e2b1cc3dc3715f6c4c8f3ef">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr class="memdesc:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix).  <a href="#ad12590783e2b1cc3dc3715f6c4c8f3ef">More...</a><br /></td></tr>
<tr class="separator:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6dff2244b2e884fc5ae7747b4489c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aea6dff2244b2e884fc5ae7747b4489c2">sphere</a> (const RealP &amp;r)</td></tr>
<tr class="memdesc:aea6dff2244b2e884fc5ae7747b4489c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="#aea6dff2244b2e884fc5ae7747b4489c2">More...</a><br /></td></tr>
<tr class="separator:aea6dff2244b2e884fc5ae7747b4489c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aae6b90b2feeb28272a15ac0ee431b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a22aae6b90b2feeb28272a15ac0ee431b">cylinderAlongZ</a> (const RealP &amp;r, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a22aae6b90b2feeb28272a15ac0ee431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="#a22aae6b90b2feeb28272a15ac0ee431b">More...</a><br /></td></tr>
<tr class="separator:a22aae6b90b2feeb28272a15ac0ee431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b955d92ee92f053e4c90301b2537e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a433b955d92ee92f053e4c90301b2537e">cylinderAlongY</a> (const RealP &amp;r, const RealP &amp;hy)</td></tr>
<tr class="memdesc:a433b955d92ee92f053e4c90301b2537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="#a433b955d92ee92f053e4c90301b2537e">More...</a><br /></td></tr>
<tr class="separator:a433b955d92ee92f053e4c90301b2537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3c0caf76077405e5eca28662214dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a89f3c0caf76077405e5eca28662214dc">cylinderAlongX</a> (const RealP &amp;r, const RealP &amp;hx)</td></tr>
<tr class="memdesc:a89f3c0caf76077405e5eca28662214dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="#a89f3c0caf76077405e5eca28662214dc">More...</a><br /></td></tr>
<tr class="separator:a89f3c0caf76077405e5eca28662214dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b">brick</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="#aa765bcf7ca1430d4bb0ee35964b6a87b">More...</a><br /></td></tr>
<tr class="separator:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6727b53f8dc2470095ead9162f74df1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a6727b53f8dc2470095ead9162f74df1e">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a6727b53f8dc2470095ead9162f74df1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths.  <a href="#a6727b53f8dc2470095ead9162f74df1e">More...</a><br /></td></tr>
<tr class="separator:a6727b53f8dc2470095ead9162f74df1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4918161a3aa2b765b10834420f2006"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006">ellipsoid</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:afb4918161a3aa2b765b10834420f2006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="#afb4918161a3aa2b765b10834420f2006">More...</a><br /></td></tr>
<tr class="separator:afb4918161a3aa2b765b10834420f2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617357823ece8ff6c7f03c6cb34ab31e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a617357823ece8ff6c7f03c6cb34ab31e">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a617357823ece8ff6c7f03c6cb34ab31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="#a617357823ece8ff6c7f03c6cb34ab31e">More...</a><br /></td></tr>
<tr class="separator:a617357823ece8ff6c7f03c6cb34ab31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:aaeb88592557341222f2514a613f01966 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aaeb88592557341222f2514a613f01966">isValidInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; 3, P &gt; &amp;m)</td></tr>
<tr class="memdesc:aaeb88592557341222f2514a613f01966 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid Inertia matrix.  <a href="classSimTK_1_1Inertia__.html#aaeb88592557341222f2514a613f01966">More...</a><br /></td></tr>
<tr class="separator:aaeb88592557341222f2514a613f01966 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#adaf11cafc9975fd5e6072f12548a467f">pointMassAtOrigin</a> ()</td></tr>
<tr class="memdesc:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point located at the origin &ndash; that is, an all-zero matrix.  <a href="classSimTK_1_1Inertia__.html#adaf11cafc9975fd5e6072f12548a467f">More...</a><br /></td></tr>
<tr class="separator:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8278c8535d3371ea505db55ba14050e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae8278c8535d3371ea505db55ba14050e">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;p, const P &amp;m)</td></tr>
<tr class="memdesc:ae8278c8535d3371ea505db55ba14050e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point of a given mass, located at a given location measured from the origin of the implicit F frame.  <a href="classSimTK_1_1Inertia__.html#ae8278c8535d3371ea505db55ba14050e">More...</a><br /></td></tr>
<tr class="separator:ae8278c8535d3371ea505db55ba14050e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb60f7e37aa0765dfbe36d5b09bf3ed7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aeb60f7e37aa0765dfbe36d5b09bf3ed7">sphere</a> (const P &amp;r)</td></tr>
<tr class="memdesc:aeb60f7e37aa0765dfbe36d5b09bf3ed7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="classSimTK_1_1Inertia__.html#aeb60f7e37aa0765dfbe36d5b09bf3ed7">More...</a><br /></td></tr>
<tr class="separator:aeb60f7e37aa0765dfbe36d5b09bf3ed7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3f62226e5e5e2138fc8e95921982a7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aad3f62226e5e5e2138fc8e95921982a7">cylinderAlongZ</a> (const P &amp;r, const P &amp;hz)</td></tr>
<tr class="memdesc:aad3f62226e5e5e2138fc8e95921982a7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="classSimTK_1_1Inertia__.html#aad3f62226e5e5e2138fc8e95921982a7">More...</a><br /></td></tr>
<tr class="separator:aad3f62226e5e5e2138fc8e95921982a7 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcc9914f46609a930c79431e9a84cdf inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aafcc9914f46609a930c79431e9a84cdf">cylinderAlongY</a> (const P &amp;r, const P &amp;hy)</td></tr>
<tr class="memdesc:aafcc9914f46609a930c79431e9a84cdf inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="classSimTK_1_1Inertia__.html#aafcc9914f46609a930c79431e9a84cdf">More...</a><br /></td></tr>
<tr class="separator:aafcc9914f46609a930c79431e9a84cdf inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f21d83610fd162db58ba4fa108636b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae9f21d83610fd162db58ba4fa108636b">cylinderAlongX</a> (const P &amp;r, const P &amp;hx)</td></tr>
<tr class="memdesc:ae9f21d83610fd162db58ba4fa108636b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="classSimTK_1_1Inertia__.html#ae9f21d83610fd162db58ba4fa108636b">More...</a><br /></td></tr>
<tr class="separator:ae9f21d83610fd162db58ba4fa108636b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2d53761000417b3d8e21c9cfe03742 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a1c2d53761000417b3d8e21c9cfe03742">brick</a> (const P &amp;hx, const P &amp;hy, const P &amp;hz)</td></tr>
<tr class="memdesc:a1c2d53761000417b3d8e21c9cfe03742 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="classSimTK_1_1Inertia__.html#a1c2d53761000417b3d8e21c9cfe03742">More...</a><br /></td></tr>
<tr class="separator:a1c2d53761000417b3d8e21c9cfe03742 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4030ece190c4841c7ad98c95b16f0ed inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab4030ece190c4841c7ad98c95b16f0ed">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;halfLengths)</td></tr>
<tr class="memdesc:ab4030ece190c4841c7ad98c95b16f0ed inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#a1c2d53761000417b3d8e21c9cfe03742" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths.  <a href="classSimTK_1_1Inertia__.html#ab4030ece190c4841c7ad98c95b16f0ed">More...</a><br /></td></tr>
<tr class="separator:ab4030ece190c4841c7ad98c95b16f0ed inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaebc3fbe31ca9d23fc0470a8d42ce5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#abcaebc3fbe31ca9d23fc0470a8d42ce5">ellipsoid</a> (const P &amp;hx, const P &amp;hy, const P &amp;hz)</td></tr>
<tr class="memdesc:abcaebc3fbe31ca9d23fc0470a8d42ce5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="classSimTK_1_1Inertia__.html#abcaebc3fbe31ca9d23fc0470a8d42ce5">More...</a><br /></td></tr>
<tr class="separator:abcaebc3fbe31ca9d23fc0470a8d42ce5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a94172e2cb1ff439e50f454e77ca41 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae3a94172e2cb1ff439e50f454e77ca41">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;halfLengths)</td></tr>
<tr class="memdesc:ae3a94172e2cb1ff439e50f454e77ca41 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#abcaebc3fbe31ca9d23fc0470a8d42ce5" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="classSimTK_1_1Inertia__.html#ae3a94172e2cb1ff439e50f454e77ca41">More...</a><br /></td></tr>
<tr class="separator:ae3a94172e2cb1ff439e50f454e77ca41 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:a8f576fbef4eaaa46b69a4deff1f0b41a inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8f576fbef4eaaa46b69a4deff1f0b41a">getAsUnitInertia</a> () const</td></tr>
<tr class="separator:a8f576fbef4eaaa46b69a4deff1f0b41a inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542289a1b1ae02d15d2e6ca581b5f03 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2542289a1b1ae02d15d2e6ca581b5f03">updAsUnitInertia</a> ()</td></tr>
<tr class="separator:a2542289a1b1ae02d15d2e6ca581b5f03 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d66b8e7953f2b986418812271eb280a inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a1d66b8e7953f2b986418812271eb280a">errChk</a> (const char *methodName) const</td></tr>
<tr class="separator:a1d66b8e7953f2b986418812271eb280a inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:a297f09049ad42ddd28f22e06249e0815 inherit pro_attribs_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a297f09049ad42ddd28f22e06249e0815">I_OF_F</a></td></tr>
<tr class="separator:a297f09049ad42ddd28f22e06249e0815 inherit pro_attribs_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa13a2386109b73510feedacbc00dcb06">operator+</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two compatible inertia matrices, meaning they must be taken about the same point and expressed in the same frame.  <a href="classSimTK_1_1Inertia__.html#aa13a2386109b73510feedacbc00dcb06">More...</a><br /></td></tr>
<tr class="separator:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad11356749d9b854ac7c54941f8898123">operator-</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from one inertia matrix another one which is compatible, meaning that both must be taken about the same point and expressed in the same frame.  <a href="classSimTK_1_1Inertia__.html#ad11356749d9b854ac7c54941f8898123">More...</a><br /></td></tr>
<tr class="separator:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0e0178f717c4a3c324ae9e7acbe670b5">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="classSimTK_1_1Inertia__.html#a0e0178f717c4a3c324ae9e7acbe670b5">More...</a><br /></td></tr>
<tr class="separator:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a81c2f71a5c2f03e9ae1be20477721e51">operator*</a> (const P &amp;r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="classSimTK_1_1Inertia__.html#a81c2f71a5c2f03e9ae1be20477721e51">More...</a><br /></td></tr>
<tr class="separator:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4f803c5be5d23c79883c07160c1b3fff">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="classSimTK_1_1Inertia__.html#a4f803c5be5d23c79883c07160c1b3fff">More...</a><br /></td></tr>
<tr class="separator:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a11dbacbcdcafff80ec99c068987b8323">operator*</a> (int r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="classSimTK_1_1Inertia__.html#a11dbacbcdcafff80ec99c068987b8323">More...</a><br /></td></tr>
<tr class="separator:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4d2db9435adf44e235f3165f8274d58b">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar.  <a href="classSimTK_1_1Inertia__.html#a4d2db9435adf44e235f3165f8274d58b">More...</a><br /></td></tr>
<tr class="separator:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51fba91692c4dd54851b29a7ccac6317">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar provided as an int.  <a href="classSimTK_1_1Inertia__.html#a51fba91692c4dd54851b29a7ccac6317">More...</a><br /></td></tr>
<tr class="separator:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5c8ce4e99ab6b63e6786f47f4647f939">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;<a class="el" href="group__TypedNumConstants.html#ga89110fa308da931e7b5b69f62b143bd3">I</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;w)</td></tr>
<tr class="memdesc:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix I on the right by a vector w giving the vector result I*w.  <a href="classSimTK_1_1Inertia__.html#a5c8ce4e99ab6b63e6786f47f4647f939">More...</a><br /></td></tr>
<tr class="separator:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad3306602216739add773fc2b00440560">operator==</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i1, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i2)</td></tr>
<tr class="memdesc:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two inertia matrices for exact (bitwise) equality.  <a href="classSimTK_1_1Inertia__.html#ad3306602216739add773fc2b00440560">More...</a><br /></td></tr>
<tr class="separator:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8cb59637de516910c73d319d793f53db">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a human-readable representation of an inertia matrix to the indicated stream.  <a href="classSimTK_1_1Inertia__.html#a8cb59637de516910c73d319d793f53db">More...</a><br /></td></tr>
<tr class="separator:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::UnitInertia_&lt; P &gt;</h3>

<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass. </p>
<p>Functionality is limited here to those few operations which ensure unit mass; most operations on a UnitInertia matrix result in a general Inertia instead. You can use a UnitInertia object wherever an Inertia is expected but not vice versa.</p>
<p>When constructing a UnitInertia matrix, note that we cannot verify that it actually has unit mass because every legal Inertia matrix can be viewed as the UnitInertia matrix for some differently-scaled object.</p>
<p>Unit inertia matrices are sometimes called "gyration" matrices; we will often represent them with the symbol "G" to avoid confusion with general inertia matrices for which the symbol "I" (or sometimes "J") is used.</p>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a>&lt;P&gt;:</p><ul>
<li><a class="el" href="namespaceSimTK.html#af4586b331c8fbbb1f3c18d2a1a03ce92">UnitInertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#a477722ebc554f08856ea0f612b27b8c3">fUnitInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#adcce13c4ad58d5aee947072ef9cd3586">dUnitInertia</a> for double precision </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae99be8ef0c02a608415ac09cd4c08d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99be8ef0c02a608415ac09cd4c08d9e">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default is a NaN-ed out mess to avoid accidents, even in Release mode. </p>
<p>Other than this value, a <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a> should always be valid. </p>

</div>
</div>
<a id="a387d94e0b21d63c31abee6e38d13a3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387d94e0b21d63c31abee6e38d13a3c2">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>moment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal unit inertia matrix with identical diagonal elements. </p>
<p>This is the unit inertia matrix of a unit mass sphere of radius r = sqrt(5/2 * moment) centered on the origin. </p>

</div>
</div>
<a id="a428d474987b57e275010e899df64b634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428d474987b57e275010e899df64b634">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals). </p>
<p>Moments are in the order xx,yy,zz; products are xy,xz,yz. </p>

</div>
</div>
<a id="acece1584634f71dc9d42338275358438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acece1584634f71dc9d42338275358438">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal unit inertia matrix (only non-zero on diagonal). </p>

</div>
</div>
<a id="af3a0c1914d9c3632de7777d1e14ccb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a0c1914d9c3632de7777d1e14ccb24">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a general unit inertia matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. </p>

</div>
</div>
<a id="a2e06c431d9332364cbd7a32055a452b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e06c431d9332364cbd7a32055a452b4">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia from a symmetric 3x3 matrix. </p>
<p>The diagonals must be nonnegative and satisfy the triangle inequality. </p>

</div>
</div>
<a id="adbd367dbd9f823d671489dca9d7f8a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd367dbd9f823d671489dca9d7f8a37">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia from a 3x3 symmetric matrix. </p>
<p>In Debug mode we'll test that the supplied matrix is numerically close to symmetric, and that it satisfies other requirements of an inertia matrix. </p>

</div>
</div>
<a id="a917a355a7e10746a3c18683b501a60e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917a355a7e10746a3c18683b501a60e2">&#9670;&nbsp;</a></span>UnitInertia_() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia matrix from an Inertia matrix. </p>
<p>Note that there is no way to check whether this is really a unit inertia &ndash; <em>any</em> inertia matrix may be interpreted as a unit inertia for some shape. So be sure you know what you're doing before you use this constructor! </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a965913951efebcc88457a3fb2309e44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965913951efebcc88457a3fb2309e44d">&#9670;&nbsp;</a></span>setUnitInertia() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal). </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a id="a941ff2a084bb33e57b81bb78f6792d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941ff2a084bb33e57b81bb78f6792d8b">&#9670;&nbsp;</a></span>setUnitInertia() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set principal moments and optionally off-diagonal terms. </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a id="af519b525445b103c7b97bec214c28788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af519b525445b103c7b97bec214c28788">&#9670;&nbsp;</a></span>setUnitInertia() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this UnitInertia to a general matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. Behaves like an assignment statement. Will throw an error message in Debug mode if the supplied elements do not constitute a valid inertia matrix. </p>

</div>
</div>
<a id="af35c30a8dcc69f3018cfd1577b16e58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35c30a8dcc69f3018cfd1577b16e58c">&#9670;&nbsp;</a></span>shiftToCentroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftToCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia matrix G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. (17 flops) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#a82798158796f6121bd121bee828c1529" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> </dd></dl>

</div>
</div>
<a id="a86344e7cc8a70d606ba5a8c16511d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86344e7cc8a70d606ba5a8c16511d4ed">&#9670;&nbsp;</a></span>shiftToCentroidInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftToCentroidInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. A reference to the modified object is returned so that you can chain this method in the manner of assignment operators. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#af35c30a8dcc69f3018cfd1577b16e58c" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a> </dd></dl>

</div>
</div>
<a id="a82798158796f6121bd121bee828c1529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82798158796f6121bd121bee828c1529">&#9670;&nbsp;</a></span>shiftFromCentroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftFromCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid. </p>
<p>This produces a new inertia G' about the point p given by G' = G + Gp where Gp is the inertia of a fictitious point located at p, taken about CF. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#af35c30a8dcc69f3018cfd1577b16e58c" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> </dd></dl>

</div>
</div>
<a id="a9e4d4d72a9d1890c1f6a45067d5c88c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d4d72a9d1890c1f6a45067d5c88c8">&#9670;&nbsp;</a></span>shiftFromCentroidInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftFromCentroidInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid. </p>
<p>This changes G to a modified inertia G' taken about the point p, with the parallel axis theorem for inertia giving G' = G + Gp where Gp is the inertia of a fictitious, unit-mass point located at p, taken about CF. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a82798158796f6121bd121bee828c1529" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroidInPlace()</a> </dd></dl>

</div>
</div>
<a id="ae5596050b7d5c795826426a39c177b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5596050b7d5c795826426a39c177b7b">&#9670;&nbsp;</a></span>reexpress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged). </p>
<p>Call this inertia matrix G_OF_F, that is, it is taken about the origin of some frame F, and expressed in F. We want to return G_OF_B, the same unit inertia matrix, still taken about the origin of F, but expressed in the B frame, given by G_OF_B=R_BF*G_OF_F*R_FB where R_FB is the rotation matrix giving the orientation of frame B in F. This is handled here by a special method of the Rotation class which rotates a symmetric tensor at a cost of 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07" title="Re-express this unit inertia matrix in another frame, changing the object in place; see reexpress() i...">reexpressInPlace()</a> </dd></dl>

</div>
</div>
<a id="a97c69d19e18eea9243f9e7c49d43fc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c69d19e18eea9243f9e7c49d43fc9f">&#9670;&nbsp;</a></span>reexpress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpress(Rotation) for information </dd></dl>

</div>
</div>
<a id="a4b820a2338b949af9816a70343940a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b820a2338b949af9816a70343940a07">&#9670;&nbsp;</a></span>reexpressInPlace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#ae5596050b7d5c795826426a39c177b7b" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead. </p>
<p>Cost is 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#ae5596050b7d5c795826426a39c177b7b" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a id="a9f0b740b16c447193af134d6dcfc8a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0b740b16c447193af134d6dcfc8a29">&#9670;&nbsp;</a></span>reexpressInPlace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

</div>
</div>
<a id="af5b680c393d367cb675d71a4a96dc46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b680c393d367cb675d71a4a96dc46e">&#9670;&nbsp;</a></span>operator const SymMat33P &()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::operator const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to const SymMat33. </p>

</div>
</div>
<a id="a8798d678c6ee98dee65a9554e4cf695d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8798d678c6ee98dee65a9554e4cf695d">&#9670;&nbsp;</a></span>asUnitInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::asUnitInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast this UnitInertia matrix as a unit inertia matrix. </p>
<p>This is just for emphasis; a UnitInertia matrix is already a kind of Inertia matrix by inheritance. </p>

</div>
</div>
<a id="a4fbd0500e52f995dd5f11639a073969d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbd0500e52f995dd5f11639a073969d">&#9670;&nbsp;</a></span>setFromUnitInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setFromUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set from a unit inertia matrix. </p>
<p>Note that we can't check; every Inertia matrix can be interpreted as a unit inertia for some shape. </p>

</div>
</div>
<a id="a0747db2089594f1958363401e7a75a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0747db2089594f1958363401e7a75a3e">&#9670;&nbsp;</a></span>isValidUnitInertiaMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::isValidUnitInertiaMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test some conditions that must hold for a valid UnitInertia matrix. </p>
<p>Cost is about 9 flops. TODO: this may not be comprehensive. </p>

</div>
</div>
<a id="a1e27445e87e048350c0733f282a14d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e27445e87e048350c0733f282a14d4a">&#9670;&nbsp;</a></span>pointMassAtOrigin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::pointMassAtOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a point located at the origin &ndash; that is, an all-zero matrix. </p>

</div>
</div>
<a id="ad12590783e2b1cc3dc3715f6c4c8f3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12590783e2b1cc3dc3715f6c4c8f3ef">&#9670;&nbsp;</a></span>pointMassAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::pointMassAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix). </p>
<p>Cost is 11 flops. </p>

</div>
</div>
<a id="aea6dff2244b2e884fc5ae7747b4489c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6dff2244b2e884fc5ae7747b4489c2">&#9670;&nbsp;</a></span>sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::sphere </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin. </p>

</div>
</div>
<a id="a22aae6b90b2feeb28272a15ac0ee431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22aae6b90b2feeb28272a15ac0ee431b">&#9670;&nbsp;</a></span>cylinderAlongZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongZ </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along z axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hz=0 it is a thin disk. </p>

</div>
</div>
<a id="a433b955d92ee92f053e4c90301b2537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433b955d92ee92f053e4c90301b2537e">&#9670;&nbsp;</a></span>cylinderAlongY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongY </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along y axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hy=0 it is a thin disk. </p>

</div>
</div>
<a id="a89f3c0caf76077405e5eca28662214dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f3c0caf76077405e5eca28662214dc">&#9670;&nbsp;</a></span>cylinderAlongX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongX </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along x axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hx=0 it is a thin disk. </p>

</div>
</div>
<a id="aa765bcf7ca1430d4bb0ee35964b6a87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa765bcf7ca1430d4bb0ee35964b6a87b">&#9670;&nbsp;</a></span>brick() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass brick given by half-lengths in each direction. </p>
<p>One dimension zero gives inertia of a thin rectangular sheet; two zero gives inertia of a thin rod in the remaining direction. </p>

</div>
</div>
<a id="a6727b53f8dc2470095ead9162f74df1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6727b53f8dc2470095ead9162f74df1e">&#9670;&nbsp;</a></span>brick() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<a id="afb4918161a3aa2b765b10834420f2006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4918161a3aa2b765b10834420f2006">&#9670;&nbsp;</a></span>ellipsoid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass ellipsoid given by half-lengths in each direction. </p>

</div>
</div>
<a id="a617357823ece8ff6c7f03c6cb34ab31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617357823ece8ff6c7f03c6cb34ab31e">&#9670;&nbsp;</a></span>ellipsoid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:19 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
