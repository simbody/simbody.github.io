<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Visualizer::InputSilo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Visualizer_1_1InputSilo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSimTK_1_1Visualizer_1_1InputSilo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Visualizer::InputSilo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This pre-built <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> is extremely useful for processing user input that is intended to affect a running simulation.  
 <a href="classSimTK_1_1Visualizer_1_1InputSilo.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Visualizer::InputSilo:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Visualizer_1_1InputSilo.png" usemap="#SimTK::Visualizer::InputSilo_map" alt=""/>
  <map id="SimTK::Visualizer::InputSilo_map" name="SimTK::Visualizer::InputSilo_map">
<area href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th..." alt="SimTK::Visualizer::InputListener" shape="rect" coords="0,0,187,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a38c8eae9396680a1722c23fbc2ed7679"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679">InputSilo</a> ()</td></tr>
<tr class="memdesc:a38c8eae9396680a1722c23fbc2ed7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction is all that is needed; there are no options.  <a href="#a38c8eae9396680a1722c23fbc2ed7679">More...</a><br /></td></tr>
<tr class="separator:a38c8eae9396680a1722c23fbc2ed7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a921f6e8340aaae8d9498e2c4b9686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a21a921f6e8340aaae8d9498e2c4b9686">~InputSilo</a> ()</td></tr>
<tr class="memdesc:a21a921f6e8340aaae8d9498e2c4b9686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws away any unprocessed input.  <a href="#a21a921f6e8340aaae8d9498e2c4b9686">More...</a><br /></td></tr>
<tr class="separator:a21a921f6e8340aaae8d9498e2c4b9686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1051385ffb8cf14d5fa0951b774adbbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a1051385ffb8cf14d5fa0951b774adbbd">isAnyUserInput</a> () const</td></tr>
<tr class="memdesc:a1051385ffb8cf14d5fa0951b774adbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a very fast test that does not require locking; you don't have to use this but it is a good idea to do so.  <a href="#a1051385ffb8cf14d5fa0951b774adbbd">More...</a><br /></td></tr>
<tr class="separator:a1051385ffb8cf14d5fa0951b774adbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f07fc1f6287b8460c424d1a850e294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294">waitForAnyUserInput</a> () const</td></tr>
<tr class="memdesc:af6f07fc1f6287b8460c424d1a850e294"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will wait quietly until the user has provided some input to the visualizer. Any kind of input will terminate the wait; you'll have to look to see what it was.  <a href="#af6f07fc1f6287b8460c424d1a850e294">More...</a><br /></td></tr>
<tr class="separator:af6f07fc1f6287b8460c424d1a850e294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f46fd92d0bdfb04fff97bc5aaec7c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55">takeKeyHit</a> (unsigned &amp;key, unsigned &amp;modifiers)</td></tr>
<tr class="memdesc:a9f46fd92d0bdfb04fff97bc5aaec7c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user key hits until they have all been consumed, in the same order they were received.  <a href="#a9f46fd92d0bdfb04fff97bc5aaec7c55">More...</a><br /></td></tr>
<tr class="separator:a9f46fd92d0bdfb04fff97bc5aaec7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67031f2e92874d90a97748d4b6248424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a67031f2e92874d90a97748d4b6248424">waitForKeyHit</a> (unsigned &amp;key, unsigned &amp;modifiers)</td></tr>
<tr class="memdesc:a67031f2e92874d90a97748d4b6248424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> except that if there is no key hit input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> would do.  <a href="#a67031f2e92874d90a97748d4b6248424">More...</a><br /></td></tr>
<tr class="separator:a67031f2e92874d90a97748d4b6248424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1b3ad69db6ec46d3ef111e1b06ebf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9">takeMenuPick</a> (int &amp;menu, int &amp;item)</td></tr>
<tr class="memdesc:a4d1b3ad69db6ec46d3ef111e1b06ebf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user menu picks until they have all been consumed, in the same order they were received.  <a href="#a4d1b3ad69db6ec46d3ef111e1b06ebf9">More...</a><br /></td></tr>
<tr class="separator:a4d1b3ad69db6ec46d3ef111e1b06ebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2a7d9dff88241bf8575441a1b0b81c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a8d2a7d9dff88241bf8575441a1b0b81c">waitForMenuPick</a> (int &amp;menu, int &amp;item)</td></tr>
<tr class="memdesc:a8d2a7d9dff88241bf8575441a1b0b81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> except that if there is no menu pick input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> would do.  <a href="#a8d2a7d9dff88241bf8575441a1b0b81c">More...</a><br /></td></tr>
<tr class="separator:a8d2a7d9dff88241bf8575441a1b0b81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007dc2fd54baefbc5b70334ffd174be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be">takeSliderMove</a> (int &amp;slider, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;value)</td></tr>
<tr class="memdesc:a3007dc2fd54baefbc5b70334ffd174be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return user changes to slider positions until they have all been consumed, in the same order they were received.  <a href="#a3007dc2fd54baefbc5b70334ffd174be">More...</a><br /></td></tr>
<tr class="separator:a3007dc2fd54baefbc5b70334ffd174be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa31bec760845d2317786be75af6d128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#afa31bec760845d2317786be75af6d128">waitForSliderMove</a> (int &amp;slider, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;value)</td></tr>
<tr class="memdesc:afa31bec760845d2317786be75af6d128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a> except that if there is no slider move input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a> would do.  <a href="#afa31bec760845d2317786be75af6d128">More...</a><br /></td></tr>
<tr class="separator:afa31bec760845d2317786be75af6d128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77636bca2813e4a7d419ff7bff9c48bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a77636bca2813e4a7d419ff7bff9c48bc">clear</a> ()</td></tr>
<tr class="memdesc:a77636bca2813e4a7d419ff7bff9c48bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw away any pending unprocessed input of all types.  <a href="#a77636bca2813e4a7d419ff7bff9c48bc">More...</a><br /></td></tr>
<tr class="separator:a77636bca2813e4a7d419ff7bff9c48bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Visualizer_1_1InputListener"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Visualizer_1_1InputListener')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html">SimTK::Visualizer::InputListener</a></td></tr>
<tr class="memitem:a443993246b8ef4c1ce45880398c7cdc9 inherit pub_methods_classSimTK_1_1Visualizer_1_1InputListener"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a443993246b8ef4c1ce45880398c7cdc9">~InputListener</a> ()</td></tr>
<tr class="memdesc:a443993246b8ef4c1ce45880398c7cdc9 inherit pub_methods_classSimTK_1_1Visualizer_1_1InputListener"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor is virtual; be sure to override it if you need to clean up.  <a href="classSimTK_1_1Visualizer_1_1InputListener.html#a443993246b8ef4c1ce45880398c7cdc9">More...</a><br /></td></tr>
<tr class="separator:a443993246b8ef4c1ce45880398c7cdc9 inherit pub_methods_classSimTK_1_1Visualizer_1_1InputListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1Visualizer_1_1InputListener"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1Visualizer_1_1InputListener')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html">SimTK::Visualizer::InputListener</a></td></tr>
<tr class="memitem:a93b0adb12021df37dfb71b063d1a6412 inherit pub_types_classSimTK_1_1Visualizer_1_1InputListener"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412">Modifier</a> { <br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412aac6a61448ad8f7a2d6876d70c3418e8d">ShiftIsDown</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412a02ec15be55564ae18626d5697bfa65b4">ControlIsDown</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412acbe644921f90fee66a77599cf26db5c3">AltIsDown</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412a771e624046b9daf479b4c3d1487b3da9">IsSpecialKey</a> = 0xC0
<br />
 }<tr class="memdesc:a93b0adb12021df37dfb71b063d1a6412"><td class="mdescLeft">&#160;</td><td class="mdescRight">These represent modifications to the character that is passed into the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#ad73885d721fd80ed92b16d342c21e01d" title="This method is called when a user hits a keyboard key in the Visualizer window, unless that key is be...">keyPressed()</a> method, including whether any of Shift/Control/Alt were down and whether a special non-ASCII code is being supplied, such as is required for an arrow key.  <a href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a93b0adb12021df37dfb71b063d1a6412 inherit pub_types_classSimTK_1_1Visualizer_1_1InputListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf1032150c14cf6bbc6b6cd4ee8596e inherit pub_types_classSimTK_1_1Visualizer_1_1InputListener"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596e">KeyCode</a> { <br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eacabe62d211f1ff941b39265f584b1f56">KeyControlC</a> = 3, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea41ba6461fe780384094cd6240d36994f">KeyBeep</a> = 7, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea71e8aa0e9a18f10c41b0bf689202f79f">KeyBackspace</a> = 8, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea42f27d53abfec290d67c489fc775c16b">KeyTab</a> = 9, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea0dddff185419026f92e3ef93f38ba787">KeyLF</a> = 10, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eadde0f957cc6714625e3aee596e91b87d">KeyReturn</a> = 13, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea9e4131a8daeeb0705c1c3aee9c10f421">KeyEnter</a> = KeyReturn, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea721c81b95606033bbbfd4968adf21337">KeyEsc</a> = 27, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea46eaae848a8c3660fca65c0897bf75e9">KeyDelete</a> = 127, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea051ca7ff218145f5ba3cf318202e48b6">KeyF1</a> = SpecialKeyOffset + 1, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea81d33ca552b976e36432a3abc763609d">KeyF2</a> = SpecialKeyOffset + 2, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea8fa493f0381fbde927a61ae1565bcf49">KeyF3</a> = SpecialKeyOffset + 3, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea922405b7e654fdc4f1ff56c4b6ac98e9">KeyF4</a> = SpecialKeyOffset + 4, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea6fad6cd2e472b704b70f61e5bc54ce78">KeyF5</a> = SpecialKeyOffset + 5, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea71d6d283648224ae81a883080d32b7c4">KeyF6</a> = SpecialKeyOffset + 6, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eadf95d1dc58bb6fa65ba84c602afddd14">KeyF7</a> = SpecialKeyOffset + 7, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eac57b2749f1b504cc342f1b3fd21c542a">KeyF8</a> = SpecialKeyOffset + 8, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea99ebcdc2e1964b44569d9a002a3420ff">KeyF9</a> = SpecialKeyOffset + 9, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea9b03a4ac6c8fb3f14a8e258197428299">KeyF10</a> = SpecialKeyOffset + 10, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea3b2e1de5e5e8c7214a3ce0e377000856">KeyF11</a> = SpecialKeyOffset + 11, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eaef47d37c5e3567901dc7f74ff394febc">KeyF12</a> = SpecialKeyOffset + 12, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea997d874ffb15d712469b631f49b1b7fe">KeyLeftArrow</a> = SpecialKeyOffset + 100, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eafa3fe84d601573d14585232b66d65620">KeyUpArrow</a> = SpecialKeyOffset + 101, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596eab23f6ea891589c60d0d96b8903d5dd0c">KeyRightArrow</a> = SpecialKeyOffset + 102, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea68f57a3e5b67a1ef7783f4cfd66dc1d9">KeyDownArrow</a> = SpecialKeyOffset + 103, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea65a03884b79816365d7e2d7a53c45199">KeyPageUp</a> = SpecialKeyOffset + 104, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea3447dd11f190968e3fe746c00eecddce">KeyPageDown</a> = SpecialKeyOffset + 105, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea5e63da8fab7ca3c825e7fc61d24d3d6d">KeyHome</a> = SpecialKeyOffset + 106, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea8aa6e28c595ec82acec0a1e4fc4f5ebb">KeyEnd</a> = SpecialKeyOffset + 107, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea8ba0bd5f40ea43eddfce4347940c91bd">KeyInsert</a> = SpecialKeyOffset + 108
<br />
 }<tr class="memdesc:afdf1032150c14cf6bbc6b6cd4ee8596e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the special keys that the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a> may report via the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#ad73885d721fd80ed92b16d342c21e01d" title="This method is called when a user hits a keyboard key in the Visualizer window, unless that key is be...">keyPressed()</a> method.  <a href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afdf1032150c14cf6bbc6b6cd4ee8596e inherit pub_types_classSimTK_1_1Visualizer_1_1InputListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classSimTK_1_1Visualizer_1_1InputListener"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classSimTK_1_1Visualizer_1_1InputListener')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html">SimTK::Visualizer::InputListener</a></td></tr>
<tr class="memitem:a3076228ad2db911047d3ebca071786b1 inherit pub_static_attribs_classSimTK_1_1Visualizer_1_1InputListener"><td class="memItemLeft" align="right" valign="top">static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a3076228ad2db911047d3ebca071786b1">SpecialKeyOffset</a> = 0x100</td></tr>
<tr class="separator:a3076228ad2db911047d3ebca071786b1 inherit pub_static_attribs_classSimTK_1_1Visualizer_1_1InputListener"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This pre-built <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> is extremely useful for processing user input that is intended to affect a running simulation. </p>
<p>The idea is that this object saves up all the user input in a set of "silos", which are first-in-first-out (FIFO) queues. The simulation periodically checks ("polls") to see if there is anything in the silos that needs processing, pulling off one user input at a time until they have all been consumed. This eliminates any need for tricky asynchronous handling of user input, and all thread synchronization issues are handled invisibly.</p>
<p>You can also request to wait quietly until some input arrives, which is useful when you can't proceed without some instruction from the user that you expect to get through the visualizer.</p>
<p>When the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> receives user input through one of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> methods it implements, it return <code>true</code> indicating that it has processed the input and that no further InputListeners should be called. So if you have other InputListeners that you would like to have called, be sure to add them to the Visulizer <em>prior</em> to adding an <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a>, which is the last refuge for unwanted user input.</p>
<p>Here's how you can use this:</p>
<div class="fragment"><div class="line">MultibodySystem system;</div><div class="line"><span class="comment">// ... build system</span></div><div class="line"></div><div class="line"><span class="comment">// Set up a Visualizer to run in real time mode, and give it an</span></div><div class="line"><span class="comment">// InputSilo to gather user input.</span></div><div class="line"><a class="code" href="classSimTK_1_1Visualizer.html#a2fa1656e1330799158cd4e79c3c691a7">Visualizer</a> viz(system);</div><div class="line">viz.setMode(<a class="code" href="classSimTK_1_1Visualizer.html#afd8266999e706427db3f86fd6bf5e1dfad5b12e033b09d5ff0f56ac6a0f5eb2d2">Visualizer::RealTime</a>);</div><div class="line"><a class="code" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679">InputSilo</a>* silo = <span class="keyword">new</span> <a class="code" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a38c8eae9396680a1722c23fbc2ed7679">InputSilo</a>;</div><div class="line">viz.addInputListener(silo);</div><div class="line"></div><div class="line"><span class="comment">// You create a PeriodicEventHandler to poll the input. Note that the interval</span></div><div class="line"><span class="comment">// you choose determines how responsive the simulation will be to user input,</span></div><div class="line"><span class="comment">// but it also limits the maximum step size that the integrator can take.</span></div><div class="line">system.addEventHandler</div><div class="line">    (<span class="keyword">new</span> MyUserInputHandler(*silo, 0.1)); <span class="comment">// check every 100ms </span></div><div class="line"></div><div class="line"><span class="comment">// Then in MyUserInputHandler::handleEvent(...):</span></div><div class="line"><span class="keywordflow">while</span> (silo.isAnyUserInput()) {</div><div class="line">    <span class="keywordflow">while</span> (silo.takeKeyHit(key,modifier)) {</div><div class="line">        <span class="comment">// Process the key that was hit</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (silo.takeMenuPick(which, item)) {</div><div class="line">        <span class="comment">// Process the picked menu item</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (silo.takeSliderMove(which, value)) {</div><div class="line">        <span class="comment">// Process the new value for slider &quot;which&quot;</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>If you want to wait until some input arrives, create the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> and add it to the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a> as above, then in your main program (that is, not in the Handler) use code like this: </p><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Hit ENTER in visualizer to continue ...\n&quot;</span>;</div><div class="line"><span class="keywordtype">unsigned</span> key, modifiers;</div><div class="line"><span class="keywordflow">do</span> {silo-&gt;waitForKeyHit(key,modifiers);}</div><div class="line"><span class="keywordflow">while</span> (key != <a class="code" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596ea9e4131a8daeeb0705c1c3aee9c10f421">Visualizer::InputListener::KeyEnter</a>);</div></div><!-- fragment --><p> Similar methods are available for all the different input types, and you can also wait on the arrival of <em>any</em> input.</p>
<h3>Implementation</h3>
<p>The <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html" title="This pre-built InputListener is extremely useful for processing user input that is intended to affect...">InputSilo</a> implementations of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html" title="This abstract class defines methods to be called when the Visualizer reports user activity back to th...">InputListener</a> methods are called from the <a class="el" href="classSimTK_1_1Visualizer.html" title="Provide simple visualization of and interaction with a Simbody simulation, with real time control of ...">Visualizer</a>'s listener thread, which is a different thread than the one that is simultaneously running the simulation. The internal silos are double-ended queues (deques) that allow inputs to be pushed onto one end and pulled off the other, so that they can be consumed in FIFO order. There is a single mutex lock associated with <em>all</em> the silos together, and the lock must be held while anything is pushed onto or pulled off of any one of the silos.</p>
<p>Each of the methods for getting the input out of the silos is called from the simulation thread, which must obtain the lock before removing anything, thus safely synchronizing the listener and simulation threads.</p>
<p>A count is maintained of the total number of items in all the silos. It is incremented only when the listener thread holds the lock and adds something to a silo; it is decremented only when the simulation thread holds the lock and pulls something from a silo. The count may be examined without locking; it will have a value that was recently correct and can thus be used for a very fast check on whether there is likely to be any input worth holding a lock for; the <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a1051385ffb8cf14d5fa0951b774adbbd" title="This is a very fast test that does not require locking; you don&#39;t have to use this but it is a good i...">isAnyUserInput()</a> method returns <code>true</code> when the count is non-zero. It may occasionally return zero in cases where there is input, but only if that input just arrived so you can safely pick it up on the next poll.</p>
<p>When possible we optimize for the case where many inputs arrive from the same device by just keeping the most recent value. That applies to slider and mouse moves. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38c8eae9396680a1722c23fbc2ed7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c8eae9396680a1722c23fbc2ed7679">&#9670;&nbsp;</a></span>InputSilo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Visualizer::InputSilo::InputSilo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default construction is all that is needed; there are no options. </p>

</div>
</div>
<a id="a21a921f6e8340aaae8d9498e2c4b9686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a921f6e8340aaae8d9498e2c4b9686">&#9670;&nbsp;</a></span>~InputSilo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Visualizer::InputSilo::~InputSilo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws away any unprocessed input. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1051385ffb8cf14d5fa0951b774adbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1051385ffb8cf14d5fa0951b774adbbd">&#9670;&nbsp;</a></span>isAnyUserInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Visualizer::InputSilo::isAnyUserInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a very fast test that does not require locking; you don't have to use this but it is a good idea to do so. </p>

</div>
</div>
<a id="af6f07fc1f6287b8460c424d1a850e294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f07fc1f6287b8460c424d1a850e294">&#9670;&nbsp;</a></span>waitForAnyUserInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Visualizer::InputSilo::waitForAnyUserInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will wait quietly until the user has provided some input to the visualizer. Any kind of input will terminate the wait; you'll have to look to see what it was. </p>

</div>
</div>
<a id="a9f46fd92d0bdfb04fff97bc5aaec7c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f46fd92d0bdfb04fff97bc5aaec7c55">&#9670;&nbsp;</a></span>takeKeyHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Visualizer::InputSilo::takeKeyHit </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will return user key hits until they have all been consumed, in the same order they were received. </p>
<p>The <em>key</em> and <em>modifiers</em> values are those that were provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#ad73885d721fd80ed92b16d342c21e01d" title="This method is called when a user hits a keyboard key in the Visualizer window, unless that key is be...">InputListener::keyPressed()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The key code for the key that was hit. See <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#afdf1032150c14cf6bbc6b6cd4ee8596e" title="These are the special keys that the Visualizer may report via the keyPressed() method. ">InputListener::KeyCode</a> for interpretation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">modifiers</td><td>Status of Shift,Ctrl,Alt and "special" key code. See <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a93b0adb12021df37dfb71b063d1a6412" title="These represent modifications to the character that is passed into the keyPressed() method...">InputListener::Modifier</a> for interpretation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a key and modifiers have been returned; <code>false</code> if the character silo is now empty in which case both <em>key</em> and <em>modifiers</em> will be set to zero. </dd></dl>

</div>
</div>
<a id="a67031f2e92874d90a97748d4b6248424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67031f2e92874d90a97748d4b6248424">&#9670;&nbsp;</a></span>waitForKeyHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Visualizer::InputSilo::waitForKeyHit </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>modifiers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> except that if there is no key hit input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a> returns <code>true</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a9f46fd92d0bdfb04fff97bc5aaec7c55" title="This will return user key hits until they have all been consumed, in the same order they were receive...">takeKeyHit()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a id="a4d1b3ad69db6ec46d3ef111e1b06ebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1b3ad69db6ec46d3ef111e1b06ebf9">&#9670;&nbsp;</a></span>takeMenuPick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Visualizer::InputSilo::takeMenuPick </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>menu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will return user menu picks until they have all been consumed, in the same order they were received. </p>
<p>The <em>item</em> value returned is the value that was provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a37b21fde4c4b9177f4c84c14795081e3" title="The user has clicked one of the menu items you defined; here is the integer value you specified when ...">InputListener::menuSelected()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">menu</td><td>The id number of the menu that was selected. This is the value that was assigned to this menu in the <a class="el" href="classSimTK_1_1Visualizer.html#a3939bbfe663c4b0436bd12baa6d2c270" title="Add a new pull-down menu to the visualizer&#39;s display. ">Visualizer::addMenu()</a> call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item</td><td>The menu item number for the entry that the user selected. This is the number that was assigned at the time the menu was added via the <a class="el" href="classSimTK_1_1Visualizer.html#a3939bbfe663c4b0436bd12baa6d2c270" title="Add a new pull-down menu to the visualizer&#39;s display. ">Visualizer::addMenu()</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a menu item number has been returned; <code>false</code> if the menu pick silo is now empty in which case <em>item</em> will be set to zero. </dd></dl>

</div>
</div>
<a id="a8d2a7d9dff88241bf8575441a1b0b81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2a7d9dff88241bf8575441a1b0b81c">&#9670;&nbsp;</a></span>waitForMenuPick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Visualizer::InputSilo::waitForMenuPick </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>menu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> except that if there is no menu pick input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a> returns <code>true</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a4d1b3ad69db6ec46d3ef111e1b06ebf9" title="This will return user menu picks until they have all been consumed, in the same order they were recei...">takeMenuPick()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a id="a3007dc2fd54baefbc5b70334ffd174be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3007dc2fd54baefbc5b70334ffd174be">&#9670;&nbsp;</a></span>takeSliderMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Visualizer::InputSilo::takeSliderMove </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>slider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This will return user changes to slider positions until they have all been consumed, in the same order they were received. </p>
<p>The <em>slider</em> and <em>value</em> returns are those that were provided to our implementation of the <a class="el" href="classSimTK_1_1Visualizer_1_1InputListener.html#a33c4bf3d5b720025ea2ef327f1692bc5" title="The user has moved one of the sliders you defined; here is the integer value you specified when you d...">InputListener::sliderMoved()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">slider</td><td>The id number of the slider that was moved. This is the value that was assigned to this slider in the <a class="el" href="classSimTK_1_1Visualizer.html#a1e2cb9ddc47715b23a8acacaa846e70d" title="Add a new slider to the visualizer&#39;s display. ">Visualizer::addSlider()</a> call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>This is the new value associated with the slider position to which the user moved it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a slider move has been returned; <code>false</code> if the slider move silo is now empty in which case <em>which</em> will be set to zero and <em>value</em> will be NaN. </dd></dl>

</div>
</div>
<a id="afa31bec760845d2317786be75af6d128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa31bec760845d2317786be75af6d128">&#9670;&nbsp;</a></span>waitForSliderMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Visualizer::InputSilo::waitForSliderMove </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>slider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a> except that if there is no slider move input available it waits until there is, then returns the first one (which is removed from the silo just as <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a> would do. </p>
<p>The behavior is like calling <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> repeatedly until <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a> returns <code>true</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#a3007dc2fd54baefbc5b70334ffd174be" title="This will return user changes to slider positions until they have all been consumed, in the same order they were received. ">takeSliderMove()</a>, <a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html#af6f07fc1f6287b8460c424d1a850e294" title="This will wait quietly until the user has provided some input to the visualizer. Any kind of input wi...">waitForAnyUserInput()</a> </dd></dl>

</div>
</div>
<a id="a77636bca2813e4a7d419ff7bff9c48bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77636bca2813e4a7d419ff7bff9c48bc">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Visualizer::InputSilo::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw away any pending unprocessed input of all types. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Visualizer__InputListener_8h_source.html">Visualizer_InputListener.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Visualizer.html">Visualizer</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Visualizer_1_1InputSilo.html">InputSilo</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:19 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
