<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Transform_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Transform__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Transform__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Transform_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the rotate-and-shift transform which gives the location and orientation of a new frame F in a base (reference) frame B.  
 <a href="classSimTK_1_1Transform__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa942cf29be6dfe83a94793a8b81dd2b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#aa942cf29be6dfe83a94793a8b81dd2b2">Transform_</a> ()</td></tr>
<tr class="memdesc:aa942cf29be6dfe83a94793a8b81dd2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor gives an identity transform.  <a href="#aa942cf29be6dfe83a94793a8b81dd2b2">More...</a><br /></td></tr>
<tr class="separator:aa942cf29be6dfe83a94793a8b81dd2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df212001307fcfc4e33cf3aa8817c90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a9df212001307fcfc4e33cf3aa8817c90">Transform_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a8e7a061a9801ca4ae0fa57de663ac9ea">R</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a082a5d4c827fd8ea2788cb6b4cf6a9c8">p</a>)</td></tr>
<tr class="memdesc:a9df212001307fcfc4e33cf3aa8817c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a rotation and a translation into a transform.  <a href="#a9df212001307fcfc4e33cf3aa8817c90">More...</a><br /></td></tr>
<tr class="separator:a9df212001307fcfc4e33cf3aa8817c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fbe8b9a20fb1bdea86d041bc6d8a62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a57fbe8b9a20fb1bdea86d041bc6d8a62">Transform_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a8e7a061a9801ca4ae0fa57de663ac9ea">R</a>)</td></tr>
<tr class="memdesc:a57fbe8b9a20fb1bdea86d041bc6d8a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct or default-convert a rotation into a transform containing that rotation and zero translation.  <a href="#a57fbe8b9a20fb1bdea86d041bc6d8a62">More...</a><br /></td></tr>
<tr class="separator:a57fbe8b9a20fb1bdea86d041bc6d8a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c35260adc6730882709e597db78a18b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a7c35260adc6730882709e597db78a18b">Transform_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a082a5d4c827fd8ea2788cb6b4cf6a9c8">p</a>)</td></tr>
<tr class="memdesc:a7c35260adc6730882709e597db78a18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct or default-convert a translation (expressed as a Vec3) into a transform with that translation and a zero rotation.  <a href="#a7c35260adc6730882709e597db78a18b">More...</a><br /></td></tr>
<tr class="separator:a7c35260adc6730882709e597db78a18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d6ac8f3fef3c908264601b84bd6d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a88d6ac8f3fef3c908264601b84bd6d07">operator=</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X)</td></tr>
<tr class="memdesc:a88d6ac8f3fef3c908264601b84bd6d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from InverseTransform.  <a href="#a88d6ac8f3fef3c908264601b84bd6d07">More...</a><br /></td></tr>
<tr class="separator:a88d6ac8f3fef3c908264601b84bd6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc0c88a25651fc828e217376765e425"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:accc0c88a25651fc828e217376765e425"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#accc0c88a25651fc828e217376765e425">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;offset_B)</td></tr>
<tr class="memdesc:accc0c88a25651fc828e217376765e425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an offset to the position vector in this Transform.  <a href="#accc0c88a25651fc828e217376765e425">More...</a><br /></td></tr>
<tr class="separator:accc0c88a25651fc828e217376765e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a5dba99e12f4d7e53a3d71c9e7ada5"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a82a5dba99e12f4d7e53a3d71c9e7ada5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a82a5dba99e12f4d7e53a3d71c9e7ada5">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;offset_B)</td></tr>
<tr class="memdesc:a82a5dba99e12f4d7e53a3d71c9e7ada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract an offset from the position vector in this Transform.  <a href="#a82a5dba99e12f4d7e53a3d71c9e7ada5">More...</a><br /></td></tr>
<tr class="separator:a82a5dba99e12f4d7e53a3d71c9e7ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254c6803ccc46ee6ac745ee40da464a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a7254c6803ccc46ee6ac745ee40da464a">set</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a8e7a061a9801ca4ae0fa57de663ac9ea">R</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a082a5d4c827fd8ea2788cb6b4cf6a9c8">p</a>)</td></tr>
<tr class="memdesc:a7254c6803ccc46ee6ac745ee40da464a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new value to this transform, explicitly providing the rotation and translation separately.  <a href="#a7254c6803ccc46ee6ac745ee40da464a">More...</a><br /></td></tr>
<tr class="separator:a7254c6803ccc46ee6ac745ee40da464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accffbeb421e93b37b303c4eceae81e67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#accffbeb421e93b37b303c4eceae81e67">setToZero</a> ()</td></tr>
<tr class="memdesc:accffbeb421e93b37b303c4eceae81e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">By zero we mean "zero transform", i.e., an identity rotation and zero translation.  <a href="#accffbeb421e93b37b303c4eceae81e67">More...</a><br /></td></tr>
<tr class="separator:accffbeb421e93b37b303c4eceae81e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5acadb0389eb80373a4cd766e2c6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a3f5acadb0389eb80373a4cd766e2c6f4">setToNaN</a> ()</td></tr>
<tr class="memdesc:a3f5acadb0389eb80373a4cd766e2c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fills both the rotation and translation with NaNs.  <a href="#a3f5acadb0389eb80373a4cd766e2c6f4">More...</a><br /></td></tr>
<tr class="separator:a3f5acadb0389eb80373a4cd766e2c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246a173e41efc5f172dc6669e41c7ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a8246a173e41efc5f172dc6669e41c7ee">invert</a> () const</td></tr>
<tr class="memdesc:a8246a173e41efc5f172dc6669e41c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only inverse of the current <a class="el" href="classSimTK_1_1Transform__.html" title="This class represents the rotate-and-shift transform which gives the location and orientation of a ne...">Transform_</a>.  <a href="#a8246a173e41efc5f172dc6669e41c7ee">More...</a><br /></td></tr>
<tr class="separator:a8246a173e41efc5f172dc6669e41c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e61c08d0cc6e37131ce9f6ac0fb378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a38e61c08d0cc6e37131ce9f6ac0fb378">updInvert</a> ()</td></tr>
<tr class="memdesc:a38e61c08d0cc6e37131ce9f6ac0fb378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable (lvalue) inverse of the current transform, simply by casting it to the <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a>.  <a href="#a38e61c08d0cc6e37131ce9f6ac0fb378">More...</a><br /></td></tr>
<tr class="separator:a38e61c08d0cc6e37131ce9f6ac0fb378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b7a421f3b787fe90c0e20fc315b994"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a71b7a421f3b787fe90c0e20fc315b994">operator~</a> () const</td></tr>
<tr class="memdesc:a71b7a421f3b787fe90c0e20fc315b994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload transpose operator to mean inversion.  <a href="#a71b7a421f3b787fe90c0e20fc315b994">More...</a><br /></td></tr>
<tr class="separator:a71b7a421f3b787fe90c0e20fc315b994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe62f45f57315377f9b2d73849bf45be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#abe62f45f57315377f9b2d73849bf45be">operator~</a> ()</td></tr>
<tr class="memdesc:abe62f45f57315377f9b2d73849bf45be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload transpose operator to mean inversion.  <a href="#abe62f45f57315377f9b2d73849bf45be">More...</a><br /></td></tr>
<tr class="separator:abe62f45f57315377f9b2d73849bf45be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabccf7acd60742a6911e55e6a949cbb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#aabccf7acd60742a6911e55e6a949cbb2">compose</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> &amp;X_FY) const</td></tr>
<tr class="memdesc:aabccf7acd60742a6911e55e6a949cbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the current transform (X_BF) with the given one.  <a href="#aabccf7acd60742a6911e55e6a949cbb2">More...</a><br /></td></tr>
<tr class="separator:aabccf7acd60742a6911e55e6a949cbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ff49bd518a5e8c02374023140dc0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a02ff49bd518a5e8c02374023140dc0f1">compose</a> (const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;X_FY) const</td></tr>
<tr class="memdesc:a02ff49bd518a5e8c02374023140dc0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the current transform (X_BF) with one that is supplied as an <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a> (typically as a result of applying the "~" operator to a transform).  <a href="#a02ff49bd518a5e8c02374023140dc0f1">More...</a><br /></td></tr>
<tr class="separator:a02ff49bd518a5e8c02374023140dc0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd634d41bfcc406e3b3960d26d35622c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#acd634d41bfcc406e3b3960d26d35622c">xformFrameVecToBase</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;vF) const</td></tr>
<tr class="memdesc:acd634d41bfcc406e3b3960d26d35622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a vector expressed in our "F" frame to our "B" frame.  <a href="#acd634d41bfcc406e3b3960d26d35622c">More...</a><br /></td></tr>
<tr class="separator:acd634d41bfcc406e3b3960d26d35622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b272a12d45859508f4a9e52504ac7d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a1b272a12d45859508f4a9e52504ac7d7">xformBaseVecToFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;vB) const</td></tr>
<tr class="memdesc:a1b272a12d45859508f4a9e52504ac7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a vector expressed in our "B" frame to our "F" frame.  <a href="#a1b272a12d45859508f4a9e52504ac7d7">More...</a><br /></td></tr>
<tr class="separator:a1b272a12d45859508f4a9e52504ac7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e4ea049413e0cd6d3be1151bedfbfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a46e4ea049413e0cd6d3be1151bedfbfb">shiftFrameStationToBase</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;sF) const</td></tr>
<tr class="memdesc:a46e4ea049413e0cd6d3be1151bedfbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point (station) measured from and expressed in our "F" frame to that same point but measured from and expressed in our "B" frame.  <a href="#a46e4ea049413e0cd6d3be1151bedfbfb">More...</a><br /></td></tr>
<tr class="separator:a46e4ea049413e0cd6d3be1151bedfbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd8b0a0ce69193eeabab453bcaa51f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a9fbd8b0a0ce69193eeabab453bcaa51f">shiftBaseStationToFrame</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;sB) const</td></tr>
<tr class="memdesc:a9fbd8b0a0ce69193eeabab453bcaa51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point (station) measured from and expressed in our "B" frame to that same point but measured from and expressed in our "F" frame.  <a href="#a9fbd8b0a0ce69193eeabab453bcaa51f">More...</a><br /></td></tr>
<tr class="separator:a9fbd8b0a0ce69193eeabab453bcaa51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7a061a9801ca4ae0fa57de663ac9ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a8e7a061a9801ca4ae0fa57de663ac9ea">R</a> () const</td></tr>
<tr class="memdesc:a8e7a061a9801ca4ae0fa57de663ac9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to the contained rotation R_BF.  <a href="#a8e7a061a9801ca4ae0fa57de663ac9ea">More...</a><br /></td></tr>
<tr class="separator:a8e7a061a9801ca4ae0fa57de663ac9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0dfb4616800cb27dbff93494f74a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a1c0dfb4616800cb27dbff93494f74a96">updR</a> ()</td></tr>
<tr class="memdesc:a1c0dfb4616800cb27dbff93494f74a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable (lvalue) reference to the contained rotation R_BF.  <a href="#a1c0dfb4616800cb27dbff93494f74a96">More...</a><br /></td></tr>
<tr class="separator:a1c0dfb4616800cb27dbff93494f74a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509f83803b53f503045203fa4f50944a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt;::ColType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a509f83803b53f503045203fa4f50944a">x</a> () const</td></tr>
<tr class="memdesc:a509f83803b53f503045203fa4f50944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to the x direction (unit vector) of the F frame, expressed in the B frame.  <a href="#a509f83803b53f503045203fa4f50944a">More...</a><br /></td></tr>
<tr class="separator:a509f83803b53f503045203fa4f50944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea54db7ea450eedced56ccaf9fe62a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt;::ColType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a9ea54db7ea450eedced56ccaf9fe62a5">y</a> () const</td></tr>
<tr class="memdesc:a9ea54db7ea450eedced56ccaf9fe62a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to the y direction (unit vector) of the F frame, expressed in the B frame.  <a href="#a9ea54db7ea450eedced56ccaf9fe62a5">More...</a><br /></td></tr>
<tr class="separator:a9ea54db7ea450eedced56ccaf9fe62a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f849e7adcd47d614d7b20ec412263d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt;::ColType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a92f849e7adcd47d614d7b20ec412263d">z</a> () const</td></tr>
<tr class="memdesc:a92f849e7adcd47d614d7b20ec412263d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to the z direction (unit vector) of the F frame, expressed in the B frame.  <a href="#a92f849e7adcd47d614d7b20ec412263d">More...</a><br /></td></tr>
<tr class="separator:a92f849e7adcd47d614d7b20ec412263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac586fb7db5e01921dcc61a8cf3ae949d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#ac586fb7db5e01921dcc61a8cf3ae949d">RInv</a> () const</td></tr>
<tr class="memdesc:ac586fb7db5e01921dcc61a8cf3ae949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to the inverse (transpose) of our contained rotation, that is R_FB.  <a href="#ac586fb7db5e01921dcc61a8cf3ae949d">More...</a><br /></td></tr>
<tr class="separator:ac586fb7db5e01921dcc61a8cf3ae949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad027199c1f83bd34b377e52002afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#ac9ad027199c1f83bd34b377e52002afe">updRInv</a> ()</td></tr>
<tr class="memdesc:ac9ad027199c1f83bd34b377e52002afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable (lvalue) reference to the inverse (transpose) of our contained rotation, that is R_FB.  <a href="#ac9ad027199c1f83bd34b377e52002afe">More...</a><br /></td></tr>
<tr class="separator:ac9ad027199c1f83bd34b377e52002afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082a5d4c827fd8ea2788cb6b4cf6a9c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a082a5d4c827fd8ea2788cb6b4cf6a9c8">p</a> () const</td></tr>
<tr class="memdesc:a082a5d4c827fd8ea2788cb6b4cf6a9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only reference to our translation vector p_BF.  <a href="#a082a5d4c827fd8ea2788cb6b4cf6a9c8">More...</a><br /></td></tr>
<tr class="separator:a082a5d4c827fd8ea2788cb6b4cf6a9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc620dd92c973510862ca3dc1ed2d4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#adc620dd92c973510862ca3dc1ed2d4a2">updP</a> ()</td></tr>
<tr class="memdesc:adc620dd92c973510862ca3dc1ed2d4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable (lvalue) reference to our translation vector p_BF.  <a href="#adc620dd92c973510862ca3dc1ed2d4a2">More...</a><br /></td></tr>
<tr class="separator:adc620dd92c973510862ca3dc1ed2d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8244bef7c4c612515fff52ad226f08b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a8244bef7c4c612515fff52ad226f08b3">setP</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;<a class="el" href="classSimTK_1_1Transform__.html#a082a5d4c827fd8ea2788cb6b4cf6a9c8">p</a>)</td></tr>
<tr class="memdesc:a8244bef7c4c612515fff52ad226f08b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new value to our translation vector.  <a href="#a8244bef7c4c612515fff52ad226f08b3">More...</a><br /></td></tr>
<tr class="separator:a8244bef7c4c612515fff52ad226f08b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0322759566d62fc5e59ac709c6a95c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a0322759566d62fc5e59ac709c6a95c93">pInv</a> () const</td></tr>
<tr class="memdesc:a0322759566d62fc5e59ac709c6a95c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of the translation vector in this transform.  <a href="#a0322759566d62fc5e59ac709c6a95c93">More...</a><br /></td></tr>
<tr class="separator:a0322759566d62fc5e59ac709c6a95c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337e6d26f7a989df392dc8e43ecc38c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a337e6d26f7a989df392dc8e43ecc38c8">setPInv</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;p_FB)</td></tr>
<tr class="memdesc:a337e6d26f7a989df392dc8e43ecc38c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value to the <em>inverse</em> of our translation vector.  <a href="#a337e6d26f7a989df392dc8e43ecc38c8">More...</a><br /></td></tr>
<tr class="separator:a337e6d26f7a989df392dc8e43ecc38c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f91216176dd9746651c159c9b4bd2d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 4, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a0f91216176dd9746651c159c9b4bd2d5">asMat34</a> () const</td></tr>
<tr class="memdesc:a0f91216176dd9746651c159c9b4bd2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast this transform as a read-only 3x4 matrix.  <a href="#a0f91216176dd9746651c159c9b4bd2d5">More...</a><br /></td></tr>
<tr class="separator:a0f91216176dd9746651c159c9b4bd2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad873446f35c5c2332758db410c2c17db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#ad873446f35c5c2332758db410c2c17db">toMat34</a> () const</td></tr>
<tr class="memdesc:ad873446f35c5c2332758db410c2c17db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less efficient version of <a class="el" href="classSimTK_1_1Transform__.html#a0f91216176dd9746651c159c9b4bd2d5" title="Recast this transform as a read-only 3x4 matrix. ">asMat34()</a>; copies into return variable.  <a href="#ad873446f35c5c2332758db410c2c17db">More...</a><br /></td></tr>
<tr class="separator:ad873446f35c5c2332758db410c2c17db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5894493db41a95c3d3c3a439f064464c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a5894493db41a95c3d3c3a439f064464c">toMat44</a> () const</td></tr>
<tr class="memdesc:a5894493db41a95c3d3c3a439f064464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the equivalent 4x4 transformation matrix.  <a href="#a5894493db41a95c3d3c3a439f064464c">More...</a><br /></td></tr>
<tr class="separator:a5894493db41a95c3d3c3a439f064464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8966a733837d4f06fa86b5f5a9011ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#ae8966a733837d4f06fa86b5f5a9011ed">T</a> () const</td></tr>
<tr class="separator:ae8966a733837d4f06fa86b5f5a9011ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd9b7821ea0a831494b7f729a1de2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a6dd9b7821ea0a831494b7f729a1de2f5">updT</a> ()</td></tr>
<tr class="separator:a6dd9b7821ea0a831494b7f729a1de2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6431752e53d0aa5556082a0282a8a214"><td class="memTemplParams" colspan="2">template&lt;class P , int S&gt; </td></tr>
<tr class="memitem:a6431752e53d0aa5556082a0282a8a214"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a6431752e53d0aa5556082a0282a8a214">operator*</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_BF, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;s_F)</td></tr>
<tr class="memdesc:a6431752e53d0aa5556082a0282a8a214"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we multiply a transform or inverse transform by a 3-vector, we treat the vector as though it had a 4th element "1" appended, that is, it is treated as a <em>station</em> rather than a <em>vector</em>.  <a href="#a6431752e53d0aa5556082a0282a8a214">More...</a><br /></td></tr>
<tr class="separator:a6431752e53d0aa5556082a0282a8a214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47aa26f1160b2408a72eb2fb25ce332"><td class="memTemplParams" colspan="2">template&lt;class P , int S&gt; </td></tr>
<tr class="memitem:af47aa26f1160b2408a72eb2fb25ce332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#af47aa26f1160b2408a72eb2fb25ce332">operator+</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_BF, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;offset_B)</td></tr>
<tr class="memdesc:af47aa26f1160b2408a72eb2fb25ce332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a 3-vector to a Transform produces a new shifted transform.  <a href="#af47aa26f1160b2408a72eb2fb25ce332">More...</a><br /></td></tr>
<tr class="separator:af47aa26f1160b2408a72eb2fb25ce332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f24668c1938312872432428c5999e9"><td class="memTemplParams" colspan="2">template&lt;class P , int S&gt; </td></tr>
<tr class="memitem:a02f24668c1938312872432428c5999e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a02f24668c1938312872432428c5999e9">operator+</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;offset_B, const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_BF)</td></tr>
<tr class="memdesc:a02f24668c1938312872432428c5999e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adding a 3-vector to a Transform produces a new shifted transform.  <a href="#a02f24668c1938312872432428c5999e9">More...</a><br /></td></tr>
<tr class="separator:a02f24668c1938312872432428c5999e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfc1ed3b6d6a82633d1e9c3eb9e5f84"><td class="memTemplParams" colspan="2">template&lt;class P , int S&gt; </td></tr>
<tr class="memitem:a5dfc1ed3b6d6a82633d1e9c3eb9e5f84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a5dfc1ed3b6d6a82633d1e9c3eb9e5f84">operator-</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_BF, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;offset_B)</td></tr>
<tr class="memdesc:a5dfc1ed3b6d6a82633d1e9c3eb9e5f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracting a 3-vector from a Transform produces a new shifted transform.  <a href="#a5dfc1ed3b6d6a82633d1e9c3eb9e5f84">More...</a><br /></td></tr>
<tr class="separator:a5dfc1ed3b6d6a82633d1e9c3eb9e5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a5a44119a5823a29eeeb578b6346f3"><td class="memTemplParams" colspan="2">template&lt;class P , int S&gt; </td></tr>
<tr class="memitem:aa6a5a44119a5823a29eeeb578b6346f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#aa6a5a44119a5823a29eeeb578b6346f3">operator*</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X_BF, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;a_F)</td></tr>
<tr class="memdesc:aa6a5a44119a5823a29eeeb578b6346f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we multiply a transform or inverse transform by an augmented 4-vector, we use the 4th element to decide how to treat it.  <a href="#aa6a5a44119a5823a29eeeb578b6346f3">More...</a><br /></td></tr>
<tr class="separator:aa6a5a44119a5823a29eeeb578b6346f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a55bee4fe245a448b2084aac7c3d847"><td class="memTemplParams" colspan="2">template&lt;class P , class E &gt; </td></tr>
<tr class="memitem:a7a55bee4fe245a448b2084aac7c3d847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__TypedNumConstants.html#ga62e94c379e736581bd70ce4647168f95">E</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a7a55bee4fe245a448b2084aac7c3d847">operator*</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X, const <a class="el" href="classSimTK_1_1VectorBase.html">VectorBase</a>&lt; <a class="el" href="group__TypedNumConstants.html#ga62e94c379e736581bd70ce4647168f95">E</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a7a55bee4fe245a448b2084aac7c3d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplying a matrix or vector by a <a class="el" href="classSimTK_1_1Transform__.html" title="This class represents the rotate-and-shift transform which gives the location and orientation of a ne...">Transform_</a>.  <a href="#a7a55bee4fe245a448b2084aac7c3d847">More...</a><br /></td></tr>
<tr class="separator:a7a55bee4fe245a448b2084aac7c3d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b0195de53b1c24ead039ab6a74f474"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a25b0195de53b1c24ead039ab6a74f474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a25b0195de53b1c24ead039ab6a74f474">operator*</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X1, const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X2)</td></tr>
<tr class="memdesc:a25b0195de53b1c24ead039ab6a74f474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of transforms.  <a href="#a25b0195de53b1c24ead039ab6a74f474">More...</a><br /></td></tr>
<tr class="separator:a25b0195de53b1c24ead039ab6a74f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa658b71de13e1f79accba3471066001d"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa658b71de13e1f79accba3471066001d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#aa658b71de13e1f79accba3471066001d">operator==</a> (const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X1, const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;X2)</td></tr>
<tr class="memdesc:aa658b71de13e1f79accba3471066001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operators return true only if the two transforms are bit identical; that's not too useful.  <a href="#aa658b71de13e1f79accba3471066001d">More...</a><br /></td></tr>
<tr class="separator:aa658b71de13e1f79accba3471066001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a11498c04820d2dd1185c61ee04a1d"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a92a11498c04820d2dd1185c61ee04a1d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Transform__.html#a92a11498c04820d2dd1185c61ee04a1d">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;)</td></tr>
<tr class="memdesc:a92a11498c04820d2dd1185c61ee04a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate formatted output of a Transform to an output stream.  <a href="#a92a11498c04820d2dd1185c61ee04a1d">More...</a><br /></td></tr>
<tr class="separator:a92a11498c04820d2dd1185c61ee04a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::Transform_&lt; P &gt;</h3>

<p>This class represents the rotate-and-shift transform which gives the location and orientation of a new frame F in a base (reference) frame B. </p>
<p>A frame is an orthogonal, right-handed set of three axes, and an origin point. A transform X from frame B to F consists of 3 perpendicular unit vectors defining F's axes as viewed from B (that is, as expressed in the basis formed by B's axes), and a vector from B's origin point Bo to F's origin point Fo. Note that the meaning of "B" comes from the context in which the transform is used. We use the phrase "frame F is in frame B" to describe the above relationship, that is, "in" means both measured from and expressed in.</p>
<p>The axis vectors constitute a <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a>. They are ordered 1-2-3 or x-y-z as you prefer, with z = x X y, making a right-handed set. These axes are arranged as columns of a 3x3 rotation matrix R_BF = [ x y z ] which is a direction cosine (rotation) matrix useful for conversions between frame B and F. (The columns of R_BF are F's coordinate axes, expressed in B.) For example, given a vector vF expressed in the F frame, that same vector re-expressed in B is given by vB = R_BF*vF. F's origin point OF is stored as the translation vector p_BF=(Fo-Bo) and expressed in B.</p>
<p>Transform is designed to behave as much as possible like the computer graphics 4x4 affine transform X which would be arranged like this: </p><pre></pre><pre>        [       |   ]
    X = [   R   | p ]    R is a 3x3 orthogonal rotation matrix
        [.......|...]    p is a 3x1 translation vector
        [ 0 0 0   1 ]
</pre><p>These can be composed directly by matrix multiplication, but more importantly they have a particularly simple inverse: </p><pre></pre><pre>   -1   [       |    ]
  X   = [  ~R   | p* ]   ~R is R transpose, p* = ~R(-p).
        [.......|....]
        [ 0 0 0   1  ] 
</pre><p>This inverse is so simple that we compute it simply by defining another type, <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a>, which is identical to Transform_ in memory but behaves as though it contains the inverse. That way we invert just by changing point of view (recasting) rather than computing.</p>
<p>This is a "POD" (plain old data) class with a well-defined memory layout on which a client of this class may depend: There are exactly 4 consecutive, packed 3-vectors in the order x,y,z,p. That is, this class is equivalent to an array of 12 Reals with the order x1,x2,x3,y1,y2,y3,z1,z2,z3,p1,p2,p3. It is expressly allowed to reinterpret Transform objects in any appropriate manner that depends on this memory layout. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa942cf29be6dfe83a94793a8b81dd2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa942cf29be6dfe83a94793a8b81dd2b2">&#9670;&nbsp;</a></span>Transform_() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor gives an identity transform. </p>

</div>
</div>
<a id="a9df212001307fcfc4e33cf3aa8817c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df212001307fcfc4e33cf3aa8817c90">&#9670;&nbsp;</a></span>Transform_() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine a rotation and a translation into a transform. </p>

</div>
</div>
<a id="a57fbe8b9a20fb1bdea86d041bc6d8a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fbe8b9a20fb1bdea86d041bc6d8a62">&#9670;&nbsp;</a></span>Transform_() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct or default-convert a rotation into a transform containing that rotation and zero translation. </p>

</div>
</div>
<a id="a7c35260adc6730882709e597db78a18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c35260adc6730882709e597db78a18b">&#9670;&nbsp;</a></span>Transform_() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct or default-convert a translation (expressed as a Vec3) into a transform with that translation and a zero rotation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a88d6ac8f3fef3c908264601b84bd6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d6ac8f3fef3c908264601b84bd6d07">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from InverseTransform. </p>
<p>This means that the transform we're assigning to must end up with the same <em>meaning</em> as the inverse transform X has, so we'll need to end up with: </p><ul>
<li>p == X.p() </li>
<li>R == X.R()</li>
</ul>
<p>Cost: one frame conversion and a negation, 18 flops. </p>

</div>
</div>
<a id="accc0c88a25651fc828e217376765e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc0c88a25651fc828e217376765e425">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an offset to the position vector in this Transform. </p>
<p>Cost is 3 flops. </p>

</div>
</div>
<a id="a82a5dba99e12f4d7e53a3d71c9e7ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a5dba99e12f4d7e53a3d71c9e7ada5">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract an offset from the position vector in this Transform. </p>
<p>Cost is 3 flops. </p>

</div>
</div>
<a id="a7254c6803ccc46ee6ac745ee40da464a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7254c6803ccc46ee6ac745ee40da464a">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new value to this transform, explicitly providing the rotation and translation separately. </p>
<p>We return a reference to the now-modified transform as though this were an assignment operator. </p>

</div>
</div>
<a id="accffbeb421e93b37b303c4eceae81e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accffbeb421e93b37b303c4eceae81e67">&#9670;&nbsp;</a></span>setToZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::setToZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By zero we mean "zero transform", i.e., an identity rotation and zero translation. </p>
<p>We return a reference to the now-modified transform as though this were an assignment operator. </p>

</div>
</div>
<a id="a3f5acadb0389eb80373a4cd766e2c6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5acadb0389eb80373a4cd766e2c6f4">&#9670;&nbsp;</a></span>setToNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::setToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This fills both the rotation and translation with NaNs. </p>
<p>Note: this is <em>not</em> the same as a default-constructed transform, which is a legitimate identity transform instead. We return a reference to the now-modified transform as though this were an assignment operator. </p>

</div>
</div>
<a id="a8246a173e41efc5f172dc6669e41c7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8246a173e41efc5f172dc6669e41c7ee">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only inverse of the current <a class="el" href="classSimTK_1_1Transform__.html" title="This class represents the rotate-and-shift transform which gives the location and orientation of a ne...">Transform_</a>. </p>
<p>, simply by casting it to the <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a></p>
<p>type. Zero cost. </p>

</div>
</div>
<a id="a38e61c08d0cc6e37131ce9f6ac0fb378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e61c08d0cc6e37131ce9f6ac0fb378">&#9670;&nbsp;</a></span>updInvert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::updInvert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable (lvalue) inverse of the current transform, simply by casting it to the <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a>. </p>
<p>type. That is, this is an lvalue. Zero cost. </p>

</div>
</div>
<a id="a71b7a421f3b787fe90c0e20fc315b994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b7a421f3b787fe90c0e20fc315b994">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload transpose operator to mean inversion. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Transform__.html#a8246a173e41efc5f172dc6669e41c7ee" title="Return a read-only inverse of the current Transform_. ">invert</a> </dd></dl>

</div>
</div>
<a id="abe62f45f57315377f9b2d73849bf45be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe62f45f57315377f9b2d73849bf45be">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload transpose operator to mean inversion. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Transform__.html#a38e61c08d0cc6e37131ce9f6ac0fb378" title="Return a writable (lvalue) inverse of the current transform, simply by casting it to the InverseTrans...">updInvert</a> </dd></dl>

</div>
</div>
<a id="aabccf7acd60742a6911e55e6a949cbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabccf7acd60742a6911e55e6a949cbb2">&#9670;&nbsp;</a></span>compose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a> <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FY</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose the current transform (X_BF) with the given one. </p>
<p>That is, return X_BY=X_BF*X_FY. Cost is 63 flops. </p>

</div>
</div>
<a id="a02ff49bd518a5e8c02374023140dc0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ff49bd518a5e8c02374023140dc0f1">&#9670;&nbsp;</a></span>compose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::compose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseTransform__.html">InverseTransform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FY</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compose the current transform (X_BF) with one that is supplied as an <a class="el" href="classSimTK_1_1InverseTransform__.html" title="Transform from frame B to frame F, but with the internal representation inverted. ...">InverseTransform_</a> (typically as a result of applying the "~" operator to a transform). </p>
<p>That is, return X_BY=X_BF*X_FY, but now X_FY is represented as ~X_YF. Cost is an extra 18 flops to calculate X_FY.p(), total 81 flops. </p>

</div>
</div>
<a id="acd634d41bfcc406e3b3960d26d35622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd634d41bfcc406e3b3960d26d35622c">&#9670;&nbsp;</a></span>xformFrameVecToBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::xformFrameVecToBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>vF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a vector expressed in our "F" frame to our "B" frame. </p>
<p>Note that this involves rotation only; it is independent of the translation stored in this transform. Cost is 15 flops. </p>

</div>
</div>
<a id="a1b272a12d45859508f4a9e52504ac7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b272a12d45859508f4a9e52504ac7d7">&#9670;&nbsp;</a></span>xformBaseVecToFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::xformBaseVecToFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>vB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a vector expressed in our "B" frame to our "F" frame. </p>
<p>Note that this involves rotation only; it is independent of the translation stored in this transform. Cost is 15 flops. </p>

</div>
</div>
<a id="a46e4ea049413e0cd6d3be1151bedfbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e4ea049413e0cd6d3be1151bedfbfb">&#9670;&nbsp;</a></span>shiftFrameStationToBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::shiftFrameStationToBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>sF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a point (station) measured from and expressed in our "F" frame to that same point but measured from and expressed in our "B" frame. </p>
<p>Cost is 18 flops. </p>

</div>
</div>
<a id="a9fbd8b0a0ce69193eeabab453bcaa51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbd8b0a0ce69193eeabab453bcaa51f">&#9670;&nbsp;</a></span>shiftBaseStationToFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::shiftBaseStationToFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>sB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a point (station) measured from and expressed in our "B" frame to that same point but measured from and expressed in our "F" frame. </p>
<p>Cost is 18 flops. </p>

</div>
</div>
<a id="a8e7a061a9801ca4ae0fa57de663ac9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7a061a9801ca4ae0fa57de663ac9ea">&#9670;&nbsp;</a></span>R()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::R </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to the contained rotation R_BF. </p>

</div>
</div>
<a id="a1c0dfb4616800cb27dbff93494f74a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0dfb4616800cb27dbff93494f74a96">&#9670;&nbsp;</a></span>updR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::updR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable (lvalue) reference to the contained rotation R_BF. </p>

</div>
</div>
<a id="a509f83803b53f503045203fa4f50944a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509f83803b53f503045203fa4f50944a">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt;P&gt;::ColType&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to the x direction (unit vector) of the F frame, expressed in the B frame. </p>

</div>
</div>
<a id="a9ea54db7ea450eedced56ccaf9fe62a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea54db7ea450eedced56ccaf9fe62a5">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt;P&gt;::ColType&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to the y direction (unit vector) of the F frame, expressed in the B frame. </p>

</div>
</div>
<a id="a92f849e7adcd47d614d7b20ec412263d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f849e7adcd47d614d7b20ec412263d">&#9670;&nbsp;</a></span>z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt;P&gt;::ColType&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::z </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to the z direction (unit vector) of the F frame, expressed in the B frame. </p>

</div>
</div>
<a id="ac586fb7db5e01921dcc61a8cf3ae949d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac586fb7db5e01921dcc61a8cf3ae949d">&#9670;&nbsp;</a></span>RInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::RInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to the inverse (transpose) of our contained rotation, that is R_FB. </p>

</div>
</div>
<a id="ac9ad027199c1f83bd34b377e52002afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ad027199c1f83bd34b377e52002afe">&#9670;&nbsp;</a></span>updRInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::updRInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable (lvalue) reference to the inverse (transpose) of our contained rotation, that is R_FB. </p>

</div>
</div>
<a id="a082a5d4c827fd8ea2788cb6b4cf6a9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082a5d4c827fd8ea2788cb6b4cf6a9c8">&#9670;&nbsp;</a></span>p()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a read-only reference to our translation vector p_BF. </p>

</div>
</div>
<a id="adc620dd92c973510862ca3dc1ed2d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc620dd92c973510862ca3dc1ed2d4a2">&#9670;&nbsp;</a></span>updP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::updP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable (lvalue) reference to our translation vector p_BF. </p>
<p>Caution: if you write through this reference you update the transform. </p>

</div>
</div>
<a id="a8244bef7c4c612515fff52ad226f08b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8244bef7c4c612515fff52ad226f08b3">&#9670;&nbsp;</a></span>setP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::setP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new value to our translation vector. </p>
<p>We expect the supplied vector <code>p</code> to be expressed in our B frame. A reference to the now-modified transform is returned as though this were an assignment operator. </p>

</div>
</div>
<a id="a0322759566d62fc5e59ac709c6a95c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0322759566d62fc5e59ac709c6a95c93">&#9670;&nbsp;</a></span>pInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::pInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the inverse of the translation vector in this transform. </p>
<p>The returned vector will be the negative of the original and will be expressed in the F frame rather than our B frame. Cost is 18 flops. </p>

</div>
</div>
<a id="a337e6d26f7a989df392dc8e43ecc38c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337e6d26f7a989df392dc8e43ecc38c8">&#9670;&nbsp;</a></span>setPInv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::setPInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a value to the <em>inverse</em> of our translation vector. </p>
<p>That is, we're given a vector in F which we invert and reexpress in B to store it in p, so that we get the original argument back if we ask for the inverse of p. Sorry, can't update pInv as an lvalue, but here we want -(~R_BF*p_BF)=p_FB =&gt; p_BF=-(R_BF*p_FB) so we can calculate it in 18 flops. A reference to the now-modified transform is returned as though this were an assignment operator. </p>

</div>
</div>
<a id="a0f91216176dd9746651c159c9b4bd2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f91216176dd9746651c159c9b4bd2d5">&#9670;&nbsp;</a></span>asMat34()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;3,4,P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::asMat34 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast this transform as a read-only 3x4 matrix. </p>
<p>This is a zero-cost reinterpretation of the data; the first three columns are the columns of the rotation and the last column is the translation. </p>

</div>
</div>
<a id="ad873446f35c5c2332758db410c2c17db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad873446f35c5c2332758db410c2c17db">&#9670;&nbsp;</a></span>toMat34()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;3,4,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::toMat34 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less efficient version of <a class="el" href="classSimTK_1_1Transform__.html#a0f91216176dd9746651c159c9b4bd2d5" title="Recast this transform as a read-only 3x4 matrix. ">asMat34()</a>; copies into return variable. </p>

</div>
</div>
<a id="a5894493db41a95c3d3c3a439f064464c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5894493db41a95c3d3c3a439f064464c">&#9670;&nbsp;</a></span>toMat44()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,4,P&gt; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::toMat44 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the equivalent 4x4 transformation matrix. </p>

</div>
</div>
<a id="ae8966a733837d4f06fa86b5f5a9011ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8966a733837d4f06fa86b5f5a9011ed">&#9670;&nbsp;</a></span>T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dd9b7821ea0a831494b7f729a1de2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd9b7821ea0a831494b7f729a1de2f5">&#9670;&nbsp;</a></span>updT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt;&amp; <a class="el" href="classSimTK_1_1Transform__.html">SimTK::Transform_</a>&lt; P &gt;::updT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6431752e53d0aa5556082a0282a8a214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6431752e53d0aa5556082a0282a8a214">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we multiply a transform or inverse transform by a 3-vector, we treat the vector as though it had a 4th element "1" appended, that is, it is treated as a <em>station</em> rather than a <em>vector</em>. </p>
<p>This way we use both the rotational and translational components of the transform. </p>

</div>
</div>
<a id="af47aa26f1160b2408a72eb2fb25ce332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47aa26f1160b2408a72eb2fb25ce332">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adding a 3-vector to a Transform produces a new shifted transform. </p>

</div>
</div>
<a id="a02f24668c1938312872432428c5999e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f24668c1938312872432428c5999e9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adding a 3-vector to a Transform produces a new shifted transform. </p>

</div>
</div>
<a id="a5dfc1ed3b6d6a82633d1e9c3eb9e5f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfc1ed3b6d6a82633d1e9c3eb9e5f84">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracting a 3-vector from a Transform produces a new shifted transform. </p>

</div>
</div>
<a id="aa6a5a44119a5823a29eeeb578b6346f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a5a44119a5823a29eeeb578b6346f3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we multiply a transform or inverse transform by an augmented 4-vector, we use the 4th element to decide how to treat it. </p>
<p>The 4th element must be 0 or 1. If 0 it is treated as a vector only and the translation is ignored. If 1 it is treated as a station and rotated &amp; shifted. </p>

</div>
</div>
<a id="a7a55bee4fe245a448b2084aac7c3d847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a55bee4fe245a448b2084aac7c3d847">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__TypedNumConstants.html#ga62e94c379e736581bd70ce4647168f95">E</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1VectorBase.html">VectorBase</a>&lt; <a class="el" href="group__TypedNumConstants.html#ga62e94c379e736581bd70ce4647168f95">E</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplying a matrix or vector by a <a class="el" href="classSimTK_1_1Transform__.html" title="This class represents the rotate-and-shift transform which gives the location and orientation of a ne...">Transform_</a>. </p>
<p>applies it to each element individually. </p>

</div>
</div>
<a id="a25b0195de53b1c24ead039ab6a74f474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b0195de53b1c24ead039ab6a74f474">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Composition of transforms. </p>
<p>Operators are provided for all the combinations of transform and inverse transform. </p>

</div>
</div>
<a id="aa658b71de13e1f79accba3471066001d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa658b71de13e1f79accba3471066001d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>X2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operators return true only if the two transforms are bit identical; that's not too useful. </p>

</div>
</div>
<a id="a92a11498c04820d2dd1185c61ee04a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a11498c04820d2dd1185c61ee04a1d">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Transform__.html">Transform_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate formatted output of a Transform to an output stream. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Transform_8h_source.html">Transform.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Transform__.html">Transform_</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:18 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
