<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: Spatial Algebra Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__SpatialAlgebraUtilities.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Spatial Algebra Utilities<div class="ingroups"><a class="el" href="group__GlobalFunctions.html">Global Functions in the SimTK namespace</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>These utility functions are used for manipulation of spatial quantities that are contained in SpatialVec or SpatialMat objects.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga09c3f8ce9203cc999a69e18bdfa299ea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 2, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SimTK::SpatialVec</a></td></tr>
<tr class="memdesc:ga09c3f8ce9203cc999a69e18bdfa299ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial vectors are used for (rotation,translation) quantities and consist of a pair of Vec3 objects, arranged as a 2-vector of 3-vectors.  <a href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">More...</a><br /></td></tr>
<tr class="separator:ga09c3f8ce9203cc999a69e18bdfa299ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa093939834c7a15587de84b8fa379572"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 2, <a class="el" href="group__MatVecTypedefs.html#ga7b64644262553826ece08af3613697b1">Row3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gaa093939834c7a15587de84b8fa379572">SimTK::SpatialRow</a></td></tr>
<tr class="memdesc:gaa093939834c7a15587de84b8fa379572"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a transposed SpatialVec; it does not usually appear explicitly in user programs.  <a href="group__SpatialAlgebraUtilities.html#gaa093939834c7a15587de84b8fa379572">More...</a><br /></td></tr>
<tr class="separator:gaa093939834c7a15587de84b8fa379572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d661c98a4b9595b84102e835800511"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 2, 2, <a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga62d661c98a4b9595b84102e835800511">SimTK::SpatialMat</a></td></tr>
<tr class="memdesc:ga62d661c98a4b9595b84102e835800511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatial matrices are used to hold 6x6 matrices that are best viewed as 2x2 matrices of 3x3 matrices; most commonly for spatial and articulated body inertias and spatial shift matrices.  <a href="group__SpatialAlgebraUtilities.html#ga62d661c98a4b9595b84102e835800511">More...</a><br /></td></tr>
<tr class="separator:ga62d661c98a4b9595b84102e835800511"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1356d52bc6c756a65449cf77b6ed450c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga1356d52bc6c756a65449cf77b6ed450c">SimTK::findRelativeVelocity</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FA, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FB)</td></tr>
<tr class="memdesc:ga1356d52bc6c756a65449cf77b6ed450c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the relative spatial velocity between two frames A and B whose individual spatial velocities are known with respect to a third frame F, with the result returned in A.  <a href="group__SpatialAlgebraUtilities.html#ga1356d52bc6c756a65449cf77b6ed450c">More...</a><br /></td></tr>
<tr class="separator:ga1356d52bc6c756a65449cf77b6ed450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29f226e57ded5cd16a97087bf6cbc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gaa29f226e57ded5cd16a97087bf6cbc7a">SimTK::findRelativeVelocityInF</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_AB_F, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FB)</td></tr>
<tr class="memdesc:gaa29f226e57ded5cd16a97087bf6cbc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the relative spatial velocity between two frames A and B whose individual spatial velocities are known in a third frame F, but leave the result in F.  <a href="group__SpatialAlgebraUtilities.html#gaa29f226e57ded5cd16a97087bf6cbc7a">More...</a><br /></td></tr>
<tr class="separator:gaa29f226e57ded5cd16a97087bf6cbc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ea6030e591f841957fe57c2e8e9856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gab4ea6030e591f841957fe57c2e8e9856">SimTK::findRelativeAcceleration</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_FA, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_FB)</td></tr>
<tr class="memdesc:gab4ea6030e591f841957fe57c2e8e9856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the relative spatial acceleration between two frames A and B whose individual spatial accelerations are known with respect to a third frame F, with the result returned in A.  <a href="group__SpatialAlgebraUtilities.html#gab4ea6030e591f841957fe57c2e8e9856">More...</a><br /></td></tr>
<tr class="separator:gab4ea6030e591f841957fe57c2e8e9856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c33467c25c79e11eb6f9cdc6b31589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gaf0c33467c25c79e11eb6f9cdc6b31589">SimTK::findRelativeAccelerationInF</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_AB_F, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_FA, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_FB)</td></tr>
<tr class="memdesc:gaf0c33467c25c79e11eb6f9cdc6b31589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the relative spatial acceleration between two frames A and B whose individual spatial acceleration are known in a third frame F, but leave the result in F.  <a href="group__SpatialAlgebraUtilities.html#gaf0c33467c25c79e11eb6f9cdc6b31589">More...</a><br /></td></tr>
<tr class="separator:gaf0c33467c25c79e11eb6f9cdc6b31589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39da5fe5d3cc806ba5e0d1da41d5638f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f">SimTK::reverseRelativeVelocity</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_AB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_AB)</td></tr>
<tr class="memdesc:ga39da5fe5d3cc806ba5e0d1da41d5638f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of frame A in B.  <a href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f">More...</a><br /></td></tr>
<tr class="separator:ga39da5fe5d3cc806ba5e0d1da41d5638f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cd519023caf21595f9346121cbc69d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gaf6cd519023caf21595f9346121cbc69d">SimTK::reverseRelativeVelocityInA</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_AB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_AB)</td></tr>
<tr class="memdesc:gaf6cd519023caf21595f9346121cbc69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of frame A in B, but leave the result expressed in frame A.  <a href="group__SpatialAlgebraUtilities.html#gaf6cd519023caf21595f9346121cbc69d">More...</a><br /></td></tr>
<tr class="separator:gaf6cd519023caf21595f9346121cbc69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e629bd9aead45c34c02f6448127edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga64e629bd9aead45c34c02f6448127edc">SimTK::shiftVelocityBy</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_AB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;r_A)</td></tr>
<tr class="memdesc:ga64e629bd9aead45c34c02f6448127edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a relative spatial velocity measured at some point to that same relative spatial quantity but measured at a new point given by an offset from the old one.  <a href="group__SpatialAlgebraUtilities.html#ga64e629bd9aead45c34c02f6448127edc">More...</a><br /></td></tr>
<tr class="separator:ga64e629bd9aead45c34c02f6448127edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606c054f4a71108a91b5f6e61bedef87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga606c054f4a71108a91b5f6e61bedef87">SimTK::shiftVelocityFromTo</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_A_BP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;fromP_A, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;toQ_A)</td></tr>
<tr class="memdesc:ga606c054f4a71108a91b5f6e61bedef87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a relative spatial velocity measured at some point P to that same relative spatial quantity but measured at a new point Q given the points P and Q.  <a href="group__SpatialAlgebraUtilities.html#ga606c054f4a71108a91b5f6e61bedef87">More...</a><br /></td></tr>
<tr class="separator:ga606c054f4a71108a91b5f6e61bedef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b44f1ea5624daf334b4aa6c0e07ea0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e">SimTK::shiftForceBy</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F_AP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;r_A)</td></tr>
<tr class="memdesc:ga2b44f1ea5624daf334b4aa6c0e07ea0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a spatial force applied at some point of a body to that same spatial force applied at a new point given by an offset from the old one.  <a href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e">More...</a><br /></td></tr>
<tr class="separator:ga2b44f1ea5624daf334b4aa6c0e07ea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d7f9be4b5cabe22b3ad7c1eef94be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga76d7f9be4b5cabe22b3ad7c1eef94be9">SimTK::shiftForceFromTo</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F_AP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;fromP_A, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;toQ_A)</td></tr>
<tr class="memdesc:ga76d7f9be4b5cabe22b3ad7c1eef94be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a spatial force applied at some point P of a body to that same spatial force applied at a new point Q, given P and Q.  <a href="group__SpatialAlgebraUtilities.html#ga76d7f9be4b5cabe22b3ad7c1eef94be9">More...</a><br /></td></tr>
<tr class="separator:ga76d7f9be4b5cabe22b3ad7c1eef94be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd275315e4cfd899f739fad664c1720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720">SimTK::shiftAccelerationBy</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_AB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;w_AB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;r_A)</td></tr>
<tr class="memdesc:ga4cd275315e4cfd899f739fad664c1720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a relative spatial acceleration measured at some point to that same relative spatial quantity but measured at a new point given by an offset from the old one.  <a href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720">More...</a><br /></td></tr>
<tr class="separator:ga4cd275315e4cfd899f739fad664c1720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5349929701832c2c4020d1ef38ad9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpatialAlgebraUtilities.html#gab5349929701832c2c4020d1ef38ad9f0">SimTK::shiftAccelerationFromTo</a> (const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;A_A_BP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;w_AB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;fromP_A, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;toQ_A)</td></tr>
<tr class="memdesc:gab5349929701832c2c4020d1ef38ad9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a relative spatial acceleration measured at some point P to that same relative spatial quantity but measured at a new point Q given the points P and Q.  <a href="group__SpatialAlgebraUtilities.html#gab5349929701832c2c4020d1ef38ad9f0">More...</a><br /></td></tr>
<tr class="separator:gab5349929701832c2c4020d1ef38ad9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These utility functions are used for manipulation of spatial quantities that are contained in SpatialVec or SpatialMat objects. </p>
<p>These are intended for expert use and are mostly used in the implemention of friendlier methods such as those in <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> that are used to obtain various spatial quantities.</p>
<dl class="section note"><dt>Note</dt><dd>Although we use SpatialVec for both, there are two different spatial vector bases: one for motion quantities like velocities, accelerations, and momentum and another for forces and impulses; be sure to use the appropriate functions. Also, we use a pair of ordinary vectors, following Abhi Jain, rather than the similar but subtly different Plucker basis vectors used by Roy Featherstone.</dd></dl>
<p>Spatial vectors are used for combined (rotational,translational) quantities. These include </p><pre class="fragment">     spatial velocity     = (angularVelocity,linearVelocity)
     spatial acceleration = (angularAcceleration,linearAcceleration)
     spatial force        = (moment,force)
</pre><p>Spatial configuration (pose) has to be handled differently though since orientation is not a vector quantity. We use the Transform class for this concept, which includes an orientation matrix and a translation vector. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga09c3f8ce9203cc999a69e18bdfa299ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c3f8ce9203cc999a69e18bdfa299ea">&#9670;&nbsp;</a></span>SpatialVec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 2, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SimTK::SpatialVec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spatial vectors are used for (rotation,translation) quantities and consist of a pair of Vec3 objects, arranged as a 2-vector of 3-vectors. </p>
<p>SpatialVec[0] is the rotational component; [1] is translational.</p>
<p>Quantities represented this way include</p><ul>
<li>spatial velocity = (angularVelocity,linearVelocity)</li>
<li>spatial acceleration = (angularAcceleration,linearAcceleration)</li>
<li>generalized forces = (torque,force)</li>
</ul>
<p>Spatial configuration has to be handled differently though since orientation is not a vector quantity. (We use Transform for this concept which includes a Rotation matrix and a translation Vec3.)</p>

</div>
</div>
<a id="gaa093939834c7a15587de84b8fa379572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa093939834c7a15587de84b8fa379572">&#9670;&nbsp;</a></span>SpatialRow</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 2, <a class="el" href="group__MatVecTypedefs.html#ga7b64644262553826ece08af3613697b1">Row3</a> &gt; <a class="el" href="group__SpatialAlgebraUtilities.html#gaa093939834c7a15587de84b8fa379572">SimTK::SpatialRow</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a transposed SpatialVec; it does not usually appear explicitly in user programs. </p>
<p>This is the type of a transposed SpatialVec.</p>

</div>
</div>
<a id="ga62d661c98a4b9595b84102e835800511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62d661c98a4b9595b84102e835800511">&#9670;&nbsp;</a></span>SpatialMat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 2, 2, <a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> &gt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga62d661c98a4b9595b84102e835800511">SimTK::SpatialMat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spatial matrices are used to hold 6x6 matrices that are best viewed as 2x2 matrices of 3x3 matrices; most commonly for spatial and articulated body inertias and spatial shift matrices. </p>
<p>This is used for primarily for spatial mass properties.</p>
<p>They also arise commonly as intermediates in computations involving SpatialVec objects.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1356d52bc6c756a65449cf77b6ed450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1356d52bc6c756a65449cf77b6ed450c">&#9670;&nbsp;</a></span>findRelativeVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::findRelativeVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the relative spatial velocity between two frames A and B whose individual spatial velocities are known with respect to a third frame F, with the result returned in A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X_FA</td><td>The pose of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FA</td><td>The spatial velocity of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_FB</td><td>The pose of frame B measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FB</td><td>The spatial velocity of frame B measured and expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_AB, the relative spatial velocity of frame B in frame A, expressed in A.</dd></dl>
<p>Given the spatial velocity V_FA of frame A in a reference frame F, and the spatial velocity V_FB of frame B in F, and transforms giving the poses of frames A and B in F, calculate the relative velocity V_AB of frame B in frame A, measured and expressed in A. Typical usage: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_GA, X_GB;      <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_GA, V_GB;</div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB = <a class="code" href="group__SpatialAlgebraUtilities.html#ga1356d52bc6c756a65449cf77b6ed450c">findRelativeVelocity</a>(X_GA, V_GA, </div><div class="line">                                       X_GB, V_GB);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This returns the result expressed in A which is almost always what you want; however, if you don't want it in that frame you can save 30 flops by calling <a class="el" href="group__SpatialAlgebraUtilities.html#gaa29f226e57ded5cd16a97087bf6cbc7a" title="Find the relative spatial velocity between two frames A and B whose individual spatial velocities are...">findRelativeVelocityInF()</a> instead.</dd></dl>
<p>Cost is 51 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#gaa29f226e57ded5cd16a97087bf6cbc7a" title="Find the relative spatial velocity between two frames A and B whose individual spatial velocities are...">findRelativeVelocityInF()</a> </dd></dl>

</div>
</div>
<a id="gaa29f226e57ded5cd16a97087bf6cbc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa29f226e57ded5cd16a97087bf6cbc7a">&#9670;&nbsp;</a></span>findRelativeVelocityInF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::findRelativeVelocityInF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_AB_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the relative spatial velocity between two frames A and B whose individual spatial velocities are known in a third frame F, but leave the result in F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_AB_F</td><td>The vector from the A frame origin OA to the B frame origin OB, but expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FA</td><td>The spatial velocity of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FB</td><td>The spatial velocity of frame B measured and expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_AB_F, the relative spatial velocity of frame B in frame A, but still expressed in F.</dd></dl>
<p>Typically the relative velocity of B in A would be returned in A; most users will want to use <a class="el" href="group__SpatialAlgebraUtilities.html#ga1356d52bc6c756a65449cf77b6ed450c" title="Find the relative spatial velocity between two frames A and B whose individual spatial velocities are...">findRelativeVelocity()</a> instead which returns the result in A. Use of this method saves the substantial cost of reexpressing the result, so is useful in the rare case that you don't want the final result in A. Example: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_GA, X_GB;      <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_GA, V_GB;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> p_AB_G = X_GB.p() - X_GA.p();</div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB_G = <a class="code" href="group__SpatialAlgebraUtilities.html#gaa29f226e57ded5cd16a97087bf6cbc7a">findRelativeVelocityInF</a>(p_AB_G, V_GA, V_GB);</div></div><!-- fragment --><p> Cost is 18 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga1356d52bc6c756a65449cf77b6ed450c" title="Find the relative spatial velocity between two frames A and B whose individual spatial velocities are...">findRelativeVelocity()</a> </dd></dl>

</div>
</div>
<a id="gab4ea6030e591f841957fe57c2e8e9856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4ea6030e591f841957fe57c2e8e9856">&#9670;&nbsp;</a></span>findRelativeAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::findRelativeAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the relative spatial acceleration between two frames A and B whose individual spatial accelerations are known with respect to a third frame F, with the result returned in A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X_FA</td><td>The pose of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FA</td><td>The spatial velocity of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_FA</td><td>The spatial acceleration of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_FB</td><td>The pose of frame B measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FB</td><td>The spatial velocity of frame B measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_FB</td><td>The spatial acceleration of frame B measured and expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_AB, the relative spatial acceleration of frame B in frame A, expressed in A.</dd></dl>
<p>Given the spatial acceleration A_FA of frame A in a reference frame F, and the spatial acceleration A_FB of frame B in F, and corresonding pose and velocity information, calculate the relative acceleration A_AB of frame B in frame A, measured and expressed in A. Typical usage: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_GA, X_GB;      <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_GA, V_GB;</div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_GA, A_GB;</div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_AB = <a class="code" href="group__SpatialAlgebraUtilities.html#gab4ea6030e591f841957fe57c2e8e9856">findRelativeAcceleration</a>(X_GA, V_GA, A_GA,</div><div class="line">                                           X_GB, V_GB, A_GB);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This returns the result expressed in A which is almost always what you want; however, if you don't want it in that frame you can save 30 flops by calling <a class="el" href="group__SpatialAlgebraUtilities.html#gaf0c33467c25c79e11eb6f9cdc6b31589" title="Find the relative spatial acceleration between two frames A and B whose individual spatial accelerati...">findRelativeAccelerationInF()</a> instead.</dd></dl>
<p>Cost is 105 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#gaf0c33467c25c79e11eb6f9cdc6b31589" title="Find the relative spatial acceleration between two frames A and B whose individual spatial accelerati...">findRelativeAccelerationInF()</a> </dd></dl>

</div>
</div>
<a id="gaf0c33467c25c79e11eb6f9cdc6b31589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c33467c25c79e11eb6f9cdc6b31589">&#9670;&nbsp;</a></span>findRelativeAccelerationInF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::findRelativeAccelerationInF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_AB_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the relative spatial acceleration between two frames A and B whose individual spatial acceleration are known in a third frame F, but leave the result in F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_AB_F</td><td>The vector from the A frame origin OA to the B frame origin OB, but expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FA</td><td>The spatial velocity of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_FA</td><td>The spatial acceleration of frame A measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_FB</td><td>The spatial velocity of frame B measured and expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_FB</td><td>The spatial acceleration of frame B measured and expressed in frame F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_AB_F, the relative spatial acceleration of frame B in frame A, but still expressed in F.</dd></dl>
<p>Typically the relative acceleration of B in A would be returned in A; most users will want to use <a class="el" href="group__SpatialAlgebraUtilities.html#gab4ea6030e591f841957fe57c2e8e9856" title="Find the relative spatial acceleration between two frames A and B whose individual spatial accelerati...">findRelativeAcceleration()</a> instead which returns the result in A. Use of this method saves the substantial cost of reexpressing the result, so is useful in the rare case that you don't want the final result in A. Example: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_GA, X_GB;      <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_GA, V_GB;</div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_GA, A_GB;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> p_AB_G = X_GB.p() - X_GA.p();</div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_AB_G = <a class="code" href="group__SpatialAlgebraUtilities.html#gaf0c33467c25c79e11eb6f9cdc6b31589">findRelativeAccelerationInF</a>(p_AB_G, V_GA, A_GA,</div><div class="line">                                                        V_GB, A_GB);</div></div><!-- fragment --><p> Cost is 72 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#gab4ea6030e591f841957fe57c2e8e9856" title="Find the relative spatial acceleration between two frames A and B whose individual spatial accelerati...">findRelativeAcceleration()</a> </dd></dl>

</div>
</div>
<a id="ga39da5fe5d3cc806ba5e0d1da41d5638f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39da5fe5d3cc806ba5e0d1da41d5638f">&#9670;&nbsp;</a></span>reverseRelativeVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::reverseRelativeVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_AB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of frame A in B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X_AB</td><td>The pose of frame B in frame A, measured and expressed in A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_AB</td><td>The relative spatial velocity of frame B in frame A, measured and expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_BA, the relative spatial velocity of frame A in frame B, measured and expressed in B.</dd></dl>
<p>The input is expressed in the A frame; the result will be expressed in the B frame instead. If you prefer that the result remain in the A frame you should call <a class="el" href="group__SpatialAlgebraUtilities.html#gaf6cd519023caf21595f9346121cbc69d" title="Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of fram...">reverseRelativeVelocityInA()</a> instead to avoid the extra cost of changing frames. Example: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_AB;    <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB;</div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_BA = <a class="code" href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f">reverseRelativeVelocity</a>(X_AB, V_AB);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If the frame origins were in the same spatial location, then the result would just be the negative of the supplied velocity. However, since the linear component of spatial velocity has to be measured at a point, and we're switching from measuring at a point coincident with B's origin OB to one coincident with A's origin OA, there is going to be a change in the linear part of the result. The angular velocity will just be negated, though, and then reexpressed in B.</dd></dl>
<p>Cost is 51 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#gaf6cd519023caf21595f9346121cbc69d" title="Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of fram...">reverseRelativeVelocityInA()</a> </dd></dl>

</div>
</div>
<a id="gaf6cd519023caf21595f9346121cbc69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6cd519023caf21595f9346121cbc69d">&#9670;&nbsp;</a></span>reverseRelativeVelocityInA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::reverseRelativeVelocityInA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_AB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of frame A in B, but leave the result expressed in frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X_AB</td><td>The pose of frame B in frame A, measured and expressed in A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_AB</td><td>The relative spatial velocity of frame B in frame A, measured and expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_BA_A, the relative velocity of frame A in frame B, but still expressed in A.</dd></dl>
<p>The input V_AB is expressed in the A frame; you will almost always want the output V_BA expressed in the B frame which is what the function <a class="el" href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f" title="Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of fram...">reverseRelativeVelocity()</a> does. However, if you're going to want it in some other frame ultimately you may prefer to avoid the substantial cost of reexpressing it in B now, in which case this routine is useful.</p>
<p>See <a class="el" href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f" title="Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of fram...">reverseRelativeVelocity()</a> for more information about what this does. Example: </p><div class="fragment"><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_AB;    <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB;    <span class="comment">// (expressed in A)</span></div><div class="line"></div><div class="line"><span class="comment">// result is still expressed in A</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_BA_A = <a class="code" href="group__SpatialAlgebraUtilities.html#gaf6cd519023caf21595f9346121cbc69d">reverseRelativeVelocityInA</a>(X_AB, V_AB);</div></div><!-- fragment --><p>Cost is 21 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga39da5fe5d3cc806ba5e0d1da41d5638f" title="Given the relative velocity of frame B in frame A, reverse that to give the relative velocity of fram...">reverseRelativeVelocity()</a> </dd></dl>

</div>
</div>
<a id="ga64e629bd9aead45c34c02f6448127edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64e629bd9aead45c34c02f6448127edc">&#9670;&nbsp;</a></span>shiftVelocityBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftVelocityBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>r_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a relative spatial velocity measured at some point to that same relative spatial quantity but measured at a new point given by an offset from the old one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V_AB</td><td>The relative spatial velocity of frame B in frame A, measured and expressed in frame A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_A</td><td>The vector offset, expressed in frame A, by which to change the point at which the translational component of the relative spatial velocity is measured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_A_BQ, the relative velocity of frame B in frame A, but measured at the point Q=Bo+r rather than at B's origin Bo.</dd></dl>
<p>Given the spatial velocity V_AB of frame B in A, measured at a point coincident with B's origin Bo, change it to the spatial velocity V_A_BQ representing the same relationship but with the velocity measured at a new point Q=Bo+r for some position vector r. All vectors are measured and expressed in frame A, including the vector r. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB;     <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       offset_A; <span class="comment">// Q = Bo + offset</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_A_BQ = <a class="code" href="group__SpatialAlgebraUtilities.html#ga64e629bd9aead45c34c02f6448127edc">shiftVelocityBy</a>(V_AB, offset_A);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The shift in location leaves the relative angular velocity w the same but results in the linear velocity changing by w X r.</dd></dl>
<p>Cost is 12 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga606c054f4a71108a91b5f6e61bedef87" title="Shift a relative spatial velocity measured at some point P to that same relative spatial quantity but...">shiftVelocityFromTo()</a> </dd></dl>

</div>
</div>
<a id="ga606c054f4a71108a91b5f6e61bedef87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606c054f4a71108a91b5f6e61bedef87">&#9670;&nbsp;</a></span>shiftVelocityFromTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftVelocityFromTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_A_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>fromP_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>toQ_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a relative spatial velocity measured at some point P to that same relative spatial quantity but measured at a new point Q given the points P and Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V_A_BP</td><td>The relative spatial velocity of frame B in frame A, measured and expressed in frame A, with the linear component measured at a point P. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromP_A</td><td>The "from" point P at which the input linear velocity was measured, given as a vector from A's origin OA to the point P, expressed in A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toQ_A</td><td>The "to" point Q at which we want to re-measure the linear velocity, given as a vector from A's origin OA to the point Q, expressed in A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_A_BQ, the relative velocity of frame B in frame A, but measured at the point Q rather than at point P.</dd></dl>
<p>Given the spatial velocity V_A_BP of frame B in A, measured at a point P, change it to the spatial velocity V_A_BQ representing the same relationship but with the velocity measured at a new point Q. Example: </p><div class="fragment"><div class="line"><span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_AB;    <span class="comment">// contains the vector from OA to OB  </span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_AB;    <span class="comment">// linear velocity is measured at origin OB of B</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       p_AQ;    <span class="comment">// vector from OA to some other point Q, in A</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> V_A_BQ = <a class="code" href="group__SpatialAlgebraUtilities.html#ga606c054f4a71108a91b5f6e61bedef87">shiftVelocityFromTo</a>(V_AB, X_AB.p(), p_AQ);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is no way to know whether the supplied velocity was actually measured at P; this method really just shifts the relative velocity by the vector r=(to-from). Use it carefully.</dd></dl>
<p>Cost is 15 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga64e629bd9aead45c34c02f6448127edc" title="Shift a relative spatial velocity measured at some point to that same relative spatial quantity but m...">shiftVelocityBy()</a> </dd></dl>

</div>
</div>
<a id="ga2b44f1ea5624daf334b4aa6c0e07ea0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b44f1ea5624daf334b4aa6c0e07ea0e">&#9670;&nbsp;</a></span>shiftForceBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftForceBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F_AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>r_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a spatial force applied at some point of a body to that same spatial force applied at a new point given by an offset from the old one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F_AP</td><td>A spatial force (moment and linear force), expressed in the A frame, whose translational component is applied at a point P. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_A</td><td>The vector offset, expressed in frame A, by which to change the point at which the translational component of the input force is to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>F_AQ, the same physical effect as the input but with the moment adjusted to reflect force application at point Q=P+r rather than at the original point P.</dd></dl>
<p>Given the spatial force F_AP including a pure moment m and a force vector f applied at a point P, return the equivalent force F_AQ representing the same physical quantity but as though the force were applied at a point Q=P+r for some position vector r. All vectors are expressed in frame A. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> F_AP;     <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       offset_A; <span class="comment">// Q = P + offset</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> F_AQ = <a class="code" href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e">shiftForceBy</a>(F_AP, offset_A);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The shift in location leaves the force f the same but results in an adjustment to the moment of -(r X f).</dd></dl>
<p>Cost is 12 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga76d7f9be4b5cabe22b3ad7c1eef94be9" title="Shift a spatial force applied at some point P of a body to that same spatial force applied at a new p...">shiftForceFromTo()</a> </dd></dl>

</div>
</div>
<a id="ga76d7f9be4b5cabe22b3ad7c1eef94be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d7f9be4b5cabe22b3ad7c1eef94be9">&#9670;&nbsp;</a></span>shiftForceFromTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftForceFromTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F_AP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>fromP_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>toQ_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a spatial force applied at some point P of a body to that same spatial force applied at a new point Q, given P and Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F_AP</td><td>A spatial force (moment and linear force), expressed in the A frame, whose translational component is applied at a point P. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromP_A</td><td>The "from" point P at which the input force is applied, given as a vector from A's origin OA to the point P, expressed in A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toQ_A</td><td>The "to" point Q to which we want to move the force application point, given as a vector from A's origin OA to the point Q, expressed in A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>F_AQ, the same physical effect as the input but with the moment adjusted to reflect force application at point Q rather than at the original point P.</dd></dl>
<p>Given the spatial force F_AP including a pure moment m and a force vector f applied at a point P, return the equivalent force F_AQ representing the same physical quantity but as though the force were applied at a new point Q. All vectors are expressed in frame A and points are measured from A's origin OA. Example: </p><div class="fragment"><div class="line"><span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> F_AP;    <span class="comment">// linear force is applied at point P</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       p_AP;    <span class="comment">// vector from OA to P, in A</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       p_AQ;    <span class="comment">// vector from OA to some other point Q, in A</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> F_AQ = <a class="code" href="group__SpatialAlgebraUtilities.html#ga76d7f9be4b5cabe22b3ad7c1eef94be9">shiftForceFromTo</a>(F_AP, p_AP, p_AQ);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is no way to know whether the supplied force was actually applied at P; this method really just shifts the application point by the vector r=(to-from). Use it carefully.</dd></dl>
<p>Cost is 15 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e" title="Shift a spatial force applied at some point of a body to that same spatial force applied at a new poi...">shiftForceBy()</a> </dd></dl>

</div>
</div>
<a id="ga4cd275315e4cfd899f739fad664c1720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd275315e4cfd899f739fad664c1720">&#9670;&nbsp;</a></span>shiftAccelerationBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftAccelerationBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>w_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>r_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a relative spatial acceleration measured at some point to that same relative spatial quantity but measured at a new point given by an offset from the old one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_AB</td><td>The relative spatial acceleration of frame B in frame A, measured and expressed in frame A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_AB</td><td>The relative angular velocity of frame B in frame A, expressed in frame A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_A</td><td>The vector offset, expressed in frame A, by which to change the point at which the translational component of the relative spatial acceleration is measured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_A_BQ, the relative acceleration of frame B in frame A, but measured at the point Q=Bo+r rather than at B's origin Bo.</dd></dl>
<p>Given the spatial acceleration A_AB and angular velocity w_AB of frame B in A, measured at a point coincident with B's origin Bo, change it to the spatial acceleration A_A_BQ representing the same relationship but with the acceleration measured at a new point Q=Bo+r for some position vector r. All vectors are measured and expressed in frame A, including the vector r. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_AB;     <span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       w_AB;</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       offset_A; <span class="comment">// Q = Bo + offset</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_A_BQ = <a class="code" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720">shiftAccelerationBy</a>(A_AB, w_AB, offset_A);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The shift in location leaves the relative angular acceleration b the same but results in the linear acceleration changing by b X r + w X (w X r).</dd></dl>
<p>Cost is 33 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#gab5349929701832c2c4020d1ef38ad9f0" title="Shift a relative spatial acceleration measured at some point P to that same relative spatial quantity...">shiftAccelerationFromTo()</a> </dd></dl>

</div>
</div>
<a id="gab5349929701832c2c4020d1ef38ad9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5349929701832c2c4020d1ef38ad9f0">&#9670;&nbsp;</a></span>shiftAccelerationFromTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::shiftAccelerationFromTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>A_A_BP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>w_AB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>fromP_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>toQ_A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift a relative spatial acceleration measured at some point P to that same relative spatial quantity but measured at a new point Q given the points P and Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A_A_BP</td><td>The relative spatial acceleration of frame B in frame A, measured and expressed in frame A, with the linear component measured at a point P. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w_AB</td><td>The relative angular velocity of frame B in frame A, expressed in frame A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fromP_A</td><td>The "from" point P at which the input linear acceleration was measured, given as a vector from A's origin Ao to the point P, expressed in A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toQ_A</td><td>The "to" point Q at which we want to re-measure the linear acceleration, given as a vector from A's origin Ao to the point Q, expressed in A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A_A_BQ, the relative acceleration of frame B in frame A, but measured at the point Q rather than at point P.</dd></dl>
<p>Given the spatial acceleration A_A_BP of frame B in A, measured at a point P, change it to the spatial acceleration A_A_BQ representing the same relationship but with the acceleration measured at a new point Q. Example: </p><div class="fragment"><div class="line"><span class="comment">// assume these are known from somewhere</span></div><div class="line"><a class="code" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>  X_AB;    <span class="comment">// contains the vector from Ao to Bo  </span></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_AB;    <span class="comment">// linear acceleration is measured at origin Bo of B</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       w_AB;</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>       p_AQ;    <span class="comment">// vector from Ao to some other point Q, in A</span></div><div class="line"></div><div class="line"><a class="code" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> A_A_BQ = <a class="code" href="group__SpatialAlgebraUtilities.html#gab5349929701832c2c4020d1ef38ad9f0">shiftAccelerationFromTo</a>(A_AB, w_AB, X_AB.p(), p_AQ);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is no way to know whether the supplied acceleration was actually measured at P; this method really just shifts the relative acceleration by the vector r=(to-from). Use it carefully.</dd></dl>
<p>Cost is 36 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720" title="Shift a relative spatial acceleration measured at some point to that same relative spatial quantity b...">shiftAccelerationBy()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:11 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
