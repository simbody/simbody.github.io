<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Rotation_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Rotation__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="classSimTK_1_1Rotation__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Rotation_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 rotation matrix giving the relative orientation of two right-handed, orthogonal, unit vector bases.  
 <a href="classSimTK_1_1Rotation__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Rotation_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Rotation__.png" usemap="#SimTK::Rotation_5F_3C_20P_20_3E_map" alt=""/>
  <map id="SimTK::Rotation_5F_3C_20P_20_3E_map" name="SimTK::Rotation_5F_3C_20P_20_3E_map">
<area href="classSimTK_1_1Mat.html" alt="SimTK::Mat&lt; 3, 3, P &gt;" shape="rect" coords="0,0,138,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3e2fe478b01daff763b20886c3773430"><td class="memItemLeft" align="right" valign="top">typedef P&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a></td></tr>
<tr class="memdesc:a3e2fe478b01daff763b20886c3773430"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are just local abbreviations.  <a href="#a3e2fe478b01daff763b20886c3773430">More...</a><br /></td></tr>
<tr class="separator:a3e2fe478b01daff763b20886c3773430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa407f28b9d81d01368529ee7f7b8d73"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 2, 2, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afa407f28b9d81d01368529ee7f7b8d73">Mat22P</a></td></tr>
<tr class="separator:afa407f28b9d81d01368529ee7f7b8d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3e0c9c1a847641ca2ec715d7b1815"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 2, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a00c3e0c9c1a847641ca2ec715d7b1815">Mat32P</a></td></tr>
<tr class="separator:a00c3e0c9c1a847641ca2ec715d7b1815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac072fb845028c8f0aa199bd0cddb7df9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a></td></tr>
<tr class="separator:ac072fb845028c8f0aa199bd0cddb7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315774852e091803bb35e68502c5cfef"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a></td></tr>
<tr class="separator:a315774852e091803bb35e68502c5cfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61eab201f0333ac3107708828b48d6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 3, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad61eab201f0333ac3107708828b48d6a">Mat34P</a></td></tr>
<tr class="separator:ad61eab201f0333ac3107708828b48d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57cfb41c686d5c3c28d3cd2799c0238"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 2, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a></td></tr>
<tr class="separator:ae57cfb41c686d5c3c28d3cd2799c0238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2b9fc21ea18fa45243ba6259a9f8c3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a></td></tr>
<tr class="separator:afd2b9fc21ea18fa45243ba6259a9f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4360cabd778a395e70af322f666e46fe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a></td></tr>
<tr class="separator:a4360cabd778a395e70af322f666e46fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0430849ee6a93f6e73db1473d80a26"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a></td></tr>
<tr class="separator:a9a0430849ee6a93f6e73db1473d80a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a50dfa7292af6166cf3f47a769be21"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; 3, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a></td></tr>
<tr class="separator:a21a50dfa7292af6166cf3f47a769be21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae558a511005019194f262fbd3b7dd08d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Quaternion__.html">Quaternion_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a></td></tr>
<tr class="separator:ae558a511005019194f262fbd3b7dd08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8156453423742aa7ab103650c3ffa4a2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, <a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a27fc7b5604dacb9eedeef01198463960">Mat33P::RowSpacing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a></td></tr>
<tr class="memdesc:a8156453423742aa7ab103650c3ffa4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a column of this Rotation matrix.  <a href="#a8156453423742aa7ab103650c3ffa4a2">More...</a><br /></td></tr>
<tr class="separator:a8156453423742aa7ab103650c3ffa4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c41f591c9926e8436596f924967f45c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt; P, <a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a91607a34c56f039489106477fcfcecac">Mat33P::ColSpacing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a></td></tr>
<tr class="memdesc:a0c41f591c9926e8436596f924967f45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a row of this Rotation matrix.  <a href="#a0c41f591c9926e8436596f924967f45c">More...</a><br /></td></tr>
<tr class="separator:a0c41f591c9926e8436596f924967f45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1Mat"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1Mat')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1Mat.html">SimTK::Mat&lt; 3, 3, P &gt;</a></td></tr>
<tr class="memitem:a9d5d5b39f2f26327081406be46fb3d81 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><tr class="memdesc:a9d5d5b39f2f26327081406be46fb3d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every Composite Numerical Type (CNT) must define these values.  <a href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9d5d5b39f2f26327081406be46fb3d81 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faf23d1979c90781a6fa6646015b7d4 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef P&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a></td></tr>
<tr class="separator:a5faf23d1979c90781a6fa6646015b7d4 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae753cfcecec9a48358e5a813445baa2 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aae753cfcecec9a48358e5a813445baa2">ENeg</a></td></tr>
<tr class="separator:aae753cfcecec9a48358e5a813445baa2 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e65c0ebbe71d4ae0d866021aa1b0d5 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ae8a35b8bde4a34b61532c2d64e977dcf">TWithoutNegator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a35e65c0ebbe71d4ae0d866021aa1b0d5">EWithoutNegator</a></td></tr>
<tr class="separator:a35e65c0ebbe71d4ae0d866021aa1b0d5 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b849d2b8cf747e211e85153615d7dc9 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ac5d6421e7a18cba31f69efee1642dd1e">TReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9b849d2b8cf747e211e85153615d7dc9">EReal</a></td></tr>
<tr class="separator:a9b849d2b8cf747e211e85153615d7dc9 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f8538ce7f17189e49cb41973889f19 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ad9cb6efc99cb8d68b8f5dcf0de22d4d3">TImag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a03f8538ce7f17189e49cb41973889f19">EImag</a></td></tr>
<tr class="separator:a03f8538ce7f17189e49cb41973889f19 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208e3109261f0a495b35768f24c39a79 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#acdfca6c1b273d11ba66f5e57aba5b780">TComplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a208e3109261f0a495b35768f24c39a79">EComplex</a></td></tr>
<tr class="separator:a208e3109261f0a495b35768f24c39a79 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db89a7646b876959eec78fbb5fb1e6 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab3db89a7646b876959eec78fbb5fb1e6">EHerm</a></td></tr>
<tr class="separator:ab3db89a7646b876959eec78fbb5fb1e6 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69853d92f6b7e9f3d62049673f4c778f inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a5ec1730573a75d69d19b911bc195b014">TPosTrans</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a69853d92f6b7e9f3d62049673f4c778f">EPosTrans</a></td></tr>
<tr class="separator:a69853d92f6b7e9f3d62049673f4c778f inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37266e8bafdc50e6924b62d433990784 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a445178b4fb438830e7d6137fe40f68b3">TSqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a37266e8bafdc50e6924b62d433990784">ESqHermT</a></td></tr>
<tr class="separator:a37266e8bafdc50e6924b62d433990784 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe698f8a66328214140efd835400992b inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a6c238d6acc462048e94968401efb1883">TSqTHerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#afe698f8a66328214140efd835400992b">ESqTHerm</a></td></tr>
<tr class="separator:afe698f8a66328214140efd835400992b inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809ebb00f742dd234dcc393ad06e21dc inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ac6ff355a5685251cc0275f7b1af40768">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a809ebb00f742dd234dcc393ad06e21dc">ESqrt</a></td></tr>
<tr class="separator:a809ebb00f742dd234dcc393ad06e21dc inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7e9161b19a181eada70eca76e931a8 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a33803159b9afd1534d547cc8a3797f10">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4c7e9161b19a181eada70eca76e931a8">EAbs</a></td></tr>
<tr class="separator:a4c7e9161b19a181eada70eca76e931a8 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21473d71d2fb2ae807c9822e7dac2adf inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a3a4021304835bbcf202e2c91a437a1e8">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a21473d71d2fb2ae807c9822e7dac2adf">EStandard</a></td></tr>
<tr class="separator:a21473d71d2fb2ae807c9822e7dac2adf inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8793209e719fd2152a1562ffc555ed3e inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ab1a2436edabf2ff08ebc43c5fa9e4915">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8793209e719fd2152a1562ffc555ed3e">EInvert</a></td></tr>
<tr class="separator:a8793209e719fd2152a1562ffc555ed3e inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a10c288a0749f53d73b3d55ff3526be inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a700e9c1c2801c21a1de3a8d4d350efe4">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6a10c288a0749f53d73b3d55ff3526be">ENormalize</a></td></tr>
<tr class="separator:a6a10c288a0749f53d73b3d55ff3526be inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b29601c581cda4e172135a0a430ce2 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a4840b7c6857fe3977ba8cbaa51a6d46e">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a91b29601c581cda4e172135a0a430ce2">EScalar</a></td></tr>
<tr class="separator:a91b29601c581cda4e172135a0a430ce2 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace30baf040a3939cd019dd271dcada19 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#abf590e2b1a6a499c839a3c2e8d7f2c47">ULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ace30baf040a3939cd019dd271dcada19">EULessScalar</a></td></tr>
<tr class="separator:ace30baf040a3939cd019dd271dcada19 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40af331a25a43c8b7656d9b5da6339db inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a82f2cf911d8caba7cd4b7e67ebb6f90e">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a40af331a25a43c8b7656d9b5da6339db">ENumber</a></td></tr>
<tr class="separator:a40af331a25a43c8b7656d9b5da6339db inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9752572efa5a4034bad15a1ea52bb9d inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a222012c773e236d370f79d722ae4e7ef">StdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad9752572efa5a4034bad15a1ea52bb9d">EStdNumber</a></td></tr>
<tr class="separator:ad9752572efa5a4034bad15a1ea52bb9d inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c2d04c9090ae231ae40c5000ea7d6d inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#af0d3b77be65e3fe5eb7c4789aceb18f4">Precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a66c2d04c9090ae231ae40c5000ea7d6d">EPrecision</a></td></tr>
<tr class="separator:a66c2d04c9090ae231ae40c5000ea7d6d inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d75f7efee451e886e74e2178a420521 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a4a15f46a835d23ac38629d50bcb5f82b">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5d75f7efee451e886e74e2178a420521">EScalarNormSq</a></td></tr>
<tr class="separator:a5d75f7efee451e886e74e2178a420521 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2421d40d41c33fd833248060c8beb0 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, CS, RS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6f2421d40d41c33fd833248060c8beb0">T</a></td></tr>
<tr class="separator:a6f2421d40d41c33fd833248060c8beb0 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277fa95f8e821dfda695121715cec9d5 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#aae753cfcecec9a48358e5a813445baa2">ENeg</a>, CS, RS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a></td></tr>
<tr class="separator:a277fa95f8e821dfda695121715cec9d5 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a35b8bde4a34b61532c2d64e977dcf inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a35e65c0ebbe71d4ae0d866021aa1b0d5">EWithoutNegator</a>, CS, RS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae8a35b8bde4a34b61532c2d64e977dcf">TWithoutNegator</a></td></tr>
<tr class="separator:ae8a35b8bde4a34b61532c2d64e977dcf inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d6421e7a18cba31f69efee1642dd1e inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a9b849d2b8cf747e211e85153615d7dc9">EReal</a>, CS *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a525b7edea493ad6d5fb3c61757f1c0b5">RealStrideFactor</a>, RS *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a525b7edea493ad6d5fb3c61757f1c0b5">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac5d6421e7a18cba31f69efee1642dd1e">TReal</a></td></tr>
<tr class="separator:ac5d6421e7a18cba31f69efee1642dd1e inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cb6efc99cb8d68b8f5dcf0de22d4d3 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a03f8538ce7f17189e49cb41973889f19">EImag</a>, CS *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a525b7edea493ad6d5fb3c61757f1c0b5">RealStrideFactor</a>, RS *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a525b7edea493ad6d5fb3c61757f1c0b5">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad9cb6efc99cb8d68b8f5dcf0de22d4d3">TImag</a></td></tr>
<tr class="separator:ad9cb6efc99cb8d68b8f5dcf0de22d4d3 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfca6c1b273d11ba66f5e57aba5b780 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a208e3109261f0a495b35768f24c39a79">EComplex</a>, CS, RS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#acdfca6c1b273d11ba66f5e57aba5b780">TComplex</a></td></tr>
<tr class="separator:acdfca6c1b273d11ba66f5e57aba5b780 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5efe848398d53aba2b0860a2589531 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, M, <a class="el" href="classSimTK_1_1Mat.html#ab3db89a7646b876959eec78fbb5fb1e6">EHerm</a>, RS, CS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a></td></tr>
<tr class="separator:aef5efe848398d53aba2b0860a2589531 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec1730573a75d69d19b911bc195b014 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, M, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, RS, CS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5ec1730573a75d69d19b911bc195b014">TPosTrans</a></td></tr>
<tr class="separator:a5ec1730573a75d69d19b911bc195b014 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1229a351616e91ff78d29a9f601c67d inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af1229a351616e91ff78d29a9f601c67d">TElement</a></td></tr>
<tr class="separator:af1229a351616e91ff78d29a9f601c67d inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d68b382d22f097026db4901c71c5597 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, CS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a></td></tr>
<tr class="separator:a6d68b382d22f097026db4901c71c5597 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e36aa5c1ae0a8a5835f435ce3ed86c inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, RS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a></td></tr>
<tr class="separator:a56e36aa5c1ae0a8a5835f435ce3ed86c inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956fdad138444b1a58edc04dc7b3e620 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81af6a6fc8a3d38e032ffaf52a5e358fd9f">MinDim</a>, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, RS+CS &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a956fdad138444b1a58edc04dc7b3e620">TDiag</a></td></tr>
<tr class="separator:a956fdad138444b1a58edc04dc7b3e620 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ff355a5685251cc0275f7b1af40768 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a809ebb00f742dd234dcc393ad06e21dc">ESqrt</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac6ff355a5685251cc0275f7b1af40768">TSqrt</a></td></tr>
<tr class="separator:ac6ff355a5685251cc0275f7b1af40768 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33803159b9afd1534d547cc8a3797f10 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a4c7e9161b19a181eada70eca76e931a8">EAbs</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a33803159b9afd1534d547cc8a3797f10">TAbs</a></td></tr>
<tr class="separator:a33803159b9afd1534d547cc8a3797f10 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4021304835bbcf202e2c91a437a1e8 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a21473d71d2fb2ae807c9822e7dac2adf">EStandard</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3a4021304835bbcf202e2c91a437a1e8">TStandard</a></td></tr>
<tr class="separator:a3a4021304835bbcf202e2c91a437a1e8 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a2436edabf2ff08ebc43c5fa9e4915 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, M, <a class="el" href="classSimTK_1_1Mat.html#a8793209e719fd2152a1562ffc555ed3e">EInvert</a>, N, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab1a2436edabf2ff08ebc43c5fa9e4915">TInvert</a></td></tr>
<tr class="separator:ab1a2436edabf2ff08ebc43c5fa9e4915 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e9c1c2801c21a1de3a8d4d350efe4 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a6a10c288a0749f53d73b3d55ff3526be">ENormalize</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a700e9c1c2801c21a1de3a8d4d350efe4">TNormalize</a></td></tr>
<tr class="separator:a700e9c1c2801c21a1de3a8d4d350efe4 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445178b4fb438830e7d6137fe40f68b3 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; N, <a class="el" href="classSimTK_1_1Mat.html#a37266e8bafdc50e6924b62d433990784">ESqHermT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a445178b4fb438830e7d6137fe40f68b3">TSqHermT</a></td></tr>
<tr class="separator:a445178b4fb438830e7d6137fe40f68b3 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c238d6acc462048e94968401efb1883 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, <a class="el" href="classSimTK_1_1Mat.html#afe698f8a66328214140efd835400992b">ESqTHerm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6c238d6acc462048e94968401efb1883">TSqTHerm</a></td></tr>
<tr class="separator:a6c238d6acc462048e94968401efb1883 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523742bb010f3f8fdf6b3573c24055a4 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a523742bb010f3f8fdf6b3573c24055a4">TPacked</a></td></tr>
<tr class="separator:a523742bb010f3f8fdf6b3573c24055a4 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fd0c2490f6a4b070924d5c64bfbc4d inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M-1, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M-1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa8fd0c2490f6a4b070924d5c64bfbc4d">TDropRow</a></td></tr>
<tr class="separator:aa8fd0c2490f6a4b070924d5c64bfbc4d inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224fd04608b7973fd66ef859fea67c5 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N-1, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac224fd04608b7973fd66ef859fea67c5">TDropCol</a></td></tr>
<tr class="separator:ac224fd04608b7973fd66ef859fea67c5 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a89676e5be08066b8ce8df4a6b685d inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M-1, N-1, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M-1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a19a89676e5be08066b8ce8df4a6b685d">TDropRowCol</a></td></tr>
<tr class="separator:a19a89676e5be08066b8ce8df4a6b685d inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f421f6ae04de16d19af931aec18637 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M+1, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M+1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a90f421f6ae04de16d19af931aec18637">TAppendRow</a></td></tr>
<tr class="separator:a90f421f6ae04de16d19af931aec18637 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c87c8e05e8fbd16672343e06e5a341 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N+1, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a19c87c8e05e8fbd16672343e06e5a341">TAppendCol</a></td></tr>
<tr class="separator:a19c87c8e05e8fbd16672343e06e5a341 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd51c59501eca17fce8993bd70958b93 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M+1, N+1, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, M+1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#acd51c59501eca17fce8993bd70958b93">TAppendRowCol</a></td></tr>
<tr class="separator:acd51c59501eca17fce8993bd70958b93 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4840b7c6857fe3977ba8cbaa51a6d46e inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#a91b29601c581cda4e172135a0a430ce2">EScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4840b7c6857fe3977ba8cbaa51a6d46e">Scalar</a></td></tr>
<tr class="separator:a4840b7c6857fe3977ba8cbaa51a6d46e inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf590e2b1a6a499c839a3c2e8d7f2c47 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#ace30baf040a3939cd019dd271dcada19">EULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abf590e2b1a6a499c839a3c2e8d7f2c47">ULessScalar</a></td></tr>
<tr class="separator:abf590e2b1a6a499c839a3c2e8d7f2c47 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f2cf911d8caba7cd4b7e67ebb6f90e inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#a40af331a25a43c8b7656d9b5da6339db">ENumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a82f2cf911d8caba7cd4b7e67ebb6f90e">Number</a></td></tr>
<tr class="separator:a82f2cf911d8caba7cd4b7e67ebb6f90e inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222012c773e236d370f79d722ae4e7ef inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#ad9752572efa5a4034bad15a1ea52bb9d">EStdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a222012c773e236d370f79d722ae4e7ef">StdNumber</a></td></tr>
<tr class="separator:a222012c773e236d370f79d722ae4e7ef inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d3b77be65e3fe5eb7c4789aceb18f4 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#a66c2d04c9090ae231ae40c5000ea7d6d">EPrecision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af0d3b77be65e3fe5eb7c4789aceb18f4">Precision</a></td></tr>
<tr class="separator:af0d3b77be65e3fe5eb7c4789aceb18f4 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15f46a835d23ac38629d50bcb5f82b inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#a5d75f7efee451e886e74e2178a420521">EScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4a15f46a835d23ac38629d50bcb5f82b">ScalarNormSq</a></td></tr>
<tr class="separator:a4a15f46a835d23ac38629d50bcb5f82b inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d54a4edcfe46a405469074a9b27a3 inherit pub_types_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a2d3d54a4edcfe46a405469074a9b27a3">TransposeType</a></td></tr>
<tr class="separator:a2d3d54a4edcfe46a405469074a9b27a3 inherit pub_types_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors, Mutators, and Assignment</h2></td></tr>
<tr class="memitem:a7dc8a355b0476f8fc3897225bcec0028"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7dc8a355b0476f8fc3897225bcec0028">Rotation_</a> ()</td></tr>
<tr class="memdesc:a7dc8a355b0476f8fc3897225bcec0028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7dc8a355b0476f8fc3897225bcec0028">More...</a><br /></td></tr>
<tr class="separator:a7dc8a355b0476f8fc3897225bcec0028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966293b042b3b6f3906bb15aec3110d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a966293b042b3b6f3906bb15aec3110d2">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R)</td></tr>
<tr class="memdesc:a966293b042b3b6f3906bb15aec3110d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a966293b042b3b6f3906bb15aec3110d2">More...</a><br /></td></tr>
<tr class="separator:a966293b042b3b6f3906bb15aec3110d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125229971a87b9405c6943687ae5cb6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a125229971a87b9405c6943687ae5cb6c">Rotation_</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr class="memdesc:a125229971a87b9405c6943687ae5cb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like copy constructor but for inverse rotation.  <a href="#a125229971a87b9405c6943687ae5cb6c">More...</a><br /></td></tr>
<tr class="separator:a125229971a87b9405c6943687ae5cb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66e7d173f96a983c32d011bb0d91fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad66e7d173f96a983c32d011bb0d91fc7">operator=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R)</td></tr>
<tr class="memdesc:ad66e7d173f96a983c32d011bb0d91fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ad66e7d173f96a983c32d011bb0d91fc7">More...</a><br /></td></tr>
<tr class="separator:ad66e7d173f96a983c32d011bb0d91fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac773d1fe4e964aebf5c62c51f1cb1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4ac773d1fe4e964aebf5c62c51f1cb1a">operator=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr class="memdesc:a4ac773d1fe4e964aebf5c62c51f1cb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like copy assignment but for inverse rotation.  <a href="#a4ac773d1fe4e964aebf5c62c51f1cb1a">More...</a><br /></td></tr>
<tr class="separator:a4ac773d1fe4e964aebf5c62c51f1cb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360123fced580910bb805feb3a602258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a360123fced580910bb805feb3a602258">setRotationToNaN</a> ()</td></tr>
<tr class="memdesc:a360123fced580910bb805feb3a602258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> filled with NaNs.  <a href="#a360123fced580910bb805feb3a602258">More...</a><br /></td></tr>
<tr class="separator:a360123fced580910bb805feb3a602258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352f6087f76d893011d1cf4a168d58d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a352f6087f76d893011d1cf4a168d58d4">setRotationToIdentityMatrix</a> ()</td></tr>
<tr class="memdesc:a352f6087f76d893011d1cf4a168d58d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct identity <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a>.  <a href="#a352f6087f76d893011d1cf4a168d58d4">More...</a><br /></td></tr>
<tr class="separator:a352f6087f76d893011d1cf4a168d58d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19962cc7af21545ae8e8f63702e83624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a19962cc7af21545ae8e8f63702e83624">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis)</td></tr>
<tr class="memdesc:a19962cc7af21545ae8e8f63702e83624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a19962cc7af21545ae8e8f63702e83624">More...</a><br /></td></tr>
<tr class="separator:a19962cc7af21545ae8e8f63702e83624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d85ae0f22416a5cd6866596fc40f2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9d85ae0f22416a5cd6866596fc40f2d8">setRotationFromAngleAboutAxis</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis)</td></tr>
<tr class="memdesc:a9d85ae0f22416a5cd6866596fc40f2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis.  <a href="#a9d85ae0f22416a5cd6866596fc40f2d8">More...</a><br /></td></tr>
<tr class="separator:a9d85ae0f22416a5cd6866596fc40f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa3df1484427409f85bdba47f263d18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aeaa3df1484427409f85bdba47f263d18">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1XCoordinateAxis.html">CoordinateAxis::XCoordinateAxis</a>)</td></tr>
<tr class="memdesc:aeaa3df1484427409f85bdba47f263d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about the X-axis.  <a href="#aeaa3df1484427409f85bdba47f263d18">More...</a><br /></td></tr>
<tr class="separator:aeaa3df1484427409f85bdba47f263d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0dd8018a891fae9f52a77a8af85913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a2b0dd8018a891fae9f52a77a8af85913">setRotationFromAngleAboutX</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle)</td></tr>
<tr class="memdesc:a2b0dd8018a891fae9f52a77a8af85913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the X-axis.  <a href="#a2b0dd8018a891fae9f52a77a8af85913">More...</a><br /></td></tr>
<tr class="separator:a2b0dd8018a891fae9f52a77a8af85913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3626657c38a81b2df9205db8dd48af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad3626657c38a81b2df9205db8dd48af2">setRotationFromAngleAboutX</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> cosAngle, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> sinAngle)</td></tr>
<tr class="memdesc:ad3626657c38a81b2df9205db8dd48af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the X-axis, where the cosine and sine of the angle are specified.  <a href="#ad3626657c38a81b2df9205db8dd48af2">More...</a><br /></td></tr>
<tr class="separator:ad3626657c38a81b2df9205db8dd48af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3cf04efd08eda9a303036fa6346bb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a6a3cf04efd08eda9a303036fa6346bb9">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1YCoordinateAxis.html">CoordinateAxis::YCoordinateAxis</a>)</td></tr>
<tr class="memdesc:a6a3cf04efd08eda9a303036fa6346bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about the Y-axis.  <a href="#a6a3cf04efd08eda9a303036fa6346bb9">More...</a><br /></td></tr>
<tr class="separator:a6a3cf04efd08eda9a303036fa6346bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c34f207cd0c05dcf8fb4fe01bece15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a03c34f207cd0c05dcf8fb4fe01bece15">setRotationFromAngleAboutY</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle)</td></tr>
<tr class="memdesc:a03c34f207cd0c05dcf8fb4fe01bece15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the Y-axis.  <a href="#a03c34f207cd0c05dcf8fb4fe01bece15">More...</a><br /></td></tr>
<tr class="separator:a03c34f207cd0c05dcf8fb4fe01bece15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0429ecf9ca8d6bf23b2ea6a1067c13bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0429ecf9ca8d6bf23b2ea6a1067c13bf">setRotationFromAngleAboutY</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> cosAngle, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> sinAngle)</td></tr>
<tr class="memdesc:a0429ecf9ca8d6bf23b2ea6a1067c13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the Y-axis, where the cosine and sine of the angle are specified.  <a href="#a0429ecf9ca8d6bf23b2ea6a1067c13bf">More...</a><br /></td></tr>
<tr class="separator:a0429ecf9ca8d6bf23b2ea6a1067c13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1171f57869b8633941395bc3baed5ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ab1171f57869b8633941395bc3baed5ed">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1ZCoordinateAxis.html">CoordinateAxis::ZCoordinateAxis</a>)</td></tr>
<tr class="memdesc:ab1171f57869b8633941395bc3baed5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about the Z-axis.  <a href="#ab1171f57869b8633941395bc3baed5ed">More...</a><br /></td></tr>
<tr class="separator:ab1171f57869b8633941395bc3baed5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019d1ba576917c1294376af5d5c07684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a019d1ba576917c1294376af5d5c07684">setRotationFromAngleAboutZ</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle)</td></tr>
<tr class="memdesc:a019d1ba576917c1294376af5d5c07684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the Z-axis.  <a href="#a019d1ba576917c1294376af5d5c07684">More...</a><br /></td></tr>
<tr class="separator:a019d1ba576917c1294376af5d5c07684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bea1532e99c7e6aa83e189053000b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a12bea1532e99c7e6aa83e189053000b2">setRotationFromAngleAboutZ</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> cosAngle, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> sinAngle)</td></tr>
<tr class="memdesc:a12bea1532e99c7e6aa83e189053000b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the Z-axis, where the cosine and sine of the angle are specified.  <a href="#a12bea1532e99c7e6aa83e189053000b2">More...</a><br /></td></tr>
<tr class="separator:a12bea1532e99c7e6aa83e189053000b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae551ca3f12b485259ba56def8ccd152a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae551ca3f12b485259ba56def8ccd152a">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;unitVector)</td></tr>
<tr class="memdesc:ae551ca3f12b485259ba56def8ccd152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about an arbitrary unit vector.  <a href="#ae551ca3f12b485259ba56def8ccd152a">More...</a><br /></td></tr>
<tr class="separator:ae551ca3f12b485259ba56def8ccd152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbe7f3f47a4b0c6d7be8650d95049c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a69dbe7f3f47a4b0c6d7be8650d95049c">setRotationFromAngleAboutUnitVector</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;unitVector)</td></tr>
<tr class="memdesc:a69dbe7f3f47a4b0c6d7be8650d95049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary unit vector.  <a href="#a69dbe7f3f47a4b0c6d7be8650d95049c">More...</a><br /></td></tr>
<tr class="separator:a69dbe7f3f47a4b0c6d7be8650d95049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340d147e68d17979a01248d6b70cfe45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a340d147e68d17979a01248d6b70cfe45">Rotation_</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;nonUnitVector)</td></tr>
<tr class="memdesc:a340d147e68d17979a01248d6b70cfe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector of arbitrary length.  <a href="#a340d147e68d17979a01248d6b70cfe45">More...</a><br /></td></tr>
<tr class="separator:a340d147e68d17979a01248d6b70cfe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e4dcab37f729839b79abf5a5e77840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a13e4dcab37f729839b79abf5a5e77840">setRotationFromAngleAboutNonUnitVector</a> (<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;nonUnitVector)</td></tr>
<tr class="memdesc:a13e4dcab37f729839b79abf5a5e77840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector of arbitrary length.  <a href="#a13e4dcab37f729839b79abf5a5e77840">More...</a><br /></td></tr>
<tr class="separator:a13e4dcab37f729839b79abf5a5e77840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451308fdf619ff01b3b07a7d960cf354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a451308fdf619ff01b3b07a7d960cf354">Rotation_</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2)</td></tr>
<tr class="memdesc:a451308fdf619ff01b3b07a7d960cf354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians).  <a href="#a451308fdf619ff01b3b07a7d960cf354">More...</a><br /></td></tr>
<tr class="separator:a451308fdf619ff01b3b07a7d960cf354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54e75b189a41cf6b0e9d23458eae32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afc54e75b189a41cf6b0e9d23458eae32">setRotationFromTwoAnglesTwoAxes</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2)</td></tr>
<tr class="memdesc:afc54e75b189a41cf6b0e9d23458eae32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians).  <a href="#afc54e75b189a41cf6b0e9d23458eae32">More...</a><br /></td></tr>
<tr class="separator:afc54e75b189a41cf6b0e9d23458eae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de3e72e32205e18ea71b03dfdc08932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4de3e72e32205e18ea71b03dfdc08932">Rotation_</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle3, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3)</td></tr>
<tr class="memdesc:a4de3e72e32205e18ea71b03dfdc08932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians).  <a href="#a4de3e72e32205e18ea71b03dfdc08932">More...</a><br /></td></tr>
<tr class="separator:a4de3e72e32205e18ea71b03dfdc08932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19a5140a685462e498d6d5c2c42c8c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad19a5140a685462e498d6d5c2c42c8c4">setRotationFromThreeAnglesThreeAxes</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> angle3, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3)</td></tr>
<tr class="memdesc:ad19a5140a685462e498d6d5c2c42c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians).  <a href="#ad19a5140a685462e498d6d5c2c42c8c4">More...</a><br /></td></tr>
<tr class="separator:ad19a5140a685462e498d6d5c2c42c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511a6db1f00e0b2e535f70fb01d4009e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a511a6db1f00e0b2e535f70fb01d4009e">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a> &amp;q)</td></tr>
<tr class="memdesc:a511a6db1f00e0b2e535f70fb01d4009e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a rotation matrix from a quaternion.  <a href="#a511a6db1f00e0b2e535f70fb01d4009e">More...</a><br /></td></tr>
<tr class="separator:a511a6db1f00e0b2e535f70fb01d4009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed39e831fc2c774c769b4afb72830874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aed39e831fc2c774c769b4afb72830874">setRotationFromQuaternion</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a> &amp;q)</td></tr>
<tr class="memdesc:aed39e831fc2c774c769b4afb72830874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for creating a rotation matrix from a quaternion.  <a href="#aed39e831fc2c774c769b4afb72830874">More...</a><br /></td></tr>
<tr class="separator:aed39e831fc2c774c769b4afb72830874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c1cf9f8c55f4371795eab53da933e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8c1c1cf9f8c55f4371795eab53da933e">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a8c1c1cf9f8c55f4371795eab53da933e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P.  <a href="#a8c1c1cf9f8c55f4371795eab53da933e">More...</a><br /></td></tr>
<tr class="separator:a8c1c1cf9f8c55f4371795eab53da933e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf320049f0aa881075905d781eee032f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#acf320049f0aa881075905d781eee032f">setRotationFromApproximateMat33</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:acf320049f0aa881075905d781eee032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P.  <a href="#acf320049f0aa881075905d781eee032f">More...</a><br /></td></tr>
<tr class="separator:acf320049f0aa881075905d781eee032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c751d1b449be1eba50a5b026a18b907"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9c751d1b449be1eba50a5b026a18b907">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;m, bool)</td></tr>
<tr class="memdesc:a9c751d1b449be1eba50a5b026a18b907"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Construct a <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> directly from a Mat33P (we trust that m is a valid Rotation_!) Things will not go well for you if it is not.  <a href="#a9c751d1b449be1eba50a5b026a18b907">More...</a><br /></td></tr>
<tr class="separator:a9c751d1b449be1eba50a5b026a18b907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a70e677a952560b2ab8d972ed79801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a34a70e677a952560b2ab8d972ed79801">setRotationFromMat33TrustMe</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a34a70e677a952560b2ab8d972ed79801"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a34a70e677a952560b2ab8d972ed79801">More...</a><br /></td></tr>
<tr class="separator:a34a70e677a952560b2ab8d972ed79801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913668d30b526d87c63b175ccef9c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9913668d30b526d87c63b175ccef9c56">setRotationColFromUnitVecTrustMe</a> (int colj, const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;uvecj)</td></tr>
<tr class="memdesc:a9913668d30b526d87c63b175ccef9c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a9913668d30b526d87c63b175ccef9c56">More...</a><br /></td></tr>
<tr class="separator:a9913668d30b526d87c63b175ccef9c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38115244428f8fc0f4411dd092ee5fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a38115244428f8fc0f4411dd092ee5fe4">setRotationFromUnitVecsTrustMe</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;colA, const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;colB, const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;colC)</td></tr>
<tr class="memdesc:a38115244428f8fc0f4411dd092ee5fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing!  <a href="#a38115244428f8fc0f4411dd092ee5fe4">More...</a><br /></td></tr>
<tr class="separator:a38115244428f8fc0f4411dd092ee5fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56498f3bd27dfa3483cb2e91512d020d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a56498f3bd27dfa3483cb2e91512d020d">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;uvec, <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> axis)</td></tr>
<tr class="memdesc:a56498f3bd27dfa3483cb2e91512d020d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors expressed in A.  <a href="#a56498f3bd27dfa3483cb2e91512d020d">More...</a><br /></td></tr>
<tr class="separator:a56498f3bd27dfa3483cb2e91512d020d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d437a754fb412b10859f035bc5312d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4d437a754fb412b10859f035bc5312d6">setRotationFromOneAxis</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;uvec, <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> axis)</td></tr>
<tr class="memdesc:a4d437a754fb412b10859f035bc5312d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors expressed in A.  <a href="#a4d437a754fb412b10859f035bc5312d6">More...</a><br /></td></tr>
<tr class="separator:a4d437a754fb412b10859f035bc5312d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7001ed401fb3f4550a6fae494a0c7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#abf7001ed401fb3f4550a6fae494a0c7a">Rotation_</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;uveci, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisi, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;vecjApprox, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisjApprox)</td></tr>
<tr class="memdesc:abf7001ed401fb3f4550a6fae494a0c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1).  <a href="#abf7001ed401fb3f4550a6fae494a0c7a">More...</a><br /></td></tr>
<tr class="separator:abf7001ed401fb3f4550a6fae494a0c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efe475b1e8a00f0628a74e660e84dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7efe475b1e8a00f0628a74e660e84dfa">setRotationFromTwoAxes</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;uveci, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisi, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;vecjApprox, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axisjApprox)</td></tr>
<tr class="memdesc:a7efe475b1e8a00f0628a74e660e84dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1).  <a href="#a7efe475b1e8a00f0628a74e660e84dfa">More...</a><br /></td></tr>
<tr class="separator:a7efe475b1e8a00f0628a74e660e84dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44ae0c01f7118c690a0c47cbf44e9a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af44ae0c01f7118c690a0c47cbf44e9a7">setRotationToBodyFixedXY</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;v)</td></tr>
<tr class="memdesc:af44ae0c01f7118c690a0c47cbf44e9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis.  <a href="#af44ae0c01f7118c690a0c47cbf44e9a7">More...</a><br /></td></tr>
<tr class="separator:af44ae0c01f7118c690a0c47cbf44e9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5b9946341290a869fdf36263c6e901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a1b5b9946341290a869fdf36263c6e901">setRotationToBodyFixedXYZ</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;v)</td></tr>
<tr class="memdesc:a1b5b9946341290a869fdf36263c6e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis, followed by a rotation of +v[2] about the body frame's NEW (twice rotated) Z axis.  <a href="#a1b5b9946341290a869fdf36263c6e901">More...</a><br /></td></tr>
<tr class="separator:a1b5b9946341290a869fdf36263c6e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2d3b70084a3a474bf2c8ac1f598bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a6d2d3b70084a3a474bf2c8ac1f598bf6">setRotationToBodyFixedXYZ</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;c, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;s)</td></tr>
<tr class="memdesc:a6d2d3b70084a3a474bf2c8ac1f598bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given cosines and sines (in that order) of three angles, set this Rotation matrix to the body-fixed 1-2-3 sequence of those angles.  <a href="#a6d2d3b70084a3a474bf2c8ac1f598bf6">More...</a><br /></td></tr>
<tr class="separator:a6d2d3b70084a3a474bf2c8ac1f598bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operators and Arithmetic</h2></td></tr>
<tr class="memitem:a9879ff3a7db426377521760cc07f3c2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9879ff3a7db426377521760cc07f3c2c">operator~</a> () const</td></tr>
<tr class="memdesc:a9879ff3a7db426377521760cc07f3c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose operator.  <a href="#a9879ff3a7db426377521760cc07f3c2c">More...</a><br /></td></tr>
<tr class="separator:a9879ff3a7db426377521760cc07f3c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec15e73cf4dbcdc7e1c6ac90f68fdef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aec15e73cf4dbcdc7e1c6ac90f68fdef3">operator~</a> ()</td></tr>
<tr class="memdesc:aec15e73cf4dbcdc7e1c6ac90f68fdef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose operator.  <a href="#aec15e73cf4dbcdc7e1c6ac90f68fdef3">More...</a><br /></td></tr>
<tr class="separator:aec15e73cf4dbcdc7e1c6ac90f68fdef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d6fd489c04b205b79d24c858968ea9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa7d6fd489c04b205b79d24c858968ea9">transpose</a> () const</td></tr>
<tr class="memdesc:aa7d6fd489c04b205b79d24c858968ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="#aa7d6fd489c04b205b79d24c858968ea9">More...</a><br /></td></tr>
<tr class="separator:aa7d6fd489c04b205b79d24c858968ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d8ca5d3b3edd6630b5fb7a0a577d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a83d8ca5d3b3edd6630b5fb7a0a577d72">updTranspose</a> ()</td></tr>
<tr class="memdesc:a83d8ca5d3b3edd6630b5fb7a0a577d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="#a83d8ca5d3b3edd6630b5fb7a0a577d72">More...</a><br /></td></tr>
<tr class="separator:a83d8ca5d3b3edd6630b5fb7a0a577d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db1dfad4d75ef91bdb6d5a49d4e25cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0db1dfad4d75ef91bdb6d5a49d4e25cc">invert</a> () const</td></tr>
<tr class="memdesc:a0db1dfad4d75ef91bdb6d5a49d4e25cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to <a class="el" href="classSimTK_1_1InverseRotation__.html" title="(Advanced) This InverseRotation class is the inverse of a Rotation. ">InverseRotation_</a> (no cost).  <a href="#a0db1dfad4d75ef91bdb6d5a49d4e25cc">More...</a><br /></td></tr>
<tr class="separator:a0db1dfad4d75ef91bdb6d5a49d4e25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf61a10b96a4320c991e55caa582386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#abcf61a10b96a4320c991e55caa582386">updInvert</a> ()</td></tr>
<tr class="memdesc:abcf61a10b96a4320c991e55caa582386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to writable <a class="el" href="classSimTK_1_1InverseRotation__.html" title="(Advanced) This InverseRotation class is the inverse of a Rotation. ">InverseRotation_</a> (no cost).  <a href="#abcf61a10b96a4320c991e55caa582386">More...</a><br /></td></tr>
<tr class="separator:abcf61a10b96a4320c991e55caa582386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26169557db013c2a8779098d00d5c846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a26169557db013c2a8779098d00d5c846">operator*=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R)</td></tr>
<tr class="memdesc:a26169557db013c2a8779098d00d5c846"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a26169557db013c2a8779098d00d5c846">More...</a><br /></td></tr>
<tr class="separator:a26169557db013c2a8779098d00d5c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa2ee262d79bf91ba2465bdbecb40c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a7fa2ee262d79bf91ba2465bdbecb40c2">operator*=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr class="memdesc:a7fa2ee262d79bf91ba2465bdbecb40c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a7fa2ee262d79bf91ba2465bdbecb40c2">More...</a><br /></td></tr>
<tr class="separator:a7fa2ee262d79bf91ba2465bdbecb40c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38257532c21876c8629b224f0431080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ab38257532c21876c8629b224f0431080">operator/=</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R)</td></tr>
<tr class="memdesc:ab38257532c21876c8629b224f0431080"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#ab38257532c21876c8629b224f0431080">More...</a><br /></td></tr>
<tr class="separator:ab38257532c21876c8629b224f0431080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94079169da0047a42fe96411f36f9f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a94079169da0047a42fe96411f36f9f42">operator/=</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;)</td></tr>
<tr class="memdesc:a94079169da0047a42fe96411f36f9f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place composition of Rotation matrices.  <a href="#a94079169da0047a42fe96411f36f9f42">More...</a><br /></td></tr>
<tr class="separator:a94079169da0047a42fe96411f36f9f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d055de40c8993a4bb9bb2d86c784a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a">multiplyByBodyXYZ_N_P</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> oocosy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB)</td></tr>
<tr class="memdesc:a3d8d055de40c8993a4bb9bb2d86c784a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular velocity of child in parent is expected to be expressed in the parent.  <a href="#a3d8d055de40c8993a4bb9bb2d86c784a">More...</a><br /></td></tr>
<tr class="separator:a3d8d055de40c8993a4bb9bb2d86c784a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776789cb0d7ba32361b1b43813591754"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a776789cb0d7ba32361b1b43813591754">multiplyByBodyXYZ_NT_P</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> oocosy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q)</td></tr>
<tr class="memdesc:a776789cb0d7ba32361b1b43813591754"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P); see the untransposed method <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> for information.  <a href="#a776789cb0d7ba32361b1b43813591754">More...</a><br /></td></tr>
<tr class="separator:a776789cb0d7ba32361b1b43813591754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0edcb1b005f9a4980302c60cec1840d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad0edcb1b005f9a4980302c60cec1840d">multiplyByBodyXYZ_NInv_P</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:ad0edcb1b005f9a4980302c60cec1840d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastest way to form the product w_PB=NInv_P*qdot.  <a href="#ad0edcb1b005f9a4980302c60cec1840d">More...</a><br /></td></tr>
<tr class="separator:ad0edcb1b005f9a4980302c60cec1840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19740559fc48c4651696e8e1d4ff6d8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae19740559fc48c4651696e8e1d4ff6d8">multiplyByBodyXYZ_NInvT_P</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;v_P)</td></tr>
<tr class="memdesc:ae19740559fc48c4651696e8e1d4ff6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P).  <a href="#ae19740559fc48c4651696e8e1d4ff6d8">More...</a><br /></td></tr>
<tr class="separator:ae19740559fc48c4651696e8e1d4ff6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessors</h2></td></tr>
<tr class="memitem:ae13f54266a4e05e0631f762dc9a1bc7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae13f54266a4e05e0631f762dc9a1bc7b">row</a> (int i) const</td></tr>
<tr class="memdesc:ae13f54266a4e05e0631f762dc9a1bc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the ith row of this Rotation matrix as a UnitRow3.  <a href="#ae13f54266a4e05e0631f762dc9a1bc7b">More...</a><br /></td></tr>
<tr class="separator:ae13f54266a4e05e0631f762dc9a1bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696c17db2db87ae9509c16008bcaf440"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a696c17db2db87ae9509c16008bcaf440">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a696c17db2db87ae9509c16008bcaf440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as row(i) but nicer to look at.  <a href="#a696c17db2db87ae9509c16008bcaf440">More...</a><br /></td></tr>
<tr class="separator:a696c17db2db87ae9509c16008bcaf440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8849ce50fb520a1add5efce72cd73f7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8849ce50fb520a1add5efce72cd73f7c">col</a> (int j) const</td></tr>
<tr class="memdesc:a8849ce50fb520a1add5efce72cd73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the jth column of this Rotation matrix as a UnitVec3.  <a href="#a8849ce50fb520a1add5efce72cd73f7c">More...</a><br /></td></tr>
<tr class="separator:a8849ce50fb520a1add5efce72cd73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3deb2a9092afa4b263f86ae29c82164"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac3deb2a9092afa4b263f86ae29c82164">operator()</a> (int j) const</td></tr>
<tr class="memdesc:ac3deb2a9092afa4b263f86ae29c82164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as col(j) but nicer to look at.  <a href="#ac3deb2a9092afa4b263f86ae29c82164">More...</a><br /></td></tr>
<tr class="separator:ac3deb2a9092afa4b263f86ae29c82164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685dec8a4ecc93e4539bc4973f59d3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac685dec8a4ecc93e4539bc4973f59d3c">x</a> () const</td></tr>
<tr class="memdesc:ac685dec8a4ecc93e4539bc4973f59d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return col(0) of this Rotation matrix as a UnitVec3.  <a href="#ac685dec8a4ecc93e4539bc4973f59d3c">More...</a><br /></td></tr>
<tr class="separator:ac685dec8a4ecc93e4539bc4973f59d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5716a25ec593380f54fbf207c69ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a1fe5716a25ec593380f54fbf207c69ea">y</a> () const</td></tr>
<tr class="memdesc:a1fe5716a25ec593380f54fbf207c69ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return col(1) of this Rotation matrix as a UnitVec3.  <a href="#a1fe5716a25ec593380f54fbf207c69ea">More...</a><br /></td></tr>
<tr class="separator:a1fe5716a25ec593380f54fbf207c69ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d73e29f638a24e76579c482d499e334"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9d73e29f638a24e76579c482d499e334">z</a> () const</td></tr>
<tr class="memdesc:a9d73e29f638a24e76579c482d499e334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return col(2) of this Rotation matrix as a UnitVec3.  <a href="#a9d73e29f638a24e76579c482d499e334">More...</a><br /></td></tr>
<tr class="separator:a9d73e29f638a24e76579c482d499e334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a177d7c3dd7bf97de90a6ed3f3aea68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0a177d7c3dd7bf97de90a6ed3f3aea68">getAxisUnitVec</a> (<a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> axis) const</td></tr>
<tr class="memdesc:a0a177d7c3dd7bf97de90a6ed3f3aea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1CoordinateAxis.html" title="This class, along with its sister class CoordinateDirection, provides convenient manipulation of the ...">CoordinateAxis</a> (XAxis,YAxis, or ZAxis) return a reference to the corresponding column of this Rotation matrix.  <a href="#a0a177d7c3dd7bf97de90a6ed3f3aea68">More...</a><br /></td></tr>
<tr class="separator:a0a177d7c3dd7bf97de90a6ed3f3aea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c754b4f1da8a121da52024f810651e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt; P, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a2c754b4f1da8a121da52024f810651e8">getAxisUnitVec</a> (<a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a> dir) const</td></tr>
<tr class="memdesc:a2c754b4f1da8a121da52024f810651e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a> (+/-XAxis, etc.) return a unit vector in that direction.  <a href="#a2c754b4f1da8a121da52024f810651e8">More...</a><br /></td></tr>
<tr class="separator:a2c754b4f1da8a121da52024f810651e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Calculations</h2></td></tr>
<tr class="memitem:a3eb22f98f2a9088cf1012a5559548e3a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a">calcNForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q)</td></tr>
<tr class="memdesc:a3eb22f98f2a9088cf1012a5559548e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where w_PB_B is the angular velocity of B in P EXPRESSED IN <em>B</em>!!! Note that N_B=N_P*R_PB.  <a href="#a3eb22f98f2a9088cf1012a5559548e3a">More...</a><br /></td></tr>
<tr class="separator:a3eb22f98f2a9088cf1012a5559548e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa54243d974e2c0a8bb80c201343ad4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aaaa54243d974e2c0a8bb80c201343ad4">calcNForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq)</td></tr>
<tr class="memdesc:aaaa54243d974e2c0a8bb80c201343ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aaaa54243d974e2c0a8bb80c201343ad4">More...</a><br /></td></tr>
<tr class="separator:aaaa54243d974e2c0a8bb80c201343ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0127cac78bdb1aea48a1b8294d2f13a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5">calcNForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q)</td></tr>
<tr class="memdesc:a0127cac78bdb1aea48a1b8294d2f13a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where w_PB is the angular velocity of B in P expressed in P (not the convention that Kane uses, where angular velocities are expressed in the outboard body B).  <a href="#a0127cac78bdb1aea48a1b8294d2f13a5">More...</a><br /></td></tr>
<tr class="separator:a0127cac78bdb1aea48a1b8294d2f13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd585adb5a86dc06adc011d46c4d2a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aabd585adb5a86dc06adc011d46c4d2a4">calcNForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq)</td></tr>
<tr class="memdesc:aabd585adb5a86dc06adc011d46c4d2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aabd585adb5a86dc06adc011d46c4d2a4">More...</a><br /></td></tr>
<tr class="separator:aabd585adb5a86dc06adc011d46c4d2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc6b4aa8b35bb60f885bc8c07927ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed">calcNDotForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:a57cc6b4aa8b35bb60f885bc8c07927ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P EXPRESSED IN <em>B</em>!!! This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> for the matrix we're differentiating here.  <a href="#a57cc6b4aa8b35bb60f885bc8c07927ed">More...</a><br /></td></tr>
<tr class="separator:a57cc6b4aa8b35bb60f885bc8c07927ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a07a41343d026e5f95c7072aa180b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af1a07a41343d026e5f95c7072aa180b1">calcNDotForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:af1a07a41343d026e5f95c7072aa180b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#af1a07a41343d026e5f95c7072aa180b1">More...</a><br /></td></tr>
<tr class="separator:af1a07a41343d026e5f95c7072aa180b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ce2d2d7aa5e3ba6bc4107f715bca2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2">calcNDotForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:a713ce2d2d7aa5e3ba6bc4107f715bca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P expressed in P.  <a href="#a713ce2d2d7aa5e3ba6bc4107f715bca2">More...</a><br /></td></tr>
<tr class="separator:a713ce2d2d7aa5e3ba6bc4107f715bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731e89578e363e9c42f998b542682a35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a731e89578e363e9c42f998b542682a35">calcNDotForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sq, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> ooc1, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:a731e89578e363e9c42f998b542682a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a731e89578e363e9c42f998b542682a35">More...</a><br /></td></tr>
<tr class="separator:a731e89578e363e9c42f998b542682a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5b6c3e33f68fc8105d2f2099969753"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753">calcNInvForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q)</td></tr>
<tr class="memdesc:aba5b6c3e33f68fc8105d2f2099969753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of routine <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a>.  <a href="#aba5b6c3e33f68fc8105d2f2099969753">More...</a><br /></td></tr>
<tr class="separator:aba5b6c3e33f68fc8105d2f2099969753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05421fe60aadcdc2c5b9a02747568a73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a05421fe60aadcdc2c5b9a02747568a73">calcNInvForBodyXYZInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq)</td></tr>
<tr class="memdesc:a05421fe60aadcdc2c5b9a02747568a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753" title="Inverse of routine calcNForBodyXYZInBodyFrame(). ">calcNInvForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a05421fe60aadcdc2c5b9a02747568a73">More...</a><br /></td></tr>
<tr class="separator:a05421fe60aadcdc2c5b9a02747568a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fc3fe5bd8a98217aafeb5a6639ccbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc">calcNInvForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q)</td></tr>
<tr class="memdesc:a37fc3fe5bd8a98217aafeb5a6639ccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#a37fc3fe5bd8a98217aafeb5a6639ccbc">More...</a><br /></td></tr>
<tr class="separator:a37fc3fe5bd8a98217aafeb5a6639ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020a2169bc07b8e28414b75892986c9f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a020a2169bc07b8e28414b75892986c9f">calcNInvForBodyXYZInParentFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq)</td></tr>
<tr class="memdesc:a020a2169bc07b8e28414b75892986c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc" title="Inverse of the above routine. ">calcNInvForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a020a2169bc07b8e28414b75892986c9f">More...</a><br /></td></tr>
<tr class="separator:a020a2169bc07b8e28414b75892986c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7a0f3971e33ca93521589eeb7cc1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d">calcUnnormalizedNForQuaternion</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;q)</td></tr>
<tr class="memdesc:af8b7a0f3971e33ca93521589eeb7cc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w to quaternion derivatives qdot.  <a href="#af8b7a0f3971e33ca93521589eeb7cc1d">More...</a><br /></td></tr>
<tr class="separator:af8b7a0f3971e33ca93521589eeb7cc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c0b4373719c68c0a14783d8fa8e8aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a30c0b4373719c68c0a14783d8fa8e8aa">calcUnnormalizedNDotForQuaternion</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;qdot)</td></tr>
<tr class="memdesc:a30c0b4373719c68c0a14783d8fa8e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the time derivative qdot of a possibly unnormalized quaternion q, calculate the 4x3 matrix NDot which is the time derivative of the matrix N as described in <a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d" title="Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w ...">calcUnnormalizedNForQuaternion()</a>.  <a href="#a30c0b4373719c68c0a14783d8fa8e8aa">More...</a><br /></td></tr>
<tr class="separator:a30c0b4373719c68c0a14783d8fa8e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939de389a2ef2d6516aee271d1f04ad7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#ad61eab201f0333ac3107708828b48d6a">Mat34P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a939de389a2ef2d6516aee271d1f04ad7">calcUnnormalizedNInvForQuaternion</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;q)</td></tr>
<tr class="memdesc:a939de389a2ef2d6516aee271d1f04ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a (possibly unnormalized) quaternion q, calculate the 3x4 matrix NInv (= N^-1) which maps quaternion derivatives qdot to angular velocity w, where the angular velocity is in the parent frame, i.e.  <a href="#a939de389a2ef2d6516aee271d1f04ad7">More...</a><br /></td></tr>
<tr class="separator:a939de389a2ef2d6516aee271d1f04ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Conversions</h2></td></tr>
<tr class="memitem:ab9704549afbc2d8e526c5fe2817e7814"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ab9704549afbc2d8e526c5fe2817e7814">asMat33</a> () const</td></tr>
<tr class="memdesc:ab9704549afbc2d8e526c5fe2817e7814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from Rotation to its base class Mat33.  <a href="#ab9704549afbc2d8e526c5fe2817e7814">More...</a><br /></td></tr>
<tr class="separator:ab9704549afbc2d8e526c5fe2817e7814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c9d3d873514da4e7316bbc83403fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a77c9d3d873514da4e7316bbc83403fbe">toMat33</a> () const</td></tr>
<tr class="memdesc:a77c9d3d873514da4e7316bbc83403fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from Rotation to its base class Mat33.  <a href="#a77c9d3d873514da4e7316bbc83403fbe">More...</a><br /></td></tr>
<tr class="separator:a77c9d3d873514da4e7316bbc83403fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a72db92b0eb76496c26e8097c48745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a04a72db92b0eb76496c26e8097c48745">reexpressSymMat33</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a> &amp;S_BB) const</td></tr>
<tr class="memdesc:a04a72db92b0eb76496c26e8097c48745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an efficient transform of a symmetric matrix that must be re-expressed with a multiply from both left and right, such as an inertia matrix.  <a href="#a04a72db92b0eb76496c26e8097c48745">More...</a><br /></td></tr>
<tr class="separator:a04a72db92b0eb76496c26e8097c48745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fff2d4b65d25bd3ba94470f0fd878fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4fff2d4b65d25bd3ba94470f0fd878fa">convertOneAxisRotationToOneAngle</a> (const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1) const</td></tr>
<tr class="memdesc:a4fff2d4b65d25bd3ba94470f0fd878fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to a single orientation angle.  <a href="#a4fff2d4b65d25bd3ba94470f0fd878fa">More...</a><br /></td></tr>
<tr class="separator:a4fff2d4b65d25bd3ba94470f0fd878fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd54cf77c2285eb8c5f9c3d4c53aba37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#acd54cf77c2285eb8c5f9c3d4c53aba37">convertTwoAxesRotationToTwoAngles</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2) const</td></tr>
<tr class="memdesc:acd54cf77c2285eb8c5f9c3d4c53aba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to two orientation angles.  <a href="#acd54cf77c2285eb8c5f9c3d4c53aba37">More...</a><br /></td></tr>
<tr class="separator:acd54cf77c2285eb8c5f9c3d4c53aba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a8ebd70ba4ca68cf18f31c6f1f1213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a07a8ebd70ba4ca68cf18f31c6f1f1213">convertThreeAxesRotationToThreeAngles</a> (<a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a> bodyOrSpace, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis1, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis2, const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;axis3) const</td></tr>
<tr class="memdesc:a07a8ebd70ba4ca68cf18f31c6f1f1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to three orientation angles.  <a href="#a07a8ebd70ba4ca68cf18f31c6f1f1213">More...</a><br /></td></tr>
<tr class="separator:a07a8ebd70ba4ca68cf18f31c6f1f1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9545e8cc66a16a4ae9f42b5af0c12131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a9545e8cc66a16a4ae9f42b5af0c12131">convertRotationToQuaternion</a> () const</td></tr>
<tr class="memdesc:a9545e8cc66a16a4ae9f42b5af0c12131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to an equivalent quaternion in canonical form (meaning its scalar element is nonnegative).  <a href="#a9545e8cc66a16a4ae9f42b5af0c12131">More...</a><br /></td></tr>
<tr class="separator:a9545e8cc66a16a4ae9f42b5af0c12131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59e76752e7a1e5706eae1e9c2547e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#af59e76752e7a1e5706eae1e9c2547e8b">convertRotationToAngleAxis</a> () const</td></tr>
<tr class="memdesc:af59e76752e7a1e5706eae1e9c2547e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rotation matrix to an equivalent angle-axis representation in canonicalized form.  <a href="#af59e76752e7a1e5706eae1e9c2547e8b">More...</a><br /></td></tr>
<tr class="separator:af59e76752e7a1e5706eae1e9c2547e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713b44b006dea6d75c1c1325970c7b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a713b44b006dea6d75c1c1325970c7b30">convertRotationToBodyFixedXY</a> () const</td></tr>
<tr class="memdesc:a713b44b006dea6d75c1c1325970c7b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#acd54cf77c2285eb8c5f9c3d4c53aba37" title="Converts rotation matrix to two orientation angles. ">convertTwoAxesRotationToTwoAngles()</a>.  <a href="#a713b44b006dea6d75c1c1325970c7b30">More...</a><br /></td></tr>
<tr class="separator:a713b44b006dea6d75c1c1325970c7b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b45916f249f3def3549f7916dd1eff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a8b45916f249f3def3549f7916dd1eff1">convertRotationToBodyFixedXYZ</a> () const</td></tr>
<tr class="memdesc:a8b45916f249f3def3549f7916dd1eff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a07a8ebd70ba4ca68cf18f31c6f1f1213" title="Converts rotation matrix to three orientation angles. ">convertThreeAxesRotationToThreeAngles()</a>.  <a href="#a8b45916f249f3def3549f7916dd1eff1">More...</a><br /></td></tr>
<tr class="separator:a8b45916f249f3def3549f7916dd1eff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7be536a78529d455a292a04fc267bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ada7be536a78529d455a292a04fc267bf">convertAngVelToBodyFixed321Dot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr class="memdesc:ada7be536a78529d455a292a04fc267bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative angular velocity vector of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives.  <a href="#ada7be536a78529d455a292a04fc267bf">More...</a><br /></td></tr>
<tr class="separator:ada7be536a78529d455a292a04fc267bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2274baac7bc6e82343040f1850f59c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a0b2274baac7bc6e82343040f1850f59c">convertBodyFixed321DotToAngVel</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qd)</td></tr>
<tr class="memdesc:a0b2274baac7bc6e82343040f1850f59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of convertAngVelToBodyFixed321Dot.  <a href="#a0b2274baac7bc6e82343040f1850f59c">More...</a><br /></td></tr>
<tr class="separator:a0b2274baac7bc6e82343040f1850f59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b70da72a012a4e248150759ae09a0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a41b70da72a012a4e248150759ae09a0b">convertAngVelDotToBodyFixed321DotDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr class="memdesc:a41b70da72a012a4e248150759ae09a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caution: needs testing.  <a href="#a41b70da72a012a4e248150759ae09a0b">More...</a><br /></td></tr>
<tr class="separator:a41b70da72a012a4e248150759ae09a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87f86eb9a0b8dff3202c35e39f1b16d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d">convertAngVelInBodyFrameToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr class="memdesc:ae87f86eb9a0b8dff3202c35e39f1b16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vector w_PB_B of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives.  <a href="#ae87f86eb9a0b8dff3202c35e39f1b16d">More...</a><br /></td></tr>
<tr class="separator:ae87f86eb9a0b8dff3202c35e39f1b16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59271d0544a807b0d43617485365efd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa59271d0544a807b0d43617485365efd">convertAngVelInBodyFrameToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B)</td></tr>
<tr class="memdesc:aa59271d0544a807b0d43617485365efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vecto...">convertAngVelInBodyFrameToBodyXYZDot()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aa59271d0544a807b0d43617485365efd">More...</a><br /></td></tr>
<tr class="separator:aa59271d0544a807b0d43617485365efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7286af6f32e76ddc0b5f90f7efd22e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e">convertBodyXYZDotToAngVelInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:afc7286af6f32e76ddc0b5f90f7efd22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#afc7286af6f32e76ddc0b5f90f7efd22e">More...</a><br /></td></tr>
<tr class="separator:afc7286af6f32e76ddc0b5f90f7efd22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed9d79a18b05275c469d18d58413ca5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aaed9d79a18b05275c469d18d58413ca5">convertBodyXYZDotToAngVelInBodyFrame</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot)</td></tr>
<tr class="memdesc:aaed9d79a18b05275c469d18d58413ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e" title="Inverse of the above routine. ">convertBodyXYZDotToAngVelInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#aaed9d79a18b05275c469d18d58413ca5">More...</a><br /></td></tr>
<tr class="separator:aaed9d79a18b05275c469d18d58413ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed514d5990532404a82da26793049900"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr class="memdesc:aed514d5990532404a82da26793049900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning: everything is measured in the <em>PARENT</em> frame, but has to be expressed in the <em>BODY</em> frame.  <a href="#aed514d5990532404a82da26793049900">More...</a><br /></td></tr>
<tr class="separator:aed514d5990532404a82da26793049900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae5a0d854e698521bde92dfe17b84a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a4ae5a0d854e698521bde92dfe17b84a7">convertAngVelDotInBodyFrameToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;cq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;sq, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_B, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;wdot_PB_B)</td></tr>
<tr class="memdesc:a4ae5a0d854e698521bde92dfe17b84a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900" title="Warning: everything is measured in the PARENT frame, but has to be expressed in the BODY frame...">convertAngVelDotInBodyFrameToBodyXYZDotDot()</a> assumes you have already calculated the cosine and sine of the three q's.  <a href="#a4ae5a0d854e698521bde92dfe17b84a7">More...</a><br /></td></tr>
<tr class="separator:a4ae5a0d854e698521bde92dfe17b84a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea472db472765197f6daf4624b9a0700"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aea472db472765197f6daf4624b9a0700">convertAngVelToQuaternionDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB_P)</td></tr>
<tr class="memdesc:aea472db472765197f6daf4624b9a0700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a possibly unnormalized quaternion (0th element is the scalar) and the relative angular velocity vector of B in its parent, expressed in the <em>PARENT</em>, return the quaternion derivatives.  <a href="#aea472db472765197f6daf4624b9a0700">More...</a><br /></td></tr>
<tr class="separator:aea472db472765197f6daf4624b9a0700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55fc1b16c0df4962094d3173ae4372"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#adc55fc1b16c0df4962094d3173ae4372">convertQuaternionDotToAngVel</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;qdot)</td></tr>
<tr class="memdesc:adc55fc1b16c0df4962094d3173ae4372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of the above routine.  <a href="#adc55fc1b16c0df4962094d3173ae4372">More...</a><br /></td></tr>
<tr class="separator:adc55fc1b16c0df4962094d3173ae4372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e2b91d6d396f2002afb7f26335e64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ac39e2b91d6d396f2002afb7f26335e64">convertAngVelDotToQuaternionDotDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;q, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;b_PB)</td></tr>
<tr class="memdesc:ac39e2b91d6d396f2002afb7f26335e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where b is angular acceleration wdot.  <a href="#ac39e2b91d6d396f2002afb7f26335e64">More...</a><br /></td></tr>
<tr class="separator:ac39e2b91d6d396f2002afb7f26335e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b111f6521a2001a2c2dbc00414d5ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#ad8b111f6521a2001a2c2dbc00414d5ad">convertAngVelInParentToBodyXYZDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> oocosy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;w_PB)</td></tr>
<tr class="memdesc:ad8b111f6521a2001a2c2dbc00414d5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate first time derivative qdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles and the angular velocity w_PB of child B in parent P, expressed in P.  <a href="#ad8b111f6521a2001a2c2dbc00414d5ad">More...</a><br /></td></tr>
<tr class="separator:ad8b111f6521a2001a2c2dbc00414d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee4bdfde750e6cb198494b1b522b20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aa5ee4bdfde750e6cb198494b1b522b20">convertAngAccInParentToBodyXYZDotDot</a> (const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;cosxy, const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;sinxy, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> oocosy, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;qdot, const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;b_PB)</td></tr>
<tr class="memdesc:aa5ee4bdfde750e6cb198494b1b522b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate second time derivative qdotdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles, the first derivative qdot and the angular acceleration b_PB of child B in parent P, expressed in P.  <a href="#aa5ee4bdfde750e6cb198494b1b522b20">More...</a><br /></td></tr>
<tr class="separator:aa5ee4bdfde750e6cb198494b1b522b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Queries</h2></td></tr>
<tr class="memitem:a420031eb5801e9a4ece6230880cbb874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a420031eb5801e9a4ece6230880cbb874">isSameRotationToWithinAngle</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> okPointingAngleErrorRads) const</td></tr>
<tr class="memdesc:a420031eb5801e9a4ece6230880cbb874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error.  <a href="#a420031eb5801e9a4ece6230880cbb874">More...</a><br /></td></tr>
<tr class="separator:a420031eb5801e9a4ece6230880cbb874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef510f32db21cd24adc4dfe15355c24b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#aef510f32db21cd24adc4dfe15355c24b">isSameRotationToWithinAngleOfMachinePrecision</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const</td></tr>
<tr class="memdesc:aef510f32db21cd24adc4dfe15355c24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if "this" Rotation is nearly identical to "R" within machine precision.  <a href="#aef510f32db21cd24adc4dfe15355c24b">More...</a><br /></td></tr>
<tr class="separator:aef510f32db21cd24adc4dfe15355c24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffdc7b0d8a7621fd56fdfef9a38e63e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#adffdc7b0d8a7621fd56fdfef9a38e63e">getMaxAbsDifferenceInRotationElements</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const</td></tr>
<tr class="memdesc:adffdc7b0d8a7621fd56fdfef9a38e63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns maximum absolute difference between elements in "this" Rotation and elements in "R".  <a href="#adffdc7b0d8a7621fd56fdfef9a38e63e">More...</a><br /></td></tr>
<tr class="separator:adffdc7b0d8a7621fd56fdfef9a38e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300622e45125dc936a94345d6037d49b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a300622e45125dc936a94345d6037d49b">areAllRotationElementsSameToEpsilon</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R, <a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> epsilon) const</td></tr>
<tr class="memdesc:a300622e45125dc936a94345d6037d49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if each element of "this" Rotation is within epsilon of the corresponding element of "R".  <a href="#a300622e45125dc936a94345d6037d49b">More...</a><br /></td></tr>
<tr class="separator:a300622e45125dc936a94345d6037d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08366c2f18e052d127e5237fce637ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Rotation__.html#a08366c2f18e052d127e5237fce637ecf">areAllRotationElementsSameToMachinePrecision</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> &amp;R) const</td></tr>
<tr class="memdesc:a08366c2f18e052d127e5237fce637ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if each element of "this" Rotation is within machine precision of the corresponding element of "R".  <a href="#a08366c2f18e052d127e5237fce637ecf">More...</a><br /></td></tr>
<tr class="separator:a08366c2f18e052d127e5237fce637ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Mat"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Mat')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Mat.html">SimTK::Mat&lt; 3, 3, P &gt;</a></td></tr>
<tr class="memitem:a4da73346dbde5b308d4ca9cb951b390e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a4a15f46a835d23ac38629d50bcb5f82b">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4da73346dbde5b308d4ca9cb951b390e">scalarNormSqr</a> () const</td></tr>
<tr class="memdesc:a4da73346dbde5b308d4ca9cb951b390e inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar norm square is the sum of squares of all the scalars that comprise the value of this Mat.  <a href="classSimTK_1_1Mat.html#a4da73346dbde5b308d4ca9cb951b390e">More...</a><br /></td></tr>
<tr class="separator:a4da73346dbde5b308d4ca9cb951b390e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9973f2d64c57282aa2da7c521c148866 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ac6ff355a5685251cc0275f7b1af40768">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9973f2d64c57282aa2da7c521c148866">sqrt</a> () const</td></tr>
<tr class="memdesc:a9973f2d64c57282aa2da7c521c148866 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root; that is, the return value has the same dimensions as this Mat but with each element replaced by whatever it thinks its square root is.  <a href="classSimTK_1_1Mat.html#a9973f2d64c57282aa2da7c521c148866">More...</a><br /></td></tr>
<tr class="separator:a9973f2d64c57282aa2da7c521c148866 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9e43ad87bad267fb2e36c4d8669d52 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a33803159b9afd1534d547cc8a3797f10">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5c9e43ad87bad267fb2e36c4d8669d52">abs</a> () const</td></tr>
<tr class="memdesc:a5c9e43ad87bad267fb2e36c4d8669d52 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise absolute value; that is, the return value has the same dimensions as this Mat but with each element replaced by whatever it thinks its absolute value is.  <a href="classSimTK_1_1Mat.html#a5c9e43ad87bad267fb2e36c4d8669d52">More...</a><br /></td></tr>
<tr class="separator:a5c9e43ad87bad267fb2e36c4d8669d52 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48976c82458ae32ada1f229a666215ca inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a3a4021304835bbcf202e2c91a437a1e8">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a48976c82458ae32ada1f229a666215ca">standardize</a> () const</td></tr>
<tr class="separator:a48976c82458ae32ada1f229a666215ca inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0198d43d287a382583142e94a6193427 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0198d43d287a382583142e94a6193427">Mat</a> ()</td></tr>
<tr class="memdesc:a0198d43d287a382583142e94a6193427 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction initializes to NaN when debugging but is left uninitialized otherwise to ensure that there is no overhead.  <a href="classSimTK_1_1Mat.html#a0198d43d287a382583142e94a6193427">More...</a><br /></td></tr>
<tr class="separator:a0198d43d287a382583142e94a6193427 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ed93ebb3ee14cd595e04129fa7f12c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a78ed93ebb3ee14cd595e04129fa7f12c">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;src)</td></tr>
<tr class="memdesc:a78ed93ebb3ee14cd595e04129fa7f12c inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor copies only the elements that are present and does not touch any unused memory space between them if they are not packed.  <a href="classSimTK_1_1Mat.html#a78ed93ebb3ee14cd595e04129fa7f12c">More...</a><br /></td></tr>
<tr class="separator:a78ed93ebb3ee14cd595e04129fa7f12c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e07809ed841d770e840e7953229cb2 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a08e07809ed841d770e840e7953229cb2">Mat</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, P &gt; &amp;src)</td></tr>
<tr class="memdesc:a08e07809ed841d770e840e7953229cb2 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit construction of a Mat from a SymMat (symmetric/Hermitian matrix).  <a href="classSimTK_1_1Mat.html#a08e07809ed841d770e840e7953229cb2">More...</a><br /></td></tr>
<tr class="separator:a08e07809ed841d770e840e7953229cb2 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c093b3824e450ae5c04fd06942abd9 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a86c093b3824e450ae5c04fd06942abd9">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, CSS, RSS &gt; &amp;src)</td></tr>
<tr class="memdesc:a86c093b3824e450ae5c04fd06942abd9 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides an <em>implicit</em> conversion from a Mat of the same dimensions and element type but with different element spacing.  <a href="classSimTK_1_1Mat.html#a86c093b3824e450ae5c04fd06942abd9">More...</a><br /></td></tr>
<tr class="separator:a86c093b3824e450ae5c04fd06942abd9 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad935eedc0438fa1363a74cd1d5df936d inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad935eedc0438fa1363a74cd1d5df936d">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#aae753cfcecec9a48358e5a813445baa2">ENeg</a>, CSS, RSS &gt; &amp;src)</td></tr>
<tr class="memdesc:ad935eedc0438fa1363a74cd1d5df936d inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides an <em>implicit</em> conversion from a Mat of the same dimensions and <em>negated</em> element type, possibly with different element spacing.  <a href="classSimTK_1_1Mat.html#ad935eedc0438fa1363a74cd1d5df936d">More...</a><br /></td></tr>
<tr class="separator:ad935eedc0438fa1363a74cd1d5df936d inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bdb0b1866f04ebe536c8329947f006 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad7bdb0b1866f04ebe536c8329947f006">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, EE, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="memdesc:ad7bdb0b1866f04ebe536c8329947f006 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit construction of a Mat from a source Mat of the same dimensions and an assignment-compatible element type, with any element spacing allowed.  <a href="classSimTK_1_1Mat.html#ad7bdb0b1866f04ebe536c8329947f006">More...</a><br /></td></tr>
<tr class="separator:ad7bdb0b1866f04ebe536c8329947f006 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac805beed030a0c2d98fb821b8122ee inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aaac805beed030a0c2d98fb821b8122ee">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e)</td></tr>
<tr class="memdesc:aaac805beed030a0c2d98fb821b8122ee inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit construction from a single element <em>e</em> of this Mat's element type E sets all the main diagonal elements to <em>e</em> but sets the rest of the elements to zero.  <a href="classSimTK_1_1Mat.html#aaac805beed030a0c2d98fb821b8122ee">More...</a><br /></td></tr>
<tr class="separator:aaac805beed030a0c2d98fb821b8122ee inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ae28643e78b8be33abb64265dff2c6 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad9ae28643e78b8be33abb64265dff2c6">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#aae753cfcecec9a48358e5a813445baa2">ENeg</a> &amp;e)</td></tr>
<tr class="memdesc:ad9ae28643e78b8be33abb64265dff2c6 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit construction from a single element <em>e</em> whose type is negator&lt;E&gt; (abbreviated ENeg here) where E is this Mat's element type sets all the main diagonal elements to <em>e</em> but sets the rest of the elements to zero.  <a href="classSimTK_1_1Mat.html#ad9ae28643e78b8be33abb64265dff2c6">More...</a><br /></td></tr>
<tr class="separator:ad9ae28643e78b8be33abb64265dff2c6 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1674c00b0bd799326cfa5eaf8c1425c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab1674c00b0bd799326cfa5eaf8c1425c">Mat</a> (int i)</td></tr>
<tr class="memdesc:ab1674c00b0bd799326cfa5eaf8c1425c inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit construction from an int value means we convert the int into an object of this Mat's element type E, and then apply the single-element constructor above which sets the Mat to zero except for its main diagonal elements which will all be set to the given value.  <a href="classSimTK_1_1Mat.html#ab1674c00b0bd799326cfa5eaf8c1425c">More...</a><br /></td></tr>
<tr class="separator:ab1674c00b0bd799326cfa5eaf8c1425c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ec083cfa58bd63957cd4ccf7e186a0 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a72ec083cfa58bd63957cd4ccf7e186a0">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1)</td></tr>
<tr class="separator:a72ec083cfa58bd63957cd4ccf7e186a0 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3653282a18649d504d37f855f977c50 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af3653282a18649d504d37f855f977c50">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2)</td></tr>
<tr class="separator:af3653282a18649d504d37f855f977c50 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3ec5dc0196edfe840e03c14ec215ae inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3e3ec5dc0196edfe840e03c14ec215ae">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3)</td></tr>
<tr class="separator:a3e3ec5dc0196edfe840e03c14ec215ae inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2874b38c861a062158a7eb0a0744507 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad2874b38c861a062158a7eb0a0744507">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4)</td></tr>
<tr class="separator:ad2874b38c861a062158a7eb0a0744507 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e255e3235c54b9efb5ad8521fd9963 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a73e255e3235c54b9efb5ad8521fd9963">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5)</td></tr>
<tr class="separator:a73e255e3235c54b9efb5ad8521fd9963 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece64d8fe1453b2c0fd535cd128c39b inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3ece64d8fe1453b2c0fd535cd128c39b">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6)</td></tr>
<tr class="separator:a3ece64d8fe1453b2c0fd535cd128c39b inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f14d6dd4d32cc351ed66bec9875e887 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a1f14d6dd4d32cc351ed66bec9875e887">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7)</td></tr>
<tr class="separator:a1f14d6dd4d32cc351ed66bec9875e887 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea06b0aa5610b9b42f1f624d711c60 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a60ea06b0aa5610b9b42f1f624d711c60">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8)</td></tr>
<tr class="separator:a60ea06b0aa5610b9b42f1f624d711c60 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4d600db39665c9a4a5f8d1b0f0ba05 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0a4d600db39665c9a4a5f8d1b0f0ba05">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9)</td></tr>
<tr class="separator:a0a4d600db39665c9a4a5f8d1b0f0ba05 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd84e05a1929ace5e97b99227079e36d inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abd84e05a1929ace5e97b99227079e36d">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10)</td></tr>
<tr class="separator:abd84e05a1929ace5e97b99227079e36d inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af900ad8ea79b61b4a1e0f97ce23c62e1 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af900ad8ea79b61b4a1e0f97ce23c62e1">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e11)</td></tr>
<tr class="separator:af900ad8ea79b61b4a1e0f97ce23c62e1 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8c353a5e97bac06a917373e558bfe8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aaa8c353a5e97bac06a917373e558bfe8">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e11, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e12)</td></tr>
<tr class="separator:aaa8c353a5e97bac06a917373e558bfe8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72ca542163d3f544a6d572be69f4be4 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac72ca542163d3f544a6d572be69f4be4">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e11, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e12, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e13)</td></tr>
<tr class="separator:ac72ca542163d3f544a6d572be69f4be4 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095ac5d1c9b9e10dbb171c97058630e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a095ac5d1c9b9e10dbb171c97058630e8">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e11, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e12, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e13, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e14)</td></tr>
<tr class="separator:a095ac5d1c9b9e10dbb171c97058630e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dc1ce8542255f91e207c5fdca07112 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a84dc1ce8542255f91e207c5fdca07112">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e8, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e9, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e10, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e11, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e12, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e13, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e14, const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;e15)</td></tr>
<tr class="separator:a84dc1ce8542255f91e207c5fdca07112 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85f3d42a6095b3524fcfe2f97aeb440 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad85f3d42a6095b3524fcfe2f97aeb440">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0)</td></tr>
<tr class="separator:ad85f3d42a6095b3524fcfe2f97aeb440 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90ef6f6cab8147409a97e6179587940 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad90ef6f6cab8147409a97e6179587940">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r1)</td></tr>
<tr class="separator:ad90ef6f6cab8147409a97e6179587940 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa6c0a0b610ef479a74ac2bd4e32d7a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6fa6c0a0b610ef479a74ac2bd4e32d7a">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r2)</td></tr>
<tr class="separator:a6fa6c0a0b610ef479a74ac2bd4e32d7a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa49bf35181091cc2fb497bceb42c4e4 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#afa49bf35181091cc2fb497bceb42c4e4">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r3)</td></tr>
<tr class="separator:afa49bf35181091cc2fb497bceb42c4e4 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1eee42d4bd99f669882fbeab667f32 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a2e1eee42d4bd99f669882fbeab667f32">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r3, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r4)</td></tr>
<tr class="separator:a2e1eee42d4bd99f669882fbeab667f32 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac3b990e45897995e6436a8f1e3d1c8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a7ac3b990e45897995e6436a8f1e3d1c8">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r3, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r4, const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;r5)</td></tr>
<tr class="separator:a7ac3b990e45897995e6436a8f1e3d1c8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e7534d70680ab3f152fe3defc23a8f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a46e7534d70680ab3f152fe3defc23a8f">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0)</td></tr>
<tr class="separator:a46e7534d70680ab3f152fe3defc23a8f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41101415e9112ccadb187b1ac20ef838 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a41101415e9112ccadb187b1ac20ef838">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r1)</td></tr>
<tr class="separator:a41101415e9112ccadb187b1ac20ef838 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651d7dceee897c6bb80ed8e3569fe5b9 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a651d7dceee897c6bb80ed8e3569fe5b9">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r2)</td></tr>
<tr class="separator:a651d7dceee897c6bb80ed8e3569fe5b9 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f4d08e2ad44e692f4a0f5e00e11981 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab3f4d08e2ad44e692f4a0f5e00e11981">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r3)</td></tr>
<tr class="separator:ab3f4d08e2ad44e692f4a0f5e00e11981 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318373a7b406a07d603a1ad04aab674a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a318373a7b406a07d603a1ad04aab674a">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r3, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r4)</td></tr>
<tr class="separator:a318373a7b406a07d603a1ad04aab674a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc58e45d71258a5d3c6558997642e15e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#afc58e45d71258a5d3c6558997642e15e">Mat</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r3, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r4, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;r5)</td></tr>
<tr class="separator:afc58e45d71258a5d3c6558997642e15e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d980d16656901eda93954e7d97f4895 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a1d980d16656901eda93954e7d97f4895">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0)</td></tr>
<tr class="separator:a1d980d16656901eda93954e7d97f4895 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb7337a56ef10eae5d851cb1cb56826 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#addb7337a56ef10eae5d851cb1cb56826">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r1)</td></tr>
<tr class="separator:addb7337a56ef10eae5d851cb1cb56826 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b35f6d365a1f16f456d012394c7e94 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad0b35f6d365a1f16f456d012394c7e94">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r2)</td></tr>
<tr class="separator:ad0b35f6d365a1f16f456d012394c7e94 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b148770369cfae485992fe795eaa87f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a1b148770369cfae485992fe795eaa87f">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r3)</td></tr>
<tr class="separator:a1b148770369cfae485992fe795eaa87f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ee82bdcd08e96e3d4d6f2644a0e7c6 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a70ee82bdcd08e96e3d4d6f2644a0e7c6">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r3, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r4)</td></tr>
<tr class="separator:a70ee82bdcd08e96e3d4d6f2644a0e7c6 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f35a6de273acca4b2e6bbe012671dc inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a50f35a6de273acca4b2e6bbe012671dc">Mat</a> (const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r0, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r1, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r2, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r3, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r4, const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;r5)</td></tr>
<tr class="separator:a50f35a6de273acca4b2e6bbe012671dc inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5affd238188daff9b67e807d2bca9eba inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5affd238188daff9b67e807d2bca9eba">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0)</td></tr>
<tr class="separator:a5affd238188daff9b67e807d2bca9eba inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1863afa2e55e7fc3b40b0bef13422e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aee1863afa2e55e7fc3b40b0bef13422e">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r1)</td></tr>
<tr class="separator:aee1863afa2e55e7fc3b40b0bef13422e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d10afa8f8175b07f87bdaa86d387e6 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af0d10afa8f8175b07f87bdaa86d387e6">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r2)</td></tr>
<tr class="separator:af0d10afa8f8175b07f87bdaa86d387e6 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485b63a185e5e879e88a9a08b83a191b inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a485b63a185e5e879e88a9a08b83a191b">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r3)</td></tr>
<tr class="separator:a485b63a185e5e879e88a9a08b83a191b inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e57e3ce57f32572bc31c38ab7d2b39 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad5e57e3ce57f32572bc31c38ab7d2b39">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r3, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r4)</td></tr>
<tr class="separator:ad5e57e3ce57f32572bc31c38ab7d2b39 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f8c3fcbc324d6f75c517fda4aec31 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae72f8c3fcbc324d6f75c517fda4aec31">Mat</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r0, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r1, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r2, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r3, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r4, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r5)</td></tr>
<tr class="separator:ae72f8c3fcbc324d6f75c517fda4aec31 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06e0a93402b3c2e376b64c343c3b512 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa06e0a93402b3c2e376b64c343c3b512">Mat</a> (const EE *p)</td></tr>
<tr class="separator:aa06e0a93402b3c2e376b64c343c3b512 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b165c41980b61822f9a75f2b503ca inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa01b165c41980b61822f9a75f2b503ca">operator=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;src)</td></tr>
<tr class="memdesc:aa01b165c41980b61822f9a75f2b503ca inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment copies only the elements that are present and does not touch any unused memory space between them if they are not packed.  <a href="classSimTK_1_1Mat.html#aa01b165c41980b61822f9a75f2b503ca">More...</a><br /></td></tr>
<tr class="separator:aa01b165c41980b61822f9a75f2b503ca inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546e13ac17fc8220d8ec16c4aad88943 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a546e13ac17fc8220d8ec16c4aad88943">operator=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, EE, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:a546e13ac17fc8220d8ec16c4aad88943 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f90d636f25a959790c99b1da544a5e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a14f90d636f25a959790c99b1da544a5e">operator=</a> (const EE *p)</td></tr>
<tr class="separator:a14f90d636f25a959790c99b1da544a5e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f105f1cdeb90ed6282e5fb9af6a166a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a1f105f1cdeb90ed6282e5fb9af6a166a">operator=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a1f105f1cdeb90ed6282e5fb9af6a166a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c030a7a2e2f455ceea585fd6489b4 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a165c030a7a2e2f455ceea585fd6489b4">operator+=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, EE, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:a165c030a7a2e2f455ceea585fd6489b4 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff1139fd3dce039ad7847065bb640ef inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5ff1139fd3dce039ad7847065bb640ef">operator+=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:a5ff1139fd3dce039ad7847065bb640ef inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80361d8e3c31fc567c41b7e9c9d77ae6 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a80361d8e3c31fc567c41b7e9c9d77ae6">operator+=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a80361d8e3c31fc567c41b7e9c9d77ae6 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca39bc36dedba2d83f71d49df7bf4c30 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aca39bc36dedba2d83f71d49df7bf4c30">operator-=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, EE, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:aca39bc36dedba2d83f71d49df7bf4c30 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b33ee071412b812e59659201b16a1e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a46b33ee071412b812e59659201b16a1e">operator-=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:a46b33ee071412b812e59659201b16a1e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75bb8191ea93e7456b587d86dfa0309 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab75bb8191ea93e7456b587d86dfa0309">operator-=</a> (const EE &amp;e)</td></tr>
<tr class="separator:ab75bb8191ea93e7456b587d86dfa0309 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4dded055349d556534fe1f9198867c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8b4dded055349d556534fe1f9198867c">operator*=</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, N, EE, CSS, RSS &gt; &amp;mm)</td></tr>
<tr class="separator:a8b4dded055349d556534fe1f9198867c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35801b92119648929150fce33968feb3 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a35801b92119648929150fce33968feb3">operator*=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a35801b92119648929150fce33968feb3 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32741c38efbcac03bc60bc6d574dd9c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &gt;::Add&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab32741c38efbcac03bc60bc6d574dd9c">conformingAdd</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;r) const</td></tr>
<tr class="separator:ab32741c38efbcac03bc60bc6d574dd9c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6895073490e9e82632a0822bdaa80e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt; &gt;::Add&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a2a6895073490e9e82632a0822bdaa80e">conformingAdd</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt; &amp;sy) const</td></tr>
<tr class="separator:a2a6895073490e9e82632a0822bdaa80e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e287f22e8f3000d6519a39ed5f8b22 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &gt;::Sub&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae0e287f22e8f3000d6519a39ed5f8b22">conformingSubtract</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;r) const</td></tr>
<tr class="separator:ae0e287f22e8f3000d6519a39ed5f8b22 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500c110c604ed80cad4db9b13a83813 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt; &gt;::Sub&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9500c110c604ed80cad4db9b13a83813">conformingSubtract</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt; &amp;sy) const</td></tr>
<tr class="separator:a9500c110c604ed80cad4db9b13a83813 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac825104a2ceea6315b615f5b190a05 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &gt;::Sub&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#adac825104a2ceea6315b615f5b190a05">conformingSubtractFromLeft</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;l) const</td></tr>
<tr class="separator:adac825104a2ceea6315b615f5b190a05 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e452d61b14c59d6c3b6ae25565cbe inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &gt;::Sub&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5f8e452d61b14c59d6c3b6ae25565cbe">conformingSubtractFromLeft</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, E2, RS2 &gt; &amp;sy) const</td></tr>
<tr class="separator:a5f8e452d61b14c59d6c3b6ae25565cbe inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad64b4da49b29af522bb5e578c3a4b3 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">EltResult&lt; E2 &gt;::Mul&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3ad64b4da49b29af522bb5e578c3a4b3">elementwiseMultiply</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;r) const</td></tr>
<tr class="separator:a3ad64b4da49b29af522bb5e578c3a4b3 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cafb66493e5e7c67b104ca65f6b924 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">EltResult&lt; E2 &gt;::Dvd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a93cafb66493e5e7c67b104ca65f6b924">elementwiseDivide</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;r) const</td></tr>
<tr class="separator:a93cafb66493e5e7c67b104ca65f6b924 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4184e67c4c47b3e4ebeff27f7c0b63 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, N2, E2, CS2, RS2 &gt; &gt;::Mul&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abe4184e67c4c47b3e4ebeff27f7c0b63">conformingMultiply</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; N, N2, E2, CS2, RS2 &gt; &amp;m) const</td></tr>
<tr class="separator:abe4184e67c4c47b3e4ebeff27f7c0b63 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f04631e6d0df40fd6e4cb47c0ae635e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, M, E2, CS2, RS2 &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &gt;::Mul&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5f04631e6d0df40fd6e4cb47c0ae635e">conformingMultiplyFromLeft</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, M, E2, CS2, RS2 &gt; &amp;m) const</td></tr>
<tr class="separator:a5f04631e6d0df40fd6e4cb47c0ae635e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8b8c62a34c9e575d107ba205a8f220 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, N, E2, CS2, RS2 &gt; &gt;::Dvd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abc8b8c62a34c9e575d107ba205a8f220">conformingDivide</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, N, E2, CS2, RS2 &gt; &amp;m) const</td></tr>
<tr class="separator:abc8b8c62a34c9e575d107ba205a8f220 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1fdb279c8171e28e2d40575b72d126 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, N, E2, CS2, RS2 &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &gt;::Dvd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0f1fdb279c8171e28e2d40575b72d126">conformingDivideFromLeft</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M2, N, E2, CS2, RS2 &gt; &amp;m) const</td></tr>
<tr class="separator:a0f1fdb279c8171e28e2d40575b72d126 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69f2e4c11166abfdbeb68d5983e08fa inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad69f2e4c11166abfdbeb68d5983e08fa">operator[]</a> (int i) const</td></tr>
<tr class="separator:ad69f2e4c11166abfdbeb68d5983e08fa inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada85341cbcd777b03cf0aecb5be54679 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ada85341cbcd777b03cf0aecb5be54679">operator[]</a> (int i)</td></tr>
<tr class="separator:ada85341cbcd777b03cf0aecb5be54679 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1c19b7643b8b270d3b1005344dda5c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#acb1c19b7643b8b270d3b1005344dda5c">operator()</a> (int j) const</td></tr>
<tr class="separator:acb1c19b7643b8b270d3b1005344dda5c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729be4c90f074b09671cb0babde787e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a729be4c90f074b09671cb0babde787e8">operator()</a> (int j)</td></tr>
<tr class="separator:a729be4c90f074b09671cb0babde787e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06e56269bfa135f79b16bec287cfae9 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab06e56269bfa135f79b16bec287cfae9">operator()</a> (int i, int j) const</td></tr>
<tr class="separator:ab06e56269bfa135f79b16bec287cfae9 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1589e3cf0f2afa9e1a5c8f8ca43541 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a2c1589e3cf0f2afa9e1a5c8f8ca43541">operator()</a> (int i, int j)</td></tr>
<tr class="separator:a2c1589e3cf0f2afa9e1a5c8f8ca43541 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4336d0bf97ee041e149ba09f127c0abc inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a4a15f46a835d23ac38629d50bcb5f82b">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4336d0bf97ee041e149ba09f127c0abc">normSqr</a> () const</td></tr>
<tr class="separator:a4336d0bf97ee041e149ba09f127c0abc inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb6432d850a906089e378d0f8db82a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a4a15f46a835d23ac38629d50bcb5f82b">ScalarNormSq</a> &gt;::<a class="el" href="classSimTK_1_1Mat.html#ac6ff355a5685251cc0275f7b1af40768">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aacfb6432d850a906089e378d0f8db82a">norm</a> () const</td></tr>
<tr class="separator:aacfb6432d850a906089e378d0f8db82a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d7acfc544eece04e3594e58fdde3f3 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a700e9c1c2801c21a1de3a8d4d350efe4">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a85d7acfc544eece04e3594e58fdde3f3">normalize</a> () const</td></tr>
<tr class="separator:a85d7acfc544eece04e3594e58fdde3f3 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c0bcba668e079b9e90335371166fc1 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ab1a2436edabf2ff08ebc43c5fa9e4915">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a29c0bcba668e079b9e90335371166fc1">invert</a> () const</td></tr>
<tr class="separator:a29c0bcba668e079b9e90335371166fc1 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3c2d6d0d7b63811c482657a66ea7ef inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aea3c2d6d0d7b63811c482657a66ea7ef">operator+</a> () const</td></tr>
<tr class="separator:aea3c2d6d0d7b63811c482657a66ea7ef inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e03942d762fddc039a366f31a6ca2 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae57e03942d762fddc039a366f31a6ca2">operator-</a> () const</td></tr>
<tr class="separator:ae57e03942d762fddc039a366f31a6ca2 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6100b7fcf5abe106505412dc023b6f99 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6100b7fcf5abe106505412dc023b6f99">operator-</a> ()</td></tr>
<tr class="separator:a6100b7fcf5abe106505412dc023b6f99 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecfdc6af5b6552e94c28a9cbd4e5ccf inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4ecfdc6af5b6552e94c28a9cbd4e5ccf">operator~</a> () const</td></tr>
<tr class="separator:a4ecfdc6af5b6552e94c28a9cbd4e5ccf inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e990f48f3610f38bc07d392c74cc80f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a5e990f48f3610f38bc07d392c74cc80f">operator~</a> ()</td></tr>
<tr class="separator:a5e990f48f3610f38bc07d392c74cc80f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad468d4d3a4c6a6aa5a702096e6dd28ed inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad468d4d3a4c6a6aa5a702096e6dd28ed">negate</a> () const</td></tr>
<tr class="separator:ad468d4d3a4c6a6aa5a702096e6dd28ed inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49cea7e6ecd158ed3b095ccdd9ebd70 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a277fa95f8e821dfda695121715cec9d5">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa49cea7e6ecd158ed3b095ccdd9ebd70">updNegate</a> ()</td></tr>
<tr class="separator:aa49cea7e6ecd158ed3b095ccdd9ebd70 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0812b1d07bb259046727baa5ad851acc inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0812b1d07bb259046727baa5ad851acc">transpose</a> () const</td></tr>
<tr class="separator:a0812b1d07bb259046727baa5ad851acc inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7563cd32d9122374cc23dee6abee8f53 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#aef5efe848398d53aba2b0860a2589531">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a7563cd32d9122374cc23dee6abee8f53">updTranspose</a> ()</td></tr>
<tr class="separator:a7563cd32d9122374cc23dee6abee8f53 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27dc787e2001efc4dd6b4be1971fa21 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a5ec1730573a75d69d19b911bc195b014">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad27dc787e2001efc4dd6b4be1971fa21">positionalTranspose</a> () const</td></tr>
<tr class="separator:ad27dc787e2001efc4dd6b4be1971fa21 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b97309e930356b4cee24a3a89b07933 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a5ec1730573a75d69d19b911bc195b014">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8b97309e930356b4cee24a3a89b07933">updPositionalTranspose</a> ()</td></tr>
<tr class="separator:a8b97309e930356b4cee24a3a89b07933 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808dad2e219b7130b1f0763da931993d inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#ac5d6421e7a18cba31f69efee1642dd1e">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a808dad2e219b7130b1f0763da931993d">real</a> () const</td></tr>
<tr class="separator:a808dad2e219b7130b1f0763da931993d inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afdda1cecb8a28f7d68dfa513a6860f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ac5d6421e7a18cba31f69efee1642dd1e">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8afdda1cecb8a28f7d68dfa513a6860f">real</a> ()</td></tr>
<tr class="separator:a8afdda1cecb8a28f7d68dfa513a6860f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad325674fea00f92fc5a2a372465aa41f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#ad9cb6efc99cb8d68b8f5dcf0de22d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad325674fea00f92fc5a2a372465aa41f">imag</a> () const</td></tr>
<tr class="separator:ad325674fea00f92fc5a2a372465aa41f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0be6880c67a146ebe3a768d3a10d4a2 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ad9cb6efc99cb8d68b8f5dcf0de22d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa0be6880c67a146ebe3a768d3a10d4a2">imag</a> ()</td></tr>
<tr class="separator:aa0be6880c67a146ebe3a768d3a10d4a2 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90c574914218748bc7c38c01de9f77 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#ae8a35b8bde4a34b61532c2d64e977dcf">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8c90c574914218748bc7c38c01de9f77">castAwayNegatorIfAny</a> () const</td></tr>
<tr class="separator:a8c90c574914218748bc7c38c01de9f77 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50a0e77ff033d1ae7ae2a9cc4bd1f8e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ae8a35b8bde4a34b61532c2d64e977dcf">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa50a0e77ff033d1ae7ae2a9cc4bd1f8e">updCastAwayNegatorIfAny</a> ()</td></tr>
<tr class="separator:aa50a0e77ff033d1ae7ae2a9cc4bd1f8e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96925501da3461f35688e1cd36e6abb4 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a96925501da3461f35688e1cd36e6abb4">row</a> (int i) const</td></tr>
<tr class="separator:a96925501da3461f35688e1cd36e6abb4 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731fda138d0baa893e93256e233af009 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a731fda138d0baa893e93256e233af009">row</a> (int i)</td></tr>
<tr class="separator:a731fda138d0baa893e93256e233af009 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68bfe8bef916edcec839c76baea3a47 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af68bfe8bef916edcec839c76baea3a47">col</a> (int j) const</td></tr>
<tr class="separator:af68bfe8bef916edcec839c76baea3a47 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e65240a13926d09aa9bb6066f2998 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae32e65240a13926d09aa9bb6066f2998">col</a> (int j)</td></tr>
<tr class="separator:ae32e65240a13926d09aa9bb6066f2998 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693af5db04bb135f688d16b81f1102c0 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a693af5db04bb135f688d16b81f1102c0">elt</a> (int i, int j) const</td></tr>
<tr class="separator:a693af5db04bb135f688d16b81f1102c0 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac329d8ec7659a689333659907d98a71 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aac329d8ec7659a689333659907d98a71">elt</a> (int i, int j)</td></tr>
<tr class="separator:aac329d8ec7659a689333659907d98a71 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caaf61ea378123bae1bd58daa244897 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Mat.html#a956fdad138444b1a58edc04dc7b3e620">TDiag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a7caaf61ea378123bae1bd58daa244897">diag</a> () const</td></tr>
<tr class="memdesc:a7caaf61ea378123bae1bd58daa244897 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select main diagonal (of largest leading square if rectangular) and return it as a read-only view (as a Vec) of the diagonal elements of this Mat.  <a href="classSimTK_1_1Mat.html#a7caaf61ea378123bae1bd58daa244897">More...</a><br /></td></tr>
<tr class="separator:a7caaf61ea378123bae1bd58daa244897 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62076c16a395e35134bdd01c9a589280 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a956fdad138444b1a58edc04dc7b3e620">TDiag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a62076c16a395e35134bdd01c9a589280">diag</a> ()</td></tr>
<tr class="memdesc:a62076c16a395e35134bdd01c9a589280 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">This non-const version of <a class="el" href="classSimTK_1_1Mat.html#a62076c16a395e35134bdd01c9a589280" title="This non-const version of diag() is an alternate name for updDiag() available for historical reasons...">diag()</a> is an alternate name for <a class="el" href="classSimTK_1_1Mat.html#ae0992c15e0e422863eede1f8a26d0211" title="Select main diagonal (of largest leading square if rectangular) and return it as a writable view (as ...">updDiag()</a> available for historical reasons.  <a href="classSimTK_1_1Mat.html#a62076c16a395e35134bdd01c9a589280">More...</a><br /></td></tr>
<tr class="separator:a62076c16a395e35134bdd01c9a589280 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0992c15e0e422863eede1f8a26d0211 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a956fdad138444b1a58edc04dc7b3e620">TDiag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ae0992c15e0e422863eede1f8a26d0211">updDiag</a> ()</td></tr>
<tr class="memdesc:ae0992c15e0e422863eede1f8a26d0211 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select main diagonal (of largest leading square if rectangular) and return it as a writable view (as a Vec) of the diagonal elements of this Mat.  <a href="classSimTK_1_1Mat.html#ae0992c15e0e422863eede1f8a26d0211">More...</a><br /></td></tr>
<tr class="separator:ae0992c15e0e422863eede1f8a26d0211 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad27a0dc934dd483014dceb6549e21e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a21473d71d2fb2ae807c9822e7dac2adf">EStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4ad27a0dc934dd483014dceb6549e21e">trace</a> () const</td></tr>
<tr class="separator:a4ad27a0dc934dd483014dceb6549e21e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404ad4acac7fa57d27c7c7e1b37beb92 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::template Result&lt; EE &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a404ad4acac7fa57d27c7c7e1b37beb92">scalarMultiply</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a404ad4acac7fa57d27c7c7e1b37beb92 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58114ac495ed3d8ff9d4389c6fbb110 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::Mul &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac58114ac495ed3d8ff9d4389c6fbb110">scalarMultiplyFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:ac58114ac495ed3d8ff9d4389c6fbb110 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e560d56dfc500211595a17b26473e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::template Result&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a81e560d56dfc500211595a17b26473e8">scalarDivide</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a81e560d56dfc500211595a17b26473e8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51e005ae3725fd1f27846e34a8c2499 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::Dvd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa51e005ae3725fd1f27846e34a8c2499">scalarDivideFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:aa51e005ae3725fd1f27846e34a8c2499 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500c613d77e3d73b3564b365d39e53b inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::template Result&lt; EE &gt;::Add &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9500c613d77e3d73b3564b365d39e53b">scalarAdd</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a9500c613d77e3d73b3564b365d39e53b inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed53cc79ac78ac55c339bb85aa227cb inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::template Result&lt; EE &gt;::Sub &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a7ed53cc79ac78ac55c339bb85aa227cb">scalarSubtract</a> (const EE &amp;e) const</td></tr>
<tr class="separator:a7ed53cc79ac78ac55c339bb85aa227cb inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64ef48b0f90102474097e4f63ae424 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template Result&lt; <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a> &gt;::Sub &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#adf64ef48b0f90102474097e4f63ae424">scalarSubtractFromLeft</a> (const EE &amp;e) const</td></tr>
<tr class="separator:adf64ef48b0f90102474097e4f63ae424 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861e45067be97f786a2e76779212d1a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac861e45067be97f786a2e76779212d1a">operator/=</a> (const EE &amp;e)</td></tr>
<tr class="separator:ac861e45067be97f786a2e76779212d1a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b03f7a2fee7a58da950b14cc378ca0d inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a4b03f7a2fee7a58da950b14cc378ca0d">scalarEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a4b03f7a2fee7a58da950b14cc378ca0d inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a39f08bdd89f4851138e11f4a16fa2 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ad8a39f08bdd89f4851138e11f4a16fa2">scalarPlusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:ad8a39f08bdd89f4851138e11f4a16fa2 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ec35a95b013f28540ddf9a0ae05b39 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa2ec35a95b013f28540ddf9a0ae05b39">scalarMinusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:aa2ec35a95b013f28540ddf9a0ae05b39 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828a86a4aa043d1e40dc148f2f64d29 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9828a86a4aa043d1e40dc148f2f64d29">scalarMinusEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a9828a86a4aa043d1e40dc148f2f64d29 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47c680cd6f882c3c293e110317b8a68 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af47c680cd6f882c3c293e110317b8a68">scalarTimesEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:af47c680cd6f882c3c293e110317b8a68 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2acb38cd7f785baf3af5888a50671 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a89c2acb38cd7f785baf3af5888a50671">scalarTimesEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a89c2acb38cd7f785baf3af5888a50671 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929a0cfc0ef50a0ceeb99833493e1044 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a929a0cfc0ef50a0ceeb99833493e1044">scalarDivideEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a929a0cfc0ef50a0ceeb99833493e1044 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d259aa3b2598a8abcffdc64e32cce1 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac4d259aa3b2598a8abcffdc64e32cce1">scalarDivideEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:ac4d259aa3b2598a8abcffdc64e32cce1 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278efce6393b52d08909cb8fe511f0bc inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a278efce6393b52d08909cb8fe511f0bc">setToNaN</a> ()</td></tr>
<tr class="separator:a278efce6393b52d08909cb8fe511f0bc inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed637f1c91cbc64291c4cab698106359 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aed637f1c91cbc64291c4cab698106359">setToZero</a> ()</td></tr>
<tr class="separator:aed637f1c91cbc64291c4cab698106359 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23667bee439137a3bb36bda79ad6bf0c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const SubMat&lt; MM, NN &gt;::Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a23667bee439137a3bb36bda79ad6bf0c">getSubMat</a> (int i, int j) const</td></tr>
<tr class="separator:a23667bee439137a3bb36bda79ad6bf0c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb479015894f95fcf50c85ad30c9a26d inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">SubMat&lt; MM, NN &gt;::Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abb479015894f95fcf50c85ad30c9a26d">updSubMat</a> (int i, int j)</td></tr>
<tr class="separator:abb479015894f95fcf50c85ad30c9a26d inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb0a9b84f7f099f92d4b6df54f1aa94 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0bb0a9b84f7f099f92d4b6df54f1aa94">setSubMat</a> (int i, int j, const typename SubMat&lt; MM, NN &gt;::Type &amp;value)</td></tr>
<tr class="separator:a0bb0a9b84f7f099f92d4b6df54f1aa94 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7a5f8a2314caf9e667312b7723ca09 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#aa8fd0c2490f6a4b070924d5c64bfbc4d">TDropRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3e7a5f8a2314caf9e667312b7723ca09">dropRow</a> (int i) const</td></tr>
<tr class="memdesc:a3e7a5f8a2314caf9e667312b7723ca09 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row smaller than this one by dropping row i.  <a href="classSimTK_1_1Mat.html#a3e7a5f8a2314caf9e667312b7723ca09">More...</a><br /></td></tr>
<tr class="separator:a3e7a5f8a2314caf9e667312b7723ca09 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3da4fb81f238bb2da9b12d0814a3f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#ac224fd04608b7973fd66ef859fea67c5">TDropCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#acab3da4fb81f238bb2da9b12d0814a3f">dropCol</a> (int j) const</td></tr>
<tr class="memdesc:acab3da4fb81f238bb2da9b12d0814a3f inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one column smaller than this one by dropping column j.  <a href="classSimTK_1_1Mat.html#acab3da4fb81f238bb2da9b12d0814a3f">More...</a><br /></td></tr>
<tr class="separator:acab3da4fb81f238bb2da9b12d0814a3f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af321277266de661a74426b602a8d2564 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a19a89676e5be08066b8ce8df4a6b685d">TDropRowCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#af321277266de661a74426b602a8d2564">dropRowCol</a> (int i, int j) const</td></tr>
<tr class="memdesc:af321277266de661a74426b602a8d2564 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row and one column smaller than this one by dropping row i and column j.  <a href="classSimTK_1_1Mat.html#af321277266de661a74426b602a8d2564">More...</a><br /></td></tr>
<tr class="separator:af321277266de661a74426b602a8d2564 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588b55e8e4a28e10b5aeff3d79bd98c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a90f421f6ae04de16d19af931aec18637">TAppendRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa588b55e8e4a28e10b5aeff3d79bd98c">appendRow</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#a96925501da3461f35688e1cd36e6abb4">row</a>) const</td></tr>
<tr class="memdesc:aa588b55e8e4a28e10b5aeff3d79bd98c inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row larger than this one by adding a row to the end.  <a href="classSimTK_1_1Mat.html#aa588b55e8e4a28e10b5aeff3d79bd98c">More...</a><br /></td></tr>
<tr class="separator:aa588b55e8e4a28e10b5aeff3d79bd98c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5763e832e61009941d88d3c964c162 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a19c87c8e05e8fbd16672343e06e5a341">TAppendCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abd5763e832e61009941d88d3c964c162">appendCol</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#af68bfe8bef916edcec839c76baea3a47">col</a>) const</td></tr>
<tr class="memdesc:abd5763e832e61009941d88d3c964c162 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one column larger than this one by adding a column to the end.  <a href="classSimTK_1_1Mat.html#abd5763e832e61009941d88d3c964c162">More...</a><br /></td></tr>
<tr class="separator:abd5763e832e61009941d88d3c964c162 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c444417376cc6c0a5f19b207457066c inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#acd51c59501eca17fce8993bd70958b93">TAppendRowCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a0c444417376cc6c0a5f19b207457066c">appendRowCol</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N+1, ER, SR &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#a96925501da3461f35688e1cd36e6abb4">row</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, EC, SC &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#af68bfe8bef916edcec839c76baea3a47">col</a>) const</td></tr>
<tr class="memdesc:a0c444417376cc6c0a5f19b207457066c inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row and one column larger than this one by adding a row to the bottom and a column to the right.  <a href="classSimTK_1_1Mat.html#a0c444417376cc6c0a5f19b207457066c">More...</a><br /></td></tr>
<tr class="separator:a0c444417376cc6c0a5f19b207457066c inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc2663283f3ccf052ec9b57510dc3e4 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a90f421f6ae04de16d19af931aec18637">TAppendRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#acbc2663283f3ccf052ec9b57510dc3e4">insertRow</a> (int i, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N, EE, SS &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#a96925501da3461f35688e1cd36e6abb4">row</a>) const</td></tr>
<tr class="memdesc:acbc2663283f3ccf052ec9b57510dc3e4 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row larger than this one by inserting a row <em>before</em> row i.  <a href="classSimTK_1_1Mat.html#acbc2663283f3ccf052ec9b57510dc3e4">More...</a><br /></td></tr>
<tr class="separator:acbc2663283f3ccf052ec9b57510dc3e4 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868f99c1645fbcdfdc994f314c033c56 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a19c87c8e05e8fbd16672343e06e5a341">TAppendCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a868f99c1645fbcdfdc994f314c033c56">insertCol</a> (int j, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#af68bfe8bef916edcec839c76baea3a47">col</a>) const</td></tr>
<tr class="memdesc:a868f99c1645fbcdfdc994f314c033c56 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one column larger than this one by inserting a column <em>before</em> column j.  <a href="classSimTK_1_1Mat.html#a868f99c1645fbcdfdc994f314c033c56">More...</a><br /></td></tr>
<tr class="separator:a868f99c1645fbcdfdc994f314c033c56 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54db4ed4744eb93609cbca501924391 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#acd51c59501eca17fce8993bd70958b93">TAppendRowCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aa54db4ed4744eb93609cbca501924391">insertRowCol</a> (int i, int j, const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; N+1, ER, SR &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#a96925501da3461f35688e1cd36e6abb4">row</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, EC, SC &gt; &amp;<a class="el" href="classSimTK_1_1Mat.html#af68bfe8bef916edcec839c76baea3a47">col</a>) const</td></tr>
<tr class="memdesc:aa54db4ed4744eb93609cbca501924391 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix one row and one column larger than this one by inserting a row <em>before</em> row i and a column <em>before</em> column j.  <a href="classSimTK_1_1Mat.html#aa54db4ed4744eb93609cbca501924391">More...</a><br /></td></tr>
<tr class="separator:aa54db4ed4744eb93609cbca501924391 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab617ea6f16ccd9a2dd92779a6d002364 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab617ea6f16ccd9a2dd92779a6d002364">isNaN</a> () const</td></tr>
<tr class="memdesc:ab617ea6f16ccd9a2dd92779a6d002364 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this Mat contains a NaN anywhere.  <a href="classSimTK_1_1Mat.html#ab617ea6f16ccd9a2dd92779a6d002364">More...</a><br /></td></tr>
<tr class="separator:ab617ea6f16ccd9a2dd92779a6d002364 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18fae97eba9f5b91d093fdebacef57e inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ac18fae97eba9f5b91d093fdebacef57e">isInf</a> () const</td></tr>
<tr class="memdesc:ac18fae97eba9f5b91d093fdebacef57e inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this Mat contains a +Inf or -Inf somewhere but no element contains a NaN anywhere.  <a href="classSimTK_1_1Mat.html#ac18fae97eba9f5b91d093fdebacef57e">More...</a><br /></td></tr>
<tr class="separator:ac18fae97eba9f5b91d093fdebacef57e inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95364f31c7748982af1530407c7108e0 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a95364f31c7748982af1530407c7108e0">isFinite</a> () const</td></tr>
<tr class="memdesc:a95364f31c7748982af1530407c7108e0 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if no element contains an Infinity or a NaN.  <a href="classSimTK_1_1Mat.html#a95364f31c7748982af1530407c7108e0">More...</a><br /></td></tr>
<tr class="separator:a95364f31c7748982af1530407c7108e0 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b415de868e7964cf8fa8fb14a95ab inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a359b415de868e7964cf8fa8fb14a95ab">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;m, double tol) const</td></tr>
<tr class="memdesc:a359b415de868e7964cf8fa8fb14a95ab inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this matrix is numerically equal to some other matrix with the same shape, using a specified tolerance.  <a href="classSimTK_1_1Mat.html#a359b415de868e7964cf8fa8fb14a95ab">More...</a><br /></td></tr>
<tr class="separator:a359b415de868e7964cf8fa8fb14a95ab inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2308c2a6d864bbf7fc3ff46c7c0ea6 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#aff2308c2a6d864bbf7fc3ff46c7c0ea6">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, E2, CS2, RS2 &gt; &amp;m) const</td></tr>
<tr class="memdesc:aff2308c2a6d864bbf7fc3ff46c7c0ea6 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this matrix is numerically equal to some other matrix with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared.  <a href="classSimTK_1_1Mat.html#aff2308c2a6d864bbf7fc3ff46c7c0ea6">More...</a><br /></td></tr>
<tr class="separator:aff2308c2a6d864bbf7fc3ff46c7c0ea6 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3b98c2b5fe8e35c29d82238ae75b3f inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a9c3b98c2b5fe8e35c29d82238ae75b3f">isNumericallyEqual</a> (const P &amp;e, double tol=<a class="el" href="classSimTK_1_1Mat.html#a3005dc435071cfb874a222b49338e549">getDefaultTolerance</a>()) const</td></tr>
<tr class="memdesc:a9c3b98c2b5fe8e35c29d82238ae75b3f inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this is numerically a "scalar" matrix, meaning that it is a diagonal matrix in which each diagonal element is numerically equal to the same scalar, using either a specified tolerance or the matrix's default tolerance (which is always the same or looser than the default tolerance for one of its elements).  <a href="classSimTK_1_1Mat.html#a9c3b98c2b5fe8e35c29d82238ae75b3f">More...</a><br /></td></tr>
<tr class="separator:a9c3b98c2b5fe8e35c29d82238ae75b3f inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb23d84f47149f535eef9aee6c4abadd inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abb23d84f47149f535eef9aee6c4abadd">isNumericallySymmetric</a> (double tol=<a class="el" href="classSimTK_1_1Mat.html#a3005dc435071cfb874a222b49338e549">getDefaultTolerance</a>()) const</td></tr>
<tr class="memdesc:abb23d84f47149f535eef9aee6c4abadd inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Matrix is symmetric (actually Hermitian) if it is square and each element (i,j) is the Hermitian transpose of element (j,i).  <a href="classSimTK_1_1Mat.html#abb23d84f47149f535eef9aee6c4abadd">More...</a><br /></td></tr>
<tr class="separator:abb23d84f47149f535eef9aee6c4abadd inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6665cfc050e2a3a8d86857409fbdda5b inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a6665cfc050e2a3a8d86857409fbdda5b">isExactlySymmetric</a> () const</td></tr>
<tr class="memdesc:a6665cfc050e2a3a8d86857409fbdda5b inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Matrix is symmetric (actually Hermitian) if it is square and each element (i,j) is the Hermitian (conjugate) transpose of element (j,i).  <a href="classSimTK_1_1Mat.html#a6665cfc050e2a3a8d86857409fbdda5b">More...</a><br /></td></tr>
<tr class="separator:a6665cfc050e2a3a8d86857409fbdda5b inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7482eb419101c2f80bd4804c722b4c1a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a7482eb419101c2f80bd4804c722b4c1a">colSum</a> () const</td></tr>
<tr class="memdesc:a7482eb419101c2f80bd4804c722b4c1a inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a row vector (Row) containing the column sums of this matrix.  <a href="classSimTK_1_1Mat.html#a7482eb419101c2f80bd4804c722b4c1a">More...</a><br /></td></tr>
<tr class="separator:a7482eb419101c2f80bd4804c722b4c1a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3513b4b11fc6a2694c0187d2b109af17 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a6d68b382d22f097026db4901c71c5597">TRow</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3513b4b11fc6a2694c0187d2b109af17">sum</a> () const</td></tr>
<tr class="memdesc:a3513b4b11fc6a2694c0187d2b109af17 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alternate name for <a class="el" href="classSimTK_1_1Mat.html#a7482eb419101c2f80bd4804c722b4c1a" title="Returns a row vector (Row) containing the column sums of this matrix. ">colSum()</a>; behaves like the Matlab function of the same name.  <a href="classSimTK_1_1Mat.html#a3513b4b11fc6a2694c0187d2b109af17">More...</a><br /></td></tr>
<tr class="separator:a3513b4b11fc6a2694c0187d2b109af17 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9294db47d51ab481a294c7f10bfc6a inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html#a56e36aa5c1ae0a8a5835f435ce3ed86c">TCol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#abc9294db47d51ab481a294c7f10bfc6a">rowSum</a> () const</td></tr>
<tr class="memdesc:abc9294db47d51ab481a294c7f10bfc6a inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a column vector (Vec) containing the row sums of this matrix.  <a href="classSimTK_1_1Mat.html#abc9294db47d51ab481a294c7f10bfc6a">More...</a><br /></td></tr>
<tr class="separator:abc9294db47d51ab481a294c7f10bfc6a inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d7017b44464a4f9a646ec7c2e9faae inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#ab5d7017b44464a4f9a646ec7c2e9faae">toString</a> () const</td></tr>
<tr class="memdesc:ab5d7017b44464a4f9a646ec7c2e9faae inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Mat.html#ab5d7017b44464a4f9a646ec7c2e9faae" title="toString() returns a string representation of the Mat. ">toString()</a> returns a string representation of the Mat.  <a href="classSimTK_1_1Mat.html#ab5d7017b44464a4f9a646ec7c2e9faae">More...</a><br /></td></tr>
<tr class="separator:ab5d7017b44464a4f9a646ec7c2e9faae inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb32357be3c922ace1bf420d3a98d8 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">const P &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a22fb32357be3c922ace1bf420d3a98d8">get</a> (int i, int j) const</td></tr>
<tr class="memdesc:a22fb32357be3c922ace1bf420d3a98d8 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of indexing operator that's scripting friendly to get entry (i, j)  <a href="classSimTK_1_1Mat.html#a22fb32357be3c922ace1bf420d3a98d8">More...</a><br /></td></tr>
<tr class="separator:a22fb32357be3c922ace1bf420d3a98d8 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3c83ee7f3cfcc170bac73bb19e4263 inherit pub_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8a3c83ee7f3cfcc170bac73bb19e4263">set</a> (int i, int j, const P &amp;value)</td></tr>
<tr class="memdesc:a8a3c83ee7f3cfcc170bac73bb19e4263 inherit pub_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of indexing operator that's scripting friendly to set entry (i, j)  <a href="classSimTK_1_1Mat.html#a8a3c83ee7f3cfcc170bac73bb19e4263">More...</a><br /></td></tr>
<tr class="separator:a8a3c83ee7f3cfcc170bac73bb19e4263 inherit pub_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSimTK_1_1Mat"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSimTK_1_1Mat')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSimTK_1_1Mat.html">SimTK::Mat&lt; 3, 3, P &gt;</a></td></tr>
<tr class="memitem:a8660d113298fda958e5b34424e613626 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a8660d113298fda958e5b34424e613626">size</a> ()</td></tr>
<tr class="memdesc:a8660d113298fda958e5b34424e613626 inherit pub_static_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of elements M*N contained in this Mat.  <a href="classSimTK_1_1Mat.html#a8660d113298fda958e5b34424e613626">More...</a><br /></td></tr>
<tr class="separator:a8660d113298fda958e5b34424e613626 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b82597b0b148385926ed865aa2888b5 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a1b82597b0b148385926ed865aa2888b5">nrow</a> ()</td></tr>
<tr class="memdesc:a1b82597b0b148385926ed865aa2888b5 inherit pub_static_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows in this Mat, echoing the value supplied for the template parameter <em>M</em>.  <a href="classSimTK_1_1Mat.html#a1b82597b0b148385926ed865aa2888b5">More...</a><br /></td></tr>
<tr class="separator:a1b82597b0b148385926ed865aa2888b5 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60485ad59f010b8af0281d6d21b11c24 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a60485ad59f010b8af0281d6d21b11c24">ncol</a> ()</td></tr>
<tr class="memdesc:a60485ad59f010b8af0281d6d21b11c24 inherit pub_static_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns in this Mat, echoing the value supplied for the template parameter <em>N</em>.  <a href="classSimTK_1_1Mat.html#a60485ad59f010b8af0281d6d21b11c24">More...</a><br /></td></tr>
<tr class="separator:a60485ad59f010b8af0281d6d21b11c24 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80737c2a4e4f6e776e4b5fe85b718086 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a80737c2a4e4f6e776e4b5fe85b718086">getAs</a> (const P *p)</td></tr>
<tr class="separator:a80737c2a4e4f6e776e4b5fe85b718086 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c00b775b66663fea90a4a3c5432220 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a70c00b775b66663fea90a4a3c5432220">updAs</a> (P *p)</td></tr>
<tr class="separator:a70c00b775b66663fea90a4a3c5432220 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098455bf9d34ff63deaaafb9aae071ec inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, P, M, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a098455bf9d34ff63deaaafb9aae071ec">getNaN</a> ()</td></tr>
<tr class="separator:a098455bf9d34ff63deaaafb9aae071ec inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3005dc435071cfb874a222b49338e549 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Mat.html#a3005dc435071cfb874a222b49338e549">getDefaultTolerance</a> ()</td></tr>
<tr class="memdesc:a3005dc435071cfb874a222b49338e549 inherit pub_static_methods_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">For approximate comparisons, the default tolerance to use for a matrix is its shortest dimension times its elements' default tolerance.  <a href="classSimTK_1_1Mat.html#a3005dc435071cfb874a222b49338e549">More...</a><br /></td></tr>
<tr class="separator:a3005dc435071cfb874a222b49338e549 inherit pub_static_methods_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1Mat"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Mat')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Mat.html">SimTK::Mat&lt; 3, 3, P &gt;</a></td></tr>
<tr class="memitem:gab42c9328d2713319247ceccdd117fc34 inherit related_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writeUnformatted.html#gab42c9328d2713319247ceccdd117fc34">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, CS, RS &gt; &amp;v)</td></tr>
<tr class="memdesc:gab42c9328d2713319247ceccdd117fc34 inherit related_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Mat&lt;M,N,E,CS,RS&gt; delegating to Row&lt;N,E,RS&gt; with newlines separating the rows, but no final newline.  <a href="group__writeUnformatted.html#gab42c9328d2713319247ceccdd117fc34">More...</a><br /></td></tr>
<tr class="separator:gab42c9328d2713319247ceccdd117fc34 inherit related_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5721daf8ec53d172f0eb2ea2357c662 inherit related_classSimTK_1_1Mat"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__readFromStream.html#gae5721daf8ec53d172f0eb2ea2357c662">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, N, <a class="el" href="classSimTK_1_1Mat.html#a5faf23d1979c90781a6fa6646015b7d4">E</a>, CS, RS &gt; &amp;v)</td></tr>
<tr class="memdesc:gae5721daf8ec53d172f0eb2ea2357c662 inherit related_classSimTK_1_1Mat"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Mat&lt;M,N,E,CS,RS&gt; delegating to Row&lt;N,E,RS&gt;.  <a href="group__readFromStream.html#gae5721daf8ec53d172f0eb2ea2357c662">More...</a><br /></td></tr>
<tr class="separator:gae5721daf8ec53d172f0eb2ea2357c662 inherit related_classSimTK_1_1Mat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::Rotation_&lt; P &gt;</h3>

<p>The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 rotation matrix giving the relative orientation of two right-handed, orthogonal, unit vector bases. </p>
<p>A rotation matrix, also known as a direction cosine matrix, is an orthogonal matrix whose columns and rows are directions (that is, unit vectors) that are mutually orthogonal. Furthermore, if the columns (or rows) are labeled x,y,z it always holds that z = x X y (rather than -(x X y)) ensuring that this is a right-handed rotation matrix and not a reflection. This is equivalent to saying that the determinant of a rotation matrix is 1, not -1.</p>
<p>The Rotation class takes advantage of known properties of orthogonal matrices. For example, multiplication by a rotation matrix preserves a vector's length so unit vectors are still unit vectors afterwards and don't need to be re-normalized.</p>
<p>Suppose there is a vector v_F expressed in terms of the right-handed, orthogonal unit vectors Fx, Fy, Fz and one would like to express v instead as v_G, in terms of a right-handed, orthogonal unit vectors Gx, Gy, Gz. To calculate it, we form a rotation matrix R_GF whose columns are the F unit vectors re-expressed in G: </p><pre>
            G F   (      |      |      )
     R_GF =  R  = ( Fx_G | Fy_G | Fz_G )
                  (      |      |      )
where
     Fx_G = ~( ~Fx*Gx, ~Fx*Gy, ~Fx*Gz ), etc.
</pre><p> (~Fx*Gx means dot(Fx,Gx)). Note that we use "monogram" notation R_GF in code to represent the more typographically demanding superscripted notation for rotation matrices. Now we can re-express the vector v from frame F to frame G via </p><pre>
     v_G = R_GF * v_F. 
</pre><p> Because a rotation is orthogonal, its transpose is its inverse. Hence R_FG = ~R_GF (where ~ is the <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> "transpose" operator). This transpose matrix can be used to expressed v_G in terms of Fx, Fy, Fz as </p><pre>
     v_F = R_FG * v_G  or  v_F = ~R_GF * v_G
</pre><p> In either direction, correct behavior can be obtained by using the recommended notation and then matching up the frame labels (after interpreting the "~" operator as reversing the labels).</p>
<p>The <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> class is templatized by the precision P, which should be float or double. A typedef defining type Rotation as <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_&lt;Real&gt;</a> is always defined and is normally used in user programs rather than the templatized class. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3e2fe478b01daff763b20886c3773430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2fe478b01daff763b20886c3773430">&#9670;&nbsp;</a></span>RealP</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef P <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are just local abbreviations. </p>

</div>
</div>
<a id="afa407f28b9d81d01368529ee7f7b8d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa407f28b9d81d01368529ee7f7b8d73">&#9670;&nbsp;</a></span>Mat22P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;2,2,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#afa407f28b9d81d01368529ee7f7b8d73">Mat22P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00c3e0c9c1a847641ca2ec715d7b1815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3e0c9c1a847641ca2ec715d7b1815">&#9670;&nbsp;</a></span>Mat32P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;3,2,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a00c3e0c9c1a847641ca2ec715d7b1815">Mat32P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac072fb845028c8f0aa199bd0cddb7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac072fb845028c8f0aa199bd0cddb7df9">&#9670;&nbsp;</a></span>Mat33P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;3,3,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a315774852e091803bb35e68502c5cfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315774852e091803bb35e68502c5cfef">&#9670;&nbsp;</a></span>Mat43P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,3,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad61eab201f0333ac3107708828b48d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61eab201f0333ac3107708828b48d6a">&#9670;&nbsp;</a></span>Mat34P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;3,4,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ad61eab201f0333ac3107708828b48d6a">Mat34P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae57cfb41c686d5c3c28d3cd2799c0238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57cfb41c686d5c3c28d3cd2799c0238">&#9670;&nbsp;</a></span>Vec2P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;2,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd2b9fc21ea18fa45243ba6259a9f8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2b9fc21ea18fa45243ba6259a9f8c3">&#9670;&nbsp;</a></span>Vec3P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4360cabd778a395e70af322f666e46fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4360cabd778a395e70af322f666e46fe">&#9670;&nbsp;</a></span>Vec4P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a0430849ee6a93f6e73db1473d80a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0430849ee6a93f6e73db1473d80a26">&#9670;&nbsp;</a></span>UnitVec3P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,1&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a50dfa7292af6166cf3f47a769be21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a50dfa7292af6166cf3f47a769be21">&#9670;&nbsp;</a></span>SymMat33P</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt;3,P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae558a511005019194f262fbd3b7dd08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae558a511005019194f262fbd3b7dd08d">&#9670;&nbsp;</a></span>QuaternionP</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Quaternion__.html">Quaternion_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8156453423742aa7ab103650c3ffa4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8156453423742aa7ab103650c3ffa4a2">&#9670;&nbsp;</a></span>ColType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a27fc7b5604dacb9eedeef01198463960">Mat33P::RowSpacing</a>&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a column of this Rotation matrix. </p>
<p>It will be a <a class="el" href="classSimTK_1_1Vec.html">Vec&lt;3&gt;</a> but will not necessarily have unit spacing. </p>

</div>
</div>
<a id="a0c41f591c9926e8436596f924967f45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c41f591c9926e8436596f924967f45c">&#9670;&nbsp;</a></span>RowType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1UnitRow.html">UnitRow</a>&lt;P,<a class="el" href="classSimTK_1_1Mat.html#a9d5d5b39f2f26327081406be46fb3d81a91607a34c56f039489106477fcfcecac">Mat33P::ColSpacing</a>&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a row of this Rotation matrix. </p>
<p>It will be a Row&lt;3&gt; but will not necessarily have unit spacing. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7dc8a355b0476f8fc3897225bcec0028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc8a355b0476f8fc3897225bcec0028">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a966293b042b3b6f3906bb15aec3110d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966293b042b3b6f3906bb15aec3110d2">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a125229971a87b9405c6943687ae5cb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125229971a87b9405c6943687ae5cb6c">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like copy constructor but for inverse rotation. </p>
<p>This allows implicit conversion from <a class="el" href="classSimTK_1_1InverseRotation__.html" title="(Advanced) This InverseRotation class is the inverse of a Rotation. ">InverseRotation_</a> to <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a>. </p>

</div>
</div>
<a id="a19962cc7af21545ae8e8f63702e83624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19962cc7af21545ae8e8f63702e83624">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a id="aeaa3df1484427409f85bdba47f263d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa3df1484427409f85bdba47f263d18">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1XCoordinateAxis.html">CoordinateAxis::XCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about the X-axis. </p>

</div>
</div>
<a id="a6a3cf04efd08eda9a303036fa6346bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3cf04efd08eda9a303036fa6346bb9">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1YCoordinateAxis.html">CoordinateAxis::YCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about the Y-axis. </p>

</div>
</div>
<a id="ab1171f57869b8633941395bc3baed5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1171f57869b8633941395bc3baed5ed">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis_1_1ZCoordinateAxis.html">CoordinateAxis::ZCoordinateAxis</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about the Z-axis. </p>

</div>
</div>
<a id="ae551ca3f12b485259ba56def8ccd152a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae551ca3f12b485259ba56def8ccd152a">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>unitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about an arbitrary unit vector. </p>

</div>
</div>
<a id="a340d147e68d17979a01248d6b70cfe45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340d147e68d17979a01248d6b70cfe45">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>nonUnitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for right-handed rotation by an angle (in radians) about an arbitrary vector of arbitrary length. </p>

</div>
</div>
<a id="a451308fdf619ff01b3b07a7d960cf354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451308fdf619ff01b3b07a7d960cf354">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians). </p>

</div>
</div>
<a id="a4de3e72e32205e18ea71b03dfdc08932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de3e72e32205e18ea71b03dfdc08932">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians). </p>

</div>
</div>
<a id="a511a6db1f00e0b2e535f70fb01d4009e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511a6db1f00e0b2e535f70fb01d4009e">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for creating a rotation matrix from a quaternion. </p>

</div>
</div>
<a id="a8c1c1cf9f8c55f4371795eab53da933e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1c1cf9f8c55f4371795eab53da933e">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P. </p>

</div>
</div>
<a id="a9c751d1b449be1eba50a5b026a18b907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c751d1b449be1eba50a5b026a18b907">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Construct a <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> directly from a Mat33P (we trust that m is a valid Rotation_!) Things will not go well for you if it is not. </p>

</div>
</div>
<a id="a56498f3bd27dfa3483cb2e91512d020d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56498f3bd27dfa3483cb2e91512d020d">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors expressed in A. </p>
<p>Note: The other vectors are perpendicular (but somewhat arbitrarily so). </p>

</div>
</div>
<a id="abf7001ed401fb3f4550a6fae494a0c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7001ed401fb3f4550a6fae494a0c7a">&#9670;&nbsp;</a></span>Rotation_() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uveci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>vecjApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisjApprox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1). </p>
<p>If v is not perpendicular to u1, no worries - we'll find a direction for u2 that is perpendicular to u1 and comes closest to v. The third vector u3 is +/- u1 X u2, as appropriate for a right-handed rotation matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad66e7d173f96a983c32d011bb0d91fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66e7d173f96a983c32d011bb0d91fc7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a id="a4ac773d1fe4e964aebf5c62c51f1cb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac773d1fe4e964aebf5c62c51f1cb1a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like copy assignment but for inverse rotation. </p>

</div>
</div>
<a id="a360123fced580910bb805feb3a602258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360123fced580910bb805feb3a602258">&#9670;&nbsp;</a></span>setRotationToNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> filled with NaNs. </p>

</div>
</div>
<a id="a352f6087f76d893011d1cf4a168d58d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352f6087f76d893011d1cf4a168d58d4">&#9670;&nbsp;</a></span>setRotationToIdentityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationToIdentityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct identity <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a>. </p>

</div>
</div>
<a id="a9d85ae0f22416a5cd6866596fc40f2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d85ae0f22416a5cd6866596fc40f2d8">&#9670;&nbsp;</a></span>setRotationFromAngleAboutAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about a coordinate axis. </p>

</div>
</div>
<a id="a2b0dd8018a891fae9f52a77a8af85913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0dd8018a891fae9f52a77a8af85913">&#9670;&nbsp;</a></span>setRotationFromAngleAboutX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the X-axis. </p>

</div>
</div>
<a id="ad3626657c38a81b2df9205db8dd48af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3626657c38a81b2df9205db8dd48af2">&#9670;&nbsp;</a></span>setRotationFromAngleAboutX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the X-axis, where the cosine and sine of the angle are specified. </p>

</div>
</div>
<a id="a03c34f207cd0c05dcf8fb4fe01bece15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c34f207cd0c05dcf8fb4fe01bece15">&#9670;&nbsp;</a></span>setRotationFromAngleAboutY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the Y-axis. </p>

</div>
</div>
<a id="a0429ecf9ca8d6bf23b2ea6a1067c13bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429ecf9ca8d6bf23b2ea6a1067c13bf">&#9670;&nbsp;</a></span>setRotationFromAngleAboutY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the Y-axis, where the cosine and sine of the angle are specified. </p>

</div>
</div>
<a id="a019d1ba576917c1294376af5d5c07684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019d1ba576917c1294376af5d5c07684">&#9670;&nbsp;</a></span>setRotationFromAngleAboutZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle (in radians) about the Z-axis. </p>

</div>
</div>
<a id="a12bea1532e99c7e6aa83e189053000b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bea1532e99c7e6aa83e189053000b2">&#9670;&nbsp;</a></span>setRotationFromAngleAboutZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>cosAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>sinAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation by an angle about the Z-axis, where the cosine and sine of the angle are specified. </p>

</div>
</div>
<a id="a69dbe7f3f47a4b0c6d7be8650d95049c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dbe7f3f47a4b0c6d7be8650d95049c">&#9670;&nbsp;</a></span>setRotationFromAngleAboutUnitVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutUnitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>unitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary unit vector. </p>

</div>
</div>
<a id="a13e4dcab37f729839b79abf5a5e77840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e4dcab37f729839b79abf5a5e77840">&#9670;&nbsp;</a></span>setRotationFromAngleAboutNonUnitVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromAngleAboutNonUnitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>nonUnitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a right-handed rotation of an angle (in radians) about an arbitrary vector of arbitrary length. </p>

</div>
</div>
<a id="afc54e75b189a41cf6b0e9d23458eae32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54e75b189a41cf6b0e9d23458eae32">&#9670;&nbsp;</a></span>setRotationFromTwoAnglesTwoAxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromTwoAnglesTwoAxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a two-angle, two-axes, Body-fixed or Space-fixed rotation sequences (angles are in radians). </p>

</div>
</div>
<a id="ad19a5140a685462e498d6d5c2c42c8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19a5140a685462e498d6d5c2c42c8c4">&#9670;&nbsp;</a></span>setRotationFromThreeAnglesThreeAxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromThreeAnglesThreeAxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>angle3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to a three-angle Body-fixed or Space-fixed rotation sequences (angles are in radians). </p>

</div>
</div>
<a id="aed39e831fc2c774c769b4afb72830874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed39e831fc2c774c769b4afb72830874">&#9670;&nbsp;</a></span>setRotationFromQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for creating a rotation matrix from a quaternion. </p>

</div>
</div>
<a id="acf320049f0aa881075905d781eee032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf320049f0aa881075905d781eee032f">&#9670;&nbsp;</a></span>setRotationFromApproximateMat33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromApproximateMat33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> object to an (hopefully nearby) orthogonal rotation matrix from a generic Mat33P. </p>

</div>
</div>
<a id="a34a70e677a952560b2ab8d972ed79801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a70e677a952560b2ab8d972ed79801">&#9670;&nbsp;</a></span>setRotationFromMat33TrustMe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromMat33TrustMe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a id="a9913668d30b526d87c63b175ccef9c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9913668d30b526d87c63b175ccef9c56">&#9670;&nbsp;</a></span>setRotationColFromUnitVecTrustMe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationColFromUnitVecTrustMe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvecj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a id="a38115244428f8fc0f4411dd092ee5fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38115244428f8fc0f4411dd092ee5fe4">&#9670;&nbsp;</a></span>setRotationFromUnitVecsTrustMe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromUnitVecsTrustMe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>colC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Set the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix directly - but you had better know what you are doing! </p>

</div>
</div>
<a id="a4d437a754fb412b10859f035bc5312d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d437a754fb412b10859f035bc5312d6">&#9670;&nbsp;</a></span>setRotationFromOneAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromOneAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors expressed in A. </p>
<p>Note: The other vectors are perpendicular (but somewhat arbitrarily so). </p>

</div>
</div>
<a id="a7efe475b1e8a00f0628a74e660e84dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efe475b1e8a00f0628a74e660e84dfa">&#9670;&nbsp;</a></span>setRotationFromTwoAxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationFromTwoAxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a9a0430849ee6a93f6e73db1473d80a26">UnitVec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>uveci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>vecjApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axisjApprox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate R_AB by knowing one of B's unit vectors u1 (could be Bx, By, or Bz) expressed in A and a vector v (also expressed in A) that is approximately in the desired direction for a second one of B's unit vectors, u2 (!= u1). </p>
<p>If v is not perpendicular to u1, no worries - we'll find a direction for u2 that is perpendicular to u1 and comes closest to v. The third vector u3 is +/- u1 X u2, as appropriate for a right-handed rotation matrix. </p>

</div>
</div>
<a id="af44ae0c01f7118c690a0c47cbf44e9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44ae0c01f7118c690a0c47cbf44e9a7">&#9670;&nbsp;</a></span>setRotationToBodyFixedXY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationToBodyFixedXY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis. </p>
<p>See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3, but the last rotation is zero. </p>

</div>
</div>
<a id="a1b5b9946341290a869fdf36263c6e901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5b9946341290a869fdf36263c6e901">&#9670;&nbsp;</a></span>setRotationToBodyFixedXYZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationToBodyFixedXYZ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to represent a rotation characterized by subsequent rotations of: +v[0] about the body frame's X axis, followed by a rotation of +v[1] about the body frame's NEW Y axis, followed by a rotation of +v[2] about the body frame's NEW (twice rotated) Z axis. </p>
<p>See Kane, Spacecraft Dynamics, pg. 423, body-three: 1-2-3. </p>

</div>
</div>
<a id="a6d2d3b70084a3a474bf2c8ac1f598bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2d3b70084a3a474bf2c8ac1f598bf6">&#9670;&nbsp;</a></span>setRotationToBodyFixedXYZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::setRotationToBodyFixedXYZ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given cosines and sines (in that order) of three angles, set this Rotation matrix to the body-fixed 1-2-3 sequence of those angles. </p>
<p>Cost is 18 flops. </p>

</div>
</div>
<a id="a9879ff3a7db426377521760cc07f3c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9879ff3a7db426377521760cc07f3c2c">&#9670;&nbsp;</a></span>operator~() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose operator. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. </p>

</div>
</div>
<a id="aec15e73cf4dbcdc7e1c6ac90f68fdef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec15e73cf4dbcdc7e1c6ac90f68fdef3">&#9670;&nbsp;</a></span>operator~() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose operator. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. </p>

</div>
</div>
<a id="aa7d6fd489c04b205b79d24c858968ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d6fd489c04b205b79d24c858968ea9">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. Overrides the base class transpose method. </p>

</div>
</div>
<a id="a83d8ca5d3b3edd6630b5fb7a0a577d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d8ca5d3b3edd6630b5fb7a0a577d72">&#9670;&nbsp;</a></span>updTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::updTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose. </p>
<p>For an orthogonal matrix like this one, transpose is the same thing as inversion. Overrides the base class transpose method. </p>

</div>
</div>
<a id="a0db1dfad4d75ef91bdb6d5a49d4e25cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db1dfad4d75ef91bdb6d5a49d4e25cc">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to <a class="el" href="classSimTK_1_1InverseRotation__.html" title="(Advanced) This InverseRotation class is the inverse of a Rotation. ">InverseRotation_</a> (no cost). </p>
<p>Overrides base class <a class="el" href="classSimTK_1_1Rotation__.html#a0db1dfad4d75ef91bdb6d5a49d4e25cc" title="Convert from Rotation_ to InverseRotation_ (no cost). ">invert()</a> method. </p>

</div>
</div>
<a id="abcf61a10b96a4320c991e55caa582386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf61a10b96a4320c991e55caa582386">&#9670;&nbsp;</a></span>updInvert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::updInvert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> to writable <a class="el" href="classSimTK_1_1InverseRotation__.html" title="(Advanced) This InverseRotation class is the inverse of a Rotation. ">InverseRotation_</a> (no cost). </p>

</div>
</div>
<a id="a26169557db013c2a8779098d00d5c846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26169557db013c2a8779098d00d5c846">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a id="a7fa2ee262d79bf91ba2465bdbecb40c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa2ee262d79bf91ba2465bdbecb40c2">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a id="ab38257532c21876c8629b224f0431080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38257532c21876c8629b224f0431080">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a id="a94079169da0047a42fe96411f36f9f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94079169da0047a42fe96411f36f9f42">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place composition of Rotation matrices. </p>

</div>
</div>
<a id="a3d8d055de40c8993a4bb9bb2d86c784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d055de40c8993a4bb9bb2d86c784a">&#9670;&nbsp;</a></span>multiplyByBodyXYZ_N_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::multiplyByBodyXYZ_N_P </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular velocity of child in parent is expected to be expressed in the parent. </p>
<p>Here we assume you have previously calculated sincos(qx), sincos(qy), and 1/cos(qy). Cost is 10 flops, faster even than the 15 it would take if you had saved N_P and then formed the N_P*w_PB product explicitly. </p>

</div>
</div>
<a id="a776789cb0d7ba32361b1b43813591754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776789cb0d7ba32361b1b43813591754">&#9670;&nbsp;</a></span>multiplyByBodyXYZ_NT_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::multiplyByBodyXYZ_NT_P </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the fastest way to form the product v_P=~N_P*q=~(~q*N_P); see the untransposed method <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> for information. </p>
<p>Cost is 9 flops. </p>

</div>
</div>
<a id="ad0edcb1b005f9a4980302c60cec1840d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0edcb1b005f9a4980302c60cec1840d">&#9670;&nbsp;</a></span>multiplyByBodyXYZ_NInv_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::multiplyByBodyXYZ_NInv_P </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fastest way to form the product w_PB=NInv_P*qdot. </p>
<p>This is never singular. Cost is 9 flops. </p>

</div>
</div>
<a id="ae19740559fc48c4651696e8e1d4ff6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19740559fc48c4651696e8e1d4ff6d8">&#9670;&nbsp;</a></span>multiplyByBodyXYZ_NInvT_P()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::multiplyByBodyXYZ_NInvT_P </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>v_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fastest way to form the product q=~NInv_P*v_P=~(~v_P*NInv_P). </p>
<p>This is never singular. Cost is 10 flops. </p>

</div>
</div>
<a id="ae13f54266a4e05e0631f762dc9a1bc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f54266a4e05e0631f762dc9a1bc7b">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the ith row of this Rotation matrix as a UnitRow3. </p>

</div>
</div>
<a id="a696c17db2db87ae9509c16008bcaf440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696c17db2db87ae9509c16008bcaf440">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a0c41f591c9926e8436596f924967f45c">RowType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as row(i) but nicer to look at. </p>

</div>
</div>
<a id="a8849ce50fb520a1add5efce72cd73f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8849ce50fb520a1add5efce72cd73f7c">&#9670;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the jth column of this Rotation matrix as a UnitVec3. </p>

</div>
</div>
<a id="ac3deb2a9092afa4b263f86ae29c82164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3deb2a9092afa4b263f86ae29c82164">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as col(j) but nicer to look at. </p>

</div>
</div>
<a id="ac685dec8a4ecc93e4539bc4973f59d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac685dec8a4ecc93e4539bc4973f59d3c">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return col(0) of this Rotation matrix as a UnitVec3. </p>

</div>
</div>
<a id="a1fe5716a25ec593380f54fbf207c69ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5716a25ec593380f54fbf207c69ea">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return col(1) of this Rotation matrix as a UnitVec3. </p>

</div>
</div>
<a id="a9d73e29f638a24e76579c482d499e334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d73e29f638a24e76579c482d499e334">&#9670;&nbsp;</a></span>z()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::z </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return col(2) of this Rotation matrix as a UnitVec3. </p>

</div>
</div>
<a id="a0a177d7c3dd7bf97de90a6ed3f3aea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a177d7c3dd7bf97de90a6ed3f3aea68">&#9670;&nbsp;</a></span>getAxisUnitVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#a8156453423742aa7ab103650c3ffa4a2">ColType</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::getAxisUnitVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1CoordinateAxis.html" title="This class, along with its sister class CoordinateDirection, provides convenient manipulation of the ...">CoordinateAxis</a> (XAxis,YAxis, or ZAxis) return a reference to the corresponding column of this Rotation matrix. </p>
<p>The result is equivalent to multiplying R_AB*v_B where v_B is [1,0,0],[0,1,0], or [0,0,1], which would cost 15 flops, but requires no computation. </p>

</div>
</div>
<a id="a2c754b4f1da8a121da52024f810651e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c754b4f1da8a121da52024f810651e8">&#9670;&nbsp;</a></span>getAxisUnitVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitVec.html">UnitVec</a>&lt;P,1&gt; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::getAxisUnitVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a>&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a> (+/-XAxis, etc.) return a unit vector in that direction. </p>
<p>The result is equivalent to multiplying R_AB*v_B where v_B is [+/-1,0,0], [0,+/-1,0], or [0,0,+/-1], which would cost 15 flops, but this method requires at most 3 flops. </p>

</div>
</div>
<a id="a3eb22f98f2a9088cf1012a5559548e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb22f98f2a9088cf1012a5559548e3a">&#9670;&nbsp;</a></span>calcNForBodyXYZInBodyFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix such that qdot=N_B(q)*w_PB_B where w_PB_B is the angular velocity of B in P EXPRESSED IN <em>B</em>!!! Note that N_B=N_P*R_PB. </p>
<p>This matrix will be singular if Y (q[1]) gets near 90 degrees!</p>
<dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method.</dd></dl>
<p>Cost: about 100 flops for sin/cos plus 12 to calculate N_B. </p><dl class="section see"><dt>See also</dt><dd>Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3. </dd></dl>

</div>
</div>
<a id="aaaa54243d974e2c0a8bb80c201343ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa54243d974e2c0a8bb80c201343ad4">&#9670;&nbsp;</a></span>calcNForBodyXYZInBodyFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is one divide plus 6 flops, say 12 flops. </p>

</div>
</div>
<a id="a0127cac78bdb1aea48a1b8294d2f13a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0127cac78bdb1aea48a1b8294d2f13a5">&#9670;&nbsp;</a></span>calcNForBodyXYZInParentFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N matrix such that qdot=N_P(q)*w_PB where w_PB is the angular velocity of B in P expressed in P (not the convention that Kane uses, where angular velocities are expressed in the outboard body B). </p>
<p>Note that N_P = N_B*~R_PB. This matrix will be singular if Y (q[1]) gets near 90 degrees!</p>
<dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method.</dd></dl>
<p>Cost: about 100 flops for sin/cos plus 12 to calculate N_P. </p>

</div>
</div>
<a id="aabd585adb5a86dc06adc011d46c4d2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd585adb5a86dc06adc011d46c4d2a4">&#9670;&nbsp;</a></span>calcNForBodyXYZInParentFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]; q[2] does not matter so you don't have to fill in the 3rd element of cq and sq. Cost is one divide plus 6 flops, say 12 flops. </p><dl class="section see"><dt>See also</dt><dd>Paul Mitiguy </dd></dl>

</div>
</div>
<a id="a57cc6b4aa8b35bb60f885bc8c07927ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc6b4aa8b35bb60f885bc8c07927ed">&#9670;&nbsp;</a></span>calcNDotForBodyXYZInBodyFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNDotForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P EXPRESSED IN <em>B</em>!!! This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a> for the matrix we're differentiating here. </p>
<dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a id="af1a07a41343d026e5f95c7072aa180b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a07a41343d026e5f95c7072aa180b1">&#9670;&nbsp;</a></span>calcNDotForBodyXYZInBodyFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNDotForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a57cc6b4aa8b35bb60f885bc8c07927ed" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is one divide plus 21 flops, say 30 flops. </p>

</div>
</div>
<a id="a713ce2d2d7aa5e3ba6bc4107f715bca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713ce2d2d7aa5e3ba6bc4107f715bca2">&#9670;&nbsp;</a></span>calcNDotForBodyXYZInParentFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNDotForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot, return the block of the NDot matrix such that qdotdot=N(q)*wdot + NDot(q,u)*w where w is the angular velocity of B in P expressed in P. </p>
<p>This matrix will be singular if Y (q[1]) gets near 90 degrees! See <a class="el" href="classSimTK_1_1Rotation__.html#a0127cac78bdb1aea48a1b8294d2f13a5" title="Given Euler angles q forming a body-fixed X-Y-Z (123) sequence return the block N_P of the system N m...">calcNForBodyXYZInParentFrame()</a> for the matrix we're differentiating here. </p><dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a id="a731e89578e363e9c42f998b542682a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731e89578e363e9c42f998b542682a35">&#9670;&nbsp;</a></span>calcNDotForBodyXYZInParentFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNDotForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>ooc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a713ce2d2d7aa5e3ba6bc4107f715bca2" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence q, and their time derivatives qdot...">calcNDotForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]. Cost is 21 flops. </p>

</div>
</div>
<a id="aba5b6c3e33f68fc8105d2f2099969753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5b6c3e33f68fc8105d2f2099969753">&#9670;&nbsp;</a></span>calcNInvForBodyXYZInBodyFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNInvForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of routine <a class="el" href="classSimTK_1_1Rotation__.html#a3eb22f98f2a9088cf1012a5559548e3a" title="Given Euler angles q forming a body-fixed X-Y-Z sequence return the block N_B of the system N matrix ...">calcNForBodyXYZInBodyFrame()</a>. </p>
<p>Return the inverse NInv_B of the N_B block computed above, such that w_PB_B=NInv_B(q)*qdot where w_PB_B is the angular velocity of B in P EXPRESSED IN <em>B</em>!!! (Kane's convention.) Note that NInv_B=~R_PB*NInv_P. This matrix is never singular. </p><dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a id="a05421fe60aadcdc2c5b9a02747568a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05421fe60aadcdc2c5b9a02747568a73">&#9670;&nbsp;</a></span>calcNInvForBodyXYZInBodyFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNInvForBodyXYZInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aba5b6c3e33f68fc8105d2f2099969753" title="Inverse of routine calcNForBodyXYZInBodyFrame(). ">calcNInvForBodyXYZInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is 3 flops. </p>

</div>
</div>
<a id="a37fc3fe5bd8a98217aafeb5a6639ccbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fc3fe5bd8a98217aafeb5a6639ccbc">&#9670;&nbsp;</a></span>calcNInvForBodyXYZInParentFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNInvForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Return the inverse NInv_P of the N_P block computed above, such that w_PB=NInv_P(q)*qdot where w_PB is the angular velocity of B in P (expressed in P). Note that NInv_P=R_PB*NInv_B. This matrix is never singular. </p><dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a id="a020a2169bc07b8e28414b75892986c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020a2169bc07b8e28414b75892986c9f">&#9670;&nbsp;</a></span>calcNInvForBodyXYZInParentFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcNInvForBodyXYZInParentFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#a37fc3fe5bd8a98217aafeb5a6639ccbc" title="Inverse of the above routine. ">calcNInvForBodyXYZInParentFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[0] and q[1]; q[2] does not matter so you don't have to fill in the 3rd element of cq and sq. Cost is 3 flops. </p>

</div>
</div>
<a id="af8b7a0f3971e33ca93521589eeb7cc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b7a0f3971e33ca93521589eeb7cc1d">&#9670;&nbsp;</a></span>calcUnnormalizedNForQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcUnnormalizedNForQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w to quaternion derivatives qdot. </p>
<p>We expect the angular velocity in the parent frame, i.e. w==w_PB_P. We don't normalize, so N=|q|N' where N' is the normalized version. Cost is 7 flops. </p>

</div>
</div>
<a id="a30c0b4373719c68c0a14783d8fa8e8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c0b4373719c68c0a14783d8fa8e8aa">&#9670;&nbsp;</a></span>calcUnnormalizedNDotForQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#a315774852e091803bb35e68502c5cfef">Mat43P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcUnnormalizedNDotForQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the time derivative qdot of a possibly unnormalized quaternion q, calculate the 4x3 matrix NDot which is the time derivative of the matrix N as described in <a class="el" href="classSimTK_1_1Rotation__.html#af8b7a0f3971e33ca93521589eeb7cc1d" title="Given a possibly unnormalized quaternion q, calculate the 4x3 matrix N which maps angular velocity w ...">calcUnnormalizedNForQuaternion()</a>. </p>
<p>Note that NDot = d/dt N = d/dt (|q|N') = |q|(d/dt N'), where N' is the normalized matrix, since the length of the quaternion should be a constant. Cost is 7 flops. </p>

</div>
</div>
<a id="a939de389a2ef2d6516aee271d1f04ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939de389a2ef2d6516aee271d1f04ad7">&#9670;&nbsp;</a></span>calcUnnormalizedNInvForQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#ad61eab201f0333ac3107708828b48d6a">Mat34P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::calcUnnormalizedNInvForQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a (possibly unnormalized) quaternion q, calculate the 3x4 matrix NInv (= N^-1) which maps quaternion derivatives qdot to angular velocity w, where the angular velocity is in the parent frame, i.e. </p>
<p>w==w_PB_P. Note: when the quaternion is not normalized, this is not precisely the (pseudo)inverse of N. inv(N)=inv(N')/|q| but we're returning |q|*inv(N')=|q|^2*inv(N). That is, NInv*N =|q|^2*I, which is I if the original q was normalized. (Note: N*NInv != I, not even close.) Cost is 7 flops. </p>

</div>
</div>
<a id="ab9704549afbc2d8e526c5fe2817e7814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9704549afbc2d8e526c5fe2817e7814">&#9670;&nbsp;</a></span>asMat33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a>&amp; <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::asMat33 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion from Rotation to its base class Mat33. </p>
<p>Note: asMat33 is more efficient than <a class="el" href="classSimTK_1_1Rotation__.html#a77c9d3d873514da4e7316bbc83403fbe" title="Conversion from Rotation to its base class Mat33. ">toMat33()</a> (no copy), but you have to know the internal layout. </p>

</div>
</div>
<a id="a77c9d3d873514da4e7316bbc83403fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c9d3d873514da4e7316bbc83403fbe">&#9670;&nbsp;</a></span>toMat33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#ac072fb845028c8f0aa199bd0cddb7df9">Mat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::toMat33 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion from Rotation to its base class Mat33. </p>
<p>Note: asMat33 is more efficient than <a class="el" href="classSimTK_1_1Rotation__.html#a77c9d3d873514da4e7316bbc83403fbe" title="Conversion from Rotation to its base class Mat33. ">toMat33()</a> (no copy), but you have to know the internal layout. </p>

</div>
</div>
<a id="a04a72db92b0eb76496c26e8097c48745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a72db92b0eb76496c26e8097c48745">&#9670;&nbsp;</a></span>reexpressSymMat33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::reexpressSymMat33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a21a50dfa7292af6166cf3f47a769be21">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>S_BB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an efficient transform of a symmetric matrix that must be re-expressed with a multiply from both left and right, such as an inertia matrix. </p>
<p>Details: assuming this Rotation is R_AB, and given a symmetric dyadic matrix S_BB expressed in B, we can reexpress it in A using S_AA=R_AB*S_BB*R_BA. The matrix should be one that is formed as products of vectors expressed in A, such as inertia, gyration or covariance matrices. This can be done efficiently exploiting properties of R (orthogonal) and S (symmetric). Total cost is 57 flops. </p>

</div>
</div>
<a id="a4fff2d4b65d25bd3ba94470f0fd878fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fff2d4b65d25bd3ba94470f0fd878fa">&#9670;&nbsp;</a></span>convertOneAxisRotationToOneAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertOneAxisRotationToOneAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts rotation matrix to a single orientation angle. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a id="acd54cf77c2285eb8c5f9c3d4c53aba37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd54cf77c2285eb8c5f9c3d4c53aba37">&#9670;&nbsp;</a></span>convertTwoAxesRotationToTwoAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertTwoAxesRotationToTwoAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts rotation matrix to two orientation angles. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a id="a07a8ebd70ba4ca68cf18f31c6f1f1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a8ebd70ba4ca68cf18f31c6f1f1213">&#9670;&nbsp;</a></span>convertThreeAxesRotationToThreeAngles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertThreeAxesRotationToThreeAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a187a6e6aa955d2c754226793d2056082">BodyOrSpaceType</a>&#160;</td>
          <td class="paramname"><em>bodyOrSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> &amp;&#160;</td>
          <td class="paramname"><em>axis3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts rotation matrix to three orientation angles. </p>
<p>Note: The result is most meaningful if the <a class="el" href="classSimTK_1_1Rotation__.html" title="The Rotation class is a Mat33 that guarantees that the matrix can be interpreted as a legitimate 3x3 ...">Rotation_</a> matrix is one that can be produced by such a sequence. </p>

</div>
</div>
<a id="a9545e8cc66a16a4ae9f42b5af0c12131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9545e8cc66a16a4ae9f42b5af0c12131">&#9670;&nbsp;</a></span>convertRotationToQuaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#ae558a511005019194f262fbd3b7dd08d">QuaternionP</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertRotationToQuaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts rotation matrix to an equivalent quaternion in canonical form (meaning its scalar element is nonnegative). </p>
<p>This uses a robust, singularity-free method due to Richard Spurrier. The cost is about 40 flops.</p>
<dl class="section user"><dt>Reference</dt><dd>Spurrier, R.A., "Comment on 'Singularity-Free Extraction of a Quaternion 
from a Direction-Cosine Matrix'", J. Spacecraft and Rockets, 15(4):255,<ol type="1">
<li></li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Quaternion__.html" title="A Quaternion is a Vec4 with the following behavior: ">Quaternion_</a> </dd></dl>

</div>
</div>
<a id="af59e76752e7a1e5706eae1e9c2547e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59e76752e7a1e5706eae1e9c2547e8b">&#9670;&nbsp;</a></span>convertRotationToAngleAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertRotationToAngleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts rotation matrix to an equivalent angle-axis representation in canonicalized form. </p>
<p>The result (a,v) is returned packed into a Vec4 [a vx vy vz], with -Pi &lt; a &lt;= Pi and |v|=1. Cost is about 140 flops.</p>
<p>If the rotation angle is zero (or very very close to zero) then the returned unit vector is arbitrary.</p>
<dl class="section user"><dt>Theory</dt><dd>Euler's Rotation Theorem (1776) guarantees that any rigid body rotation is equivalent to a rotation by an angle about a fixed axis. This method finds such an angle and axis. Numerically, this is a very tricky computation to get correct in all cases. We use Spurrier's method to obtain a numerically-robust quaternion equivalent to this rotation matrix, then carefully extract and canonicalize the angle-axis form from the quaternion.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Rotation__.html#a9545e8cc66a16a4ae9f42b5af0c12131" title="Converts rotation matrix to an equivalent quaternion in canonical form (meaning its scalar element is...">convertRotationToQuaternion()</a> </dd></dl>

</div>
</div>
<a id="a713b44b006dea6d75c1c1325970c7b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713b44b006dea6d75c1c1325970c7b30">&#9670;&nbsp;</a></span>convertRotationToBodyFixedXY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertRotationToBodyFixedXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#acd54cf77c2285eb8c5f9c3d4c53aba37" title="Converts rotation matrix to two orientation angles. ">convertTwoAxesRotationToTwoAngles()</a>. </p>

</div>
</div>
<a id="a8b45916f249f3def3549f7916dd1eff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b45916f249f3def3549f7916dd1eff1">&#9670;&nbsp;</a></span>convertRotationToBodyFixedXYZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertRotationToBodyFixedXYZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenient special case of <a class="el" href="classSimTK_1_1Rotation__.html#a07a8ebd70ba4ca68cf18f31c6f1f1213" title="Converts rotation matrix to three orientation angles. ">convertThreeAxesRotationToThreeAngles()</a>. </p>

</div>
</div>
<a id="ada7be536a78529d455a292a04fc267bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7be536a78529d455a292a04fc267bf">&#9670;&nbsp;</a></span>convertAngVelToBodyFixed321Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelToBodyFixed321Dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles forming a body-fixed 3-2-1 sequence, and the relative angular velocity vector of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives. </p>
<p>You are dead if q[1] gets near 90 degrees! See Kane's Spacecraft Dynamics, page 428, body-three: 3-2-1. </p>

</div>
</div>
<a id="a0b2274baac7bc6e82343040f1850f59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2274baac7bc6e82343040f1850f59c">&#9670;&nbsp;</a></span>convertBodyFixed321DotToAngVel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertBodyFixed321DotToAngVel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of convertAngVelToBodyFixed321Dot. </p>
<p>Returned angular velocity is B in P, expressed in <em>B</em>: w_PB_B. </p>

</div>
</div>
<a id="a41b70da72a012a4e248150759ae09a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b70da72a012a4e248150759ae09a0b">&#9670;&nbsp;</a></span>convertAngVelDotToBodyFixed321DotDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelDotToBodyFixed321DotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Caution: needs testing. </p>

</div>
</div>
<a id="ae87f86eb9a0b8dff3202c35e39f1b16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87f86eb9a0b8dff3202c35e39f1b16d">&#9670;&nbsp;</a></span>convertAngVelInBodyFrameToBodyXYZDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelInBodyFrameToBodyXYZDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vector w_PB_B of B in the parent frame, <em>BUT EXPRESSED IN THE BODY FRAME</em>, return the Euler angle derivatives. </p>
<p>You are dead if q[1] gets near 90 degrees! </p><dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Kane's Spacecraft Dynamics, page 427, body-three: 1-2-3. </dd></dl>

</div>
</div>
<a id="aa59271d0544a807b0d43617485365efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59271d0544a807b0d43617485365efd">&#9670;&nbsp;</a></span>convertAngVelInBodyFrameToBodyXYZDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelInBodyFrameToBodyXYZDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#ae87f86eb9a0b8dff3202c35e39f1b16d" title="Given Euler angles forming a body-fixed X-Y-Z (123) sequence, and the relative angular velocity vecto...">convertAngVelInBodyFrameToBodyXYZDot()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is 27 flops. </p>

</div>
</div>
<a id="afc7286af6f32e76ddc0b5f90f7efd22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7286af6f32e76ddc0b5f90f7efd22e">&#9670;&nbsp;</a></span>convertBodyXYZDotToAngVelInBodyFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertBodyXYZDotToAngVelInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Returned angular velocity is B in P, expressed in <em>B</em>: w_PB_B. </p><dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. </dd></dl>

</div>
</div>
<a id="aaed9d79a18b05275c469d18d58413ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed9d79a18b05275c469d18d58413ca5">&#9670;&nbsp;</a></span>convertBodyXYZDotToAngVelInBodyFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertBodyXYZDotToAngVelInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#afc7286af6f32e76ddc0b5f90f7efd22e" title="Inverse of the above routine. ">convertBodyXYZDotToAngVelInBodyFrame()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is 18 flops. </p>

</div>
</div>
<a id="aed514d5990532404a82da26793049900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed514d5990532404a82da26793049900">&#9670;&nbsp;</a></span>convertAngVelDotInBodyFrameToBodyXYZDotDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelDotInBodyFrameToBodyXYZDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Warning: everything is measured in the <em>PARENT</em> frame, but has to be expressed in the <em>BODY</em> frame. </p>
<dl class="section note"><dt>Note</dt><dd>This version is very expensive because it has to calculate sines and cosines. If you already have those, use the alternate form of this method. Caution: needs testing. </dd></dl>

</div>
</div>
<a id="a4ae5a0d854e698521bde92dfe17b84a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae5a0d854e698521bde92dfe17b84a7">&#9670;&nbsp;</a></span>convertAngVelDotInBodyFrameToBodyXYZDotDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelDotInBodyFrameToBodyXYZDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>wdot_PB_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This faster version of <a class="el" href="classSimTK_1_1Rotation__.html#aed514d5990532404a82da26793049900" title="Warning: everything is measured in the PARENT frame, but has to be expressed in the BODY frame...">convertAngVelDotInBodyFrameToBodyXYZDotDot()</a> assumes you have already calculated the cosine and sine of the three q's. </p>
<p>Note that we only look at the cosines and sines of q[1] and q[2]; q[0] does not matter so you don't have to fill in the 0'th element of cq and sq. Cost is about 93 flops. </p>

</div>
</div>
<a id="aea472db472765197f6daf4624b9a0700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea472db472765197f6daf4624b9a0700">&#9670;&nbsp;</a></span>convertAngVelToQuaternionDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelToQuaternionDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB_P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a possibly unnormalized quaternion (0th element is the scalar) and the relative angular velocity vector of B in its parent, expressed in the <em>PARENT</em>, return the quaternion derivatives. </p>
<p>This is never singular. Cost is 27 flops. </p>

</div>
</div>
<a id="adc55fc1b16c0df4962094d3173ae4372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55fc1b16c0df4962094d3173ae4372">&#9670;&nbsp;</a></span>convertQuaternionDotToAngVel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertQuaternionDotToAngVel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse of the above routine. </p>
<p>Returned AngVel is expressed in the <em>PARENT</em> frame: w_PB_P. Cost is 28 flops. </p>

</div>
</div>
<a id="ac39e2b91d6d396f2002afb7f26335e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e2b91d6d396f2002afb7f26335e64">&#9670;&nbsp;</a></span>convertAngVelDotToQuaternionDotDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelDotToQuaternionDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#a4360cabd778a395e70af322f666e46fe">Vec4P</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>b_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We want to differentiate qdot=N(q)*w to get qdotdot=N*b+NDot*w where b is angular acceleration wdot. </p>
<p>Note that NDot=NDot(qdot), but it is far better to calculate the matrix-vector product NDot(N*w)*w directly rather than calculate NDot separately. That gives </p><pre>
    NDot*w = -(w^2)/4 * q
</pre><p> Cost is 41 flops. </p>

</div>
</div>
<a id="ad8b111f6521a2001a2c2dbc00414d5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b111f6521a2001a2c2dbc00414d5ad">&#9670;&nbsp;</a></span>convertAngVelInParentToBodyXYZDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngVelInParentToBodyXYZDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>w_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate first time derivative qdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles and the angular velocity w_PB of child B in parent P, expressed in P. </p>
<p>Cost is 10 flops.</p>
<p>Theory: calculate qdot=N_P(q)*w_PB using <a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Rotation__.html#a3d8d055de40c8993a4bb9bb2d86c784a" title="This is the fastest way to form the product qdot=N_P*w_PB for a body-fixed XYZ sequence where angular...">multiplyByBodyXYZ_N_P()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cosxy</td><td>cos(qx), cos(qy) </td></tr>
    <tr><td class="paramname">sinxy</td><td>sin(qx), sin(qy) </td></tr>
    <tr><td class="paramname">oocosy</td><td>1/cos(qy) </td></tr>
    <tr><td class="paramname">w_PB</td><td>angular velocity of B in P, exp. in P </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ee4bdfde750e6cb198494b1b522b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ee4bdfde750e6cb198494b1b522b20">&#9670;&nbsp;</a></span>convertAngAccInParentToBodyXYZDotDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::convertAngAccInParentToBodyXYZDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>cosxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#ae57cfb41c686d5c3c28d3cd2799c0238">Vec2P</a> &amp;&#160;</td>
          <td class="paramname"><em>sinxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>oocosy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html#afd2b9fc21ea18fa45243ba6259a9f8c3">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>b_PB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate second time derivative qdotdot of body-fixed XYZ Euler angles q given sines and cosines of the Euler angles, the first derivative qdot and the angular acceleration b_PB of child B in parent P, expressed in P. </p>
<p>Cost is 22 flops.</p>
<p>Theory: we have qdot=N_P*w_PB, which we differentiate in P to get qdotdot=N_P*b_PB + NDot_P*w_PB. Note that NDot_P=NDot_P(q,qdot) and w_PB=NInv_P*qdot (because N_P is invertible). We can then rewrite qdotdot=N_P*b_PB + NDot_P*(NInv_P*qdot) which can be calculated very efficiently. The second term is just an acceleration remainder term quadratic in qdot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cosxy</td><td>cos(qx), cos(qy) </td></tr>
    <tr><td class="paramname">sinxy</td><td>sin(qx), sin(qy) </td></tr>
    <tr><td class="paramname">oocosy</td><td>1/cos(qy) </td></tr>
    <tr><td class="paramname">qdot</td><td>previously calculated BodyXYZDot </td></tr>
    <tr><td class="paramname">b_PB</td><td>angular acceleration, a.k.a. wdot_PB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420031eb5801e9a4ece6230880cbb874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420031eb5801e9a4ece6230880cbb874">&#9670;&nbsp;</a></span>isSameRotationToWithinAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::isSameRotationToWithinAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>okPointingAngleErrorRads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if "this" Rotation is nearly identical to "R" within a specified pointing angle error. </p>

</div>
</div>
<a id="aef510f32db21cd24adc4dfe15355c24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef510f32db21cd24adc4dfe15355c24b">&#9670;&nbsp;</a></span>isSameRotationToWithinAngleOfMachinePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::isSameRotationToWithinAngleOfMachinePrecision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if "this" Rotation is nearly identical to "R" within machine precision. </p>

</div>
</div>
<a id="adffdc7b0d8a7621fd56fdfef9a38e63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffdc7b0d8a7621fd56fdfef9a38e63e">&#9670;&nbsp;</a></span>getMaxAbsDifferenceInRotationElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a> <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::getMaxAbsDifferenceInRotationElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns maximum absolute difference between elements in "this" Rotation and elements in "R". </p>

</div>
</div>
<a id="a300622e45125dc936a94345d6037d49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300622e45125dc936a94345d6037d49b">&#9670;&nbsp;</a></span>areAllRotationElementsSameToEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::areAllRotationElementsSameToEpsilon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Rotation__.html#a3e2fe478b01daff763b20886c3773430">RealP</a>&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if each element of "this" Rotation is within epsilon of the corresponding element of "R". </p>

</div>
</div>
<a id="a08366c2f18e052d127e5237fce637ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08366c2f18e052d127e5237fce637ecf">&#9670;&nbsp;</a></span>areAllRotationElementsSameToMachinePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Rotation__.html">SimTK::Rotation_</a>&lt; P &gt;::areAllRotationElementsSameToMachinePrecision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if each element of "this" Rotation is within machine precision of the corresponding element of "R". </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Quaternion_8h_source.html">Quaternion.h</a></li>
<li><a class="el" href="Rotation_8h_source.html">Rotation.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:18 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
