<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::ContactGeometry::TriangleMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1ContactGeometry_1_1TriangleMesh.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSimTK_1_1ContactGeometry_1_1TriangleMesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ContactGeometry::TriangleMesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> subclass represents an arbitrary shape described by a mesh of triangular faces.  
 <a href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::ContactGeometry::TriangleMesh:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1ContactGeometry_1_1TriangleMesh.png" usemap="#SimTK::ContactGeometry::TriangleMesh_map" alt=""/>
  <map id="SimTK::ContactGeometry::TriangleMesh_map" name="SimTK::ContactGeometry::TriangleMesh_map">
<area href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object..." alt="SimTK::ContactGeometry" shape="rect" coords="0,0,233,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html">OBBTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a node in the Oriented Bounding Box Tree for a <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>.  <a href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8d7b4bfd6175acb944d54e92b96118b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a8d7b4bfd6175acb944d54e92b96118b1">TriangleMesh</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;vertices, const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; int &gt; &amp;faceIndices, bool smooth=false)</td></tr>
<tr class="memdesc:a8d7b4bfd6175acb944d54e92b96118b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>.  <a href="#a8d7b4bfd6175acb944d54e92b96118b1">More...</a><br /></td></tr>
<tr class="separator:a8d7b4bfd6175acb944d54e92b96118b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc2151edb6813ada2712b7bc245829c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a9bc2151edb6813ada2712b7bc245829c">TriangleMesh</a> (const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;mesh, bool smooth=false)</td></tr>
<tr class="memdesc:a9bc2151edb6813ada2712b7bc245829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a> based on a <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> object.  <a href="#a9bc2151edb6813ada2712b7bc245829c">More...</a><br /></td></tr>
<tr class="separator:a9bc2151edb6813ada2712b7bc245829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5821841a4545f7cce4e4274090c09b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a5821841a4545f7cce4e4274090c09b2c">getNumEdges</a> () const</td></tr>
<tr class="memdesc:a5821841a4545f7cce4e4274090c09b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in the mesh.  <a href="#a5821841a4545f7cce4e4274090c09b2c">More...</a><br /></td></tr>
<tr class="separator:a5821841a4545f7cce4e4274090c09b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baa53ff1df2f429e48a800c1ed754f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#ad0baa53ff1df2f429e48a800c1ed754f">getNumFaces</a> () const</td></tr>
<tr class="memdesc:ad0baa53ff1df2f429e48a800c1ed754f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces in the mesh.  <a href="#ad0baa53ff1df2f429e48a800c1ed754f">More...</a><br /></td></tr>
<tr class="separator:ad0baa53ff1df2f429e48a800c1ed754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace76d99ac18f98334475a6a702ce9267"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#ace76d99ac18f98334475a6a702ce9267">getNumVertices</a> () const</td></tr>
<tr class="memdesc:ace76d99ac18f98334475a6a702ce9267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices in the mesh.  <a href="#ace76d99ac18f98334475a6a702ce9267">More...</a><br /></td></tr>
<tr class="separator:ace76d99ac18f98334475a6a702ce9267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5571b769bb78fb855cf25cf77e781a64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a5571b769bb78fb855cf25cf77e781a64">getVertexPosition</a> (int index) const</td></tr>
<tr class="memdesc:a5571b769bb78fb855cf25cf77e781a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a vertex in the mesh.  <a href="#a5571b769bb78fb855cf25cf77e781a64">More...</a><br /></td></tr>
<tr class="separator:a5571b769bb78fb855cf25cf77e781a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c0c332d7eeba0956ab45971d231e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a082c0c332d7eeba0956ab45971d231e0">getFaceEdge</a> (int face, int edge) const</td></tr>
<tr class="memdesc:a082c0c332d7eeba0956ab45971d231e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one of the edges of a face.  <a href="#a082c0c332d7eeba0956ab45971d231e0">More...</a><br /></td></tr>
<tr class="separator:a082c0c332d7eeba0956ab45971d231e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e520cff0320c1e806b54324bc81ebf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#ad5e520cff0320c1e806b54324bc81ebf">getFaceVertex</a> (int face, int vertex) const</td></tr>
<tr class="memdesc:ad5e520cff0320c1e806b54324bc81ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one of the vertices of a face.  <a href="#ad5e520cff0320c1e806b54324bc81ebf">More...</a><br /></td></tr>
<tr class="separator:ad5e520cff0320c1e806b54324bc81ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dfc034b042b7dd9522e331ff472763"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a91dfc034b042b7dd9522e331ff472763">getEdgeFace</a> (int edge, int face) const</td></tr>
<tr class="memdesc:a91dfc034b042b7dd9522e331ff472763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one of the faces shared by an edge.  <a href="#a91dfc034b042b7dd9522e331ff472763">More...</a><br /></td></tr>
<tr class="separator:a91dfc034b042b7dd9522e331ff472763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095cddbc80db3b718abe9fa47534f72b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a095cddbc80db3b718abe9fa47534f72b">getEdgeVertex</a> (int edge, int vertex) const</td></tr>
<tr class="memdesc:a095cddbc80db3b718abe9fa47534f72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of one of the vertices shared by an edge.  <a href="#a095cddbc80db3b718abe9fa47534f72b">More...</a><br /></td></tr>
<tr class="separator:a095cddbc80db3b718abe9fa47534f72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e1dda3e89134bf13c2b6e9d5b330e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#af6e1dda3e89134bf13c2b6e9d5b330e8">findVertexEdges</a> (int vertex, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;edges) const</td></tr>
<tr class="memdesc:af6e1dda3e89134bf13c2b6e9d5b330e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all edges that intersect a vertex.  <a href="#af6e1dda3e89134bf13c2b6e9d5b330e8">More...</a><br /></td></tr>
<tr class="separator:af6e1dda3e89134bf13c2b6e9d5b330e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d13f30654d34bd7c702760c4e194a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a2b2d13f30654d34bd7c702760c4e194a">getFaceNormal</a> (int face) const</td></tr>
<tr class="memdesc:a2b2d13f30654d34bd7c702760c4e194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the normal vector for a face.  <a href="#a2b2d13f30654d34bd7c702760c4e194a">More...</a><br /></td></tr>
<tr class="separator:a2b2d13f30654d34bd7c702760c4e194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249e99b7cc687cd3b4c67073ca208773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a249e99b7cc687cd3b4c67073ca208773">getFaceArea</a> (int face) const</td></tr>
<tr class="memdesc:a249e99b7cc687cd3b4c67073ca208773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of a face.  <a href="#a249e99b7cc687cd3b4c67073ca208773">More...</a><br /></td></tr>
<tr class="separator:a249e99b7cc687cd3b4c67073ca208773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf073134ea386e06b4c773e3932283d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a6cf073134ea386e06b4c773e3932283d">findPoint</a> (int face, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;uv) const</td></tr>
<tr class="memdesc:a6cf073134ea386e06b4c773e3932283d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the location of a point on the surface, in the local frame of the <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>.  <a href="#a6cf073134ea386e06b4c773e3932283d">More...</a><br /></td></tr>
<tr class="separator:a6cf073134ea386e06b4c773e3932283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634dfc5d9c84b5d8c81b23f67a038099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a634dfc5d9c84b5d8c81b23f67a038099">findCentroid</a> (int face) const</td></tr>
<tr class="memdesc:a634dfc5d9c84b5d8c81b23f67a038099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the location of a face's centroid, that is, the point uv=(1/3,1/3) which is the average of the three vertex locations.  <a href="#a634dfc5d9c84b5d8c81b23f67a038099">More...</a><br /></td></tr>
<tr class="separator:a634dfc5d9c84b5d8c81b23f67a038099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ce0795c43d29504ffd45c0598d82c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a649ce0795c43d29504ffd45c0598d82c">findNormalAtPoint</a> (int face, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;uv) const</td></tr>
<tr class="memdesc:a649ce0795c43d29504ffd45c0598d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the normal vector at a point on the surface.  <a href="#a649ce0795c43d29504ffd45c0598d82c">More...</a><br /></td></tr>
<tr class="separator:a649ce0795c43d29504ffd45c0598d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2aa28401a535e7d548036693366b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a8f2aa28401a535e7d548036693366b07">findNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position, bool &amp;inside, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a8f2aa28401a535e7d548036693366b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point, find the nearest point on the surface of this object.  <a href="#a8f2aa28401a535e7d548036693366b07">More...</a><br /></td></tr>
<tr class="separator:a8f2aa28401a535e7d548036693366b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070d1e38e2c672ac3aa63be7ad4a4b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a070d1e38e2c672ac3aa63be7ad4a4b86">findNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position, bool &amp;inside, int &amp;face, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;uv) const</td></tr>
<tr class="memdesc:a070d1e38e2c672ac3aa63be7ad4a4b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point, find the nearest point on the surface of this object.  <a href="#a070d1e38e2c672ac3aa63be7ad4a4b86">More...</a><br /></td></tr>
<tr class="separator:a070d1e38e2c672ac3aa63be7ad4a4b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b888d26f48200a1cd194038b6261e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a63b888d26f48200a1cd194038b6261e4">findNearestPointToFace</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position, int face, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;uv) const</td></tr>
<tr class="memdesc:a63b888d26f48200a1cd194038b6261e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point and a face of this object, find the point of the face that is nearest the given point.  <a href="#a63b888d26f48200a1cd194038b6261e4">More...</a><br /></td></tr>
<tr class="separator:a63b888d26f48200a1cd194038b6261e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a00f2fa5a39991fddf472cc35362cd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a7a00f2fa5a39991fddf472cc35362cd0">intersectsRay</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;origin, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;distance, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a7a00f2fa5a39991fddf472cc35362cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this mesh intersects a ray, and if so, find the intersection point.  <a href="#a7a00f2fa5a39991fddf472cc35362cd0">More...</a><br /></td></tr>
<tr class="separator:a7a00f2fa5a39991fddf472cc35362cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee188a66ce43c3e2e5ae3e42628ea13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#aeee188a66ce43c3e2e5ae3e42628ea13">intersectsRay</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;origin, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;distance, int &amp;face, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;uv) const</td></tr>
<tr class="memdesc:aeee188a66ce43c3e2e5ae3e42628ea13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this mesh intersects a ray, and if so, find what face it hit.  <a href="#aeee188a66ce43c3e2e5ae3e42628ea13">More...</a><br /></td></tr>
<tr class="separator:aeee188a66ce43c3e2e5ae3e42628ea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4620231869d0b9abeeaab57304c353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html">OBBTreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a5f4620231869d0b9abeeaab57304c353">getOBBTreeNode</a> () const</td></tr>
<tr class="memdesc:a5f4620231869d0b9abeeaab57304c353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html" title="This class represents a node in the Oriented Bounding Box Tree for a TriangleMesh. ">OBBTreeNode</a> which forms the root of this mesh's Oriented Bounding Box Tree.  <a href="#a5f4620231869d0b9abeeaab57304c353">More...</a><br /></td></tr>
<tr class="separator:a5f4620231869d0b9abeeaab57304c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0839274eee4b9e754d3c37afef714f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#af0839274eee4b9e754d3c37afef714f3">createPolygonalMesh</a> () const</td></tr>
<tr class="memdesc:af0839274eee4b9e754d3c37afef714f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> from this <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>; useful mostly for debugging because you can create a <a class="el" href="classSimTK_1_1DecorativeMesh.html" title="This defines a displayable mesh by referencing an already-existing PolygonalMesh object. ">DecorativeMesh</a> from this and then look at it.  <a href="#af0839274eee4b9e754d3c37afef714f3">More...</a><br /></td></tr>
<tr class="separator:af0839274eee4b9e754d3c37afef714f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38399dbeb7318ed5ede2a51717268c9b"><td class="memItemLeft" align="right" valign="top">const Impl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a38399dbeb7318ed5ede2a51717268c9b">getImpl</a> () const</td></tr>
<tr class="memdesc:a38399dbeb7318ed5ede2a51717268c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="#a38399dbeb7318ed5ede2a51717268c9b">More...</a><br /></td></tr>
<tr class="separator:a38399dbeb7318ed5ede2a51717268c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159fcbac31b7c7a1a390c807d177df62"><td class="memItemLeft" align="right" valign="top">Impl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a159fcbac31b7c7a1a390c807d177df62">updImpl</a> ()</td></tr>
<tr class="memdesc:a159fcbac31b7c7a1a390c807d177df62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="#a159fcbac31b7c7a1a390c807d177df62">More...</a><br /></td></tr>
<tr class="separator:a159fcbac31b7c7a1a390c807d177df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ContactGeometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ContactGeometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ContactGeometry.html">SimTK::ContactGeometry</a></td></tr>
<tr class="memitem:a8fb7742035ba957d61c9e1b96379eb2c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a8fb7742035ba957d61c9e1b96379eb2c">ContactGeometry</a> ()</td></tr>
<tr class="memdesc:a8fb7742035ba957d61c9e1b96379eb2c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class default constructor creates an empty handle.  <a href="classSimTK_1_1ContactGeometry.html#a8fb7742035ba957d61c9e1b96379eb2c">More...</a><br /></td></tr>
<tr class="separator:a8fb7742035ba957d61c9e1b96379eb2c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa642e845dd9f30b956af41f9531dbf inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a8aa642e845dd9f30b956af41f9531dbf">ContactGeometry</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;src)</td></tr>
<tr class="memdesc:a8aa642e845dd9f30b956af41f9531dbf inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor makes a deep copy.  <a href="classSimTK_1_1ContactGeometry.html#a8aa642e845dd9f30b956af41f9531dbf">More...</a><br /></td></tr>
<tr class="separator:a8aa642e845dd9f30b956af41f9531dbf inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc513cdb28da4f1964c2edae11e36ab5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#afc513cdb28da4f1964c2edae11e36ab5">operator=</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;src)</td></tr>
<tr class="memdesc:afc513cdb28da4f1964c2edae11e36ab5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment makes a deep copy.  <a href="classSimTK_1_1ContactGeometry.html#afc513cdb28da4f1964c2edae11e36ab5">More...</a><br /></td></tr>
<tr class="separator:afc513cdb28da4f1964c2edae11e36ab5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2f8d53493d9b837bc4663bb96bb25f inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a4b2f8d53493d9b837bc4663bb96bb25f">~ContactGeometry</a> ()</td></tr>
<tr class="memdesc:a4b2f8d53493d9b837bc4663bb96bb25f inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class destructor deletes the implementation object. Note that this is not virtual; handles should consist of just a pointer to the implementation.  <a href="classSimTK_1_1ContactGeometry.html#a4b2f8d53493d9b837bc4663bb96bb25f">More...</a><br /></td></tr>
<tr class="separator:a4b2f8d53493d9b837bc4663bb96bb25f inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a19393f98ce54aa06b2c7484345808 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a29a19393f98ce54aa06b2c7484345808">createDecorativeGeometry</a> () const</td></tr>
<tr class="memdesc:a29a19393f98ce54aa06b2c7484345808 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a <a class="el" href="classSimTK_1_1DecorativeGeometry.html" title="This is the client-side interface to an implementation-independent representation of &quot;Decorations&quot; su...">DecorativeGeometry</a> that matches the shape of this <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a>.  <a href="classSimTK_1_1ContactGeometry.html#a29a19393f98ce54aa06b2c7484345808">More...</a><br /></td></tr>
<tr class="separator:a29a19393f98ce54aa06b2c7484345808 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d72b5b0d0b2b534abafe1f7d63266 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a4d7d72b5b0d0b2b534abafe1f7d63266">findNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position, bool &amp;inside, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a4d7d72b5b0d0b2b534abafe1f7d63266 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point, find the nearest point on the surface of this object.  <a href="classSimTK_1_1ContactGeometry.html#a4d7d72b5b0d0b2b534abafe1f7d63266">More...</a><br /></td></tr>
<tr class="separator:a4d7d72b5b0d0b2b534abafe1f7d63266 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9804dd155c59290d7c06a0672eba9ccb inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9804dd155c59290d7c06a0672eba9ccb">projectDownhillToNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointQ) const</td></tr>
<tr class="memdesc:a9804dd155c59290d7c06a0672eba9ccb inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a query point Q, find the nearest point P on the surface of this object, looking only down the local gradient.  <a href="classSimTK_1_1ContactGeometry.html#a9804dd155c59290d7c06a0672eba9ccb">More...</a><br /></td></tr>
<tr class="separator:a9804dd155c59290d7c06a0672eba9ccb inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6290140efb148474bd35294ad34b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a57f6290140efb148474bd35294ad34b6">trackSeparationFromLine</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointOnLine, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;directionOfLine, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;startingGuessForClosestPoint, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;newClosestPointOnSurface, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;closestPointOnLine, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;height) const</td></tr>
<tr class="memdesc:a57f6290140efb148474bd35294ad34b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the closest point between this implicit surface and a given line, or the point of deepest penetration if the line intersects the surface.  <a href="classSimTK_1_1ContactGeometry.html#a57f6290140efb148474bd35294ad34b6">More...</a><br /></td></tr>
<tr class="separator:a57f6290140efb148474bd35294ad34b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b665e9ef6e190a88c13665a222e8ad5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a6b665e9ef6e190a88c13665a222e8ad5">intersectsRay</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;origin, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;distance, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a6b665e9ef6e190a88c13665a222e8ad5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this object intersects a ray, and if so, find the intersection point.  <a href="classSimTK_1_1ContactGeometry.html#a6b665e9ef6e190a88c13665a222e8ad5">More...</a><br /></td></tr>
<tr class="separator:a6b665e9ef6e190a88c13665a222e8ad5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7407d10f6c12ea2584ca9620c666c0 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1a7407d10f6c12ea2584ca9620c666c0">getBoundingSphere</a> (<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;center, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;radius) const</td></tr>
<tr class="memdesc:a1a7407d10f6c12ea2584ca9620c666c0 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bounding sphere which completely encloses this object.  <a href="classSimTK_1_1ContactGeometry.html#a1a7407d10f6c12ea2584ca9620c666c0">More...</a><br /></td></tr>
<tr class="separator:a1a7407d10f6c12ea2584ca9620c666c0 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ec4a215693e39d3225411c4b7a58d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a506ec4a215693e39d3225411c4b7a58d">isSmooth</a> () const</td></tr>
<tr class="memdesc:a506ec4a215693e39d3225411c4b7a58d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this is a smooth surface, meaning that it can provide meaningful curvature information and continuous derivatives with respect to its parameterization.  <a href="classSimTK_1_1ContactGeometry.html#a506ec4a215693e39d3225411c4b7a58d">More...</a><br /></td></tr>
<tr class="separator:a506ec4a215693e39d3225411c4b7a58d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5ef5f86ba50c0767b6e10249fc107 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1dc5ef5f86ba50c0767b6e10249fc107">calcCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;curvature, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;orientation) const</td></tr>
<tr class="memdesc:a1dc5ef5f86ba50c0767b6e10249fc107 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the principal curvatures and their directions, and the surface normal, at a given point on a smooth surface.  <a href="classSimTK_1_1ContactGeometry.html#a1dc5ef5f86ba50c0767b6e10249fc107">More...</a><br /></td></tr>
<tr class="separator:a1dc5ef5f86ba50c0767b6e10249fc107 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c7cf706c65a63f56c0d5cd8c2b0b47 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a0802d357d8b06888b8a1bc35a78c715c">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a32c7cf706c65a63f56c0d5cd8c2b0b47">getImplicitFunction</a> () const</td></tr>
<tr class="memdesc:a32c7cf706c65a63f56c0d5cd8c2b0b47 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our smooth surfaces define a function f(P)=0 that provides an implicit representation of the surface.  <a href="classSimTK_1_1ContactGeometry.html#a32c7cf706c65a63f56c0d5cd8c2b0b47">More...</a><br /></td></tr>
<tr class="separator:a32c7cf706c65a63f56c0d5cd8c2b0b47 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add690900c2e6be0482b133fe8ad8a921 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#add690900c2e6be0482b133fe8ad8a921">calcSurfaceValue</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:add690900c2e6be0482b133fe8ad8a921 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#add690900c2e6be0482b133fe8ad8a921">More...</a><br /></td></tr>
<tr class="separator:add690900c2e6be0482b133fe8ad8a921 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a00c2b0e3dc15fdf4661b3cf41d064 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a11a00c2b0e3dc15fdf4661b3cf41d064">calcSurfaceUnitNormal</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a11a00c2b0e3dc15fdf4661b3cf41d064 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the implicit surface outward facing unit normal at the given point.  <a href="classSimTK_1_1ContactGeometry.html#a11a00c2b0e3dc15fdf4661b3cf41d064">More...</a><br /></td></tr>
<tr class="separator:a11a00c2b0e3dc15fdf4661b3cf41d064 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b950a7f4bafa6509425a0fb8a2ad29 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29">calcSurfaceGradient</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a44b950a7f4bafa6509425a0fb8a2ad29 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29">More...</a><br /></td></tr>
<tr class="separator:a44b950a7f4bafa6509425a0fb8a2ad29 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533a7ba51866683ef8c4d0b5678818b inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7533a7ba51866683ef8c4d0b5678818b">calcSurfaceHessian</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a7533a7ba51866683ef8c4d0b5678818b inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the hessian of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#a7533a7ba51866683ef8c4d0b5678818b">More...</a><br /></td></tr>
<tr class="separator:a7533a7ba51866683ef8c4d0b5678818b inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ab9554de594636a6d6d15f96e5277 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7a4ab9554de594636a6d6d15f96e5277">calcGaussianCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;gradient, const <a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> &amp;Hessian) const</td></tr>
<tr class="memdesc:a7a4ab9554de594636a6d6d15f96e5277 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface, return the Gaussian curvature at the point p whose implicit surface function gradient g(p) and Hessian H(p) are supplied.  <a href="classSimTK_1_1ContactGeometry.html#a7a4ab9554de594636a6d6d15f96e5277">More...</a><br /></td></tr>
<tr class="separator:a7a4ab9554de594636a6d6d15f96e5277 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902cdbf3bd8aecf82958c61de9b17c91 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a902cdbf3bd8aecf82958c61de9b17c91">calcGaussianCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a902cdbf3bd8aecf82958c61de9b17c91 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature is for convenience; use the other one to save time if you already have the gradient and Hessian available for this point.  <a href="classSimTK_1_1ContactGeometry.html#a902cdbf3bd8aecf82958c61de9b17c91">More...</a><br /></td></tr>
<tr class="separator:a902cdbf3bd8aecf82958c61de9b17c91 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516845833a62bc3fcad6619a54585a9 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ac516845833a62bc3fcad6619a54585a9">calcSurfaceCurvatureInDirection</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction) const</td></tr>
<tr class="memdesc:ac516845833a62bc3fcad6619a54585a9 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface, return the curvature k of the surface at a given point p in a given direction tp.  <a href="classSimTK_1_1ContactGeometry.html#ac516845833a62bc3fcad6619a54585a9">More...</a><br /></td></tr>
<tr class="separator:ac516845833a62bc3fcad6619a54585a9 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48cf8ac6a47aef3c70779f12c99004 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aac48cf8ac6a47aef3c70779f12c99004">calcSurfacePrincipalCurvatures</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;curvature, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP) const</td></tr>
<tr class="memdesc:aac48cf8ac6a47aef3c70779f12c99004 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface at a given point p, return the principal curvatures and principal curvature directions, using only the implicit function and its derivatives.  <a href="classSimTK_1_1ContactGeometry.html#aac48cf8ac6a47aef3c70779f12c99004">More...</a><br /></td></tr>
<tr class="separator:aac48cf8ac6a47aef3c70779f12c99004 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f54e083249ea3cd0e2a91c68e74a4e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a09f54e083249ea3cd0e2a91c68e74a4e">isConvex</a> () const</td></tr>
<tr class="memdesc:a09f54e083249ea3cd0e2a91c68e74a4e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this surface is known to be convex.  <a href="classSimTK_1_1ContactGeometry.html#a09f54e083249ea3cd0e2a91c68e74a4e">More...</a><br /></td></tr>
<tr class="separator:a09f54e083249ea3cd0e2a91c68e74a4e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756676e69c6fba68114b4f427c951a72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a756676e69c6fba68114b4f427c951a72">calcSupportPoint</a> (<a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> direction) const</td></tr>
<tr class="memdesc:a756676e69c6fba68114b4f427c951a72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a direction expressed in the surface's frame S, return the point P on the surface that is the furthest in that direction (or one of those points if there is more than one).  <a href="classSimTK_1_1ContactGeometry.html#a756676e69c6fba68114b4f427c951a72">More...</a><br /></td></tr>
<tr class="separator:a756676e69c6fba68114b4f427c951a72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae853e413043e89d59f19edcf903862ca inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometryTypeId.html">ContactGeometryTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ae853e413043e89d59f19edcf903862ca">getTypeId</a> () const</td></tr>
<tr class="memdesc:ae853e413043e89d59f19edcf903862ca inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1ContactTrackerSubsystem.html" title="This subsystem identifies and tracks potential contacts between the mobilized bodies of a multibody s...">ContactTrackerSubsystem</a> uses this id for fast identification of specific surface shapes.  <a href="classSimTK_1_1ContactGeometry.html#ae853e413043e89d59f19edcf903862ca">More...</a><br /></td></tr>
<tr class="separator:ae853e413043e89d59f19edcf903862ca inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac648a4888974dc91db4c67ee3c21ef72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ac648a4888974dc91db4c67ee3c21ef72">ContactGeometry</a> (ContactGeometryImpl *<a class="el" href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">impl</a>)</td></tr>
<tr class="memdesc:ac648a4888974dc91db4c67ee3c21ef72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#ac648a4888974dc91db4c67ee3c21ef72">More...</a><br /></td></tr>
<tr class="separator:ac648a4888974dc91db4c67ee3c21ef72 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa335794fd91bf6ed25be4d1c6a5fc527 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aa335794fd91bf6ed25be4d1c6a5fc527">isOwnerHandle</a> () const</td></tr>
<tr class="memdesc:aa335794fd91bf6ed25be4d1c6a5fc527 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#aa335794fd91bf6ed25be4d1c6a5fc527">More...</a><br /></td></tr>
<tr class="separator:aa335794fd91bf6ed25be4d1c6a5fc527 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959dc355f4f7f04f5d5eb9a3daf95b3d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a959dc355f4f7f04f5d5eb9a3daf95b3d">isEmptyHandle</a> () const</td></tr>
<tr class="memdesc:a959dc355f4f7f04f5d5eb9a3daf95b3d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a959dc355f4f7f04f5d5eb9a3daf95b3d">More...</a><br /></td></tr>
<tr class="separator:a959dc355f4f7f04f5d5eb9a3daf95b3d inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3712ed3c23bf8fc01874be710d3f077a inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a3712ed3c23bf8fc01874be710d3f077a">hasImpl</a> () const</td></tr>
<tr class="memdesc:a3712ed3c23bf8fc01874be710d3f077a inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a3712ed3c23bf8fc01874be710d3f077a">More...</a><br /></td></tr>
<tr class="separator:a3712ed3c23bf8fc01874be710d3f077a inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b135711e8d5966b36a954f0c3cc5d0e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const ContactGeometryImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9b135711e8d5966b36a954f0c3cc5d0e">getImpl</a> () const</td></tr>
<tr class="memdesc:a9b135711e8d5966b36a954f0c3cc5d0e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a9b135711e8d5966b36a954f0c3cc5d0e">More...</a><br /></td></tr>
<tr class="separator:a9b135711e8d5966b36a954f0c3cc5d0e inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bbdd8a3d084c2030b29d9618b64a28 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">ContactGeometryImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#af1bbdd8a3d084c2030b29d9618b64a28">updImpl</a> ()</td></tr>
<tr class="memdesc:af1bbdd8a3d084c2030b29d9618b64a28 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#af1bbdd8a3d084c2030b29d9618b64a28">More...</a><br /></td></tr>
<tr class="separator:af1bbdd8a3d084c2030b29d9618b64a28 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a15eaf1f2184a1323e6661f63e6a34 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#af2a15eaf1f2184a1323e6661f63e6a34">initGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xSP, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:af2a15eaf1f2184a1323e6661f63e6a34 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two points, find a geodesic curve connecting them.  <a href="classSimTK_1_1ContactGeometry.html#af2a15eaf1f2184a1323e6661f63e6a34">More...</a><br /></td></tr>
<tr class="separator:af2a15eaf1f2184a1323e6661f63e6a34 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a03a49e77241257d018405e30dcb49 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a88a03a49e77241257d018405e30dcb49">continueGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;prevGeod, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a88a03a49e77241257d018405e30dcb49 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the current positions of two points P and Q moving on this surface, and the previous geodesic curve G' connecting prior locations P' and Q' of those same two points, return the geodesic G between P and Q that is closest in length to the previous one.  <a href="classSimTK_1_1ContactGeometry.html#a88a03a49e77241257d018405e30dcb49">More...</a><br /></td></tr>
<tr class="separator:a88a03a49e77241257d018405e30dcb49 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936a25de7017a330823f93104fb24859 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a936a25de7017a330823f93104fb24859">makeStraightLineGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;defaultDirectionIfNeeded, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a936a25de7017a330823f93104fb24859 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a straight-line approximation to the (presumably short) geodesic between two points on this implicit surface.  <a href="classSimTK_1_1ContactGeometry.html#a936a25de7017a330823f93104fb24859">More...</a><br /></td></tr>
<tr class="separator:a936a25de7017a330823f93104fb24859 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b672c233d2437c421408a121da4c8 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a990b672c233d2437c421408a121da4c8">shootGeodesicInDirectionUntilLengthReached</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;terminatingLength, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a990b672c233d2437c421408a121da4c8 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length.  <a href="classSimTK_1_1ContactGeometry.html#a990b672c233d2437c421408a121da4c8">More...</a><br /></td></tr>
<tr class="separator:a990b672c233d2437c421408a121da4c8 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad1de0db758a5bc13c5160951e66f5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2bad1de0db758a5bc13c5160951e66f5">calcGeodesicReverseSensitivity</a> (<a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geodesic, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;initSensitivity=<a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(0, 1)) const</td></tr>
<tr class="memdesc:a2bad1de0db758a5bc13c5160951e66f5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already-calculated geodesic on this surface connecting points P and Q, fill in the sensitivity of point P with respect to a change of tangent direction at Q.  <a href="classSimTK_1_1ContactGeometry.html#a2bad1de0db758a5bc13c5160951e66f5">More...</a><br /></td></tr>
<tr class="separator:a2bad1de0db758a5bc13c5160951e66f5 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d2b533f1c69f6c9b4c5ea22371f27 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ab46d2b533f1c69f6c9b4c5ea22371f27">shootGeodesicInDirectionUntilPlaneHit</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;terminatingPlane, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:ab46d2b533f1c69f6c9b4c5ea22371f27 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane.  <a href="classSimTK_1_1ContactGeometry.html#ab46d2b533f1c69f6c9b4c5ea22371f27">More...</a><br /></td></tr>
<tr class="separator:ab46d2b533f1c69f6c9b4c5ea22371f27 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c08e2a56fb38546efdb48f1cda079 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a765c08e2a56fb38546efdb48f1cda079">calcGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tQhint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a765c08e2a56fb38546efdb48f1cda079 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to find geodesic between P and Q using split geodesic method with initial shooting directions tPhint and -tQhint.  <a href="classSimTK_1_1ContactGeometry.html#a765c08e2a56fb38546efdb48f1cda079">More...</a><br /></td></tr>
<tr class="separator:a765c08e2a56fb38546efdb48f1cda079 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b44f8a2e2daa2e09341ad3085ba4eae inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a0b44f8a2e2daa2e09341ad3085ba4eae">calcGeodesicUsingOrthogonalMethod</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> lengthHint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a0b44f8a2e2daa2e09341ad3085ba4eae inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to find geodesic between P and Q using the orthogonal method, with initial direction tPhint and initial length lengthHint.  <a href="classSimTK_1_1ContactGeometry.html#a0b44f8a2e2daa2e09341ad3085ba4eae">More...</a><br /></td></tr>
<tr class="separator:a0b44f8a2e2daa2e09341ad3085ba4eae inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fdde7022416b8d88bc1735cab1e224 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a01fdde7022416b8d88bc1735cab1e224">calcGeodesicUsingOrthogonalMethod</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a01fdde7022416b8d88bc1735cab1e224 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature makes a guess at the initial direction and length and then calls the other signature.  <a href="classSimTK_1_1ContactGeometry.html#a01fdde7022416b8d88bc1735cab1e224">More...</a><br /></td></tr>
<tr class="separator:a01fdde7022416b8d88bc1735cab1e224 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9af982b24f430502bac9c545c9abdc inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2d9af982b24f430502bac9c545c9abdc">calcSplitGeodError</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;Q, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *geod=0) const</td></tr>
<tr class="memdesc:a2d9af982b24f430502bac9c545c9abdc inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ.  <a href="classSimTK_1_1ContactGeometry.html#a2d9af982b24f430502bac9c545c9abdc">More...</a><br /></td></tr>
<tr class="separator:a2d9af982b24f430502bac9c545c9abdc inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754766a3425583c7e8342f7216ee6ce2 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a754766a3425583c7e8342f7216ee6ce2">shootGeodesicInDirectionUntilLengthReachedAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;terminatingLength, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a754766a3425583c7e8342f7216ee6ce2 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length.  <a href="classSimTK_1_1ContactGeometry.html#a754766a3425583c7e8342f7216ee6ce2">More...</a><br /></td></tr>
<tr class="separator:a754766a3425583c7e8342f7216ee6ce2 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f489bb3134725a7d1a9e584fb9da903 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9f489bb3134725a7d1a9e584fb9da903">shootGeodesicInDirectionUntilPlaneHitAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;terminatingPlane, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a9f489bb3134725a7d1a9e584fb9da903 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane.  <a href="classSimTK_1_1ContactGeometry.html#a9f489bb3134725a7d1a9e584fb9da903">More...</a><br /></td></tr>
<tr class="separator:a9f489bb3134725a7d1a9e584fb9da903 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12e31eb56f265f70c682554c471649 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a3c12e31eb56f265f70c682554c471649">calcGeodesicAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tQhint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a3c12e31eb56f265f70c682554c471649 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to analytically find geodesic between P and Q with initial shooting directions tPhint and tQhint.  <a href="classSimTK_1_1ContactGeometry.html#a3c12e31eb56f265f70c682554c471649">More...</a><br /></td></tr>
<tr class="separator:a3c12e31eb56f265f70c682554c471649 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1393837d0460e675354885666fff43ea inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1393837d0460e675354885666fff43ea">calcSplitGeodErrorAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;Q, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *geod=0) const</td></tr>
<tr class="memdesc:a1393837d0460e675354885666fff43ea inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to analytically calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ.  <a href="classSimTK_1_1ContactGeometry.html#a1393837d0460e675354885666fff43ea">More...</a><br /></td></tr>
<tr class="separator:a1393837d0460e675354885666fff43ea inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcf119352496ba829cf6783c9fb3e1c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2bcf119352496ba829cf6783c9fb3e1c">getPlane</a> () const</td></tr>
<tr class="memdesc:a2bcf119352496ba829cf6783c9fb3e1c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler.  <a href="classSimTK_1_1ContactGeometry.html#a2bcf119352496ba829cf6783c9fb3e1c">More...</a><br /></td></tr>
<tr class="separator:a2bcf119352496ba829cf6783c9fb3e1c inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b64dde0ca2dfcd094b0b6204f4a21b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2b64dde0ca2dfcd094b0b6204f4a21b6">setPlane</a> (const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;plane) const</td></tr>
<tr class="memdesc:a2b64dde0ca2dfcd094b0b6204f4a21b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the plane associated with the geodesic hit plane event handler.  <a href="classSimTK_1_1ContactGeometry.html#a2b64dde0ca2dfcd094b0b6204f4a21b6">More...</a><br /></td></tr>
<tr class="separator:a2b64dde0ca2dfcd094b0b6204f4a21b6 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25147aeb5d31211fbf031a0dac23132 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aa25147aeb5d31211fbf031a0dac23132">getGeodP</a> () const</td></tr>
<tr class="memdesc:aa25147aeb5d31211fbf031a0dac23132 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geodesic for access by visualizer.  <a href="classSimTK_1_1ContactGeometry.html#aa25147aeb5d31211fbf031a0dac23132">More...</a><br /></td></tr>
<tr class="separator:aa25147aeb5d31211fbf031a0dac23132 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaf2ca0c1905728867539f33765133 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aecdaf2ca0c1905728867539f33765133">getGeodQ</a> () const</td></tr>
<tr class="memdesc:aecdaf2ca0c1905728867539f33765133 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geodesic for access by visualizer.  <a href="classSimTK_1_1ContactGeometry.html#aecdaf2ca0c1905728867539f33765133">More...</a><br /></td></tr>
<tr class="separator:aecdaf2ca0c1905728867539f33765133 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194ad90ea8cba0a176b5e0982d2b1997 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a194ad90ea8cba0a176b5e0982d2b1997">getNumGeodesicsShot</a> () const</td></tr>
<tr class="memdesc:a194ad90ea8cba0a176b5e0982d2b1997 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler.  <a href="classSimTK_1_1ContactGeometry.html#a194ad90ea8cba0a176b5e0982d2b1997">More...</a><br /></td></tr>
<tr class="separator:a194ad90ea8cba0a176b5e0982d2b1997 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4542caabc4680f44e5a696caf303e86 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ae4542caabc4680f44e5a696caf303e86">addVizReporter</a> (<a class="el" href="classSimTK_1_1ScheduledEventReporter.html">ScheduledEventReporter</a> *reporter) const</td></tr>
<tr class="memdesc:ae4542caabc4680f44e5a696caf303e86 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler.  <a href="classSimTK_1_1ContactGeometry.html#ae4542caabc4680f44e5a696caf303e86">More...</a><br /></td></tr>
<tr class="separator:ae4542caabc4680f44e5a696caf303e86 inherit pub_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7331b438b6efd2ade5b37fb5784e6701"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a7331b438b6efd2ade5b37fb5784e6701">isInstance</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;geo)</td></tr>
<tr class="memdesc:a7331b438b6efd2ade5b37fb5784e6701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object is a triangle mesh.  <a href="#a7331b438b6efd2ade5b37fb5784e6701">More...</a><br /></td></tr>
<tr class="separator:a7331b438b6efd2ade5b37fb5784e6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b203b2f7ac058d75beb25c5dbaae64"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#ae7b203b2f7ac058d75beb25c5dbaae64">getAs</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;geo)</td></tr>
<tr class="memdesc:ae7b203b2f7ac058d75beb25c5dbaae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object to a const triangle mesh.  <a href="#ae7b203b2f7ac058d75beb25c5dbaae64">More...</a><br /></td></tr>
<tr class="separator:ae7b203b2f7ac058d75beb25c5dbaae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b07be58136154ab7f6dd78ebd5f6c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a48b07be58136154ab7f6dd78ebd5f6c8">updAs</a> (<a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;geo)</td></tr>
<tr class="memdesc:a48b07be58136154ab7f6dd78ebd5f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object to a writable triangle mesh.  <a href="#a48b07be58136154ab7f6dd78ebd5f6c8">More...</a><br /></td></tr>
<tr class="separator:a48b07be58136154ab7f6dd78ebd5f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b64f4d0382abe2dc35ddff32aa53a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1ContactGeometryTypeId.html">ContactGeometryTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a29b64f4d0382abe2dc35ddff32aa53a3">classTypeId</a> ()</td></tr>
<tr class="memdesc:a29b64f4d0382abe2dc35ddff32aa53a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the unique id for <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a> contact geometry.  <a href="#a29b64f4d0382abe2dc35ddff32aa53a3">More...</a><br /></td></tr>
<tr class="separator:a29b64f4d0382abe2dc35ddff32aa53a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSimTK_1_1ContactGeometry"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSimTK_1_1ContactGeometry')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSimTK_1_1ContactGeometry.html">SimTK::ContactGeometry</a></td></tr>
<tr class="memitem:a990797bf74d949e5eb6fe6ccc02d56db inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a990797bf74d949e5eb6fe6ccc02d56db">evalParametricCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;nn, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;dPdu, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;dPdv, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdu2, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdv2, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdudv, <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_EP)</td></tr>
<tr class="memdesc:a990797bf74d949e5eb6fe6ccc02d56db inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate surface curvature at a point using differential geometry as suggested by Harris 2006, "Curvature of ellipsoids and other surfaces" Ophthal.  <a href="classSimTK_1_1ContactGeometry.html#a990797bf74d949e5eb6fe6ccc02d56db">More...</a><br /></td></tr>
<tr class="separator:a990797bf74d949e5eb6fe6ccc02d56db inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d96a97f8100e4a46194654f0bdf22d4 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4">combineParaboloids</a> (const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP1, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k1, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;x2, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k2, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k)</td></tr>
<tr class="memdesc:a7d96a97f8100e4a46194654f0bdf22d4 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces in contact, in a way that is useful for later application of Hertz compliant contact theory for generating forces.  <a href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4">More...</a><br /></td></tr>
<tr class="separator:a7d96a97f8100e4a46194654f0bdf22d4 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a0968761d422b1f0bf0045416fef16 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a15a0968761d422b1f0bf0045416fef16">combineParaboloids</a> (const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP1, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k1, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;x2, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k2, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k)</td></tr>
<tr class="memdesc:a15a0968761d422b1f0bf0045416fef16 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a much faster version of <a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4" title="This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces...">combineParaboloids()</a> for when you just need the curvatures of the difference paraboloid, but not the directions of those curvatures.  <a href="classSimTK_1_1ContactGeometry.html#a15a0968761d422b1f0bf0045416fef16">More...</a><br /></td></tr>
<tr class="separator:a15a0968761d422b1f0bf0045416fef16 inherit pub_static_methods_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classSimTK_1_1ContactGeometry"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSimTK_1_1ContactGeometry')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSimTK_1_1ContactGeometry.html">SimTK::ContactGeometry</a></td></tr>
<tr class="memitem:a03ff2fddea5008e383fa7588bb813837 inherit pro_attribs_classSimTK_1_1ContactGeometry"><td class="memItemLeft" align="right" valign="top">ContactGeometryImpl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">impl</a></td></tr>
<tr class="memdesc:a03ff2fddea5008e383fa7588bb813837 inherit pro_attribs_classSimTK_1_1ContactGeometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">More...</a><br /></td></tr>
<tr class="separator:a03ff2fddea5008e383fa7588bb813837 inherit pro_attribs_classSimTK_1_1ContactGeometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> subclass represents an arbitrary shape described by a mesh of triangular faces. </p>
<p>The mesh surface must satisfy the following requirements:</p><ul>
<li>It must be closed, so that any point can unambiguously be classified as either inside or outside.</li>
<li>It may not intersect itself anywhere, even at a single point.</li>
<li>It must be an oriented manifold.</li>
<li>The vertices for each face must be ordered counter-clockwise when viewed from the outside. That is, if v0, v1, and v2 are the locations of the three vertices for a face, the cross product (v1-v0)%(v2-v0) must point outward.</li>
<li>The length of every edge must be non-zero.</li>
</ul>
<p>It is your responsibility to ensure that any mesh you create meets these requirements. The constructor will detect many incorrect meshes and signal them by throwing an exception, but it is not guaranteed to detect all possible problems. If a mesh fails to satisfy any of these requirements, the results of calculations performed with it are undefined. For example, collisions involving it might fail to be detected, or contact forces on it might be calculated incorrectly. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8d7b4bfd6175acb944d54e92b96118b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7b4bfd6175acb944d54e92b96118b1">&#9670;&nbsp;</a></span>TriangleMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">SimTK::ContactGeometry::TriangleMesh::TriangleMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>faceIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The positions of all vertices in the mesh. </td></tr>
    <tr><td class="paramname">faceIndices</td><td>The indices of the vertices that make up each face. The first three elements are the vertices in the first face, the next three elements are the vertices in the second face, etc. </td></tr>
    <tr><td class="paramname">smooth</td><td>If true, the mesh will be treated as a smooth surface, and normal vectors will be smoothly interpolated between vertices. If false, it will be treated as a faceted mesh with a constant normal vector over each face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bc2151edb6813ada2712b7bc245829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc2151edb6813ada2712b7bc245829c">&#9670;&nbsp;</a></span>TriangleMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">SimTK::ContactGeometry::TriangleMesh::TriangleMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a> based on a <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> object. </p>
<p>If any faces of the <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> have more than three vertices, they are automatically triangulated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> from which to construct a triangle mesh. </td></tr>
    <tr><td class="paramname">smooth</td><td>If true, the mesh will be treated as a smooth surface, and normal vectors will be smoothly interpolated between vertices. If false, it will be treated as a faceted mesh with a constant normal vector over each face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5821841a4545f7cce4e4274090c09b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5821841a4545f7cce4e4274090c09b2c">&#9670;&nbsp;</a></span>getNumEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges in the mesh. </p>

</div>
</div>
<a id="ad0baa53ff1df2f429e48a800c1ed754f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0baa53ff1df2f429e48a800c1ed754f">&#9670;&nbsp;</a></span>getNumFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of faces in the mesh. </p>

</div>
</div>
<a id="ace76d99ac18f98334475a6a702ce9267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace76d99ac18f98334475a6a702ce9267">&#9670;&nbsp;</a></span>getNumVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of vertices in the mesh. </p>

</div>
</div>
<a id="a5571b769bb78fb855cf25cf77e781a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5571b769bb78fb855cf25cf77e781a64">&#9670;&nbsp;</a></span>getVertexPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::ContactGeometry::TriangleMesh::getVertexPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a vertex in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the vertex to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the specified vertex. </dd></dl>

</div>
</div>
<a id="a082c0c332d7eeba0956ab45971d231e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082c0c332d7eeba0956ab45971d231e0">&#9670;&nbsp;</a></span>getFaceEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getFaceEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one of the edges of a face. </p>
<p>Edge 0 connects vertices 0 and 1. Edge 1 connects vertices 1 and 2. Edge 2 connects vertices 0 and 2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face. </td></tr>
    <tr><td class="paramname">edge</td><td>The index of the edge within the face (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified edge. </dd></dl>

</div>
</div>
<a id="ad5e520cff0320c1e806b54324bc81ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e520cff0320c1e806b54324bc81ebf">&#9670;&nbsp;</a></span>getFaceVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getFaceVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one of the vertices of a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face. </td></tr>
    <tr><td class="paramname">vertex</td><td>The index of the vertex within the face (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified vertex. </dd></dl>

</div>
</div>
<a id="a91dfc034b042b7dd9522e331ff472763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dfc034b042b7dd9522e331ff472763">&#9670;&nbsp;</a></span>getEdgeFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getEdgeFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one of the faces shared by an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The index of the edge. </td></tr>
    <tr><td class="paramname">face</td><td>The index of the face within the edge (0 or 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified face. </dd></dl>

</div>
</div>
<a id="a095cddbc80db3b718abe9fa47534f72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095cddbc80db3b718abe9fa47534f72b">&#9670;&nbsp;</a></span>getEdgeVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::ContactGeometry::TriangleMesh::getEdgeVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of one of the vertices shared by an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The index of the edge. </td></tr>
    <tr><td class="paramname">vertex</td><td>The index of the vertex within the edge (0 or 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the specified vertex. </dd></dl>

</div>
</div>
<a id="af6e1dda3e89134bf13c2b6e9d5b330e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e1dda3e89134bf13c2b6e9d5b330e8">&#9670;&nbsp;</a></span>findVertexEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::TriangleMesh::findVertexEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all edges that intersect a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>The index of the vertex. </td></tr>
    <tr><td class="paramname">edges</td><td>The indices of all edges intersecting the vertex will be added to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2d13f30654d34bd7c702760c4e194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d13f30654d34bd7c702760c4e194a">&#9670;&nbsp;</a></span>getFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&amp; SimTK::ContactGeometry::TriangleMesh::getFaceNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the normal vector for a face. </p>
<p>This points outward from the mesh. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a249e99b7cc687cd3b4c67073ca208773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249e99b7cc687cd3b4c67073ca208773">&#9670;&nbsp;</a></span>getFaceArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::TriangleMesh::getFaceArea </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the area of a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cf073134ea386e06b4c773e3932283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf073134ea386e06b4c773e3932283d">&#9670;&nbsp;</a></span>findPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::TriangleMesh::findPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the location of a point on the surface, in the local frame of the <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>. </p>
<p>Cost is 11 flops. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face containing the point. </td></tr>
    <tr><td class="paramname">uv</td><td>The point within the face, specified by its barycentric uv coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a634dfc5d9c84b5d8c81b23f67a038099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634dfc5d9c84b5d8c81b23f67a038099">&#9670;&nbsp;</a></span>findCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::TriangleMesh::findCentroid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the location of a face's centroid, that is, the point uv=(1/3,1/3) which is the average of the three vertex locations. </p>
<p>This is a common special case of <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#a6cf073134ea386e06b4c773e3932283d" title="Calculate the location of a point on the surface, in the local frame of the TriangleMesh. ">findPoint()</a> that can be calculated more quickly (7 flops). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face whose centroid is of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a649ce0795c43d29504ffd45c0598d82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649ce0795c43d29504ffd45c0598d82c">&#9670;&nbsp;</a></span>findNormalAtPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> SimTK::ContactGeometry::TriangleMesh::findNormalAtPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the normal vector at a point on the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The index of the face containing the point. </td></tr>
    <tr><td class="paramname">uv</td><td>The point within the face, specified by its barycentric uv coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2aa28401a535e7d548036693366b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2aa28401a535e7d548036693366b07">&#9670;&nbsp;</a></span>findNearestPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::TriangleMesh::findNearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point, find the nearest point on the surface of this object. </p>
<p>If multiple points on the surface are equally close to the specified point, this may return any of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The point in question. </td></tr>
    <tr><td class="paramname">inside</td><td>On exit, this is set to true if the specified point is inside this object, false otherwise. </td></tr>
    <tr><td class="paramname">normal</td><td>On exit, this contains the surface normal at the returned point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point on the surface of the object which is closest to the specified point. </dd></dl>

</div>
</div>
<a id="a070d1e38e2c672ac3aa63be7ad4a4b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070d1e38e2c672ac3aa63be7ad4a4b86">&#9670;&nbsp;</a></span>findNearestPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::TriangleMesh::findNearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point, find the nearest point on the surface of this object. </p>
<p>If multiple points on the surface are equally close to the specified point, this may return any of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The point in question. </td></tr>
    <tr><td class="paramname">inside</td><td>On exit, this is set to true if the specified point is inside this object, false otherwise. </td></tr>
    <tr><td class="paramname">face</td><td>On exit, this contains the index of the face containing the returned point. </td></tr>
    <tr><td class="paramname">uv</td><td>On exit, this contains the barycentric coordinates (u and v) of the returned point within its face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point on the surface of the object which is closest to the specified point. </dd></dl>

</div>
</div>
<a id="a63b888d26f48200a1cd194038b6261e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b888d26f48200a1cd194038b6261e4">&#9670;&nbsp;</a></span>findNearestPointToFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::TriangleMesh::findNearestPointToFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point and a face of this object, find the point of the face that is nearest the given point. </p>
<p>If multiple points on the face are equally close to the specified point, this may return any of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The point in question. </td></tr>
    <tr><td class="paramname">face</td><td>The face to be examined. </td></tr>
    <tr><td class="paramname">uv</td><td>On exit, this contains the barycentric coordinates (u and v) of the returned point within the face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The face point, in the surface's frame, that is closest to the specified point. </dd></dl>

</div>
</div>
<a id="a7a00f2fa5a39991fddf472cc35362cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a00f2fa5a39991fddf472cc35362cd0">&#9670;&nbsp;</a></span>intersectsRay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::TriangleMesh::intersectsRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this mesh intersects a ray, and if so, find the intersection point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The position at which the ray begins. </td></tr>
    <tr><td class="paramname">direction</td><td>The ray direction. </td></tr>
    <tr><td class="paramname">distance</td><td>If an intersection is found, the distance from the ray origin to the intersection point is stored in this. Otherwise, it is left unchanged. </td></tr>
    <tr><td class="paramname">normal</td><td>If an intersection is found, the surface normal of the intersection point is stored in this. Otherwise, it is left unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an intersection is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aeee188a66ce43c3e2e5ae3e42628ea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee188a66ce43c3e2e5ae3e42628ea13">&#9670;&nbsp;</a></span>intersectsRay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::TriangleMesh::intersectsRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this mesh intersects a ray, and if so, find what face it hit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The position at which the ray begins. </td></tr>
    <tr><td class="paramname">direction</td><td>The ray direction. </td></tr>
    <tr><td class="paramname">distance</td><td>If an intersection is found, the distance from the ray origin to the intersection point is stored in this. Otherwise, it is left unchanged. </td></tr>
    <tr><td class="paramname">face</td><td>If an intersection is found, the index of the face hit by the ray is stored in this. Otherwise, it is left unchanged. </td></tr>
    <tr><td class="paramname">uv</td><td>If an intersection is found, the barycentric coordinates (u and v) of the intersection point within the hit face are stored in this. Otherwise, it is left unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an intersection is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5f4620231869d0b9abeeaab57304c353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4620231869d0b9abeeaab57304c353">&#9670;&nbsp;</a></span>getOBBTreeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html">OBBTreeNode</a> SimTK::ContactGeometry::TriangleMesh::getOBBTreeNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh_1_1OBBTreeNode.html" title="This class represents a node in the Oriented Bounding Box Tree for a TriangleMesh. ">OBBTreeNode</a> which forms the root of this mesh's Oriented Bounding Box Tree. </p>

</div>
</div>
<a id="af0839274eee4b9e754d3c37afef714f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0839274eee4b9e754d3c37afef714f3">&#9670;&nbsp;</a></span>createPolygonalMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PolygonalMesh.html">PolygonalMesh</a> SimTK::ContactGeometry::TriangleMesh::createPolygonalMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a <a class="el" href="classSimTK_1_1PolygonalMesh.html" title="This class provides a description of a mesh made of polygonal faces (not limited to triangles)...">PolygonalMesh</a> from this <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a>; useful mostly for debugging because you can create a <a class="el" href="classSimTK_1_1DecorativeMesh.html" title="This defines a displayable mesh by referencing an already-existing PolygonalMesh object. ">DecorativeMesh</a> from this and then look at it. </p>

</div>
</div>
<a id="a7331b438b6efd2ade5b37fb5784e6701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7331b438b6efd2ade5b37fb5784e6701">&#9670;&nbsp;</a></span>isInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::ContactGeometry::TriangleMesh::isInstance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object is a triangle mesh. </p>

</div>
</div>
<a id="ae7b203b2f7ac058d75beb25c5dbaae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b203b2f7ac058d75beb25c5dbaae64">&#9670;&nbsp;</a></span>getAs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a>&amp; SimTK::ContactGeometry::TriangleMesh::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object to a const triangle mesh. </p>

</div>
</div>
<a id="a48b07be58136154ab7f6dd78ebd5f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b07be58136154ab7f6dd78ebd5f6c8">&#9670;&nbsp;</a></span>updAs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a>&amp; SimTK::ContactGeometry::TriangleMesh::updAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the supplied <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object...">ContactGeometry</a> object to a writable triangle mesh. </p>

</div>
</div>
<a id="a29b64f4d0382abe2dc35ddff32aa53a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b64f4d0382abe2dc35ddff32aa53a3">&#9670;&nbsp;</a></span>classTypeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1ContactGeometryTypeId.html">ContactGeometryTypeId</a> SimTK::ContactGeometry::TriangleMesh::classTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the unique id for <a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces...">TriangleMesh</a> contact geometry. </p>

</div>
</div>
<a id="a38399dbeb7318ed5ede2a51717268c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38399dbeb7318ed5ede2a51717268c9b">&#9670;&nbsp;</a></span>getImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Impl&amp; SimTK::ContactGeometry::TriangleMesh::getImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal use only. </p>
<p>Internal use only. </p>

</div>
</div>
<a id="a159fcbac31b7c7a1a390c807d177df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159fcbac31b7c7a1a390c807d177df62">&#9670;&nbsp;</a></span>updImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Impl&amp; SimTK::ContactGeometry::TriangleMesh::updImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ContactGeometry_8h_source.html">ContactGeometry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:13 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
