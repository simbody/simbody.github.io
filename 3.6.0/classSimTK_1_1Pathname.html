<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Pathname Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Pathname.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSimTK_1_1Pathname-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Pathname Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class encapsulates the handling of file and directory pathnames in a platform-independent manner.  
 <a href="classSimTK_1_1Pathname.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0e51e8b3e6491bcc5494c5868a27b235"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235">deconstructPathname</a> (const std::string &amp;pathname, bool &amp;dontApplySearchPath, std::string &amp;directory, std::string &amp;fileName, std::string &amp;extension)</td></tr>
<tr class="memdesc:a0e51e8b3e6491bcc5494c5868a27b235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dismantle a supplied pathname into its component parts.  <a href="#a0e51e8b3e6491bcc5494c5868a27b235">More...</a><br /></td></tr>
<tr class="separator:a0e51e8b3e6491bcc5494c5868a27b235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa589f84feef8859e37fd6c397540e49f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#aa589f84feef8859e37fd6c397540e49f">deconstructPathnameUsingSpecifiedWorkingDirectory</a> (const std::string &amp;swd, const std::string &amp;pathname, std::string &amp;directory, std::string &amp;fileName, std::string &amp;extension)</td></tr>
<tr class="memdesc:aa589f84feef8859e37fd6c397540e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extension of <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a>.  <a href="#aa589f84feef8859e37fd6c397540e49f">More...</a><br /></td></tr>
<tr class="separator:aa589f84feef8859e37fd6c397540e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35635d66ec2b42671d27a914b0a9be21"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a35635d66ec2b42671d27a914b0a9be21">deconstructAbsolutePathname</a> (const std::string &amp;pathname, std::string &amp;directory, std::string &amp;fileName, std::string &amp;extension)</td></tr>
<tr class="memdesc:a35635d66ec2b42671d27a914b0a9be21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give back the deconstructed canonicalized absolute pathname for a given path.  <a href="#a35635d66ec2b42671d27a914b0a9be21">More...</a><br /></td></tr>
<tr class="separator:a35635d66ec2b42671d27a914b0a9be21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845b3c5f154c28cfa54293a2bf648a72"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a845b3c5f154c28cfa54293a2bf648a72">getAbsolutePathname</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:a845b3c5f154c28cfa54293a2bf648a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get canonicalized absolute pathname from a given pathname which can be relative or absolute.  <a href="#a845b3c5f154c28cfa54293a2bf648a72">More...</a><br /></td></tr>
<tr class="separator:a845b3c5f154c28cfa54293a2bf648a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f06e70b3fd45d32957eaf19daaab2a3"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a4f06e70b3fd45d32957eaf19daaab2a3">getAbsoluteDirectoryPathname</a> (const std::string &amp;dirPathname)</td></tr>
<tr class="memdesc:a4f06e70b3fd45d32957eaf19daaab2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same as <a class="el" href="classSimTK_1_1Pathname.html#a845b3c5f154c28cfa54293a2bf648a72" title="Get canonicalized absolute pathname from a given pathname which can be relative or absolute...">getAbsolutePathname()</a> except that the final segment is interpreted as a directory name rather than a file name, meaning that we append a slash if necessary.  <a href="#a4f06e70b3fd45d32957eaf19daaab2a3">More...</a><br /></td></tr>
<tr class="separator:a4f06e70b3fd45d32957eaf19daaab2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3509afcaa0347a9bcda5dd9421d8182"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#ac3509afcaa0347a9bcda5dd9421d8182">getAbsolutePathnameUsingSpecifiedWorkingDirectory</a> (const std::string &amp;swd, const std::string &amp;pathname)</td></tr>
<tr class="memdesc:ac3509afcaa0347a9bcda5dd9421d8182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Pathname.html#a845b3c5f154c28cfa54293a2bf648a72" title="Get canonicalized absolute pathname from a given pathname which can be relative or absolute...">getAbsolutePathname()</a> but using a specified working directory rather than the current working directory.  <a href="#ac3509afcaa0347a9bcda5dd9421d8182">More...</a><br /></td></tr>
<tr class="separator:ac3509afcaa0347a9bcda5dd9421d8182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07a1388bc9548bbbb5196c86ab3e40"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a5a07a1388bc9548bbbb5196c86ab3e40">getAbsoluteDirectoryPathnameUsingSpecifiedWorkingDirectory</a> (const std::string &amp;swd, const std::string &amp;dirPathname)</td></tr>
<tr class="memdesc:a5a07a1388bc9548bbbb5196c86ab3e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classSimTK_1_1Pathname.html#a4f06e70b3fd45d32957eaf19daaab2a3" title="This is the same as getAbsolutePathname() except that the final segment is interpreted as a directory...">getAbsoluteDirectoryPathname()</a> but using a specified working directory rather than the current working directory.  <a href="#a5a07a1388bc9548bbbb5196c86ab3e40">More...</a><br /></td></tr>
<tr class="separator:a5a07a1388bc9548bbbb5196c86ab3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a59b63342127fe16d19256261b5f3d6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a9a59b63342127fe16d19256261b5f3d6">fileExists</a> (const std::string &amp;pathname)</td></tr>
<tr class="memdesc:a9a59b63342127fe16d19256261b5f3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given pathname names a file that exists and is readable.  <a href="#a9a59b63342127fe16d19256261b5f3d6">More...</a><br /></td></tr>
<tr class="separator:a9a59b63342127fe16d19256261b5f3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa576ebf3bc101d0d7bedabcc199ce6f1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#aa576ebf3bc101d0d7bedabcc199ce6f1">getDefaultInstallDir</a> ()</td></tr>
<tr class="memdesc:aa576ebf3bc101d0d7bedabcc199ce6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default installation directory for this platform.  <a href="#aa576ebf3bc101d0d7bedabcc199ce6f1">More...</a><br /></td></tr>
<tr class="separator:aa576ebf3bc101d0d7bedabcc199ce6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084a59219d24b31b1fbac6f2106a7d92"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a084a59219d24b31b1fbac6f2106a7d92">addDirectoryOffset</a> (const std::string &amp;base, const std::string &amp;offset)</td></tr>
<tr class="memdesc:a084a59219d24b31b1fbac6f2106a7d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a subdirectory offset to an existing pathname (relative or absolute).  <a href="#a084a59219d24b31b1fbac6f2106a7d92">More...</a><br /></td></tr>
<tr class="separator:a084a59219d24b31b1fbac6f2106a7d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ebcfbaed51911bcfe8450c3888ff1e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#ab5ebcfbaed51911bcfe8450c3888ff1e">getInstallDir</a> (const std::string &amp;envInstallDir, const std::string &amp;offsetFromDefaultInstallDir)</td></tr>
<tr class="memdesc:ab5ebcfbaed51911bcfe8450c3888ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the installation directory for something, using the named installation directory environment variable if it exists, otherwise by appending the supplied path offset to the default install directory.  <a href="#ab5ebcfbaed51911bcfe8450c3888ff1e">More...</a><br /></td></tr>
<tr class="separator:ab5ebcfbaed51911bcfe8450c3888ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d9d72e3285d6706da043e27f0360a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a8e1d9d72e3285d6706da043e27f0360a">getThisExecutablePath</a> ()</td></tr>
<tr class="memdesc:a8e1d9d72e3285d6706da043e27f0360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute pathname of the currently executing program.  <a href="#a8e1d9d72e3285d6706da043e27f0360a">More...</a><br /></td></tr>
<tr class="separator:a8e1d9d72e3285d6706da043e27f0360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef0da67c8b68b26d235bd113488898e"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a6ef0da67c8b68b26d235bd113488898e">getThisExecutableDirectory</a> ()</td></tr>
<tr class="memdesc:a6ef0da67c8b68b26d235bd113488898e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute pathname of the directory which contains the currently executing program.  <a href="#a6ef0da67c8b68b26d235bd113488898e">More...</a><br /></td></tr>
<tr class="separator:a6ef0da67c8b68b26d235bd113488898e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68f2642e778e83973686a8ce85289d1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#ac68f2642e778e83973686a8ce85289d1">getFunctionLibraryDirectory</a> (void *func, std::string &amp;absolutePathname)</td></tr>
<tr class="memdesc:ac68f2642e778e83973686a8ce85289d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute pathname of the directory which contains the library/binary from which func was loaded.  <a href="#ac68f2642e778e83973686a8ce85289d1">More...</a><br /></td></tr>
<tr class="separator:ac68f2642e778e83973686a8ce85289d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adff7e48ad8a092f96cf1da3af5edab"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a4adff7e48ad8a092f96cf1da3af5edab">getCurrentWorkingDirectory</a> (const std::string &amp;drive=&quot;&quot;)</td></tr>
<tr class="memdesc:a4adff7e48ad8a092f96cf1da3af5edab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute pathname of the current working directory including a trailing separator character.  <a href="#a4adff7e48ad8a092f96cf1da3af5edab">More...</a><br /></td></tr>
<tr class="separator:a4adff7e48ad8a092f96cf1da3af5edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb2c4007a69513f8dc736eb9e18231d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a4cb2c4007a69513f8dc736eb9e18231d">getRootDirectory</a> (const std::string &amp;drive=&quot;&quot;)</td></tr>
<tr class="memdesc:a4cb2c4007a69513f8dc736eb9e18231d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the canonicalized name of the root directory.  <a href="#a4cb2c4007a69513f8dc736eb9e18231d">More...</a><br /></td></tr>
<tr class="separator:a4cb2c4007a69513f8dc736eb9e18231d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cb824113fe3e52b30f76c0d0c9b6a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a775cb824113fe3e52b30f76c0d0c9b6a">getCurrentDriveLetter</a> ()</td></tr>
<tr class="memdesc:a775cb824113fe3e52b30f76c0d0c9b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Windows, return the current drive letter in lowercase, with no trailing ":"; on other platforms return an empty string.  <a href="#a775cb824113fe3e52b30f76c0d0c9b6a">More...</a><br /></td></tr>
<tr class="separator:a775cb824113fe3e52b30f76c0d0c9b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f5c064521e8ced8dae794cbc5267a9"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a13f5c064521e8ced8dae794cbc5267a9">getCurrentDrive</a> ()</td></tr>
<tr class="memdesc:a13f5c064521e8ced8dae794cbc5267a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">On Windows, return the current drive letter in lowercase, followed by ":"; on other platforms just return an empty string.  <a href="#a13f5c064521e8ced8dae794cbc5267a9">More...</a><br /></td></tr>
<tr class="separator:a13f5c064521e8ced8dae794cbc5267a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af908776e0f27f159bd504305e7db8c73"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#af908776e0f27f159bd504305e7db8c73">environmentVariableExists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af908776e0f27f159bd504305e7db8c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the named environment variable is present in the environment.  <a href="#af908776e0f27f159bd504305e7db8c73">More...</a><br /></td></tr>
<tr class="separator:af908776e0f27f159bd504305e7db8c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee5811cebab0f5c168145d836a12dae"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a6ee5811cebab0f5c168145d836a12dae">getEnvironmentVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6ee5811cebab0f5c168145d836a12dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the named environment variable or the empty string if the variable is not found.  <a href="#a6ee5811cebab0f5c168145d836a12dae">More...</a><br /></td></tr>
<tr class="separator:a6ee5811cebab0f5c168145d836a12dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936d17128aea528e7b3896aba10d672f"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a936d17128aea528e7b3896aba10d672f">getPathSeparator</a> ()</td></tr>
<tr class="memdesc:a936d17128aea528e7b3896aba10d672f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this platform's pathname separator character as a string.  <a href="#a936d17128aea528e7b3896aba10d672f">More...</a><br /></td></tr>
<tr class="separator:a936d17128aea528e7b3896aba10d672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1baaca539bcbec5a61275ec41bbb8d0"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#ae1baaca539bcbec5a61275ec41bbb8d0">getPathSeparatorChar</a> ()</td></tr>
<tr class="memdesc:ae1baaca539bcbec5a61275ec41bbb8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this platform's pathname separator character as a char.  <a href="#ae1baaca539bcbec5a61275ec41bbb8d0">More...</a><br /></td></tr>
<tr class="separator:ae1baaca539bcbec5a61275ec41bbb8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f41f0fd8819ab985a695a28b346d74"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Pathname.html#a89f41f0fd8819ab985a695a28b346d74">isPathSeparator</a> (char c)</td></tr>
<tr class="memdesc:a89f41f0fd8819ab985a695a28b346d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the character is slash or backslash.  <a href="#a89f41f0fd8819ab985a695a28b346d74">More...</a><br /></td></tr>
<tr class="separator:a89f41f0fd8819ab985a695a28b346d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class encapsulates the handling of file and directory pathnames in a platform-independent manner. </p>
<p>We consider a pathname to consist of three components: </p><pre> [directory] [filename [extension]] </pre><p> where the directory may be an absolute location or relative to a current working directory or specified working directory.</p>
<p>Several special directory names are supported here:</p><ul>
<li>root (/)</li>
<li>current working directory (.)</li>
<li>current executable directory (@)</li>
<li>platform default installation directory</li>
<li>parent directory (..)</li>
</ul>
<p>On Windows root and current working directory are drive-specific, referring to the current drive if none is specified. The current executable directory is the absolute directory name containing the executable program which is currently running.</p>
<p>A pathname has "segments" which are separated by either forward slashes or backslashes. We are relaxed about the slashes and will accept either one and pathnames which use both. However, each operating system platform has a preferred separator character, backslash on Windows and forward slash everywhere else and we will clean up returned pathnames to use exclusively the preferred separator for the current platform.</p>
<p>Pathnames that end in an empty segment, or a segment consisting of just "." or ".." are directory path names, meaning that the "filename" and "extension" components are empty. Other pathnames may be directories or filenames depending on context. Whenever we generate a pathname that we know to be a directory, it will end in a final slash.</p>
<p>There is also the concept of a "drive" which on Windows is a drive letter followed by a colon (e.g. "c:") but is always the empty string on non-Windows platforms. The drive, if present is considered part of the directory and does not affect whether the directory is considered relative or absolute. Drive designators are recognized only on Windows; they are just considered ordinary pathname characters on other platforms.</p>
<p>This class is useful for generating "canonicalized" pathnames from names that have been pieced together from environment variables and user entry. Canonicalized names are always absolute pathnames; they contain no empty, ".", or ".." segments. On Windows a canonicalized name is always prefixed by an explicit disk designator followed by a backslash; on other platforms the canonicalized name will always begin with a forward slash.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e51e8b3e6491bcc5494c5868a27b235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e51e8b3e6491bcc5494c5868a27b235">&#9670;&nbsp;</a></span>deconstructPathname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::Pathname::deconstructPathname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dontApplySearchPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dismantle a supplied pathname into its component parts. </p>
<p>This can take pathnames like </p><pre>   
    /usr/local/libMyDll_d.so
    e:\Program Files\Something\myLibrary_d.dll
</pre><p> and chop them into </p><pre>
directory                       fileName       extension
------------------------------- -------------- ---------
/usr/local/                     libMyDll_d     .so 
e:\Program Files\Something\     myLibrary_d    .dll
</pre><p> as well as tell you whether the given pathname is absolute or relative (and thus subject to search rules). At the beginning of the pathname (or right after the drive specification on Windows) we recognize three special symbols:</p><ul>
<li>"/" means root; i.e., this is an absolute path name starting from the root directory (this drive's root for Windows).</li>
<li>"." starts an absolute path name which is relative to the current working directory (or drive's cwd on Windows).</li>
<li>"@" starts an absolute path name which is relative to the directory in which the currently running executable is located.</li>
</ul>
<p>Anywhere in the pathname, the name ".." means "go up one level from
the prior directory". ".." at the start is interpreted as "./..". A '.' appearing anywhere in the path name except the beginning is ignored. An '@' appearing anywhere in the pathname other than the beginning is treated as an ordinary file character.</p>
<p>The pathname components are returned as separate strings with separators included such that concatenating all the strings reproduces the pathname in a canonicalized form. The "drive" letter prefix is recognized only when running on Windows; otherwise a prefix like "C:" is treated as ordinary file name characters. Note that we include the drive letter as part of the absolute directory. White space is removed, and path separator characters in the directory are changed to the appropriate slash for the currently running platform (i.e. backslash for Windows and forward slash everywhere else). </p>

</div>
</div>
<a id="aa589f84feef8859e37fd6c397540e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa589f84feef8859e37fd6c397540e49f">&#9670;&nbsp;</a></span>deconstructPathnameUsingSpecifiedWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::Pathname::deconstructPathnameUsingSpecifiedWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>swd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An extension of <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a>. </p>
<p>Given a specified working directory (swd) and path, this function evaluates the absolute path of a given path relative to the swd and returns the directory, fileName, and extension of the canonicalized path with respect to a swd, if needed. This means, for the path, that instead of evaluating "." as the current working directory (cwd), the swd is used. Unlike <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a>, this function will always return an absolute path, and no bool dontApplySearchPath is returned. Rules:</p><ul>
<li>If path is empty, directory, fileName and extension will be returned empty. This case probably should just use getCurrentworkingDirectory().</li>
<li>If the swd is empty (after removing whitespace), <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a> is called, and cwd is prepended if needed to make it an absolute path.</li>
<li>Otherwise, we evaluate path relative to the swd. These steps are as follows:<ol type="1">
<li>If path is an absolute path name (and on Windows this includes a drive) (e.g. /usr/file.ext or c:/documents/file.ext), then swd is ignored, and the absolute path is returned.</li>
<li>Preprocess the swd. This means that if the swd is of any form that denotes an absolute path (i.e. "C:/file.ext", "C:file.ext", "./file.ext", "/file.ext") we change the swd to reflect the absolute path (e.g. "./file.ext" may change to "/cwd/file.ext" or "C:/cwdOnC/file.ext").</li>
<li>Otherwise, if a path is given relative to a directory that is not the root (e.g. "./dir/file.ext" or "dir/file.ext"), then the swd is prepended to path.</li>
<li>To resolve drive ambiguities, if swd provides a drive, it is used. If not, then the path drive is used. If neither provides a drive, then the current drive is used. </li>
</ol>
</li>
</ul>

</div>
</div>
<a id="a35635d66ec2b42671d27a914b0a9be21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35635d66ec2b42671d27a914b0a9be21">&#9670;&nbsp;</a></span>deconstructAbsolutePathname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::Pathname::deconstructAbsolutePathname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give back the deconstructed canonicalized absolute pathname for a given path. </p>
<p>If the path is not an absolute path, it will be made into an absolute path first following the rules of <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a> (which it uses). </p>

</div>
</div>
<a id="a845b3c5f154c28cfa54293a2bf648a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845b3c5f154c28cfa54293a2bf648a72">&#9670;&nbsp;</a></span>getAbsolutePathname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getAbsolutePathname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get canonicalized absolute pathname from a given pathname which can be relative or absolute. </p>
<p>Canonicalizing means</p><ul>
<li>drive designator is recognized if we're on Windows;</li>
<li>leading "." and "@" are replaced with the current working directory or the executable directory, resp.</li>
<li>each ".." segment is processed, removing it and its previous segment; initial ".." is treated as "./..".</li>
<li>empty segments and interior "." segments are removed</li>
<li>if the input pathname ends in a slash after above processing, then the returned pathname will also end in a slash.</li>
<li>separators are made all-forward slash or all-backslash</li>
<li>on Windows, the returned pathname begins with an explicit disk designator in lower case, e.g. "c:".</li>
</ul>
<p>The result here is what you get by reassembling the components from <a class="el" href="classSimTK_1_1Pathname.html#a0e51e8b3e6491bcc5494c5868a27b235" title="Dismantle a supplied pathname into its component parts. ">deconstructPathname()</a>, plus inserting the current working directory in front if the path name was relative. </p>

</div>
</div>
<a id="a4f06e70b3fd45d32957eaf19daaab2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f06e70b3fd45d32957eaf19daaab2a3">&#9670;&nbsp;</a></span>getAbsoluteDirectoryPathname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getAbsoluteDirectoryPathname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirPathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the same as <a class="el" href="classSimTK_1_1Pathname.html#a845b3c5f154c28cfa54293a2bf648a72" title="Get canonicalized absolute pathname from a given pathname which can be relative or absolute...">getAbsolutePathname()</a> except that the final segment is interpreted as a directory name rather than a file name, meaning that we append a slash if necessary. </p>

</div>
</div>
<a id="ac3509afcaa0347a9bcda5dd9421d8182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3509afcaa0347a9bcda5dd9421d8182">&#9670;&nbsp;</a></span>getAbsolutePathnameUsingSpecifiedWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getAbsolutePathnameUsingSpecifiedWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>swd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Pathname.html#a845b3c5f154c28cfa54293a2bf648a72" title="Get canonicalized absolute pathname from a given pathname which can be relative or absolute...">getAbsolutePathname()</a> but using a specified working directory rather than the current working directory. </p>
<p>See <a class="el" href="classSimTK_1_1Pathname.html#aa589f84feef8859e37fd6c397540e49f" title="An extension of deconstructPathname(). ">deconstructPathnameUsingSpecifiedWorkingDirectory()</a> for subtleties. </p>

</div>
</div>
<a id="a5a07a1388bc9548bbbb5196c86ab3e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a07a1388bc9548bbbb5196c86ab3e40">&#9670;&nbsp;</a></span>getAbsoluteDirectoryPathnameUsingSpecifiedWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getAbsoluteDirectoryPathnameUsingSpecifiedWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>swd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirPathname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classSimTK_1_1Pathname.html#a4f06e70b3fd45d32957eaf19daaab2a3" title="This is the same as getAbsolutePathname() except that the final segment is interpreted as a directory...">getAbsoluteDirectoryPathname()</a> but using a specified working directory rather than the current working directory. </p>
<p>See <a class="el" href="classSimTK_1_1Pathname.html#aa589f84feef8859e37fd6c397540e49f" title="An extension of deconstructPathname(). ">deconstructPathnameUsingSpecifiedWorkingDirectory()</a> for subtleties. </p>

</div>
</div>
<a id="a9a59b63342127fe16d19256261b5f3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a59b63342127fe16d19256261b5f3d6">&#9670;&nbsp;</a></span>fileExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Pathname::fileExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given pathname names a file that exists and is readable. </p>

</div>
</div>
<a id="aa576ebf3bc101d0d7bedabcc199ce6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa576ebf3bc101d0d7bedabcc199ce6f1">&#9670;&nbsp;</a></span>getDefaultInstallDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getDefaultInstallDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default installation directory for this platform. </p>
<p>This will be /usr/local/ for Linux and Apple, and the value of the %ProgramFiles% registry entry on Windows (typically c:\Program Files\). </p>

</div>
</div>
<a id="a084a59219d24b31b1fbac6f2106a7d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084a59219d24b31b1fbac6f2106a7d92">&#9670;&nbsp;</a></span>addDirectoryOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::addDirectoryOffset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a subdirectory offset to an existing pathname (relative or absolute). </p>
<p>A single slash will be inserted in between, ignoring any slash at the end of <code>base</code> or start of <code>offset</code>, and the result will end with a slash. All slashes in the result will be the correct ones for the current platform. </p>

</div>
</div>
<a id="ab5ebcfbaed51911bcfe8450c3888ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ebcfbaed51911bcfe8450c3888ff1e">&#9670;&nbsp;</a></span>getInstallDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getInstallDir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>envInstallDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>offsetFromDefaultInstallDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the installation directory for something, using the named installation directory environment variable if it exists, otherwise by appending the supplied path offset to the default install directory. </p>

</div>
</div>
<a id="a8e1d9d72e3285d6706da043e27f0360a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1d9d72e3285d6706da043e27f0360a">&#9670;&nbsp;</a></span>getThisExecutablePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getThisExecutablePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute pathname of the currently executing program. </p>

</div>
</div>
<a id="a6ef0da67c8b68b26d235bd113488898e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef0da67c8b68b26d235bd113488898e">&#9670;&nbsp;</a></span>getThisExecutableDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getThisExecutableDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute pathname of the directory which contains the currently executing program. </p>

</div>
</div>
<a id="ac68f2642e778e83973686a8ce85289d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68f2642e778e83973686a8ce85289d1">&#9670;&nbsp;</a></span>getFunctionLibraryDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Pathname::getFunctionLibraryDirectory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>absolutePathname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute pathname of the directory which contains the library/binary from which func was loaded. </p>
<p>It is expected that func is defined in a dynamically-linked library; if func was statically linked into another binary, then this may provide the directory containing that binary. The function returns true if the pathname was successfully found, and false otherwise. This operation is not available on Windows. Here's an example of getting the directory containing the SimTKcommon library: </p><div class="fragment"><div class="line">std::string libDir;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classSimTK_1_1Pathname.html#ac68f2642e778e83973686a8ce85289d1">Pathname::getFunctionLibraryDirectory</a>(</div><div class="line">                (<span class="keywordtype">void</span>*)<a class="code" href="classSimTK_1_1Pathname.html#a936d17128aea528e7b3896aba10d672f">Pathname::getPathSeparator</a>, libraryDir)) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SimTKcommon is located in &quot;</span> &lt;&lt; libDir &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a4adff7e48ad8a092f96cf1da3af5edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adff7e48ad8a092f96cf1da3af5edab">&#9670;&nbsp;</a></span>getCurrentWorkingDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getCurrentWorkingDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drive</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute pathname of the current working directory including a trailing separator character. </p>
<p>Windows keeps a current working directory for each drive which can be optionally specified (otherwise we use the current drive). If the specified drive doesn't exist we'll behave as though root were its current working directory. The drive argument is ignored on non-Windows platforms. </p>

</div>
</div>
<a id="a4cb2c4007a69513f8dc736eb9e18231d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb2c4007a69513f8dc736eb9e18231d">&#9670;&nbsp;</a></span>getRootDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getRootDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drive</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the canonicalized name of the root directory. </p>
<p>This is "x:\" on Windows with "x" replaced by the current drive letter or the specified drive (in lowercase), and just "/" on non-Windows systems. </p>

</div>
</div>
<a id="a775cb824113fe3e52b30f76c0d0c9b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775cb824113fe3e52b30f76c0d0c9b6a">&#9670;&nbsp;</a></span>getCurrentDriveLetter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getCurrentDriveLetter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On Windows, return the current drive letter in lowercase, with no trailing ":"; on other platforms return an empty string. </p>

</div>
</div>
<a id="a13f5c064521e8ced8dae794cbc5267a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f5c064521e8ced8dae794cbc5267a9">&#9670;&nbsp;</a></span>getCurrentDrive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getCurrentDrive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On Windows, return the current drive letter in lowercase, followed by ":"; on other platforms just return an empty string. </p>

</div>
</div>
<a id="af908776e0f27f159bd504305e7db8c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af908776e0f27f159bd504305e7db8c73">&#9670;&nbsp;</a></span>environmentVariableExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Pathname::environmentVariableExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the named environment variable is present in the environment. </p>

</div>
</div>
<a id="a6ee5811cebab0f5c168145d836a12dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee5811cebab0f5c168145d836a12dae">&#9670;&nbsp;</a></span>getEnvironmentVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getEnvironmentVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the named environment variable or the empty string if the variable is not found. </p>
<p>Note that that is indistinguishable from a variable that is present but with a null value &ndash; use <a class="el" href="classSimTK_1_1Pathname.html#af908776e0f27f159bd504305e7db8c73" title="Return true if the named environment variable is present in the environment. ">environmentVariableExists()</a> if you really need to know the difference. </p>

</div>
</div>
<a id="a936d17128aea528e7b3896aba10d672f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936d17128aea528e7b3896aba10d672f">&#9670;&nbsp;</a></span>getPathSeparator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimTK::Pathname::getPathSeparator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this platform's pathname separator character as a string. </p>
<p>This is backslash on Windows and forward slash everywhere else. </p>

</div>
</div>
<a id="ae1baaca539bcbec5a61275ec41bbb8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1baaca539bcbec5a61275ec41bbb8d0">&#9670;&nbsp;</a></span>getPathSeparatorChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char SimTK::Pathname::getPathSeparatorChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this platform's pathname separator character as a char. </p>
<p>This is backslash on Windows and forward slash everywhere else. </p>

</div>
</div>
<a id="a89f41f0fd8819ab985a695a28b346d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f41f0fd8819ab985a695a28b346d74">&#9670;&nbsp;</a></span>isPathSeparator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Pathname::isPathSeparator </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the character is slash or backslash. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Pathname_8h_source.html">Pathname.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Pathname.html">Pathname</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:17 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
