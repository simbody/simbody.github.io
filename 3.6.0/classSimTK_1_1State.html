<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1State.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSimTK_1_1State-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::State Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This object is intended to contain all state information for a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">SimTK::System</a>, except topological information which is stored in the System itself.  
 <a href="classSimTK_1_1State.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a718a90ef538a16cfd6a5fd4f89f3857f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a718a90ef538a16cfd6a5fd4f89f3857f">State</a> ()</td></tr>
<tr class="memdesc:a718a90ef538a16cfd6a5fd4f89f3857f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>; this allocates an implementation object on the heap.  <a href="#a718a90ef538a16cfd6a5fd4f89f3857f">More...</a><br /></td></tr>
<tr class="separator:a718a90ef538a16cfd6a5fd4f89f3857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb872fdefc6d344720d197e129e6712a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#acb872fdefc6d344720d197e129e6712a">State</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;)</td></tr>
<tr class="memdesc:acb872fdefc6d344720d197e129e6712a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor has deep copy semantics; that is, this creates a new <em>copy</em> of the source object, <em>not</em> a reference to the original object.  <a href="#acb872fdefc6d344720d197e129e6712a">More...</a><br /></td></tr>
<tr class="separator:acb872fdefc6d344720d197e129e6712a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2061481eae28255481ef6aba4402a49c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2061481eae28255481ef6aba4402a49c">State</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:a2061481eae28255481ef6aba4402a49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The move constructor is very fast. The source object is left empty.  <a href="#a2061481eae28255481ef6aba4402a49c">More...</a><br /></td></tr>
<tr class="separator:a2061481eae28255481ef6aba4402a49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac829588930f550a7c5da85ab0e5e6e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ac829588930f550a7c5da85ab0e5e6e04">operator=</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;)</td></tr>
<tr class="memdesc:ac829588930f550a7c5da85ab0e5e6e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment has deep copy semantics; that is, <code>this</code> State will contain a <em>copy</em> of the source, <em>not</em> a reference into it.  <a href="#ac829588930f550a7c5da85ab0e5e6e04">More...</a><br /></td></tr>
<tr class="separator:ac829588930f550a7c5da85ab0e5e6e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947448ce0d2b0d811a18a27759d7a563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a947448ce0d2b0d811a18a27759d7a563">operator=</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:a947448ce0d2b0d811a18a27759d7a563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment is very fast.  <a href="#a947448ce0d2b0d811a18a27759d7a563">More...</a><br /></td></tr>
<tr class="separator:a947448ce0d2b0d811a18a27759d7a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18970cc5d1a4ae82595d1679009cc42b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a18970cc5d1a4ae82595d1679009cc42b">~State</a> ()</td></tr>
<tr class="memdesc:a18970cc5d1a4ae82595d1679009cc42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct this State object and free up the heap space it is using.  <a href="#a18970cc5d1a4ae82595d1679009cc42b">More...</a><br /></td></tr>
<tr class="separator:a18970cc5d1a4ae82595d1679009cc42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa724ccf9b959542f1c617563905cd07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#afa724ccf9b959542f1c617563905cd07">clear</a> ()</td></tr>
<tr class="memdesc:afa724ccf9b959542f1c617563905cd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> to default-constructed condition.  <a href="#afa724ccf9b959542f1c617563905cd07">More...</a><br /></td></tr>
<tr class="separator:afa724ccf9b959542f1c617563905cd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417494916f15aed4de6e84f3f97b6c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a417494916f15aed4de6e84f3f97b6c4b">isConsistent</a> (const <a class="el" href="classSimTK_1_1State.html">SimTK::State</a> &amp;otherState) const</td></tr>
<tr class="memdesc:a417494916f15aed4de6e84f3f97b6c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given state has the same number of state variables, constraints, etc as this state.  <a href="#a417494916f15aed4de6e84f3f97b6c4b">More...</a><br /></td></tr>
<tr class="separator:a417494916f15aed4de6e84f3f97b6c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa67d2a9a76764b295fc97493023f26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5aa67d2a9a76764b295fc97493023f26">setNumSubsystems</a> (int i)</td></tr>
<tr class="memdesc:a5aa67d2a9a76764b295fc97493023f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of subsystems in this state.  <a href="#a5aa67d2a9a76764b295fc97493023f26">More...</a><br /></td></tr>
<tr class="separator:a5aa67d2a9a76764b295fc97493023f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b9ddedb2298764f16c3559e8a4611a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae7b9ddedb2298764f16c3559e8a4611a">initializeSubsystem</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;version)</td></tr>
<tr class="memdesc:ae7b9ddedb2298764f16c3559e8a4611a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name and version for a given subsystem, which must already have a slot allocated.  <a href="#ae7b9ddedb2298764f16c3559e8a4611a">More...</a><br /></td></tr>
<tr class="separator:ae7b9ddedb2298764f16c3559e8a4611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94cdc6575bff73529cf048fbfdcf942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ab94cdc6575bff73529cf048fbfdcf942">addSubsystem</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;version)</td></tr>
<tr class="memdesc:ab94cdc6575bff73529cf048fbfdcf942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new subsystem as a client of this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#ab94cdc6575bff73529cf048fbfdcf942">More...</a><br /></td></tr>
<tr class="separator:ab94cdc6575bff73529cf048fbfdcf942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65457448eac39d61d01fba4b24a688bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a65457448eac39d61d01fba4b24a688bb">getNumSubsystems</a> () const</td></tr>
<tr class="memdesc:a65457448eac39d61d01fba4b24a688bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of Subsystems known to this State.  <a href="#a65457448eac39d61d01fba4b24a688bb">More...</a><br /></td></tr>
<tr class="separator:a65457448eac39d61d01fba4b24a688bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780aec1fd5e066ffb7904e1f06adf191"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a780aec1fd5e066ffb7904e1f06adf191">getSubsystemName</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a780aec1fd5e066ffb7904e1f06adf191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e68264437a265bfcc802316c4b0d8bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a4e68264437a265bfcc802316c4b0d8bf">getSubsystemVersion</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a4e68264437a265bfcc802316c4b0d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd27de669cf7d707084d3e7c2dec3d75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#abd27de669cf7d707084d3e7c2dec3d75">getSubsystemStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:abd27de669cf7d707084d3e7c2dec3d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d22280cc0c8e7d6aa5c22ac5803563d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a3d22280cc0c8e7d6aa5c22ac5803563d">getSystemStage</a> () const</td></tr>
<tr class="memdesc:a3d22280cc0c8e7d6aa5c22ac5803563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the <em>global</em> stage for this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a3d22280cc0c8e7d6aa5c22ac5803563d">More...</a><br /></td></tr>
<tr class="separator:a3d22280cc0c8e7d6aa5c22ac5803563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060484b97a44dddef791e2e101f0a407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a060484b97a44dddef791e2e101f0a407">invalidateAll</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>)</td></tr>
<tr class="memdesc:a060484b97a44dddef791e2e101f0a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any subsystem or the system stage is currently at or higher than the passed-in one, back up to the stage just prior; otherwise do nothing.  <a href="#a060484b97a44dddef791e2e101f0a407">More...</a><br /></td></tr>
<tr class="separator:a060484b97a44dddef791e2e101f0a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae67d741a8ce475c00807830db99a751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aae67d741a8ce475c00807830db99a751">invalidateAllCacheAtOrAbove</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="memdesc:aae67d741a8ce475c00807830db99a751"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any subsystem or the system stage is currently at or higher than the passed-in one, back up to the stage just prior; otherwise do nothing.  <a href="#aae67d741a8ce475c00807830db99a751">More...</a><br /></td></tr>
<tr class="separator:aae67d741a8ce475c00807830db99a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c94044ec3bdfdfe0a046031bcd5681f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a8c94044ec3bdfdfe0a046031bcd5681f">advanceSubsystemToStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="memdesc:a8c94044ec3bdfdfe0a046031bcd5681f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance a particular <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>'s current stage by one to the indicated stage.  <a href="#a8c94044ec3bdfdfe0a046031bcd5681f">More...</a><br /></td></tr>
<tr class="separator:a8c94044ec3bdfdfe0a046031bcd5681f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90042787b00c2dbdb91e9b7a647bf19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a90042787b00c2dbdb91e9b7a647bf19d">advanceSystemToStage</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="memdesc:a90042787b00c2dbdb91e9b7a647bf19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the System-level current stage by one to the indicated stage.  <a href="#a90042787b00c2dbdb91e9b7a647bf19d">More...</a><br /></td></tr>
<tr class="separator:a90042787b00c2dbdb91e9b7a647bf19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89309dc29d22e97c3b41a8d7cd93e6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a89309dc29d22e97c3b41a8d7cd93e6a2">getSystemTopologyStageVersion</a> () const</td></tr>
<tr class="memdesc:a89309dc29d22e97c3b41a8d7cd93e6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Topology stage version number (an integer) stored in this State must match the topology cache version number stored in the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> for which it is allegedly a state.  <a href="#a89309dc29d22e97c3b41a8d7cd93e6a2">More...</a><br /></td></tr>
<tr class="separator:a89309dc29d22e97c3b41a8d7cd93e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae937631188e36fe6505dfcef5ca4f5f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae937631188e36fe6505dfcef5ca4f5f0">getEventTriggers</a> () const</td></tr>
<tr class="separator:ae937631188e36fe6505dfcef5ca4f5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0bf1624c0e1800b0dea50b2abaa242"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#adb0bf1624c0e1800b0dea50b2abaa242">getEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:adb0bf1624c0e1800b0dea50b2abaa242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c00117bfeac202b5b2781efa776a34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a58c00117bfeac202b5b2781efa776a34">getEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:a58c00117bfeac202b5b2781efa776a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6510b31a9638122ab7ca191ad653690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad6510b31a9638122ab7ca191ad653690">updEventTriggers</a> () const</td></tr>
<tr class="separator:ad6510b31a9638122ab7ca191ad653690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e8c46979e5eaa4a77d674b0ff0d41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a87e8c46979e5eaa4a77d674b0ff0d41f">updEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:a87e8c46979e5eaa4a77d674b0ff0d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbef800d9be58c9197f0c619ceafb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#adcbef800d9be58c9197f0c619ceafb73">updEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:adcbef800d9be58c9197f0c619ceafb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfef05086f246eb3a2840f1a9ad9666d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#abfef05086f246eb3a2840f1a9ad9666d">getQ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="memdesc:abfef05086f246eb3a2840f1a9ad9666d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-subsystem access to the global shared variables.  <a href="#abfef05086f246eb3a2840f1a9ad9666d">More...</a><br /></td></tr>
<tr class="separator:abfef05086f246eb3a2840f1a9ad9666d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a537330cd84cd9fb83033547cd5a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a103a537330cd84cd9fb83033547cd5a6">getU</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a103a537330cd84cd9fb83033547cd5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1671ec5a3d645fedf0fa7d70b266f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#afd1671ec5a3d645fedf0fa7d70b266f1">getZ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:afd1671ec5a3d645fedf0fa7d70b266f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e67e37ea549d4ce56f447ca4bc3ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a931e67e37ea549d4ce56f447ca4bc3ac">getUWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a931e67e37ea549d4ce56f447ca4bc3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825d9ddb16458cfb67fae997921e303f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a825d9ddb16458cfb67fae997921e303f">getZWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a825d9ddb16458cfb67fae997921e303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998c661cf0cfae47dbe7ce5a1e2e846a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a998c661cf0cfae47dbe7ce5a1e2e846a">updQ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a998c661cf0cfae47dbe7ce5a1e2e846a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4faebca10be06bd35e9e055d41d59a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5d4faebca10be06bd35e9e055d41d59a">updU</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a5d4faebca10be06bd35e9e055d41d59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c31219b0a00ca8712ee087a9d7b486b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1c31219b0a00ca8712ee087a9d7b486b">updZ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a1c31219b0a00ca8712ee087a9d7b486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d331d59007c1fa6bf3f09c24a434e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1d331d59007c1fa6bf3f09c24a434e75">updUWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a1d331d59007c1fa6bf3f09c24a434e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3074f727ff1dd233ed8037309c2be403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a3074f727ff1dd233ed8037309c2be403">updZWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a3074f727ff1dd233ed8037309c2be403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06f2c0ac05bcbd0a53af0df3fe9800a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ab06f2c0ac05bcbd0a53af0df3fe9800a">getQDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="memdesc:ab06f2c0ac05bcbd0a53af0df3fe9800a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-subsystem access to the shared cache entries.  <a href="#ab06f2c0ac05bcbd0a53af0df3fe9800a">More...</a><br /></td></tr>
<tr class="separator:ab06f2c0ac05bcbd0a53af0df3fe9800a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142555537cd80867a44904bc6643c2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa142555537cd80867a44904bc6643c2f">getUDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aa142555537cd80867a44904bc6643c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069c9630afec2b6f3158d11eeaf0b8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9069c9630afec2b6f3158d11eeaf0b8a">getZDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a9069c9630afec2b6f3158d11eeaf0b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11882eb9704c213460aacaa3925b3535"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a11882eb9704c213460aacaa3925b3535">getQDotDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a11882eb9704c213460aacaa3925b3535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a124682670310f9752c453f1550530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a99a124682670310f9752c453f1550530">updQDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a99a124682670310f9752c453f1550530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9a71b86968194532bdf73b8446280d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aed9a71b86968194532bdf73b8446280d">updUDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aed9a71b86968194532bdf73b8446280d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417820c596075754d70b4387a2e30da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a417820c596075754d70b4387a2e30da3">updZDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a417820c596075754d70b4387a2e30da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b4e19cb9f44b53ba8e8c9176e5deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9c1b4e19cb9f44b53ba8e8c9176e5deb">updQDotDot</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a9c1b4e19cb9f44b53ba8e8c9176e5deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25df40622475e26ff7ebae2d788db67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad25df40622475e26ff7ebae2d788db67">getQErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:ad25df40622475e26ff7ebae2d788db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540fac0201b34b2259a63388c8cece02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a540fac0201b34b2259a63388c8cece02">getUErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a540fac0201b34b2259a63388c8cece02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7242f06c6bf37d2cccad2807ddab2a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ac7242f06c6bf37d2cccad2807ddab2a1">getUDotErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:ac7242f06c6bf37d2cccad2807ddab2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa439d92d79754e2ba31b2fda0736868d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa439d92d79754e2ba31b2fda0736868d">getMultipliers</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aa439d92d79754e2ba31b2fda0736868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1434a637071931e65010ccf515891f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aec1434a637071931e65010ccf515891f">getQErrWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aec1434a637071931e65010ccf515891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b8527b6865870c34839cde41adc557"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a65b8527b6865870c34839cde41adc557">getUErrWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a65b8527b6865870c34839cde41adc557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbe52f140d204adbcc69aa72c2adad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aefbe52f140d204adbcc69aa72c2adad9">updQErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aefbe52f140d204adbcc69aa72c2adad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f13e2cddf532c946e1943eda13aea8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a7f13e2cddf532c946e1943eda13aea8b">updUErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a7f13e2cddf532c946e1943eda13aea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f1f023369a3eb10b9fd03a42e2c146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a07f1f023369a3eb10b9fd03a42e2c146">updUDotErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a07f1f023369a3eb10b9fd03a42e2c146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a912b355d8d5d0450b7b263ad33e765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2a912b355d8d5d0450b7b263ad33e765">updMultipliers</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a2a912b355d8d5d0450b7b263ad33e765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0d8452c50d9f472aea76f4054697de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#abc0d8452c50d9f472aea76f4054697de">updQErrWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:abc0d8452c50d9f472aea76f4054697de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dcf460b49fc2ee3087581817a021b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a78dcf460b49fc2ee3087581817a021b3">updUErrWeights</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>)</td></tr>
<tr class="separator:a78dcf460b49fc2ee3087581817a021b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c6a82b454c04ed89dfb3d48e3aad89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a47c6a82b454c04ed89dfb3d48e3aad89">getTime</a> () const</td></tr>
<tr class="memdesc:a47c6a82b454c04ed89dfb3d48e3aad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can call these as long as <em>system</em> stage &gt;= Model.  <a href="#a47c6a82b454c04ed89dfb3d48e3aad89">More...</a><br /></td></tr>
<tr class="separator:a47c6a82b454c04ed89dfb3d48e3aad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbdb5a64fdca6881a783917be081f7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5fbdb5a64fdca6881a783917be081f7c">getY</a> () const</td></tr>
<tr class="separator:a5fbdb5a64fdca6881a783917be081f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af738e098a8785a581bab83977335ecf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#af738e098a8785a581bab83977335ecf0">getQ</a> () const</td></tr>
<tr class="memdesc:af738e098a8785a581bab83977335ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are just views into Y.  <a href="#af738e098a8785a581bab83977335ecf0">More...</a><br /></td></tr>
<tr class="separator:af738e098a8785a581bab83977335ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6181af8fa9d255ff427812630ac56929"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a6181af8fa9d255ff427812630ac56929">getU</a> () const</td></tr>
<tr class="separator:a6181af8fa9d255ff427812630ac56929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e08f5ebcb3568e5a328f8326504ea5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a91e08f5ebcb3568e5a328f8326504ea5">getZ</a> () const</td></tr>
<tr class="separator:a91e08f5ebcb3568e5a328f8326504ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9e2dc6b441261d4e0a42c8fffd8212"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#abe9e2dc6b441261d4e0a42c8fffd8212">getUWeights</a> () const</td></tr>
<tr class="memdesc:abe9e2dc6b441261d4e0a42c8fffd8212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unit weighting (1/unit change) for each u that can be used to weight a vector du so that the disparate elements are comparable in physical effect.  <a href="#abe9e2dc6b441261d4e0a42c8fffd8212">More...</a><br /></td></tr>
<tr class="separator:abe9e2dc6b441261d4e0a42c8fffd8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab160c534ea60aa1392c86da43be2958a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ab160c534ea60aa1392c86da43be2958a">getZWeights</a> () const</td></tr>
<tr class="memdesc:ab160c534ea60aa1392c86da43be2958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unit weighting (1/unit change) for each z that can be used to weight a vector dz so that the disparate elements are comparable in physical effect.  <a href="#ab160c534ea60aa1392c86da43be2958a">More...</a><br /></td></tr>
<tr class="separator:ab160c534ea60aa1392c86da43be2958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b4a718e984085983c9edc6507b3274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa2b4a718e984085983c9edc6507b3274">updUWeights</a> ()</td></tr>
<tr class="memdesc:aa2b4a718e984085983c9edc6507b3274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set u weights (and q weights indirectly).  <a href="#aa2b4a718e984085983c9edc6507b3274">More...</a><br /></td></tr>
<tr class="separator:aa2b4a718e984085983c9edc6507b3274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45c5bc8d846bf15ab20c8f239843383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad45c5bc8d846bf15ab20c8f239843383">updZWeights</a> ()</td></tr>
<tr class="memdesc:ad45c5bc8d846bf15ab20c8f239843383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set z weights.  <a href="#ad45c5bc8d846bf15ab20c8f239843383">More...</a><br /></td></tr>
<tr class="separator:ad45c5bc8d846bf15ab20c8f239843383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383c266a4f58c5ae6fe12e6fa60f5c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad383c266a4f58c5ae6fe12e6fa60f5c9">updTime</a> ()</td></tr>
<tr class="memdesc:ad383c266a4f58c5ae6fe12e6fa60f5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can call these as long as <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> stage &gt;= Model, but the stage will be backed up if necessary to the indicated stage.  <a href="#ad383c266a4f58c5ae6fe12e6fa60f5c9">More...</a><br /></td></tr>
<tr class="separator:ad383c266a4f58c5ae6fe12e6fa60f5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f395b315b5e7c9e45c3049ef5e79dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae3f395b315b5e7c9e45c3049ef5e79dd">updY</a> ()</td></tr>
<tr class="separator:ae3f395b315b5e7c9e45c3049ef5e79dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc4d78f371896753ece80fe92eb8eaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aecc4d78f371896753ece80fe92eb8eaf">setTime</a> (<a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> t)</td></tr>
<tr class="memdesc:aecc4d78f371896753ece80fe92eb8eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternate syntax equivalent to <a class="el" href="classSimTK_1_1State.html#ad383c266a4f58c5ae6fe12e6fa60f5c9" title="You can call these as long as System stage &gt;= Model, but the stage will be backed up if necessary to ...">updTime()</a> and <a class="el" href="classSimTK_1_1State.html#ae3f395b315b5e7c9e45c3049ef5e79dd">updY()</a>.  <a href="#aecc4d78f371896753ece80fe92eb8eaf">More...</a><br /></td></tr>
<tr class="separator:aecc4d78f371896753ece80fe92eb8eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b6c852725c0c1cbc3632f3fb51a395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a12b6c852725c0c1cbc3632f3fb51a395">setY</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;y)</td></tr>
<tr class="separator:a12b6c852725c0c1cbc3632f3fb51a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fad986d5547dd10b1f5f7bad802d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a00fad986d5547dd10b1f5f7bad802d1e">updQ</a> ()</td></tr>
<tr class="memdesc:a00fad986d5547dd10b1f5f7bad802d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are just views into Y.  <a href="#a00fad986d5547dd10b1f5f7bad802d1e">More...</a><br /></td></tr>
<tr class="separator:a00fad986d5547dd10b1f5f7bad802d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d88df32c0564319245e2d0926d8083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a30d88df32c0564319245e2d0926d8083">updU</a> ()</td></tr>
<tr class="separator:a30d88df32c0564319245e2d0926d8083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec53ed9d99548566703a4b2185c2511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1ec53ed9d99548566703a4b2185c2511">updZ</a> ()</td></tr>
<tr class="separator:a1ec53ed9d99548566703a4b2185c2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9181b7d2f1cf17be5b75061e488a70bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9181b7d2f1cf17be5b75061e488a70bb">setQ</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;q)</td></tr>
<tr class="memdesc:a9181b7d2f1cf17be5b75061e488a70bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface.  <a href="#a9181b7d2f1cf17be5b75061e488a70bb">More...</a><br /></td></tr>
<tr class="separator:a9181b7d2f1cf17be5b75061e488a70bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fcba284ec2e81d7f2fac2b64e43086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a09fcba284ec2e81d7f2fac2b64e43086">setU</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u)</td></tr>
<tr class="separator:a09fcba284ec2e81d7f2fac2b64e43086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4166209fae1e16ca2b9191aec5d64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a4c4166209fae1e16ca2b9191aec5d64e">setZ</a> (const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;z)</td></tr>
<tr class="separator:a4c4166209fae1e16ca2b9191aec5d64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06de1c3eb81c8bcda79c70d8822ccb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a6f06de1c3eb81c8bcda79c70d8822ccb">getYDot</a> () const</td></tr>
<tr class="separator:a6f06de1c3eb81c8bcda79c70d8822ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff2d09293658d51a7fdb588d8467ebc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#afff2d09293658d51a7fdb588d8467ebc">getQDot</a> () const</td></tr>
<tr class="memdesc:afff2d09293658d51a7fdb588d8467ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are just views into YDot.  <a href="#afff2d09293658d51a7fdb588d8467ebc">More...</a><br /></td></tr>
<tr class="separator:afff2d09293658d51a7fdb588d8467ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dd0c01ec08a5c73dd9164cc8a91409"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a75dd0c01ec08a5c73dd9164cc8a91409">getZDot</a> () const</td></tr>
<tr class="separator:a75dd0c01ec08a5c73dd9164cc8a91409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe58c51b0d810cca6476d47c4ddbe0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2ebe58c51b0d810cca6476d47c4ddbe0">getUDot</a> () const</td></tr>
<tr class="separator:a2ebe58c51b0d810cca6476d47c4ddbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b27825ccfe6a4af92482aee95d22fe9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a3b27825ccfe6a4af92482aee95d22fe9">getQDotDot</a> () const</td></tr>
<tr class="memdesc:a3b27825ccfe6a4af92482aee95d22fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This has its own space, not a view.  <a href="#a3b27825ccfe6a4af92482aee95d22fe9">More...</a><br /></td></tr>
<tr class="separator:a3b27825ccfe6a4af92482aee95d22fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2427c0f3f41063fa3cf579d86b557fe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2427c0f3f41063fa3cf579d86b557fe6">updYDot</a> () const</td></tr>
<tr class="memdesc:a2427c0f3f41063fa3cf579d86b557fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are mutable.  <a href="#a2427c0f3f41063fa3cf579d86b557fe6">More...</a><br /></td></tr>
<tr class="separator:a2427c0f3f41063fa3cf579d86b557fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfd9805097678644a0adc46806569c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a4bfd9805097678644a0adc46806569c3">updQDot</a> () const</td></tr>
<tr class="separator:a4bfd9805097678644a0adc46806569c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad777c9e6ad94d5222d7555dfae12d43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad777c9e6ad94d5222d7555dfae12d43e">updZDot</a> () const</td></tr>
<tr class="separator:ad777c9e6ad94d5222d7555dfae12d43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e6d7e76ce6f8502a02fad5eb1e8054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a88e6d7e76ce6f8502a02fad5eb1e8054">updUDot</a> () const</td></tr>
<tr class="separator:a88e6d7e76ce6f8502a02fad5eb1e8054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9988f2775ec44885803f3d2f11040d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9988f2775ec44885803f3d2f11040d62">updQDotDot</a> () const</td></tr>
<tr class="memdesc:a9988f2775ec44885803f3d2f11040d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a separate shared cache entry, not part of YDot.  <a href="#a9988f2775ec44885803f3d2f11040d62">More...</a><br /></td></tr>
<tr class="separator:a9988f2775ec44885803f3d2f11040d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292fd97ca66638c68396a9e4095ae799"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a292fd97ca66638c68396a9e4095ae799">getYErr</a> () const</td></tr>
<tr class="memdesc:a292fd97ca66638c68396a9e4095ae799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current constraint errors for all constraints.  <a href="#a292fd97ca66638c68396a9e4095ae799">More...</a><br /></td></tr>
<tr class="separator:a292fd97ca66638c68396a9e4095ae799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb5e25020b36ca267d9bab478d36235"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aceb5e25020b36ca267d9bab478d36235">getQErr</a> () const</td></tr>
<tr class="memdesc:aceb5e25020b36ca267d9bab478d36235"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are just views into YErr.  <a href="#aceb5e25020b36ca267d9bab478d36235">More...</a><br /></td></tr>
<tr class="separator:aceb5e25020b36ca267d9bab478d36235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bfd0d24469fc3854c4ad4d42e9eeea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ac2bfd0d24469fc3854c4ad4d42e9eeea">getUErr</a> () const</td></tr>
<tr class="separator:ac2bfd0d24469fc3854c4ad4d42e9eeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e394c42ecbc470977478b3d110db0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a81e394c42ecbc470977478b3d110db0f">getUDotErr</a> () const</td></tr>
<tr class="memdesc:a81e394c42ecbc470977478b3d110db0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These have their own space, they are not views.  <a href="#a81e394c42ecbc470977478b3d110db0f">More...</a><br /></td></tr>
<tr class="separator:a81e394c42ecbc470977478b3d110db0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758422437d8e45ef8b9f5c2a24bdf599"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a758422437d8e45ef8b9f5c2a24bdf599">getMultipliers</a> () const</td></tr>
<tr class="separator:a758422437d8e45ef8b9f5c2a24bdf599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e01de3e48296f95edfa82edb2218a76"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a8e01de3e48296f95edfa82edb2218a76">getQErrWeights</a> () const</td></tr>
<tr class="memdesc:a8e01de3e48296f95edfa82edb2218a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit weighting (1/unit error) for each of the mp+mquat position inline constraints equations.  <a href="#a8e01de3e48296f95edfa82edb2218a76">More...</a><br /></td></tr>
<tr class="separator:a8e01de3e48296f95edfa82edb2218a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d3da654cced4f45e2cd74ff0f2a3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a6a5d3da654cced4f45e2cd74ff0f2a3f">getUErrWeights</a> () const</td></tr>
<tr class="memdesc:a6a5d3da654cced4f45e2cd74ff0f2a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unit weighting (1/unit error) for each of the mp+mv velocity-level inline constraint equations, meaning mp time derivatives of position (holonomic) inline constraint equations followed by mv velocity (nonholonomic) constraints.  <a href="#a6a5d3da654cced4f45e2cd74ff0f2a3f">More...</a><br /></td></tr>
<tr class="separator:a6a5d3da654cced4f45e2cd74ff0f2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3fbf1a3f55f0ace6a69ac74e5a968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aebb3fbf1a3f55f0ace6a69ac74e5a968">updQErrWeights</a> ()</td></tr>
<tr class="memdesc:aebb3fbf1a3f55f0ace6a69ac74e5a968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the unit weighting (1/unit error) for each of the mp+mquat position inline constraint equations.  <a href="#aebb3fbf1a3f55f0ace6a69ac74e5a968">More...</a><br /></td></tr>
<tr class="separator:aebb3fbf1a3f55f0ace6a69ac74e5a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8c6c59ee75df582d7fb398417f89e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a54e8c6c59ee75df582d7fb398417f89e">updUErrWeights</a> ()</td></tr>
<tr class="memdesc:a54e8c6c59ee75df582d7fb398417f89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the unit weighting (1/unit error) for each of the mp+mv velocity-level inline constraints.  <a href="#a54e8c6c59ee75df582d7fb398417f89e">More...</a><br /></td></tr>
<tr class="separator:a54e8c6c59ee75df582d7fb398417f89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63978bdd9b8f199b283051a0c022a138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a63978bdd9b8f199b283051a0c022a138">updYErr</a> () const</td></tr>
<tr class="memdesc:a63978bdd9b8f199b283051a0c022a138"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are mutable.  <a href="#a63978bdd9b8f199b283051a0c022a138">More...</a><br /></td></tr>
<tr class="separator:a63978bdd9b8f199b283051a0c022a138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7587709bd6d42bde62f6051ba5c37cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a7587709bd6d42bde62f6051ba5c37cf0">updQErr</a> () const</td></tr>
<tr class="separator:a7587709bd6d42bde62f6051ba5c37cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828fc2e7694015ef91dd6da3f16b516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9828fc2e7694015ef91dd6da3f16b516">updUErr</a> () const</td></tr>
<tr class="separator:a9828fc2e7694015ef91dd6da3f16b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4efc9ede89d222115f4c3a9885ea44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ade4efc9ede89d222115f4c3a9885ea44">updUDotErr</a> () const</td></tr>
<tr class="separator:ade4efc9ede89d222115f4c3a9885ea44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ead5a89db2527671c91ad8ebeaef15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a36ead5a89db2527671c91ad8ebeaef15">updMultipliers</a> () const</td></tr>
<tr class="separator:a36ead5a89db2527671c91ad8ebeaef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Continuous state variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These continuous state variables are shared among all the subsystems and are not allocated until the <em>system</em> is advanced to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>.</p>
<p>The returned index is local to each subsystem. After the system is modeled, we guarantee that all the q's for a subsystem will be contiguous, and similarly for u's and z's. However, q,u,z will <em>not</em> be contiguous with each other. The <em>global</em> y={q,u,z} is contiguous, and global q,u,z are contiguous within y, in that order. Corresponding cache entries for the derivatives of these variables are allocated at Model stage also. </p>
</div></td></tr>
<tr class="memitem:a31299e8d0eb4446e9739598d604dd0fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1QIndex.html">QIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a31299e8d0eb4446e9739598d604dd0fb">allocateQ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qInit)</td></tr>
<tr class="memdesc:a31299e8d0eb4446e9739598d604dd0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate generalized coordinates <em>q</em>, which are second order continuous state variables.  <a href="#a31299e8d0eb4446e9739598d604dd0fb">More...</a><br /></td></tr>
<tr class="separator:a31299e8d0eb4446e9739598d604dd0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4988e8d824beb1161a67d8e2a1d4c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae4988e8d824beb1161a67d8e2a1d4c85">allocateU</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;uInit)</td></tr>
<tr class="memdesc:ae4988e8d824beb1161a67d8e2a1d4c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate generalized speeds <em>u</em>, which are first order continuous state variables related to the derivatives of the second order <em>q's</em> by qdot=N(q)*u, for a System-defined coupling matrix N.  <a href="#ae4988e8d824beb1161a67d8e2a1d4c85">More...</a><br /></td></tr>
<tr class="separator:ae4988e8d824beb1161a67d8e2a1d4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb532c8ae68fded77c3d943218a3eb54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ZIndex.html">ZIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aeb532c8ae68fded77c3d943218a3eb54">allocateZ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;zInit)</td></tr>
<tr class="memdesc:aeb532c8ae68fded77c3d943218a3eb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate auxiliary first order continuous state variables <em>z</em>.  <a href="#aeb532c8ae68fded77c3d943218a3eb54">More...</a><br /></td></tr>
<tr class="separator:aeb532c8ae68fded77c3d943218a3eb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraint errors and multipliers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These constraint error cache entries are shared among all the subsystems and are not allocated until the <em>system</em> is advanced to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a>.</p>
<p>The returned index is local to each subsystem. Q errors and U errors will each be contiguous for a given subsystem, but <em>not</em> with each other. However, the System-level yerr={qerr,uerr} <em>is</em> a single contiguous vector. UDotErr is a separate quantity, not part of yerr. Again the UDotErr's for each subsystem will be contiguous within the larger UDotErr Vector. Allocating a UDotErr has the side effect of allocating another Vector of the same size in the cache for the corresponding Lagrange multipliers, and these are partitioned identically to UDotErrs. </p>
</div></td></tr>
<tr class="memitem:a51730fe482557455030b56ea468371e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1QErrIndex.html">QErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a51730fe482557455030b56ea468371e9">allocateQErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, int nqerr) const</td></tr>
<tr class="memdesc:a51730fe482557455030b56ea468371e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>nqerr</em> cache slots to hold the current error for position-level (holonomic) constraint equations.  <a href="#a51730fe482557455030b56ea468371e9">More...</a><br /></td></tr>
<tr class="separator:a51730fe482557455030b56ea468371e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51bd56abbb91f73ed8c9fc04fa433fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UErrIndex.html">UErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa51bd56abbb91f73ed8c9fc04fa433fa">allocateUErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, int nuerr) const</td></tr>
<tr class="memdesc:aa51bd56abbb91f73ed8c9fc04fa433fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>nuerr</em> cache slots to hold the current error for velocity-level (nonholonomic and holonomic first derivative) constraint equations.  <a href="#aa51bd56abbb91f73ed8c9fc04fa433fa">More...</a><br /></td></tr>
<tr class="separator:aa51bd56abbb91f73ed8c9fc04fa433fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ce8e273dab1ccb3bae95f0e10c16bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UDotErrIndex.html">UDotErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a97ce8e273dab1ccb3bae95f0e10c16bb">allocateUDotErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, int nudoterr) const</td></tr>
<tr class="memdesc:a97ce8e273dab1ccb3bae95f0e10c16bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <em>nudoterr</em> cache slots to hold the current error for acceleration-level (acceleration-only, nonholonomic first derivative, and holonomic second derivative) constraint equations.  <a href="#a97ce8e273dab1ccb3bae95f0e10c16bb">More...</a><br /></td></tr>
<tr class="separator:a97ce8e273dab1ccb3bae95f0e10c16bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event witness functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Some Events require a slot in the State cache to hold the current value of the event trigger function (a.k.a.</p>
<p>event "witness" function). The <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> here is the stage at which the trigger function's value should be examined by a <a class="el" href="classSimTK_1_1TimeStepper.html" title="This class uses an Integrator to advance a System through time. ">TimeStepper</a>. The returned index is local to the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and also to the stage. These can be allocated in a State that has not yet been realized to Instance stage, and will be forgotten appropriately if the State is later backed up to an earlier stage. When this State is realized to Instance stage, global event trigger slots will be allocated, collecting all same-stage event triggers together consecutively for the convenience of the <a class="el" href="classSimTK_1_1TimeStepper.html" title="This class uses an Integrator to advance a System through time. ">TimeStepper</a>. Within a stage, a given subsystem's event trigger slots for that stage are consecutive. </p>
</div></td></tr>
<tr class="memitem:aea9d50f4caecd95aa13c0408b1849830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1EventTriggerByStageIndex.html">EventTriggerByStageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aea9d50f4caecd95aa13c0408b1849830">allocateEventTrigger</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> stage, int nevent) const</td></tr>
<tr class="memdesc:aea9d50f4caecd95aa13c0408b1849830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate room for <em>nevent</em> witness function values that will be available at the indicated <em>stage</em>.  <a href="#aea9d50f4caecd95aa13c0408b1849830">More...</a><br /></td></tr>
<tr class="separator:aea9d50f4caecd95aa13c0408b1849830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Discrete Variables</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can allocate a new DiscreteVariable in any <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose stage has not yet been advanced to Model stage.</p>
<p>The stage at allocation (Empty or Topology) is remembered so that the appropriate discrete variables can be forgotten if the State's stage is reduced back to that stage later after advancing past it. DiscreteVariables are private to each <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and allocated immediately. The returned index is unique within the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and there is no corresponding global index. </p>
</div></td></tr>
<tr class="memitem:ae7fc9b56d326138a77e39bd73ad59aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae7fc9b56d326138a77e39bd73ad59aaa">allocateDiscreteVariable</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> invalidates, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *)</td></tr>
<tr class="memdesc:ae7fc9b56d326138a77e39bd73ad59aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> supplied here in the call is the earliest subsystem stage which is invalidated by a change made to this discrete variable.  <a href="#ae7fc9b56d326138a77e39bd73ad59aaa">More...</a><br /></td></tr>
<tr class="separator:ae7fc9b56d326138a77e39bd73ad59aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2b067d10792c14666301c9bf2d77b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aaa2b067d10792c14666301c9bf2d77b9">allocateAutoUpdateDiscreteVariable</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> invalidates, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> updateDependsOn)</td></tr>
<tr class="memdesc:aaa2b067d10792c14666301c9bf2d77b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates a DiscreteVariable whose value should be updated automatically after each time step.  <a href="#aaa2b067d10792c14666301c9bf2d77b9">More...</a><br /></td></tr>
<tr class="separator:aaa2b067d10792c14666301c9bf2d77b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d47cbf8652f97a5fde685478c74954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa1d47cbf8652f97a5fde685478c74954">getDiscreteVarUpdateIndex</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:aa1d47cbf8652f97a5fde685478c74954"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an auto-updating discrete variable, return the <a class="el" href="classSimTK_1_1CacheEntryIndex.html" title="This unique integer type is for selecting non-shared cache entries. ">CacheEntryIndex</a> for its associated update cache entry, otherwise return an invalid index.  <a href="#aa1d47cbf8652f97a5fde685478c74954">More...</a><br /></td></tr>
<tr class="separator:aa1d47cbf8652f97a5fde685478c74954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784ec4ea2497234a278bfb6df1e67c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a784ec4ea2497234a278bfb6df1e67c6c">getDiscreteVarAllocationStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a784ec4ea2497234a278bfb6df1e67c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">At what stage was this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> when this discrete variable was allocated? The answer must be <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a> or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a>.  <a href="#a784ec4ea2497234a278bfb6df1e67c6c">More...</a><br /></td></tr>
<tr class="separator:a784ec4ea2497234a278bfb6df1e67c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d2efd9c179cf43a28158ca4c7fe5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5f1d2efd9c179cf43a28158ca4c7fe5f">getDiscreteVarInvalidatesStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a5f1d2efd9c179cf43a28158ca4c7fe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">What is the earliest stage that is invalidated when this discrete variable is modified? All later stages are also invalidated.  <a href="#a5f1d2efd9c179cf43a28158ca4c7fe5f">More...</a><br /></td></tr>
<tr class="separator:a5f1d2efd9c179cf43a28158ca4c7fe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f47c2becd6ce07a00bdc86b332716d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ac3f47c2becd6ce07a00bdc86b332716d">getDiscreteVariable</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:ac3f47c2becd6ce07a00bdc86b332716d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value of the indicated discrete variable.  <a href="#ac3f47c2becd6ce07a00bdc86b332716d">More...</a><br /></td></tr>
<tr class="separator:ac3f47c2becd6ce07a00bdc86b332716d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e695448606960d9b6efcee1766702c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a87e695448606960d9b6efcee1766702c">getDiscreteVarLastUpdateTime</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a87e695448606960d9b6efcee1766702c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time of last update for this discrete variable.  <a href="#a87e695448606960d9b6efcee1766702c">More...</a><br /></td></tr>
<tr class="separator:a87e695448606960d9b6efcee1766702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f59135730c847a29d09c494d04f20c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a55f59135730c847a29d09c494d04f20c">getDiscreteVarUpdateValue</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a55f59135730c847a29d09c494d04f20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an auto-updating discrete variable, return the current value of its associated update cache entry; this is the value the discrete variable will have the next time it is updated.  <a href="#a55f59135730c847a29d09c494d04f20c">More...</a><br /></td></tr>
<tr class="separator:a55f59135730c847a29d09c494d04f20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a6cddb2c20e4496723136242c5a60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a63a6cddb2c20e4496723136242c5a60c">updDiscreteVarUpdateValue</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a63a6cddb2c20e4496723136242c5a60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an auto-updating discrete variable, return a writable reference to the value of its associated update cache entry.  <a href="#a63a6cddb2c20e4496723136242c5a60c">More...</a><br /></td></tr>
<tr class="separator:a63a6cddb2c20e4496723136242c5a60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f481c3d79705cd5f4ac85754355645"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a48f481c3d79705cd5f4ac85754355645">isDiscreteVarUpdateValueRealized</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:a48f481c3d79705cd5f4ac85754355645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the update value for this auto-update discrete variable has already been computed since the last change to state variables it depends on.  <a href="#a48f481c3d79705cd5f4ac85754355645">More...</a><br /></td></tr>
<tr class="separator:a48f481c3d79705cd5f4ac85754355645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d91317f60dc4d9477b1b6f11d9cb37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae0d91317f60dc4d9477b1b6f11d9cb37">markDiscreteVarUpdateValueRealized</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>) const</td></tr>
<tr class="memdesc:ae0d91317f60dc4d9477b1b6f11d9cb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the update value for this auto-update discrete variable as up-to-date with respect to the state variables it depends on.  <a href="#ae0d91317f60dc4d9477b1b6f11d9cb37">More...</a><br /></td></tr>
<tr class="separator:ae0d91317f60dc4d9477b1b6f11d9cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836298382ef60e18f64e850e89146075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a836298382ef60e18f64e850e89146075">updDiscreteVariable</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>)</td></tr>
<tr class="memdesc:a836298382ef60e18f64e850e89146075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to the value stored in the indicated discrete state variable dv, and invalidate stage dv.invalidates and all higher stages.  <a href="#a836298382ef60e18f64e850e89146075">More...</a><br /></td></tr>
<tr class="separator:a836298382ef60e18f64e850e89146075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063c76cfff04618f04734c8cf4d2ed57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a063c76cfff04618f04734c8cf4d2ed57">setDiscreteVariable</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>, const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;)</td></tr>
<tr class="memdesc:a063c76cfff04618f04734c8cf4d2ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to updDiscreteVariable.  <a href="#a063c76cfff04618f04734c8cf4d2ed57">More...</a><br /></td></tr>
<tr class="separator:a063c76cfff04618f04734c8cf4d2ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cache Entries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can allocate a new CacheEntry in any <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose stage has not yet been advanced to Instance stage.</p>
<p>The stage at allocation (Empty, Topology, or Model) is remembered so that the appropriate cache entries can be forgotten if the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>'s stage is reduced back to that stage later after advancing past it. CacheEntries are private to each <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and allocated immediately. The returned index is unique within the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and there is no corresponding global index. </p>
</div></td></tr>
<tr class="memitem:ad50d2ab0c6326eed4fc78ea3dd06e3d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3">allocateCacheEntry</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> earliest, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> latest, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *value) const</td></tr>
<tr class="memdesc:ad50d2ab0c6326eed4fc78ea3dd06e3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are two Stages supplied explicitly as arguments to this method: <em>earliest</em> and <em>latest</em>.  <a href="#ad50d2ab0c6326eed4fc78ea3dd06e3d3">More...</a><br /></td></tr>
<tr class="separator:ad50d2ab0c6326eed4fc78ea3dd06e3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f101ddceed0c34c6ee6f375dceccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#acb9f101ddceed0c34c6ee6f375dceccb">allocateCacheEntry</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a> sx, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> stage, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *value) const</td></tr>
<tr class="memdesc:acb9f101ddceed0c34c6ee6f375dceccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abbreviation for allocation of a cache entry whose earliest and latest Stages are the same.  <a href="#acb9f101ddceed0c34c6ee6f375dceccb">More...</a><br /></td></tr>
<tr class="separator:acb9f101ddceed0c34c6ee6f375dceccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e6878b4a12b3fc5b98a8327872b264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a61e6878b4a12b3fc5b98a8327872b264">allocateLazyCacheEntry</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a> sx, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> earliest, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *value) const</td></tr>
<tr class="memdesc:a61e6878b4a12b3fc5b98a8327872b264"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abbreviation for allocation of a lazy cache entry.  <a href="#a61e6878b4a12b3fc5b98a8327872b264">More...</a><br /></td></tr>
<tr class="separator:a61e6878b4a12b3fc5b98a8327872b264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f685181c1c13eafeb1d969650ef84e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a69f685181c1c13eafeb1d969650ef84e">allocateCacheEntryWithPrerequisites</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> earliest, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> latest, bool q, bool u, bool z, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &gt; &amp;discreteVars, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &gt; &amp;cacheEntries, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *value)</td></tr>
<tr class="memdesc:a69f685181c1c13eafeb1d969650ef84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Allocate a cache entry with prerequisites other than just reaching a particular computation stage.  <a href="#a69f685181c1c13eafeb1d969650ef84e">More...</a><br /></td></tr>
<tr class="separator:a69f685181c1c13eafeb1d969650ef84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6aacc096cf8af29e32ceca85f6b5286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa6aacc096cf8af29e32ceca85f6b5286">getCacheEntryAllocationStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:aa6aacc096cf8af29e32ceca85f6b5286"><td class="mdescLeft">&#160;</td><td class="mdescRight">At what stage was this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> when this cache entry was allocated? The answer must be <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a>, <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a>, or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>.  <a href="#aa6aacc096cf8af29e32ceca85f6b5286">More...</a><br /></td></tr>
<tr class="separator:aa6aacc096cf8af29e32ceca85f6b5286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd3f94e66eb4f829b247e5dc71b74e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8">getCacheEntry</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:a9bd3f94e66eb4f829b247e5dc71b74e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to the value contained in a particular cache entry.  <a href="#a9bd3f94e66eb4f829b247e5dc71b74e8">More...</a><br /></td></tr>
<tr class="separator:a9bd3f94e66eb4f829b247e5dc71b74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2434b9f4619f59b91f049be7bf7bf7c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2434b9f4619f59b91f049be7bf7bf7c6">updCacheEntry</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:a2434b9f4619f59b91f049be7bf7bf7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a writable reference to the value contained in a particular cache entry.  <a href="#a2434b9f4619f59b91f049be7bf7bf7c6">More...</a><br /></td></tr>
<tr class="separator:a2434b9f4619f59b91f049be7bf7bf7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe2e602ff82897322d4ae6b5be3974"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974">isCacheValueRealized</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:aeffe2e602ff82897322d4ae6b5be3974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the value in a particular cache entry has been recalculated since the last change to the state variables it depends on.  <a href="#aeffe2e602ff82897322d4ae6b5be3974">More...</a><br /></td></tr>
<tr class="separator:aeffe2e602ff82897322d4ae6b5be3974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9293f334adc4b01091934b6b9a361f28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28">markCacheValueRealized</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:a9293f334adc4b01091934b6b9a361f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the value of a particular cache entry as up to date after it has been recalculated.  <a href="#a9293f334adc4b01091934b6b9a361f28">More...</a><br /></td></tr>
<tr class="separator:a9293f334adc4b01091934b6b9a361f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edc7993b5c6594ababafecfcb3bd87f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a2edc7993b5c6594ababafecfcb3bd87f">markCacheValueNotRealized</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>) const</td></tr>
<tr class="memdesc:a2edc7993b5c6594ababafecfcb3bd87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Normally cache entries are invalidated automatically, however this method allows manual invalidation of the value of a particular cache entry.  <a href="#a2edc7993b5c6594ababafecfcb3bd87f">More...</a><br /></td></tr>
<tr class="separator:a2edc7993b5c6594ababafecfcb3bd87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Global Resource Dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the dimensions of the global shared state and cache resources, as well as the dimensions of the per-Subsystem partioning of those resources.</p>
<p><a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> resource dimensions (including cache resources directly related to state variables) are known after the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> has been realized to Model stage. Other cache resource dimensions are known after the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> has been realized to Instance stage. Access to the actual data arrays may have stricter requirements (for example, you can't ask to look at UErr arrays until Velocity stage). Hence it is better to use these explicit dimension-providing methods than to get a reference to a Vector and ask for its size().</p>
<dl class="section see"><dt>See also</dt><dd>Per-Subsystem Dimensions group </dd>
<dd>
Global-to-Subsystem Maps group </dd></dl>
</div></td></tr>
<tr class="memitem:aab1591fbfc16916a36bb55c73f45c4b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aab1591fbfc16916a36bb55c73f45c4b9">getNY</a> () const</td></tr>
<tr class="memdesc:aab1591fbfc16916a36bb55c73f45c4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number ny=nq+nu+nz of shared continuous state variables.  <a href="#aab1591fbfc16916a36bb55c73f45c4b9">More...</a><br /></td></tr>
<tr class="separator:aab1591fbfc16916a36bb55c73f45c4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31594d0f20222cd35b55eb0f64136f1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a31594d0f20222cd35b55eb0f64136f1a">getNQ</a> () const</td></tr>
<tr class="memdesc:a31594d0f20222cd35b55eb0f64136f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of shared q's (generalized coordinates; second order state variables).  <a href="#a31594d0f20222cd35b55eb0f64136f1a">More...</a><br /></td></tr>
<tr class="separator:a31594d0f20222cd35b55eb0f64136f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d42f6ac58bfb9c8fb3bef2321d82eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a7d42f6ac58bfb9c8fb3bef2321d82eae">getQStart</a> () const</td></tr>
<tr class="memdesc:a7d42f6ac58bfb9c8fb3bef2321d82eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the y index at which the q's begin. Callable at Model stage.  <a href="#a7d42f6ac58bfb9c8fb3bef2321d82eae">More...</a><br /></td></tr>
<tr class="separator:a7d42f6ac58bfb9c8fb3bef2321d82eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf2142114256d777c7f4a00553e151a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a6bf2142114256d777c7f4a00553e151a">getNU</a> () const</td></tr>
<tr class="memdesc:a6bf2142114256d777c7f4a00553e151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of shared u's (generalized speeds; mobilities).  <a href="#a6bf2142114256d777c7f4a00553e151a">More...</a><br /></td></tr>
<tr class="separator:a6bf2142114256d777c7f4a00553e151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f483b0cc0b9df6646108944e1f6b9ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5f483b0cc0b9df6646108944e1f6b9ae">getUStart</a> () const</td></tr>
<tr class="memdesc:a5f483b0cc0b9df6646108944e1f6b9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the y index at which the u's begin. Callable at Model stage.  <a href="#a5f483b0cc0b9df6646108944e1f6b9ae">More...</a><br /></td></tr>
<tr class="separator:a5f483b0cc0b9df6646108944e1f6b9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7938019259ed5c714fccf3f19f7f85a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa7938019259ed5c714fccf3f19f7f85a">getNZ</a> () const</td></tr>
<tr class="memdesc:aa7938019259ed5c714fccf3f19f7f85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of shared z's (auxiliary state variables).  <a href="#aa7938019259ed5c714fccf3f19f7f85a">More...</a><br /></td></tr>
<tr class="separator:aa7938019259ed5c714fccf3f19f7f85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af95be0d1d3a5a4cfe2fde3e4b514e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9af95be0d1d3a5a4cfe2fde3e4b514e4">getZStart</a> () const</td></tr>
<tr class="memdesc:a9af95be0d1d3a5a4cfe2fde3e4b514e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the y index at which the z's begin. Callable at Model stage.  <a href="#a9af95be0d1d3a5a4cfe2fde3e4b514e4">More...</a><br /></td></tr>
<tr class="separator:a9af95be0d1d3a5a4cfe2fde3e4b514e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036445604f7e839554ee325ef467323e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a036445604f7e839554ee325ef467323e">getNYErr</a> () const</td></tr>
<tr class="memdesc:a036445604f7e839554ee325ef467323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number nyerr=nqerr+nuerr of shared cache entries for position-level and velocity-level constraint errors.  <a href="#a036445604f7e839554ee325ef467323e">More...</a><br /></td></tr>
<tr class="separator:a036445604f7e839554ee325ef467323e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745d2467dea71aa7860c1c92b4ff852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a0745d2467dea71aa7860c1c92b4ff852">getNQErr</a> () const</td></tr>
<tr class="memdesc:a0745d2467dea71aa7860c1c92b4ff852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number nqerr=mp+nQuaternions of cache entries for position-level constraint errors.  <a href="#a0745d2467dea71aa7860c1c92b4ff852">More...</a><br /></td></tr>
<tr class="separator:a0745d2467dea71aa7860c1c92b4ff852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6124257208c313d9c0edba994038004d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemYErrIndex.html">SystemYErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a6124257208c313d9c0edba994038004d">getQErrStart</a> () const</td></tr>
<tr class="memdesc:a6124257208c313d9c0edba994038004d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the yErr index at which the qErr's begin. Callable at Instance stage.  <a href="#a6124257208c313d9c0edba994038004d">More...</a><br /></td></tr>
<tr class="separator:a6124257208c313d9c0edba994038004d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b50e0412b0a9046ab5ea2270347b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ab2b50e0412b0a9046ab5ea2270347b9e">getNUErr</a> () const</td></tr>
<tr class="memdesc:ab2b50e0412b0a9046ab5ea2270347b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number nuerr=mp+mv of cache entries for velocity-level constraint errors (including also errors in the time derivatives of position-level constraints).  <a href="#ab2b50e0412b0a9046ab5ea2270347b9e">More...</a><br /></td></tr>
<tr class="separator:ab2b50e0412b0a9046ab5ea2270347b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbe931aab4f4163d8ce86b0503eb87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemYErrIndex.html">SystemYErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1bbe931aab4f4163d8ce86b0503eb87f">getUErrStart</a> () const</td></tr>
<tr class="memdesc:a1bbe931aab4f4163d8ce86b0503eb87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the yErr index at which the uErr's begin. Callable at Instance stage.  <a href="#a1bbe931aab4f4163d8ce86b0503eb87f">More...</a><br /></td></tr>
<tr class="separator:a1bbe931aab4f4163d8ce86b0503eb87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082fc31461b157f1da46da2df72bcf60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a082fc31461b157f1da46da2df72bcf60">getNUDotErr</a> () const</td></tr>
<tr class="memdesc:a082fc31461b157f1da46da2df72bcf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number nudotErr=mp+mv+ma of cache entries for acceleration-level constraint errors (including also errors in the second time derivatives of position-level constraints and the first time derivatives of velocity-level constraints).  <a href="#a082fc31461b157f1da46da2df72bcf60">More...</a><br /></td></tr>
<tr class="separator:a082fc31461b157f1da46da2df72bcf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4eca7208c711c12149d2096ee4c18f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#abe4eca7208c711c12149d2096ee4c18f">getNMultipliers</a> () const</td></tr>
<tr class="memdesc:abe4eca7208c711c12149d2096ee4c18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of constraint multipliers; necessarily the same as the number of acceleration-level constraint errors nUDotErr.  <a href="#abe4eca7208c711c12149d2096ee4c18f">More...</a><br /></td></tr>
<tr class="separator:abe4eca7208c711c12149d2096ee4c18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076c641653cd00f82872ff64cbcb6342"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a076c641653cd00f82872ff64cbcb6342">getNEventTriggers</a> () const</td></tr>
<tr class="memdesc:a076c641653cd00f82872ff64cbcb6342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of event trigger function slots in the cache.  <a href="#a076c641653cd00f82872ff64cbcb6342">More...</a><br /></td></tr>
<tr class="separator:a076c641653cd00f82872ff64cbcb6342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae787389cc0de0b7a99ebf973c70becd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ae787389cc0de0b7a99ebf973c70becd1">getNEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="memdesc:ae787389cc0de0b7a99ebf973c70becd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the partition of event trigger functions which are evaluated at a given <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>.  <a href="#ae787389cc0de0b7a99ebf973c70becd1">More...</a><br /></td></tr>
<tr class="separator:ae787389cc0de0b7a99ebf973c70becd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012645eec84528408efa4be616890988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemEventTriggerIndex.html">SystemEventTriggerIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a012645eec84528408efa4be616890988">getEventTriggerStartByStage</a> (<a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="memdesc:a012645eec84528408efa4be616890988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index within the global event trigger array at which the first of the event triggers associated with a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> are stored; the rest follow contiguously.  <a href="#a012645eec84528408efa4be616890988">More...</a><br /></td></tr>
<tr class="separator:a012645eec84528408efa4be616890988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d830f911cd7aec6500f0d2ff03cbfce"><td class="memItemLeft" align="right" valign="top">std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9d830f911cd7aec6500f0d2ff03cbfce">getStateLock</a> () const</td></tr>
<tr class="memdesc:a9d830f911cd7aec6500f0d2ff03cbfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutex that should be used to lock the state whenever multiple threads are asynchronously writing/updating a common state cache.  <a href="#a9d830f911cd7aec6500f0d2ff03cbfce">More...</a><br /></td></tr>
<tr class="separator:a9d830f911cd7aec6500f0d2ff03cbfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Per-Subsystem Dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the dimensions and locations within the global resource arrays of state and cache resources allocated to a particular <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.</p>
<p>Note that a <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> has contiguous q's, contiguous u's, and contiguous z's but that the q-, u-, and z-partitions are not contiguous. Hence there is no <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> equivalent of the global y vector.</p>
<p>These serve as a mapping from Subsystem-local indices for the various shared resources to their global resource indices.</p>
<dl class="section see"><dt>See also</dt><dd>Global Resource Dimensions </dd></dl>
</div></td></tr>
<tr class="memitem:acc5a5f6746156bd509f74e6f7110cfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemQIndex.html">SystemQIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#acc5a5f6746156bd509f74e6f7110cfca">getQStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:acc5a5f6746156bd509f74e6f7110cfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9198acda366eee66d5cf1248c117edd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad9198acda366eee66d5cf1248c117edd">getNQ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:ad9198acda366eee66d5cf1248c117edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cc420210abb81682e23997e97989d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUIndex.html">SystemUIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a58cc420210abb81682e23997e97989d9">getUStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a58cc420210abb81682e23997e97989d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f88645b31787074b8e32107d33c536"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a07f88645b31787074b8e32107d33c536">getNU</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a07f88645b31787074b8e32107d33c536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bef5e35cf2280b7434391a0dae1a0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemZIndex.html">SystemZIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1bef5e35cf2280b7434391a0dae1a0dc">getZStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a1bef5e35cf2280b7434391a0dae1a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0233da5e6f4375abc09aed3061ca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad7b0233da5e6f4375abc09aed3061ca6">getNZ</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:ad7b0233da5e6f4375abc09aed3061ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fabff77f983fd5f4741cc14b0a9985b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemQErrIndex.html">SystemQErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a8fabff77f983fd5f4741cc14b0a9985b">getQErrStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a8fabff77f983fd5f4741cc14b0a9985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f055d671b27685ddc1eacb0884a26f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a15f055d671b27685ddc1eacb0884a26f">getNQErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a15f055d671b27685ddc1eacb0884a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19b0e2a13562e6c8e7935062bdedb27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUErrIndex.html">SystemUErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad19b0e2a13562e6c8e7935062bdedb27">getUErrStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:ad19b0e2a13562e6c8e7935062bdedb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b52d82da83302c292ab587f6c9a0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a5d1b52d82da83302c292ab587f6c9a0b">getNUErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a5d1b52d82da83302c292ab587f6c9a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb94e588ba3dbb0426f5bcd4557b18cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUDotErrIndex.html">SystemUDotErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#acb94e588ba3dbb0426f5bcd4557b18cc">getUDotErrStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:acb94e588ba3dbb0426f5bcd4557b18cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f59839325094fe6e754f94e8673457"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a32f59839325094fe6e754f94e8673457">getNUDotErr</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a32f59839325094fe6e754f94e8673457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4492082f25ffb7e2773d5b9a40223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemMultiplierIndex.html">SystemMultiplierIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a87c4492082f25ffb7e2773d5b9a40223">getMultipliersStart</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:a87c4492082f25ffb7e2773d5b9a40223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b3b3ca85e41da22f2c730ee43d0055"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa2b3b3ca85e41da22f2c730ee43d0055">getNMultipliers</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="separator:aa2b3b3ca85e41da22f2c730ee43d0055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8a13e9e95510bbc8cbeaada3fd348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemEventTriggerByStageIndex.html">SystemEventTriggerByStageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a52b8a13e9e95510bbc8cbeaada3fd348">getEventTriggerStartByStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:a52b8a13e9e95510bbc8cbeaada3fd348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fdda8ae010c4c01086f2496df57f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa9fdda8ae010c4c01086f2496df57f41">getNEventTriggersByStage</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>, <a class="el" href="classSimTK_1_1Stage.html">Stage</a>) const</td></tr>
<tr class="separator:aa9fdda8ae010c4c01086f2496df57f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced/Obscure/Debugging</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Don't call these methods unless you know what you're doing.</p>
</div></td></tr>
<tr class="memitem:af3df5a71d4c08fd85fc4145de9bf4c15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#af3df5a71d4c08fd85fc4145de9bf4c15">getSystemStageVersions</a> (<a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> &gt; &amp;versions) const</td></tr>
<tr class="memdesc:af3df5a71d4c08fd85fc4145de9bf4c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Record the current version numbers of each valid System-level stage.  <a href="#af3df5a71d4c08fd85fc4145de9bf4c15">More...</a><br /></td></tr>
<tr class="separator:af3df5a71d4c08fd85fc4145de9bf4c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e14a5c3a2b35a3f66f97bb6f43b748"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ac8e14a5c3a2b35a3f66f97bb6f43b748">getLowestSystemStageDifference</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> &gt; &amp;prevVersions) const</td></tr>
<tr class="memdesc:ac8e14a5c3a2b35a3f66f97bb6f43b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Given a list of per-stage version numbers extracted by an earlier call to <a class="el" href="classSimTK_1_1State.html#af3df5a71d4c08fd85fc4145de9bf4c15" title="(Advanced) Record the current version numbers of each valid System-level stage. ">getSystemStageVersions()</a>, note the lowest system stage in the current <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose version number differs from the corresponding previous version number.  <a href="#ac8e14a5c3a2b35a3f66f97bb6f43b748">More...</a><br /></td></tr>
<tr class="separator:ac8e14a5c3a2b35a3f66f97bb6f43b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fca0c246567f476fec83b86eea51a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a18fca0c246567f476fec83b86eea51a3">setSystemTopologyStageVersion</a> (<a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> topoVersion)</td></tr>
<tr class="memdesc:a18fca0c246567f476fec83b86eea51a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This explicitly modifies the Topology stage version; don't use this method unless you know what you're doing! This can be used to force compatibility with a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has had Topology changes since this State was created.  <a href="#a18fca0c246567f476fec83b86eea51a3">More...</a><br /></td></tr>
<tr class="separator:a18fca0c246567f476fec83b86eea51a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551aaa3c0182729f9bf36b2fbfffe6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a4551aaa3c0182729f9bf36b2fbfffe6a">getQValueVersion</a> () const</td></tr>
<tr class="memdesc:a4551aaa3c0182729f9bf36b2fbfffe6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a ValueVersion for q, meaning an integer that is incremented whenever any q is changed (or more precisely whenever q or y is returned with writable access).  <a href="#a4551aaa3c0182729f9bf36b2fbfffe6a">More...</a><br /></td></tr>
<tr class="separator:a4551aaa3c0182729f9bf36b2fbfffe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c4055fe998e57cf9ae76a29c442e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#aa76c4055fe998e57cf9ae76a29c442e9">getUValueVersion</a> () const</td></tr>
<tr class="memdesc:aa76c4055fe998e57cf9ae76a29c442e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a ValueVersion for u, meaning an integer that is incremented whenever any u is changed (or more precisely whenever u or y is returned with writable access).  <a href="#aa76c4055fe998e57cf9ae76a29c442e9">More...</a><br /></td></tr>
<tr class="separator:aa76c4055fe998e57cf9ae76a29c442e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fb41f73c69865c20659dc3baaaa0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a55fb41f73c69865c20659dc3baaaa0a5">getZValueVersion</a> () const</td></tr>
<tr class="memdesc:a55fb41f73c69865c20659dc3baaaa0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a ValueVersion for z, meaning an integer that is incremented whenever any z is changed (or more precisely whenever z or y is returned with writable access).  <a href="#a55fb41f73c69865c20659dc3baaaa0a5">More...</a><br /></td></tr>
<tr class="separator:a55fb41f73c69865c20659dc3baaaa0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1895b780da66c168296aea21077fdeab"><td class="memItemLeft" align="right" valign="top">const ListOfDependents &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a1895b780da66c168296aea21077fdeab">getQDependents</a> () const</td></tr>
<tr class="memdesc:a1895b780da66c168296aea21077fdeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return the list of cache entries for which q was specified as an explicit prerequisite.  <a href="#a1895b780da66c168296aea21077fdeab">More...</a><br /></td></tr>
<tr class="separator:a1895b780da66c168296aea21077fdeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172f9a50d0f8011336a11230b909f012"><td class="memItemLeft" align="right" valign="top">const ListOfDependents &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a172f9a50d0f8011336a11230b909f012">getUDependents</a> () const</td></tr>
<tr class="memdesc:a172f9a50d0f8011336a11230b909f012"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return the list of cache entries for which u was specified as an explicit prerequisite.  <a href="#a172f9a50d0f8011336a11230b909f012">More...</a><br /></td></tr>
<tr class="separator:a172f9a50d0f8011336a11230b909f012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a89c6d8beab10b83a59f6fd1205567e"><td class="memItemLeft" align="right" valign="top">const ListOfDependents &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a9a89c6d8beab10b83a59f6fd1205567e">getZDependents</a> () const</td></tr>
<tr class="memdesc:a9a89c6d8beab10b83a59f6fd1205567e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return the list of cache entries for which z was specified as an explicit prerequisite.  <a href="#a9a89c6d8beab10b83a59f6fd1205567e">More...</a><br /></td></tr>
<tr class="separator:a9a89c6d8beab10b83a59f6fd1205567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59f5235ad0a93d52de44dd49cd952c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a3d59f5235ad0a93d52de44dd49cd952c">hasCacheEntry</a> (const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;cacheEntry) const</td></tr>
<tr class="memdesc:a3d59f5235ad0a93d52de44dd49cd952c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether this State has a particular cache entry.  <a href="#a3d59f5235ad0a93d52de44dd49cd952c">More...</a><br /></td></tr>
<tr class="separator:a3d59f5235ad0a93d52de44dd49cd952c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc6b6ff0d8e15b061b8ee32d6156cb0"><td class="memItemLeft" align="right" valign="top">const CacheEntryInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#adcc6b6ff0d8e15b061b8ee32d6156cb0">getCacheEntryInfo</a> (const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;cacheEntry) const</td></tr>
<tr class="memdesc:adcc6b6ff0d8e15b061b8ee32d6156cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a const reference to the cache entry information for a particular cache entry.  <a href="#adcc6b6ff0d8e15b061b8ee32d6156cb0">More...</a><br /></td></tr>
<tr class="separator:adcc6b6ff0d8e15b061b8ee32d6156cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a11f9e6bcd3a2b41b79e1b7d4b5d8"><td class="memItemLeft" align="right" valign="top">CacheEntryInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a440a11f9e6bcd3a2b41b79e1b7d4b5d8">updCacheEntryInfo</a> (const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;cacheEntry)</td></tr>
<tr class="memdesc:a440a11f9e6bcd3a2b41b79e1b7d4b5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a writable reference to the cache entry information for a particular cache entry.  <a href="#a440a11f9e6bcd3a2b41b79e1b7d4b5d8">More...</a><br /></td></tr>
<tr class="separator:a440a11f9e6bcd3a2b41b79e1b7d4b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a165f4d23ba9de1dd3c4069361fe34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a32a165f4d23ba9de1dd3c4069361fe34">hasDiscreteVar</a> (const <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &amp;discreteVar) const</td></tr>
<tr class="memdesc:a32a165f4d23ba9de1dd3c4069361fe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether this State has a particular discrete state variable.  <a href="#a32a165f4d23ba9de1dd3c4069361fe34">More...</a><br /></td></tr>
<tr class="separator:a32a165f4d23ba9de1dd3c4069361fe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc6bac3a60925f1ef4fdfb55b0287b"><td class="memItemLeft" align="right" valign="top">const DiscreteVarInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a49dc6bac3a60925f1ef4fdfb55b0287b">getDiscreteVarInfo</a> (const <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &amp;discreteVar) const</td></tr>
<tr class="memdesc:a49dc6bac3a60925f1ef4fdfb55b0287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a reference to the discrete variable information for a particular discrete variable.  <a href="#a49dc6bac3a60925f1ef4fdfb55b0287b">More...</a><br /></td></tr>
<tr class="separator:a49dc6bac3a60925f1ef4fdfb55b0287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af223c2bcbf269e32ac808bd21d38b2b4"><td class="memItemLeft" align="right" valign="top">const PerSubsystemInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#af223c2bcbf269e32ac808bd21d38b2b4">getPerSubsystemInfo</a> (<a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>) const</td></tr>
<tr class="memdesc:af223c2bcbf269e32ac808bd21d38b2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Return a reference to the per-subsystem information in the state.  <a href="#af223c2bcbf269e32ac808bd21d38b2b4">More...</a><br /></td></tr>
<tr class="separator:af223c2bcbf269e32ac808bd21d38b2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b1ef1c1e2b8e9687e413c2eea0eb17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a30b1ef1c1e2b8e9687e413c2eea0eb17">autoUpdateDiscreteVariables</a> ()</td></tr>
<tr class="memdesc:a30b1ef1c1e2b8e9687e413c2eea0eb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This is called at the beginning of every integration step to set the values of auto-update discrete variables from the values stored in their associated cache entries.  <a href="#a30b1ef1c1e2b8e9687e413c2eea0eb17">More...</a><br /></td></tr>
<tr class="separator:a30b1ef1c1e2b8e9687e413c2eea0eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad203ce6caa843bed1cadd85729b840ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#ad203ce6caa843bed1cadd85729b840ba">toString</a> () const</td></tr>
<tr class="memdesc:ad203ce6caa843bed1cadd85729b840ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Debugging) Not suitable for serialization.  <a href="#ad203ce6caa843bed1cadd85729b840ba">More...</a><br /></td></tr>
<tr class="separator:ad203ce6caa843bed1cadd85729b840ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2a7ce055d8281330f88b0c6f019cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1State.html#a3bb2a7ce055d8281330f88b0c6f019cc">cacheToString</a> () const</td></tr>
<tr class="memdesc:a3bb2a7ce055d8281330f88b0c6f019cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Debugging) Not suitable for serialization.  <a href="#a3bb2a7ce055d8281330f88b0c6f019cc">More...</a><br /></td></tr>
<tr class="separator:a3bb2a7ce055d8281330f88b0c6f019cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This object is intended to contain all state information for a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">SimTK::System</a>, except topological information which is stored in the System itself. </p>
<p>A <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">SimTK::System</a> is "const" after its topology has been constructed and realized. Anything changeable is instead stored in a State. Systems contain a set of <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> objects, and State supports that concept by allowing per-subsystem partitioning of the total system state. This allows subsystems to have their own private state variables, while permitting the system to allow shared access to state among the subsystems when necessary.</p>
<p>The State provides services reflecting the structure of the equations it expects to find in the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>. Three different views of the same state information are supported to accommodate three different users:</p><ul>
<li>the system as a whole</li>
<li>Subsystems contained in the system</li>
<li>numerical methods operating on the state</li>
</ul>
<p>Typically numerical methods have a much less nuanced view of the state than do the system or subsystems.</p>
<p>The system is expected to be a "hybrid DAE", that is, a mixture of continuous and discrete dynamic equations, and algebraic constraints. There is an independent variable t, continuous state variables y, and discrete state variables d.</p>
<p>The continuous part is an ODE-on-a-manifold system suitable for solution via coordinate projection, structured like this for the view taken by numerical methods: </p><pre>
     (1)  y' = f(d;t,y)         differential equations
     (2)  c  = c(d;t,y)         algebraic equations (manifold is c=0)
     (3)  e  = e(d;t,y)         event triggers (watch for zero crossings)
</pre><p> with initial conditions t0,y0,d0 such that c=0. The discrete variables d are updated upon occurrence of specific events. When those events are functions of time or state, they are detected using the set of scalar-valued event trigger functions e (3).</p>
<p>In the more detailed view as seen from the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>, we consider y={q,u,z} to be partitioned into position variables q, velocity variables u, and auxiliary variables z. There will be algebraic constraints involving q, u, and u's time derivatives udot. The system is now assumed to look like this: </p><pre>
     (4) qdot    = N(q) u
     (5) zdot    = zdot(d;t,q,u,z)</pre><pre>     (6) M(q) udot + ~G(q) mult = f(d;t,q,u,z)
         G(q) udot              = b(d;t,q,u)</pre><pre>                   [ pdotdot(d;t,q,u,udot) ]
     (7) udotErr = [ vdot(d;t,q,u,udot)    ] = 0
                   [ a(d;t,q,u,udot)       ]</pre><pre>     (8) uErr    = [ pdot(d;t,q,u) ]         = 0
                   [ v(d;t,q,u)    ]</pre><pre>     (9) qErr    = [ p(d;t,q) ]              = 0
                   [ n(q)     ]
</pre><p> The q's can also be dealt with directly as second order variables via </p><pre>
    (10) qdotdot = Ndot(q,qdot) u + N(q) udot
</pre><p>Here G = [P;V;A] with A(q) being the coefficient matrix for constraints appearing only at the acceleration level, and V(q)=partial(v)/partial(u) the coefficient matrix for the velocity (nonholonomic) constraints, and P(q)=partial(pdot)/partial(u) is the coefficient matrix of the first time derivatives of the position (holonomic) constraints. Note that uErr in Eq 8 is assumed to include equations resulting from differentiation of p() in Eq 9, as well as ones first introduced at the velocity level (nonholonomic constraints), and udotErr is similarly built from acceleration-only constraints a() and derivatives of higher-level constraints.</p>
<p>If a system allocates nq q's, nu u's, and nz z's the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> will also allocate matching cache variables qdot, qdotdot, udot, and zdot. If mp position (holonomic) constraints (9), mpv velocity constraints (8) and mpva acceleration constraints (7) are allocated, the state creates cache entries of like sizes qErr, uErr, udotErr. In addition room for the mpva Lagrange multipliers 'mult' is allocated in the cache.</p>
<p>In the final view, the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> view, the same variables and cache entries exist, but only the ones allocated by that <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> are visible. All of a <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>'s q's are consecutive in memory, as are its u's, uErr's, etc., but the q's are not adjacent to the u's as they are for the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s view.</p>
<p>The default constructor creates a State containing no state variables and with its realization cache stage set to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a>. During subsystem construction, variables and cache entries for any stage can be allocated, however <em>all</em> Model stage variables must be allocated during this time. At the end of construction, call advanceSubsystemToStage(Topology) which will put the subsystem at <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a>. Then the subsystems realize their Model stages, during which variables at any stage &gt; Model, and cache entries at any stage &gt;= Model can be allocated. After that call advanceSubsystemToStage(Model) which sets the stage to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a> and disallows further state allocation.</p>
<p>Note that there is a global <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> for the state as a whole, and individual Stages for each subsystem. The global stage can never be higher than the lowest subsystem stage. Global state resources are allocated when the global <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> advances to "Model" and tossed out if that stage is invalidated. Similarly, cache resources are allocated at stage Instance and forgotten when Instance is invalidated. Note that subsystems will "register" their use of the global variable pools during their own modeling stages, but that the actual global resources won't exist until the <em>system</em> has been advanced to Model or Instance stage.</p>
<h3>Implementation note</h3>
<p>This class is actually a "handle" that contains only a pointer to the hidden implementation class, StateImpl. Most of the methods here are inline and simply forward to the implementation object; the implementations of these must wait for the declaration of StateImpl in <a class="el" href="StateImpl_8h.html" title="This is part of the internal implementation of SimTK::State and does not contain any user-visible obj...">StateImpl.h</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a718a90ef538a16cfd6a5fd4f89f3857f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718a90ef538a16cfd6a5fd4f89f3857f">&#9670;&nbsp;</a></span>State() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::State::State </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>; this allocates an implementation object on the heap. </p>

</div>
</div>
<a id="acb872fdefc6d344720d197e129e6712a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb872fdefc6d344720d197e129e6712a">&#9670;&nbsp;</a></span>State() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::State::State </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The copy constructor has deep copy semantics; that is, this creates a new <em>copy</em> of the source object, <em>not</em> a reference to the original object. </p>
<p>This makes the new State contain a copy of the state information in the source State, copying only state variables and not the cache. If the source state hasn't been realized to at least <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>, then we don't copy its state variables either, except those associated with the Topology stage. </p>

</div>
</div>
<a id="a2061481eae28255481ef6aba4402a49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2061481eae28255481ef6aba4402a49c">&#9670;&nbsp;</a></span>State() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::State::State </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The move constructor is very fast. The source object is left empty. </p>

</div>
</div>
<a id="a18970cc5d1a4ae82595d1679009cc42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18970cc5d1a4ae82595d1679009cc42b">&#9670;&nbsp;</a></span>~State()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::State::~State </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct this State object and free up the heap space it is using. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac829588930f550a7c5da85ab0e5e6e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac829588930f550a7c5da85ab0e5e6e04">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1State.html">State</a>&amp; SimTK::State::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment has deep copy semantics; that is, <code>this</code> State will contain a <em>copy</em> of the source, <em>not</em> a reference into it. </p>
<p>This makes the current State contain a copy of the state information in the source State, copying only state variables and not the cache. If the source state hasn't been realized to at least <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>, then we don't copy its state variables either, except those associated with the Topology stage. </p>

</div>
</div>
<a id="a947448ce0d2b0d811a18a27759d7a563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947448ce0d2b0d811a18a27759d7a563">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1State.html">State</a>&amp; SimTK::State::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment is very fast. </p>
<p>The source object is left in a valid but undefined condition. </p>

</div>
</div>
<a id="afa724ccf9b959542f1c617563905cd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa724ccf9b959542f1c617563905cd07">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> to default-constructed condition. </p>

</div>
</div>
<a id="a417494916f15aed4de6e84f3f97b6c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417494916f15aed4de6e84f3f97b6c4b">&#9670;&nbsp;</a></span>isConsistent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::State::isConsistent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">SimTK::State</a> &amp;&#160;</td>
          <td class="paramname"><em>otherState</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given state has the same number of state variables, constraints, etc as this state. </p>
<p>Returns true if the following quantities are the same for both this state and <code>otherState</code>.</p>
<ul>
<li>number of subsystems</li>
<li>number of generalized coordinates (Q's)</li>
<li>number of generalized speeds (U's)</li>
<li>number of auxiliary state variables (Z's)</li>
<li>number of position constraints (QErr's)</li>
<li>number of velocity constraints (UErr's)</li>
<li>number of acceleration constraints (UDotErr's)</li>
<li>number of constraint Lagrange multipliers</li>
<li>number of event triggers</li>
</ul>
<p>Returns false otherwise.</p>
<p>You can call this after Instance stage has been realized on both this state and <code>otherState</code>.</p>
<p>This method does NOT guarantee that both states are for the same system or that both states will work with the same system. Also, this method does NOT check for any relationship between the times in the two states. </p>

</div>
</div>
<a id="a5aa67d2a9a76764b295fc97493023f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa67d2a9a76764b295fc97493023f26">&#9670;&nbsp;</a></span>setNumSubsystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setNumSubsystems </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of subsystems in this state. </p>
<p>This is done during initialization of the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> by a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>; it completely wipes out anything that used to be in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> so use cautiously! </p>

</div>
</div>
<a id="ae7b9ddedb2298764f16c3559e8a4611a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b9ddedb2298764f16c3559e8a4611a">&#9670;&nbsp;</a></span>initializeSubsystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::initializeSubsystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the name and version for a given subsystem, which must already have a slot allocated. </p>

</div>
</div>
<a id="ab94cdc6575bff73529cf048fbfdcf942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94cdc6575bff73529cf048fbfdcf942">&#9670;&nbsp;</a></span>addSubsystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a> SimTK::State::addSubsystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new subsystem as a client of this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>The supplied strings are stored with the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> but are not interpreted by it. The intent is that they can be used to perform "sanity checks" on deserialized States to make sure they match the currently instantiated <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>. The subsystem index (a small integer) is returned. </p>

</div>
</div>
<a id="a65457448eac39d61d01fba4b24a688bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65457448eac39d61d01fba4b24a688bb">&#9670;&nbsp;</a></span>getNumSubsystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNumSubsystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of Subsystems known to this State. </p>

</div>
</div>
<a id="a780aec1fd5e066ffb7904e1f06adf191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780aec1fd5e066ffb7904e1f06adf191">&#9670;&nbsp;</a></span>getSubsystemName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::State::getSubsystemName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e68264437a265bfcc802316c4b0d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e68264437a265bfcc802316c4b0d8bf">&#9670;&nbsp;</a></span>getSubsystemVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::State::getSubsystemVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd27de669cf7d707084d3e7c2dec3d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd27de669cf7d707084d3e7c2dec3d75">&#9670;&nbsp;</a></span>getSubsystemStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a>&amp; SimTK::State::getSubsystemStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d22280cc0c8e7d6aa5c22ac5803563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d22280cc0c8e7d6aa5c22ac5803563d">&#9670;&nbsp;</a></span>getSystemStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a>&amp; SimTK::State::getSystemStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the <em>global</em> stage for this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a id="a060484b97a44dddef791e2e101f0a407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060484b97a44dddef791e2e101f0a407">&#9670;&nbsp;</a></span>invalidateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::invalidateAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If any subsystem or the system stage is currently at or higher than the passed-in one, back up to the stage just prior; otherwise do nothing. </p>
<p>This is for use if you have write access to the state and can invalidate even Topology and Model stages which may destroy state variables. "All" here refers to all Subysystems. </p>

</div>
</div>
<a id="aae67d741a8ce475c00807830db99a751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae67d741a8ce475c00807830db99a751">&#9670;&nbsp;</a></span>invalidateAllCacheAtOrAbove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::invalidateAllCacheAtOrAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If any subsystem or the system stage is currently at or higher than the passed-in one, back up to the stage just prior; otherwise do nothing. </p>
<p>This const method can only be used to invalidate <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. To invalidate Model or Topology stage you must have write access to the state because invalidating those stages can destroy state variables in addition to cache entries. "All" here refers to all Subsystems. </p>

</div>
</div>
<a id="a8c94044ec3bdfdfe0a046031bcd5681f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c94044ec3bdfdfe0a046031bcd5681f">&#9670;&nbsp;</a></span>advanceSubsystemToStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::advanceSubsystemToStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance a particular <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>'s current stage by one to the indicated stage. </p>
<p>The stage is passed in just to give us a chance to verify that all is as expected. You can only advance one stage at a time. Advancing to Topology, Model, or Instance stage affects what you can do later. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a90042787b00c2dbdb91e9b7a647bf19d" title="Advance the System-level current stage by one to the indicated stage. ">advanceSystemToStage()</a> </dd></dl>

</div>
</div>
<a id="a90042787b00c2dbdb91e9b7a647bf19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90042787b00c2dbdb91e9b7a647bf19d">&#9670;&nbsp;</a></span>advanceSystemToStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::advanceSystemToStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the System-level current stage by one to the indicated stage. </p>
<p>This can only be done if <em>all</em> <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> have already been advanced to this <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a8c94044ec3bdfdfe0a046031bcd5681f" title="Advance a particular Subsystem&#39;s current stage by one to the indicated stage. ">advanceSubsystemToStage()</a> </dd></dl>

</div>
</div>
<a id="a89309dc29d22e97c3b41a8d7cd93e6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89309dc29d22e97c3b41a8d7cd93e6a2">&#9670;&nbsp;</a></span>getSystemTopologyStageVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> SimTK::State::getSystemTopologyStageVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Topology stage version number (an integer) stored in this State must match the topology cache version number stored in the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> for which it is allegedly a state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1System.html#a9098487689f44873c275731d1cc571cf" title="(Advanced) Return the current version number of this system&#39;s Topology cache information. ">System::getSystemTopologyCacheVersion()</a> </dd></dl>

</div>
</div>
<a id="a31299e8d0eb4446e9739598d604dd0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31299e8d0eb4446e9739598d604dd0fb">&#9670;&nbsp;</a></span>allocateQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1QIndex.html">QIndex</a> SimTK::State::allocateQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate generalized coordinates <em>q</em>, which are second order continuous state variables. </p>
<p>Matching cache entries <em>qdot</em> and <em>qdotdot</em> are allocated to hold the first and second time derivatives of <em>q</em>. The supplied vector <em>qInit</em> is used to specify the number of <em>q's</em> to be allocated and their initial values. The Subsystem-local <a class="el" href="classSimTK_1_1QIndex.html" title="Unique integer type for Subsystem-local q indexing. ">QIndex</a> of the first allocated <em>q</em> is returned; the others follow consecutively. </p>

</div>
</div>
<a id="ae4988e8d824beb1161a67d8e2a1d4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4988e8d824beb1161a67d8e2a1d4c85">&#9670;&nbsp;</a></span>allocateU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> SimTK::State::allocateU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>uInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate generalized speeds <em>u</em>, which are first order continuous state variables related to the derivatives of the second order <em>q's</em> by qdot=N(q)*u, for a System-defined coupling matrix N. </p>
<p>A matching cache entry <em>udot</em> is allocated to hold the time derivative of <em>u</em>. The supplied vector <em>uInit</em> is used to specify the number of <em>u's</em> to be allocated and their initial values. The Subsystem-local <a class="el" href="classSimTK_1_1UIndex.html" title="Unique integer type for Subsystem-local u indexing. ">UIndex</a> of the first allocated <em>u</em> is returned; the others follow consecutively. </p>

</div>
</div>
<a id="aeb532c8ae68fded77c3d943218a3eb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb532c8ae68fded77c3d943218a3eb54">&#9670;&nbsp;</a></span>allocateZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ZIndex.html">ZIndex</a> SimTK::State::allocateZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>zInit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate auxiliary first order continuous state variables <em>z</em>. </p>
<p>A matching cache entry <em>zdot</em> is allocated to hold the time derivative of <em>z</em>. The supplied vector <em>zInit</em> is used to specify the number of <em>z's</em> to be allocated and their initial values. The Subsystem-local <a class="el" href="classSimTK_1_1ZIndex.html" title="Unique integer type for Subsystem-local z indexing. ">ZIndex</a> of the first allocated <em>z</em> is returned; the others follow consecutively. </p>

</div>
</div>
<a id="a51730fe482557455030b56ea468371e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51730fe482557455030b56ea468371e9">&#9670;&nbsp;</a></span>allocateQErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1QErrIndex.html">QErrIndex</a> SimTK::State::allocateQErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nqerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <em>nqerr</em> cache slots to hold the current error for position-level (holonomic) constraint equations. </p>

</div>
</div>
<a id="aa51bd56abbb91f73ed8c9fc04fa433fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51bd56abbb91f73ed8c9fc04fa433fa">&#9670;&nbsp;</a></span>allocateUErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UErrIndex.html">UErrIndex</a> SimTK::State::allocateUErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nuerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <em>nuerr</em> cache slots to hold the current error for velocity-level (nonholonomic and holonomic first derivative) constraint equations. </p>

</div>
</div>
<a id="a97ce8e273dab1ccb3bae95f0e10c16bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ce8e273dab1ccb3bae95f0e10c16bb">&#9670;&nbsp;</a></span>allocateUDotErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UDotErrIndex.html">UDotErrIndex</a> SimTK::State::allocateUDotErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nudoterr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <em>nudoterr</em> cache slots to hold the current error for acceleration-level (acceleration-only, nonholonomic first derivative, and holonomic second derivative) constraint equations. </p>
<p>This also allocates the same number of slots in the constraint multipliers vector. </p>

</div>
</div>
<a id="aea9d50f4caecd95aa13c0408b1849830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d50f4caecd95aa13c0408b1849830">&#9670;&nbsp;</a></span>allocateEventTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1EventTriggerByStageIndex.html">EventTriggerByStageIndex</a> SimTK::State::allocateEventTrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nevent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate room for <em>nevent</em> witness function values that will be available at the indicated <em>stage</em>. </p>
<p>The Subsystem- and Stage-local index of the first allocated witness is returned; the rest follow consecutively. </p>

</div>
</div>
<a id="ae7fc9b56d326138a77e39bd73ad59aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fc9b56d326138a77e39bd73ad59aaa">&#9670;&nbsp;</a></span>allocateDiscreteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> SimTK::State::allocateDiscreteVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>invalidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> supplied here in the call is the earliest subsystem stage which is invalidated by a change made to this discrete variable. </p>
<p>You may access the value of the discrete variable for reading (via <a class="el" href="classSimTK_1_1State.html#ac3f47c2becd6ce07a00bdc86b332716d" title="Get the current value of the indicated discrete variable. ">getDiscreteVariable()</a>) or writing (via <a class="el" href="classSimTK_1_1State.html#a836298382ef60e18f64e850e89146075" title="Get a writable reference to the value stored in the indicated discrete state variable dv...">updDiscreteVariable()</a>) any time after it has been allocated. Access for writing has the side effect of reducing the subsystem and system stages for this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> to one stage below the one supplied here, that is, the stage supplied here is invalidated. Note that you must have write access to the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> in order to change the value of any state variable.</p>
<p>Ownership of the <a class="el" href="classSimTK_1_1AbstractValue.html" title="Abstract base class representing an arbitrary value of unknown type. ">AbstractValue</a> object supplied here is taken over by the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> &ndash; don't delete the object after this call! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ac3f47c2becd6ce07a00bdc86b332716d" title="Get the current value of the indicated discrete variable. ">getDiscreteVariable()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1State.html#a836298382ef60e18f64e850e89146075" title="Get a writable reference to the value stored in the indicated discrete state variable dv...">updDiscreteVariable()</a> </dd></dl>

</div>
</div>
<a id="aaa2b067d10792c14666301c9bf2d77b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2b067d10792c14666301c9bf2d77b9">&#9670;&nbsp;</a></span>allocateAutoUpdateDiscreteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> SimTK::State::allocateAutoUpdateDiscreteVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>invalidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>updateDependsOn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allocates a DiscreteVariable whose value should be updated automatically after each time step. </p>
<p>A CacheEntry of the same value type as the variable is allocated to hold the update value. The discrete variable is allocated as described for <a class="el" href="classSimTK_1_1State.html#ae7fc9b56d326138a77e39bd73ad59aaa" title="The Stage supplied here in the call is the earliest subsystem stage which is invalidated by a change ...">allocateDiscreteVariable()</a>, except that the <em>invalidates</em> stage must be higher than <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a06ce2e5708ad9e6c20d8265601afbdb9" title="A new time has been realized. ">Stage::Time</a>. The cache entry is allocated as described for <a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a> without an automatic calculation (<em>latest</em>) stage. The cache entry is then considered to be the "update" value for the discrete variable. Update values play a similar role for discrete variables as derivatives play for continuous variables. That is, they define how the variable is to be updated when a <a class="el" href="classSimTK_1_1TimeStepper.html" title="This class uses an Integrator to advance a System through time. ">TimeStepper</a> accepts a step.</p>
<p>Update occurs as follows: at the start of every continuous interval, after all other pending events have been handled, a time stepper should call the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> method <a class="el" href="classSimTK_1_1State.html#a30b1ef1c1e2b8e9687e413c2eea0eb17" title="(Advanced) This is called at the beginning of every integration step to set the values of auto-update...">autoUpdateDiscreteVariables()</a>. That method looks at all the auto-update discrete variables to see which ones have valid update values. For each valid value, the discrete variable and its update value are swapped, and the new cache value is marked invalid.</p>
<dl class="section note"><dt>Note</dt><dd>No stage is invalidated by the swap even though this is clearly modifying the state variable. It is up to the user of this variable to make sure that is reasonable, by using the <em>update value</em>, not the <em>variable value</em> for computations during realize(). In that way the results are always calculated using the value as it will be <em>after</em> an update. That means that no results will change when the swap occurs, so no stage needs to be invalidated upon updating. If you do use both values, make sure that all computed results remain unchanged from the end of one step to the beginning of the next.</dd></dl>
<p>The above behavior is entirely analogous to the treatment of continuous variables like q: the integrator ensures that only updated values of q are seen when evaluations are made at intermediate or trial steps; you should do the same. In contrast to this auto-update behavior, any <em>explicit</em> change to the discrete variable will invalidate the variable's <em>invalidates</em> stage just as for a non-auto-updating discrete variable. The auto-update cache entry is always invalidated by an explicit change to the variable, as well as by the <em>updateDependsOn</em> stage being invalidated.</p>
<p>Ownership of the <a class="el" href="classSimTK_1_1AbstractValue.html" title="Abstract base class representing an arbitrary value of unknown type. ">AbstractValue</a> object supplied here is taken over by the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> &ndash; don't delete the object after this call! A clone() of this value will be used in the auto-update cache entry so there will be two objects of this type around at run time that get swapped back and forth between the state variable and the cache entry.</p>
<p>You can allocate discrete variables in a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> at Topology stage or Model stage but not later. That is, you allocate the variable while the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> is in <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a>, and then it appears when you do realizeTopology(); or, you allocate the variable when the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> is in <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a> and it appears when you do realizeModel().</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ae7fc9b56d326138a77e39bd73ad59aaa" title="The Stage supplied here in the call is the earliest subsystem stage which is invalidated by a change ...">allocateDiscreteVariable()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a> </dd></dl>

</div>
</div>
<a id="aa1d47cbf8652f97a5fde685478c74954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d47cbf8652f97a5fde685478c74954">&#9670;&nbsp;</a></span>getDiscreteVarUpdateIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> SimTK::State::getDiscreteVarUpdateIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an auto-updating discrete variable, return the <a class="el" href="classSimTK_1_1CacheEntryIndex.html" title="This unique integer type is for selecting non-shared cache entries. ">CacheEntryIndex</a> for its associated update cache entry, otherwise return an invalid index. </p>

</div>
</div>
<a id="a784ec4ea2497234a278bfb6df1e67c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784ec4ea2497234a278bfb6df1e67c6c">&#9670;&nbsp;</a></span>getDiscreteVarAllocationStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Stage.html">Stage</a> SimTK::State::getDiscreteVarAllocationStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At what stage was this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> when this discrete variable was allocated? The answer must be <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a> or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a>. </p>

</div>
</div>
<a id="a5f1d2efd9c179cf43a28158ca4c7fe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d2efd9c179cf43a28158ca4c7fe5f">&#9670;&nbsp;</a></span>getDiscreteVarInvalidatesStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Stage.html">Stage</a> SimTK::State::getDiscreteVarInvalidatesStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What is the earliest stage that is invalidated when this discrete variable is modified? All later stages are also invalidated. </p>
<p>This stage was set when the discrete variable was allocated and can't be changed with unallocating it first. </p>

</div>
</div>
<a id="ac3f47c2becd6ce07a00bdc86b332716d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f47c2becd6ce07a00bdc86b332716d">&#9670;&nbsp;</a></span>getDiscreteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::getDiscreteVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current value of the indicated discrete variable. </p>
<p>This requires only that the variable has already been allocated and will fail otherwise. </p>

</div>
</div>
<a id="a87e695448606960d9b6efcee1766702c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e695448606960d9b6efcee1766702c">&#9670;&nbsp;</a></span>getDiscreteVarLastUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::State::getDiscreteVarLastUpdateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the time of last update for this discrete variable. </p>

</div>
</div>
<a id="a55f59135730c847a29d09c494d04f20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f59135730c847a29d09c494d04f20c">&#9670;&nbsp;</a></span>getDiscreteVarUpdateValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::getDiscreteVarUpdateValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an auto-updating discrete variable, return the current value of its associated update cache entry; this is the value the discrete variable will have the next time it is updated. </p>
<p>This will fail if the value is not valid or if this is not an auto-update discrete variable. </p>

</div>
</div>
<a id="a63a6cddb2c20e4496723136242c5a60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a6cddb2c20e4496723136242c5a60c">&#9670;&nbsp;</a></span>updDiscreteVarUpdateValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::updDiscreteVarUpdateValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an auto-updating discrete variable, return a writable reference to the value of its associated update cache entry. </p>
<p>This will be the value that this discrete variable will have when it is next updated. Don't forget to mark the cache entry valid after you have updated it. This will fail if this is not an auto-update discrete variable. </p>

</div>
</div>
<a id="a48f481c3d79705cd5f4ac85754355645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f481c3d79705cd5f4ac85754355645">&#9670;&nbsp;</a></span>isDiscreteVarUpdateValueRealized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::State::isDiscreteVarUpdateValueRealized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the update value for this auto-update discrete variable has already been computed since the last change to state variables it depends on. </p>

</div>
</div>
<a id="ae0d91317f60dc4d9477b1b6f11d9cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d91317f60dc4d9477b1b6f11d9cb37">&#9670;&nbsp;</a></span>markDiscreteVarUpdateValueRealized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::markDiscreteVarUpdateValueRealized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the update value for this auto-update discrete variable as up-to-date with respect to the state variables it depends on. </p>

</div>
</div>
<a id="a836298382ef60e18f64e850e89146075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836298382ef60e18f64e850e89146075">&#9670;&nbsp;</a></span>updDiscreteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::updDiscreteVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable reference to the value stored in the indicated discrete state variable dv, and invalidate stage dv.invalidates and all higher stages. </p>
<p>The current time is recorded as the variable's "last update time". </p>

</div>
</div>
<a id="a063c76cfff04618f04734c8cf4d2ed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c76cfff04618f04734c8cf4d2ed57">&#9670;&nbsp;</a></span>setDiscreteVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setDiscreteVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to updDiscreteVariable. </p>

</div>
</div>
<a id="ad50d2ab0c6326eed4fc78ea3dd06e3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50d2ab0c6326eed4fc78ea3dd06e3d3">&#9670;&nbsp;</a></span>allocateCacheEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> SimTK::State::allocateCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>earliest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>latest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are two Stages supplied explicitly as arguments to this method: <em>earliest</em> and <em>latest</em>. </p>
<p>The <em>earliest</em> <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> is the stage at which the cache entry <em>could</em> be calculated. Hence if the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> stage is reduced below <em>earliest</em> the cache entry is known to be invalid. The <em>latest</em> <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>, if any, is the stage at which the cache entry is <em>guaranteed</em> to have been calculated (typically as the result of a System-wide realize() call to that stage). For stages <em>earliest</em> through <em>latest-1</em>, the cache entry <em>may</em> be valid, if it has already been calculated. In that case an explicit validity indicator will have been set at the time it was computed, via <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a>. That indicator is cleared automatically whenever the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> stage is reduced below <em>earliest</em>. The validity indicator need not have been set in order for the cache entry to be deemed valid at <em>latest</em> stage.</p>
<p>If <em>latest</em> is given as <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af1940a612a2fd4cb358e87322b7815d9" title="Higher than any legitimate Stage. ">Stage::Infinity</a> then there is no guarantee that this <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> will automatically calculate a value for this cache entry, which makes it a "lazy" evaluation that is done only if requested. In that case the only way the cache entry can become valid is if the calculation is performed and the validity indicator is set explicitly with <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a>. Here is how we suggest you structure lazy evaluation of a cache entry CE of type CEType and <a class="el" href="classSimTK_1_1CacheEntryIndex.html" title="This unique integer type is for selecting non-shared cache entries. ">CacheEntryIndex</a> CEIndex (this is pseudocode):</p>
<p>(1) Allocate your lazy cache entry something like this: </p><div class="fragment"><div class="line">CEIndex = s.allocateLazyCacheEntry(subsys,stage,<span class="keyword">new</span> Value&lt;CEType&gt;());</div></div><!-- fragment --><p> (2) Write a realizeCE() method structured like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> realizeCE(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1State.html#a718a90ef538a16cfd6a5fd4f89f3857f">State</a>&amp; s)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">if</span> (s.isCacheValueRealized(subsys,CEIndex)) </div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    <span class="comment">// calculate the cache entry, update with updCacheEntry()</span></div><div class="line">    s.markCacheValueRealized(subsys,CEIndex);</div><div class="line">}</div></div><!-- fragment --><p> (3) Write a getCE() method structured like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> CEType&amp; getCE(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1State.html#a718a90ef538a16cfd6a5fd4f89f3857f">State</a>&amp; s)<span class="keyword"> const </span>{</div><div class="line">    realizeCE(s); <span class="comment">// make sure CE has been calculated</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Value.html#a4ee7953a27a64c053c4d1d4ce446b04d">Value&lt;CEType&gt;::downcast</a>(s.getCacheEntry(subsys,CEIndex));</div><div class="line">}</div></div><!-- fragment --><p> (4) Write an updCE() method like this: </p><div class="fragment"><div class="line">CEType&amp; updCE(<span class="keyword">const</span> <a class="code" href="classSimTK_1_1State.html#a718a90ef538a16cfd6a5fd4f89f3857f">State</a>&amp; s)<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classSimTK_1_1Value.html#a9590dd1f7d98e008733cc6c30765cc84">Value&lt;CEType&gt;::updDowncast</a>(s.updCacheEntry(subsys,CEIndex));</div><div class="line">}</div></div><!-- fragment --><p>Then access CE <em>only</em> through your getCE() method. There should be only one place in your code where <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a> and <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> are called for a particular cache entry. If you do this from multiple locations there is a high probability of a bug being introduced, especially due to later modification of the code.</p>
<p>Prior to the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> advancing to <em>earliest</em> stage, and prior to <em>latest</em> stage unless the validity indicator is set, attempts to look at the value via <a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a> will throw an exception. However, you may access the cache entry for writing via <a class="el" href="classSimTK_1_1State.html#a2434b9f4619f59b91f049be7bf7bf7c6" title="Retrieve a writable reference to the value contained in a particular cache entry. ...">updCacheEntry()</a> any time after stage <em>earliest-1</em>. If you evaluate it prior to <em>latest</em>, be sure to explicitly mark it valid. Note that cache entries are mutable so you do not need write access to the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> in order to access a cache entry for writing.</p>
<p>Ownership of the <a class="el" href="classSimTK_1_1AbstractValue.html" title="Abstract base class representing an arbitrary value of unknown type. ">AbstractValue</a> object supplied here is taken over by the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> &ndash; don't delete the object after this call! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#a2434b9f4619f59b91f049be7bf7bf7c6" title="Retrieve a writable reference to the value contained in a particular cache entry. ...">updCacheEntry()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1State.html#a61e6878b4a12b3fc5b98a8327872b264" title="This is an abbreviation for allocation of a lazy cache entry. ">allocateLazyCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> </dd></dl>

</div>
</div>
<a id="acb9f101ddceed0c34c6ee6f375dceccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9f101ddceed0c34c6ee6f375dceccb">&#9670;&nbsp;</a></span>allocateCacheEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> SimTK::State::allocateCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an abbreviation for allocation of a cache entry whose earliest and latest Stages are the same. </p>
<p>That is, this cache entry is guaranteed to be valid if its <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> has advanced to the supplied <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> or later, and is guaranteed to be invalid below that <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>. </p>

</div>
</div>
<a id="a61e6878b4a12b3fc5b98a8327872b264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e6878b4a12b3fc5b98a8327872b264">&#9670;&nbsp;</a></span>allocateLazyCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> SimTK::State::allocateLazyCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>earliest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an abbreviation for allocation of a lazy cache entry. </p>
<p>The <em>earliest</em> stage at which this <em>can</em> be evaluated is provided; but there is no stage at which the cache entry will automatically be evaluated. Instead you have to evaluate it explicitly when someone asks for it, and then call <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> to indicate that the value is available. The value is automatically invalidated when the indicated stage <em>earliest</em> is invalidated in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> </dd></dl>

</div>
</div>
<a id="a69f685181c1c13eafeb1d969650ef84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f685181c1c13eafeb1d969650ef84e">&#9670;&nbsp;</a></span>allocateCacheEntryWithPrerequisites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> SimTK::State::allocateCacheEntryWithPrerequisites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>earliest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"><em>latest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>discreteVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cacheEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Allocate a cache entry with prerequisites other than just reaching a particular computation stage. </p>
<p>Possible prerequisites are continuous variables q, u, and z; any discrete variable; and any "upstream" cache entry whose <code>earliest</code> stage is no later than this one's <code>earliest</code> stage. </p>

</div>
</div>
<a id="aa6aacc096cf8af29e32ceca85f6b5286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6aacc096cf8af29e32ceca85f6b5286">&#9670;&nbsp;</a></span>getCacheEntryAllocationStage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Stage.html">Stage</a> SimTK::State::getCacheEntryAllocationStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At what stage was this <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> when this cache entry was allocated? The answer must be <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a7952f85d965f096e94dd68d9b769f887" title="Lower than any legitimate Stage. ">Stage::Empty</a>, <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a>, or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>. </p>

</div>
</div>
<a id="a9bd3f94e66eb4f829b247e5dc71b74e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd3f94e66eb4f829b247e5dc71b74e8">&#9670;&nbsp;</a></span>getCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::getCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to the value contained in a particular cache entry. </p>
<p>The value must be up to date with respect to the state variables it depends on or this will throw an exception. No calculation will be performed here. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a2434b9f4619f59b91f049be7bf7bf7c6" title="Retrieve a writable reference to the value contained in a particular cache entry. ...">updCacheEntry()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> </dd></dl>

</div>
</div>
<a id="a2434b9f4619f59b91f049be7bf7bf7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2434b9f4619f59b91f049be7bf7bf7c6">&#9670;&nbsp;</a></span>updCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a>&amp; SimTK::State::updCacheEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a writable reference to the value contained in a particular cache entry. </p>
<p>You can access a cache entry for writing any time after it has been allocated. This does not affect the current stage. The cache entry will neither be invalidated nor marked valid by accessing it here. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> </dd></dl>

</div>
</div>
<a id="aeffe2e602ff82897322d4ae6b5be3974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffe2e602ff82897322d4ae6b5be3974">&#9670;&nbsp;</a></span>isCacheValueRealized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::State::isCacheValueRealized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the value in a particular cache entry has been recalculated since the last change to the state variables it depends on. </p>
<p>Validity can result either from an explicit call to <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> or by this State's stage reaching the <em>latest</em> stage specified when the cache entry was allocated, after which the value is <em>presumed</em> valid. If this method returns true, then you can access the value with <a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a> without getting an exception thrown. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a> </dd></dl>

</div>
</div>
<a id="a9293f334adc4b01091934b6b9a361f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9293f334adc4b01091934b6b9a361f28">&#9670;&nbsp;</a></span>markCacheValueRealized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::markCacheValueRealized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the value of a particular cache entry as up to date after it has been recalculated. </p>
<p>This State's current stage must be at least the <em>earliest</em> stage as supplied when this cache entry was allocated, and it is unnecessary to call this method if the stage has reached the specified <em>latest</em> stage since after that we'll <em>presume</em> that the cache entry's value has been realized. Note that if the <em>latest</em> stage was given as <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af1940a612a2fd4cb358e87322b7815d9" title="Higher than any legitimate Stage. ">Stage::Infinity</a> then it is always necessary to call this method prior to accessing the cache entry's value. After a cache entry has been marked valid here, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a> will return true. The cache entry is marked invalid automatically whenever a change occurs to a state variable on which it depends. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ad50d2ab0c6326eed4fc78ea3dd06e3d3" title="There are two Stages supplied explicitly as arguments to this method: earliest and latest...">allocateCacheEntry()</a>, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9bd3f94e66eb4f829b247e5dc71b74e8" title="Retrieve a const reference to the value contained in a particular cache entry. ">getCacheEntry()</a> </dd></dl>

</div>
</div>
<a id="a2edc7993b5c6594ababafecfcb3bd87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edc7993b5c6594ababafecfcb3bd87f">&#9670;&nbsp;</a></span>markCacheValueNotRealized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::markCacheValueNotRealized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Normally cache entries are invalidated automatically, however this method allows manual invalidation of the value of a particular cache entry. </p>
<p>After a cache entry has been marked invalid here, <a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a> will return false. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#aeffe2e602ff82897322d4ae6b5be3974" title="Check whether the value in a particular cache entry has been recalculated since the last change to th...">isCacheValueRealized()</a>, <a class="el" href="classSimTK_1_1State.html#a9293f334adc4b01091934b6b9a361f28" title="Mark the value of a particular cache entry as up to date after it has been recalculated. ">markCacheValueRealized()</a> </dd></dl>

</div>
</div>
<a id="aab1591fbfc16916a36bb55c73f45c4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1591fbfc16916a36bb55c73f45c4b9">&#9670;&nbsp;</a></span>getNY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number ny=nq+nu+nz of shared continuous state variables. </p>
<p>This is also the number of state derivatives in the cache entry ydot. Callable at Model stage. </p>

</div>
</div>
<a id="a31594d0f20222cd35b55eb0f64136f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31594d0f20222cd35b55eb0f64136f1a">&#9670;&nbsp;</a></span>getNQ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of shared q's (generalized coordinates; second order state variables). </p>
<p>This is also the number of first and second q time derivatives in the cache entries qdot and qdotdot. Callable at Model stage. </p>

</div>
</div>
<a id="a7d42f6ac58bfb9c8fb3bef2321d82eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d42f6ac58bfb9c8fb3bef2321d82eae">&#9670;&nbsp;</a></span>getQStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a> SimTK::State::getQStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the y index at which the q's begin. Callable at Model stage. </p>

</div>
</div>
<a id="a6bf2142114256d777c7f4a00553e151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf2142114256d777c7f4a00553e151a">&#9670;&nbsp;</a></span>getNU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of shared u's (generalized speeds; mobilities). </p>
<p>This is also the number of u time derivatives in the cache entry udot. Callable at Model stage. </p>

</div>
</div>
<a id="a5f483b0cc0b9df6646108944e1f6b9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f483b0cc0b9df6646108944e1f6b9ae">&#9670;&nbsp;</a></span>getUStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a> SimTK::State::getUStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the y index at which the u's begin. Callable at Model stage. </p>

</div>
</div>
<a id="aa7938019259ed5c714fccf3f19f7f85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7938019259ed5c714fccf3f19f7f85a">&#9670;&nbsp;</a></span>getNZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total number of shared z's (auxiliary state variables). </p>
<p>This is also the number of z time derivatives in the cache entry zdot. Callable at Model stage. </p>

</div>
</div>
<a id="a9af95be0d1d3a5a4cfe2fde3e4b514e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af95be0d1d3a5a4cfe2fde3e4b514e4">&#9670;&nbsp;</a></span>getZStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemYIndex.html">SystemYIndex</a> SimTK::State::getZStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the y index at which the z's begin. Callable at Model stage. </p>

</div>
</div>
<a id="a036445604f7e839554ee325ef467323e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036445604f7e839554ee325ef467323e">&#9670;&nbsp;</a></span>getNYErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNYErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number nyerr=nqerr+nuerr of shared cache entries for position-level and velocity-level constraint errors. </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="a0745d2467dea71aa7860c1c92b4ff852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0745d2467dea71aa7860c1c92b4ff852">&#9670;&nbsp;</a></span>getNQErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNQErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number nqerr=mp+nQuaternions of cache entries for position-level constraint errors. </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="a6124257208c313d9c0edba994038004d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6124257208c313d9c0edba994038004d">&#9670;&nbsp;</a></span>getQErrStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemYErrIndex.html">SystemYErrIndex</a> SimTK::State::getQErrStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the yErr index at which the qErr's begin. Callable at Instance stage. </p>

</div>
</div>
<a id="ab2b50e0412b0a9046ab5ea2270347b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b50e0412b0a9046ab5ea2270347b9e">&#9670;&nbsp;</a></span>getNUErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNUErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number nuerr=mp+mv of cache entries for velocity-level constraint errors (including also errors in the time derivatives of position-level constraints). </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="a1bbe931aab4f4163d8ce86b0503eb87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbe931aab4f4163d8ce86b0503eb87f">&#9670;&nbsp;</a></span>getUErrStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemYErrIndex.html">SystemYErrIndex</a> SimTK::State::getUErrStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the yErr index at which the uErr's begin. Callable at Instance stage. </p>

</div>
</div>
<a id="a082fc31461b157f1da46da2df72bcf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082fc31461b157f1da46da2df72bcf60">&#9670;&nbsp;</a></span>getNUDotErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNUDotErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number nudotErr=mp+mv+ma of cache entries for acceleration-level constraint errors (including also errors in the second time derivatives of position-level constraints and the first time derivatives of velocity-level constraints). </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="abe4eca7208c711c12149d2096ee4c18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4eca7208c711c12149d2096ee4c18f">&#9670;&nbsp;</a></span>getNMultipliers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNMultipliers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of constraint multipliers; necessarily the same as the number of acceleration-level constraint errors nUDotErr. </p>
<p>Callable at Instance stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a082fc31461b157f1da46da2df72bcf60" title="Return the total number nudotErr=mp+mv+ma of cache entries for acceleration-level constraint errors (...">getNUDotErr()</a> </dd></dl>

</div>
</div>
<a id="a076c641653cd00f82872ff64cbcb6342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076c641653cd00f82872ff64cbcb6342">&#9670;&nbsp;</a></span>getNEventTriggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNEventTriggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of event trigger function slots in the cache. </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="ae787389cc0de0b7a99ebf973c70becd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae787389cc0de0b7a99ebf973c70becd1">&#9670;&nbsp;</a></span>getNEventTriggersByStage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the partition of event trigger functions which are evaluated at a given <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>. </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="a012645eec84528408efa4be616890988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012645eec84528408efa4be616890988">&#9670;&nbsp;</a></span>getEventTriggerStartByStage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemEventTriggerIndex.html">SystemEventTriggerIndex</a> SimTK::State::getEventTriggerStartByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index within the global event trigger array at which the first of the event triggers associated with a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a> are stored; the rest follow contiguously. </p>
<p>Callable at Instance stage. </p>

</div>
</div>
<a id="a9d830f911cd7aec6500f0d2ff03cbfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d830f911cd7aec6500f0d2ff03cbfce">&#9670;&nbsp;</a></span>getStateLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex&amp; SimTK::State::getStateLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutex that should be used to lock the state whenever multiple threads are asynchronously writing/updating a common state cache. </p>
<p>A lock should always be used when thread-safe state is not guarenteed. If multiple threads are simply reading from the cache, locking the state may not be necessary. </p>

</div>
</div>
<a id="acc5a5f6746156bd509f74e6f7110cfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a5f6746156bd509f74e6f7110cfca">&#9670;&nbsp;</a></span>getQStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemQIndex.html">SystemQIndex</a> SimTK::State::getQStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9198acda366eee66d5cf1248c117edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9198acda366eee66d5cf1248c117edd">&#9670;&nbsp;</a></span>getNQ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58cc420210abb81682e23997e97989d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cc420210abb81682e23997e97989d9">&#9670;&nbsp;</a></span>getUStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemUIndex.html">SystemUIndex</a> SimTK::State::getUStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f88645b31787074b8e32107d33c536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f88645b31787074b8e32107d33c536">&#9670;&nbsp;</a></span>getNU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bef5e35cf2280b7434391a0dae1a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bef5e35cf2280b7434391a0dae1a0dc">&#9670;&nbsp;</a></span>getZStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemZIndex.html">SystemZIndex</a> SimTK::State::getZStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7b0233da5e6f4375abc09aed3061ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0233da5e6f4375abc09aed3061ca6">&#9670;&nbsp;</a></span>getNZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fabff77f983fd5f4741cc14b0a9985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fabff77f983fd5f4741cc14b0a9985b">&#9670;&nbsp;</a></span>getQErrStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemQErrIndex.html">SystemQErrIndex</a> SimTK::State::getQErrStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a15f055d671b27685ddc1eacb0884a26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f055d671b27685ddc1eacb0884a26f">&#9670;&nbsp;</a></span>getNQErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNQErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad19b0e2a13562e6c8e7935062bdedb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19b0e2a13562e6c8e7935062bdedb27">&#9670;&nbsp;</a></span>getUErrStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemUErrIndex.html">SystemUErrIndex</a> SimTK::State::getUErrStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1b52d82da83302c292ab587f6c9a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1b52d82da83302c292ab587f6c9a0b">&#9670;&nbsp;</a></span>getNUErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNUErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb94e588ba3dbb0426f5bcd4557b18cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb94e588ba3dbb0426f5bcd4557b18cc">&#9670;&nbsp;</a></span>getUDotErrStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemUDotErrIndex.html">SystemUDotErrIndex</a> SimTK::State::getUDotErrStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32f59839325094fe6e754f94e8673457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f59839325094fe6e754f94e8673457">&#9670;&nbsp;</a></span>getNUDotErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNUDotErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87c4492082f25ffb7e2773d5b9a40223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c4492082f25ffb7e2773d5b9a40223">&#9670;&nbsp;</a></span>getMultipliersStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemMultiplierIndex.html">SystemMultiplierIndex</a> SimTK::State::getMultipliersStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2b3b3ca85e41da22f2c730ee43d0055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b3b3ca85e41da22f2c730ee43d0055">&#9670;&nbsp;</a></span>getNMultipliers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNMultipliers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52b8a13e9e95510bbc8cbeaada3fd348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8a13e9e95510bbc8cbeaada3fd348">&#9670;&nbsp;</a></span>getEventTriggerStartByStage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SystemEventTriggerByStageIndex.html">SystemEventTriggerByStageIndex</a> SimTK::State::getEventTriggerStartByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9fdda8ae010c4c01086f2496df57f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fdda8ae010c4c01086f2496df57f41">&#9670;&nbsp;</a></span>getNEventTriggersByStage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::State::getNEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae937631188e36fe6505dfcef5ca4f5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae937631188e36fe6505dfcef5ca4f5f0">&#9670;&nbsp;</a></span>getEventTriggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getEventTriggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb0bf1624c0e1800b0dea50b2abaa242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0bf1624c0e1800b0dea50b2abaa242">&#9670;&nbsp;</a></span>getEventTriggersByStage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58c00117bfeac202b5b2781efa776a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c00117bfeac202b5b2781efa776a34">&#9670;&nbsp;</a></span>getEventTriggersByStage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6510b31a9638122ab7ca191ad653690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6510b31a9638122ab7ca191ad653690">&#9670;&nbsp;</a></span>updEventTriggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updEventTriggers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e8c46979e5eaa4a77d674b0ff0d41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e8c46979e5eaa4a77d674b0ff0d41f">&#9670;&nbsp;</a></span>updEventTriggersByStage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcbef800d9be58c9197f0c619ceafb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbef800d9be58c9197f0c619ceafb73">&#9670;&nbsp;</a></span>updEventTriggersByStage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updEventTriggersByStage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfef05086f246eb3a2840f1a9ad9666d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfef05086f246eb3a2840f1a9ad9666d">&#9670;&nbsp;</a></span>getQ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Per-subsystem access to the global shared variables. </p>

</div>
</div>
<a id="a103a537330cd84cd9fb83033547cd5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103a537330cd84cd9fb83033547cd5a6">&#9670;&nbsp;</a></span>getU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd1671ec5a3d645fedf0fa7d70b266f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1671ec5a3d645fedf0fa7d70b266f1">&#9670;&nbsp;</a></span>getZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a931e67e37ea549d4ce56f447ca4bc3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e67e37ea549d4ce56f447ca4bc3ac">&#9670;&nbsp;</a></span>getUWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a825d9ddb16458cfb67fae997921e303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825d9ddb16458cfb67fae997921e303f">&#9670;&nbsp;</a></span>getZWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a998c661cf0cfae47dbe7ce5a1e2e846a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998c661cf0cfae47dbe7ce5a1e2e846a">&#9670;&nbsp;</a></span>updQ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d4faebca10be06bd35e9e055d41d59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4faebca10be06bd35e9e055d41d59a">&#9670;&nbsp;</a></span>updU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c31219b0a00ca8712ee087a9d7b486b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c31219b0a00ca8712ee087a9d7b486b">&#9670;&nbsp;</a></span>updZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d331d59007c1fa6bf3f09c24a434e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d331d59007c1fa6bf3f09c24a434e75">&#9670;&nbsp;</a></span>updUWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3074f727ff1dd233ed8037309c2be403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3074f727ff1dd233ed8037309c2be403">&#9670;&nbsp;</a></span>updZWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab06f2c0ac05bcbd0a53af0df3fe9800a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06f2c0ac05bcbd0a53af0df3fe9800a">&#9670;&nbsp;</a></span>getQDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Per-subsystem access to the shared cache entries. </p>

</div>
</div>
<a id="aa142555537cd80867a44904bc6643c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142555537cd80867a44904bc6643c2f">&#9670;&nbsp;</a></span>getUDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9069c9630afec2b6f3158d11eeaf0b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9069c9630afec2b6f3158d11eeaf0b8a">&#9670;&nbsp;</a></span>getZDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11882eb9704c213460aacaa3925b3535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11882eb9704c213460aacaa3925b3535">&#9670;&nbsp;</a></span>getQDotDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQDotDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99a124682670310f9752c453f1550530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a124682670310f9752c453f1550530">&#9670;&nbsp;</a></span>updQDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aed9a71b86968194532bdf73b8446280d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9a71b86968194532bdf73b8446280d">&#9670;&nbsp;</a></span>updUDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a417820c596075754d70b4387a2e30da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417820c596075754d70b4387a2e30da3">&#9670;&nbsp;</a></span>updZDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c1b4e19cb9f44b53ba8e8c9176e5deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1b4e19cb9f44b53ba8e8c9176e5deb">&#9670;&nbsp;</a></span>updQDotDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQDotDot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad25df40622475e26ff7ebae2d788db67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25df40622475e26ff7ebae2d788db67">&#9670;&nbsp;</a></span>getQErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a540fac0201b34b2259a63388c8cece02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540fac0201b34b2259a63388c8cece02">&#9670;&nbsp;</a></span>getUErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7242f06c6bf37d2cccad2807ddab2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7242f06c6bf37d2cccad2807ddab2a1">&#9670;&nbsp;</a></span>getUDotErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUDotErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa439d92d79754e2ba31b2fda0736868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa439d92d79754e2ba31b2fda0736868d">&#9670;&nbsp;</a></span>getMultipliers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getMultipliers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec1434a637071931e65010ccf515891f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1434a637071931e65010ccf515891f">&#9670;&nbsp;</a></span>getQErrWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQErrWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65b8527b6865870c34839cde41adc557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b8527b6865870c34839cde41adc557">&#9670;&nbsp;</a></span>getUErrWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUErrWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aefbe52f140d204adbcc69aa72c2adad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbe52f140d204adbcc69aa72c2adad9">&#9670;&nbsp;</a></span>updQErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f13e2cddf532c946e1943eda13aea8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f13e2cddf532c946e1943eda13aea8b">&#9670;&nbsp;</a></span>updUErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f1f023369a3eb10b9fd03a42e2c146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f1f023369a3eb10b9fd03a42e2c146">&#9670;&nbsp;</a></span>updUDotErr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUDotErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a912b355d8d5d0450b7b263ad33e765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a912b355d8d5d0450b7b263ad33e765">&#9670;&nbsp;</a></span>updMultipliers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updMultipliers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc0d8452c50d9f472aea76f4054697de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0d8452c50d9f472aea76f4054697de">&#9670;&nbsp;</a></span>updQErrWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQErrWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a78dcf460b49fc2ee3087581817a021b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dcf460b49fc2ee3087581817a021b3">&#9670;&nbsp;</a></span>updUErrWeights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUErrWeights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c6a82b454c04ed89dfb3d48e3aad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c6a82b454c04ed89dfb3d48e3aad89">&#9670;&nbsp;</a></span>getTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&amp; SimTK::State::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You can call these as long as <em>system</em> stage &gt;= Model. </p>

</div>
</div>
<a id="a5fbdb5a64fdca6881a783917be081f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbdb5a64fdca6881a783917be081f7c">&#9670;&nbsp;</a></span>getY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af738e098a8785a581bab83977335ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af738e098a8785a581bab83977335ecf0">&#9670;&nbsp;</a></span>getQ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are just views into Y. </p>

</div>
</div>
<a id="a6181af8fa9d255ff427812630ac56929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6181af8fa9d255ff427812630ac56929">&#9670;&nbsp;</a></span>getU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91e08f5ebcb3568e5a328f8326504ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e08f5ebcb3568e5a328f8326504ea5">&#9670;&nbsp;</a></span>getZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe9e2dc6b441261d4e0a42c8fffd8212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e2dc6b441261d4e0a42c8fffd8212">&#9670;&nbsp;</a></span>getUWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a unit weighting (1/unit change) for each u that can be used to weight a vector du so that the disparate elements are comparable in physical effect. </p>
<p>This permits mixing of generalized speeds that have different units, and scaling of generalized speeds that have differing amounts of leverage due to their positions in the multibody tree. This can be used to create a scaled norm that represents the overall significance of a change du to u.</p>
<p>Define a unit change di for each ui such that a change ui+eps*di to each generalized speed in turn produces a physical velocity change of roughly equal significance. Then a diagonal matrix Wu=diag(1/di) is a weighting matrix such that wdu=Wu*du is a vector in which each element wdu_i has units of "unit change" for its corresponding ui. This method returns a vector which is the diagonal of Wu.</p>
<p>These same weights on u also determine the scaling of the generalized coordinates q, because q and u are related via qdot=N*u. For cases where qdot_i=u_i, the numerical value of the unit change to q_i is just di because dP/dq_i == dV/du_i. Otherwise, they are related by Wq = N*Wu*pinv(N) where Wq is the weighting matrix for dq (block diagonal), and pinv() is the pseudoinverse.</p>
<p>For example, say you define unit scaling for an angle coordinate to be 1 radian (about 57 degrees), meaning that a 1 radian change of coordinate produces (roughly) one length unit of meaningful position change. Then if a generalized coordinate is measured in radians, its unit scale would be 1. If instead you created a generalized coordinate with units of degrees, its unit scale would be 57 degrees. That would allow mixing of such coordinates in the same system by bringing the coordinates into a physically-meaningful basis. Scaling is defined in the u basis where each variable is independent; the N matrix couples variables in the q basis. So here the units would actually be 1 radian/time unit and 57 degrees/time unit (numerically identical).</p>
<p>This is allocated and set to 1 at the end of realize(Model). </p>

</div>
</div>
<a id="ab160c534ea60aa1392c86da43be2958a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab160c534ea60aa1392c86da43be2958a">&#9670;&nbsp;</a></span>getZWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a unit weighting (1/unit change) for each z that can be used to weight a vector dz so that the disparate elements are comparable in physical effect. </p>
<p>This defines a weighting matrix Wz=diag(1/unitchange_zi) such that wdz=Wz*dz is a vector in which each element wdz_i has units of "unit change" for its corresponding zi. This method returns a vector which is the diagonal of Wz. </p>

</div>
</div>
<a id="aa2b4a718e984085983c9edc6507b3274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b4a718e984085983c9edc6507b3274">&#9670;&nbsp;</a></span>updUWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set u weights (and q weights indirectly). </p>
<p>You can call this after Model stage has been realized. This will invalidate just Report stage because it is not used in calculating udots. </p>

</div>
</div>
<a id="ad45c5bc8d846bf15ab20c8f239843383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45c5bc8d846bf15ab20c8f239843383">&#9670;&nbsp;</a></span>updZWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set z weights. </p>
<p>You can call this after Model stage has been realized. This will invalidate just Report stage because it is not used in calculating zdots. </p>

</div>
</div>
<a id="ad383c266a4f58c5ae6fe12e6fa60f5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383c266a4f58c5ae6fe12e6fa60f5c9">&#9670;&nbsp;</a></span>updTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&amp; SimTK::State::updTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You can call these as long as <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> stage &gt;= Model, but the stage will be backed up if necessary to the indicated stage. </p>

</div>
</div>
<a id="ae3f395b315b5e7c9e45c3049ef5e79dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f395b315b5e7c9e45c3049ef5e79dd">&#9670;&nbsp;</a></span>updY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc4d78f371896753ece80fe92eb8eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc4d78f371896753ece80fe92eb8eaf">&#9670;&nbsp;</a></span>setTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alternate syntax equivalent to <a class="el" href="classSimTK_1_1State.html#ad383c266a4f58c5ae6fe12e6fa60f5c9" title="You can call these as long as System stage &gt;= Model, but the stage will be backed up if necessary to ...">updTime()</a> and <a class="el" href="classSimTK_1_1State.html#ae3f395b315b5e7c9e45c3049ef5e79dd">updY()</a>. </p>

</div>
</div>
<a id="a12b6c852725c0c1cbc3632f3fb51a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b6c852725c0c1cbc3632f3fb51a395">&#9670;&nbsp;</a></span>setY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setY </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00fad986d5547dd10b1f5f7bad802d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fad986d5547dd10b1f5f7bad802d1e">&#9670;&nbsp;</a></span>updQ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are just views into Y. </p>

</div>
</div>
<a id="a30d88df32c0564319245e2d0926d8083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d88df32c0564319245e2d0926d8083">&#9670;&nbsp;</a></span>updU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ec53ed9d99548566703a4b2185c2511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec53ed9d99548566703a4b2185c2511">&#9670;&nbsp;</a></span>updZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9181b7d2f1cf17be5b75061e488a70bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9181b7d2f1cf17be5b75061e488a70bb">&#9670;&nbsp;</a></span>setQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface. </p>

</div>
</div>
<a id="a09fcba284ec2e81d7f2fac2b64e43086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fcba284ec2e81d7f2fac2b64e43086">&#9670;&nbsp;</a></span>setU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c4166209fae1e16ca2b9191aec5d64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4166209fae1e16ca2b9191aec5d64e">&#9670;&nbsp;</a></span>setZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setZ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f06de1c3eb81c8bcda79c70d8822ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06de1c3eb81c8bcda79c70d8822ccb">&#9670;&nbsp;</a></span>getYDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getYDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afff2d09293658d51a7fdb588d8467ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff2d09293658d51a7fdb588d8467ebc">&#9670;&nbsp;</a></span>getQDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are just views into YDot. </p>

</div>
</div>
<a id="a75dd0c01ec08a5c73dd9164cc8a91409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dd0c01ec08a5c73dd9164cc8a91409">&#9670;&nbsp;</a></span>getZDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getZDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ebe58c51b0d810cca6476d47c4ddbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe58c51b0d810cca6476d47c4ddbe0">&#9670;&nbsp;</a></span>getUDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b27825ccfe6a4af92482aee95d22fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b27825ccfe6a4af92482aee95d22fe9">&#9670;&nbsp;</a></span>getQDotDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQDotDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This has its own space, not a view. </p>

</div>
</div>
<a id="a2427c0f3f41063fa3cf579d86b557fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2427c0f3f41063fa3cf579d86b557fe6">&#9670;&nbsp;</a></span>updYDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updYDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are mutable. </p>

</div>
</div>
<a id="a4bfd9805097678644a0adc46806569c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfd9805097678644a0adc46806569c3">&#9670;&nbsp;</a></span>updQDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad777c9e6ad94d5222d7555dfae12d43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad777c9e6ad94d5222d7555dfae12d43e">&#9670;&nbsp;</a></span>updZDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updZDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88e6d7e76ce6f8502a02fad5eb1e8054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e6d7e76ce6f8502a02fad5eb1e8054">&#9670;&nbsp;</a></span>updUDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9988f2775ec44885803f3d2f11040d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9988f2775ec44885803f3d2f11040d62">&#9670;&nbsp;</a></span>updQDotDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQDotDot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a separate shared cache entry, not part of YDot. </p>
<p>If you have a direct 2nd order integrator you can integrate QDotDot (twice) to get Q. </p>

</div>
</div>
<a id="a292fd97ca66638c68396a9e4095ae799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292fd97ca66638c68396a9e4095ae799">&#9670;&nbsp;</a></span>getYErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getYErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current constraint errors for all constraints. </p>
<p>This is {QErr,UErr} packed and in that order. </p>

</div>
</div>
<a id="aceb5e25020b36ca267d9bab478d36235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb5e25020b36ca267d9bab478d36235">&#9670;&nbsp;</a></span>getQErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are just views into YErr. </p>

</div>
</div>
<a id="ac2bfd0d24469fc3854c4ad4d42e9eeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bfd0d24469fc3854c4ad4d42e9eeea">&#9670;&nbsp;</a></span>getUErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81e394c42ecbc470977478b3d110db0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e394c42ecbc470977478b3d110db0f">&#9670;&nbsp;</a></span>getUDotErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUDotErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These have their own space, they are not views. </p>

</div>
</div>
<a id="a758422437d8e45ef8b9f5c2a24bdf599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758422437d8e45ef8b9f5c2a24bdf599">&#9670;&nbsp;</a></span>getMultipliers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getMultipliers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e01de3e48296f95edfa82edb2218a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e01de3e48296f95edfa82edb2218a76">&#9670;&nbsp;</a></span>getQErrWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getQErrWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unit weighting (1/unit error) for each of the mp+mquat position inline constraints equations. </p>
<p>Allocated and initialized to 1 on realize(Instance). </p>

</div>
</div>
<a id="a6a5d3da654cced4f45e2cd74ff0f2a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d3da654cced4f45e2cd74ff0f2a3f">&#9670;&nbsp;</a></span>getUErrWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::getUErrWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unit weighting (1/unit error) for each of the mp+mv velocity-level inline constraint equations, meaning mp time derivatives of position (holonomic) inline constraint equations followed by mv velocity (nonholonomic) constraints. </p>
<p>Typically the weight of position constraint derivatives is just the position constraint weight times the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s characteristic time scale.</p>
<p>There is no entry corresponding to quaternions here since they do not produce velocity-level constraints in Simbody's forumulation.</p>
<p>This is allocated and initialized to 1 on realize(Instance). </p>

</div>
</div>
<a id="aebb3fbf1a3f55f0ace6a69ac74e5a968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3fbf1a3f55f0ace6a69ac74e5a968">&#9670;&nbsp;</a></span>updQErrWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQErrWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the unit weighting (1/unit error) for each of the mp+mquat position inline constraint equations. </p>
<p>You can call this after the weight variable is allocated at the end of Instance stage. Position stage is invalidated to force recalculation of weighted position constraint errors. </p>

</div>
</div>
<a id="a54e8c6c59ee75df582d7fb398417f89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8c6c59ee75df582d7fb398417f89e">&#9670;&nbsp;</a></span>updUErrWeights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUErrWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the unit weighting (1/unit error) for each of the mp+mv velocity-level inline constraints. </p>
<p>You can call this after the weight variable is allocated at the end of Instance stage. Velocity stage is invalidated to force recalculation of weighted velocity-level constraint errors. </p>

</div>
</div>
<a id="a63978bdd9b8f199b283051a0c022a138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63978bdd9b8f199b283051a0c022a138">&#9670;&nbsp;</a></span>updYErr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updYErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are mutable. </p>

</div>
</div>
<a id="a7587709bd6d42bde62f6051ba5c37cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7587709bd6d42bde62f6051ba5c37cf0">&#9670;&nbsp;</a></span>updQErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updQErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9828fc2e7694015ef91dd6da3f16b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9828fc2e7694015ef91dd6da3f16b516">&#9670;&nbsp;</a></span>updUErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade4efc9ede89d222115f4c3a9885ea44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4efc9ede89d222115f4c3a9885ea44">&#9670;&nbsp;</a></span>updUDotErr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updUDotErr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36ead5a89db2527671c91ad8ebeaef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ead5a89db2527671c91ad8ebeaef15">&#9670;&nbsp;</a></span>updMultipliers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::State::updMultipliers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3df5a71d4c08fd85fc4145de9bf4c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3df5a71d4c08fd85fc4145de9bf4c15">&#9670;&nbsp;</a></span>getSystemStageVersions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::getSystemStageVersions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>versions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Record the current version numbers of each valid System-level stage. </p>
<p>This can be used to unambiguously determine what stages have been changed by some opaque operation, even if that operation realized the stages after modifying them. This is particularly useful for event handlers as a way for a time stepper to know how much damage may have been done by a handler, and thus how much reinitialization is required before continuing on. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#ac8e14a5c3a2b35a3f66f97bb6f43b748" title="(Advanced) Given a list of per-stage version numbers extracted by an earlier call to getSystemStageVe...">getLowestSystemStageDifference()</a> </dd></dl>

</div>
</div>
<a id="ac8e14a5c3a2b35a3f66f97bb6f43b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e14a5c3a2b35a3f66f97bb6f43b748">&#9670;&nbsp;</a></span>getLowestSystemStageDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Stage.html">Stage</a> SimTK::State::getLowestSystemStageDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>prevVersions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Given a list of per-stage version numbers extracted by an earlier call to <a class="el" href="classSimTK_1_1State.html#af3df5a71d4c08fd85fc4145de9bf4c15" title="(Advanced) Record the current version numbers of each valid System-level stage. ">getSystemStageVersions()</a>, note the lowest system stage in the current <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose version number differs from the corresponding previous version number. </p>
<p>Returns <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af1940a612a2fd4cb358e87322b7815d9" title="Higher than any legitimate Stage. ">Stage::Infinity</a> if all the stages present in <em>prevVersions</em> are valid and have identical versions now, even if there are additional valid stages now, since nothing the caller cared about before has been changed. If the current <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> is not realized as far as the previous one, then the first unrealized stage is returned if all the lower versions match. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#af3df5a71d4c08fd85fc4145de9bf4c15" title="(Advanced) Record the current version numbers of each valid System-level stage. ">getSystemStageVersions()</a> </dd></dl>

</div>
</div>
<a id="a18fca0c246567f476fec83b86eea51a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fca0c246567f476fec83b86eea51a3">&#9670;&nbsp;</a></span>setSystemTopologyStageVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::setSystemTopologyStageVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a09991b6777d8d12d368bc95c9753b3fc">StageVersion</a>&#160;</td>
          <td class="paramname"><em>topoVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) This explicitly modifies the Topology stage version; don't use this method unless you know what you're doing! This can be used to force compatibility with a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has had Topology changes since this State was created. </p>
<p>This has no effect on the realization level. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a89309dc29d22e97c3b41a8d7cd93e6a2" title="The Topology stage version number (an integer) stored in this State must match the topology cache ver...">getSystemTopologyStageVersion()</a>, <a class="el" href="classSimTK_1_1System.html#a9098487689f44873c275731d1cc571cf" title="(Advanced) Return the current version number of this system&#39;s Topology cache information. ">System::getSystemTopologyCacheVersion()</a> </dd></dl>

</div>
</div>
<a id="a4551aaa3c0182729f9bf36b2fbfffe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4551aaa3c0182729f9bf36b2fbfffe6a">&#9670;&nbsp;</a></span>getQValueVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a> SimTK::State::getQValueVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return a ValueVersion for q, meaning an integer that is incremented whenever any q is changed (or more precisely whenever q or y is returned with writable access). </p>
<p>Will be 1 or greater if q has been allocated. </p>

</div>
</div>
<a id="aa76c4055fe998e57cf9ae76a29c442e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76c4055fe998e57cf9ae76a29c442e9">&#9670;&nbsp;</a></span>getUValueVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a> SimTK::State::getUValueVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return a ValueVersion for u, meaning an integer that is incremented whenever any u is changed (or more precisely whenever u or y is returned with writable access). </p>
<p>Will be 1 or greater if u has been allocated. </p>

</div>
</div>
<a id="a55fb41f73c69865c20659dc3baaaa0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fb41f73c69865c20659dc3baaaa0a5">&#9670;&nbsp;</a></span>getZValueVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a1939653185b956a2a6432455a31b61c4">ValueVersion</a> SimTK::State::getZValueVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return a ValueVersion for z, meaning an integer that is incremented whenever any z is changed (or more precisely whenever z or y is returned with writable access). </p>
<p>Will be 1 or greater if z has been allocated. </p>

</div>
</div>
<a id="a1895b780da66c168296aea21077fdeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1895b780da66c168296aea21077fdeab">&#9670;&nbsp;</a></span>getQDependents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ListOfDependents&amp; SimTK::State::getQDependents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return the list of cache entries for which q was specified as an explicit prerequisite. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a69f685181c1c13eafeb1d969650ef84e" title="(Advanced) Allocate a cache entry with prerequisites other than just reaching a particular computatio...">allocateCacheEntryWithPrerequisites()</a> </dd></dl>

</div>
</div>
<a id="a172f9a50d0f8011336a11230b909f012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172f9a50d0f8011336a11230b909f012">&#9670;&nbsp;</a></span>getUDependents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ListOfDependents&amp; SimTK::State::getUDependents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return the list of cache entries for which u was specified as an explicit prerequisite. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a69f685181c1c13eafeb1d969650ef84e" title="(Advanced) Allocate a cache entry with prerequisites other than just reaching a particular computatio...">allocateCacheEntryWithPrerequisites()</a> </dd></dl>

</div>
</div>
<a id="a9a89c6d8beab10b83a59f6fd1205567e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a89c6d8beab10b83a59f6fd1205567e">&#9670;&nbsp;</a></span>getZDependents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ListOfDependents&amp; SimTK::State::getZDependents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Return the list of cache entries for which z was specified as an explicit prerequisite. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1State.html#a69f685181c1c13eafeb1d969650ef84e" title="(Advanced) Allocate a cache entry with prerequisites other than just reaching a particular computatio...">allocateCacheEntryWithPrerequisites()</a> </dd></dl>

</div>
</div>
<a id="a3d59f5235ad0a93d52de44dd49cd952c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d59f5235ad0a93d52de44dd49cd952c">&#9670;&nbsp;</a></span>hasCacheEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::State::hasCacheEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;&#160;</td>
          <td class="paramname"><em>cacheEntry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Check whether this State has a particular cache entry. </p>

</div>
</div>
<a id="adcc6b6ff0d8e15b061b8ee32d6156cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc6b6ff0d8e15b061b8ee32d6156cb0">&#9670;&nbsp;</a></span>getCacheEntryInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CacheEntryInfo&amp; SimTK::State::getCacheEntryInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;&#160;</td>
          <td class="paramname"><em>cacheEntry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Return a const reference to the cache entry information for a particular cache entry. </p>
<p>No validity checking is performed. </p>

</div>
</div>
<a id="a440a11f9e6bcd3a2b41b79e1b7d4b5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a11f9e6bcd3a2b41b79e1b7d4b5d8">&#9670;&nbsp;</a></span>updCacheEntryInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CacheEntryInfo&amp; SimTK::State::updCacheEntryInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a3a55a8b16947a7261506ac7740a612bd">CacheEntryKey</a> &amp;&#160;</td>
          <td class="paramname"><em>cacheEntry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Return a writable reference to the cache entry information for a particular cache entry. </p>
<p>No validity checking is performed. </p>

</div>
</div>
<a id="a32a165f4d23ba9de1dd3c4069361fe34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a165f4d23ba9de1dd3c4069361fe34">&#9670;&nbsp;</a></span>hasDiscreteVar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::State::hasDiscreteVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &amp;&#160;</td>
          <td class="paramname"><em>discreteVar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Check whether this State has a particular discrete state variable. </p>

</div>
</div>
<a id="a49dc6bac3a60925f1ef4fdfb55b0287b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dc6bac3a60925f1ef4fdfb55b0287b">&#9670;&nbsp;</a></span>getDiscreteVarInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const DiscreteVarInfo&amp; SimTK::State::getDiscreteVarInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a07f56ab37e21fd4f35a1bd2da82188d9">DiscreteVarKey</a> &amp;&#160;</td>
          <td class="paramname"><em>discreteVar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Return a reference to the discrete variable information for a particular discrete variable. </p>

</div>
</div>
<a id="af223c2bcbf269e32ac808bd21d38b2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af223c2bcbf269e32ac808bd21d38b2b4">&#9670;&nbsp;</a></span>getPerSubsystemInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PerSubsystemInfo&amp; SimTK::State::getPerSubsystemInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Return a reference to the per-subsystem information in the state. </p>

</div>
</div>
<a id="a30b1ef1c1e2b8e9687e413c2eea0eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b1ef1c1e2b8e9687e413c2eea0eb17">&#9670;&nbsp;</a></span>autoUpdateDiscreteVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::State::autoUpdateDiscreteVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) This is called at the beginning of every integration step to set the values of auto-update discrete variables from the values stored in their associated cache entries. </p>

</div>
</div>
<a id="ad203ce6caa843bed1cadd85729b840ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad203ce6caa843bed1cadd85729b840ba">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::State::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Debugging) Not suitable for serialization. </p>

</div>
</div>
<a id="a3bb2a7ce055d8281330f88b0c6f019cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb2a7ce055d8281330f88b0c6f019cc">&#9670;&nbsp;</a></span>cacheToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::State::cacheToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Debugging) Not suitable for serialization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="State_8h_source.html">State.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1State.html">State</a></li>
    <li class="footer">Generated on Sat Jan 13 2018 15:29:18 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
