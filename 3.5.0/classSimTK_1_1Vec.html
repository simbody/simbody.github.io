<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Vec&lt; M, ELT, STRIDE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Vec.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Vec-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Vec&lt; M, ELT, STRIDE &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__MatVecUtilities.html">Matrix and Vector Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a fixed-length column vector designed for no-overhead inline computation.  
 <a href="classSimTK_1_1Vec.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1EltResult.html">EltResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1Vec_1_1Substitute.html">Substitute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape-preserving element substitution (always packed).  <a href="structSimTK_1_1Vec_1_1Substitute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are obscure members of Vec that are used for template metaprogramming and can be ignored by most users.</p>
</div></td></tr>
<tr class="memitem:ac68d02035e9fb29b2b7c810a8d3554fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca4098ba4c994d0a05d79f1f011fe826bb">NRows</a> = M, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaacb219bca801fa9b299610f154f34a04">NCols</a> = 1, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca71e046bac8a181561519a6122e2da18d">NPackedElements</a> = M, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaa25980e89b5b6f756347facaa55bd6e5">NActualElements</a> = M * STRIDE, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcaece1f9f77763466fb8f7c196fd2b8f7a">NActualScalars</a> = CNT&lt;E&gt;::NActualScalars * NActualElements, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca8f18985bf3fa11ed08b6840c04705116">RowSpacing</a> = STRIDE, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6d4bd0883fc982185b9e36f48ce39e1c">ColSpacing</a> = NActualElements, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcad531daf9c05933f95244a34b03754cda">ImagOffset</a> = NTraits&lt;ENumber&gt;::ImagOffset, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> = 1, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca4f5243de94fcb7adbf667f1a107ea625">ArgDepth</a>, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fcade2306ea77a38b5b4eb3c23646f359be">IsScalar</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca2a5ac8bb16b80ee3aab25745909e0de4">IsULessScalar</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca766b45bc4868d8a042efa4533671d18a">IsNumber</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca2816cf70d3e06a09f6c54fc943689d17">IsStdNumber</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca8f0d38ec0caa44f7307829d6ec454170">IsPrecision</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca25bedfb632d2832892205ac5572d38be">SignInterpretation</a> = CNT&lt;E&gt;::SignInterpretation
<br />
 }<tr class="memdesc:ac68d02035e9fb29b2b7c810a8d3554fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac68d02035e9fb29b2b7c810a8d3554fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4f863a54b68343ab160d46a4dfa107"><td class="memItemLeft" align="right" valign="top">typedef ELT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a></td></tr>
<tr class="memdesc:a1c4f863a54b68343ab160d46a4dfa107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this Vec.  <a href="#a1c4f863a54b68343ab160d46a4dfa107">More...</a><br /></td></tr>
<tr class="separator:a1c4f863a54b68343ab160d46a4dfa107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180db0a856dcd33f438ff607fb2d578e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a></td></tr>
<tr class="memdesc:a180db0a856dcd33f438ff607fb2d578e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negated version of this Vec's element type; ENeg==negator&lt; E &gt;.  <a href="#a180db0a856dcd33f438ff607fb2d578e">More...</a><br /></td></tr>
<tr class="separator:a180db0a856dcd33f438ff607fb2d578e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1688fa5889391ca2510ec85af32c4d27"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a></td></tr>
<tr class="memdesc:a1688fa5889391ca2510ec85af32c4d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type, stripped of negator&lt;&gt; if it has one.  <a href="#a1688fa5889391ca2510ec85af32c4d27">More...</a><br /></td></tr>
<tr class="separator:a1688fa5889391ca2510ec85af32c4d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe820179fbd756adb31a21ea1635c1b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a></td></tr>
<tr class="memdesc:a9fe820179fbd756adb31a21ea1635c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing just the real part of an element of this Vec if elements are complex; otherwise just the element type.  <a href="#a9fe820179fbd756adb31a21ea1635c1b">More...</a><br /></td></tr>
<tr class="separator:a9fe820179fbd756adb31a21ea1635c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac960a48f176aa0870f267e6555489969"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a></td></tr>
<tr class="memdesc:ac960a48f176aa0870f267e6555489969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type showing the imaginary part of an element of this Vec as real, if elements are complex; otherwise a type that can hold a zero of the element type.  <a href="#ac960a48f176aa0870f267e6555489969">More...</a><br /></td></tr>
<tr class="separator:ac960a48f176aa0870f267e6555489969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7122a7babdc45b6559fcfb2bcc5ba3e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a></td></tr>
<tr class="memdesc:aa7122a7babdc45b6559fcfb2bcc5ba3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that elements would have if complex, if E is currently real; otherwise just the element type E.  <a href="#aa7122a7babdc45b6559fcfb2bcc5ba3e">More...</a><br /></td></tr>
<tr class="separator:aa7122a7babdc45b6559fcfb2bcc5ba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a6fe2fbd6109e110319dde19ef8080"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a></td></tr>
<tr class="memdesc:af1a6fe2fbd6109e110319dde19ef8080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the Hermitian transpose of an element of this Vec.  <a href="#af1a6fe2fbd6109e110319dde19ef8080">More...</a><br /></td></tr>
<tr class="separator:af1a6fe2fbd6109e110319dde19ef8080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf724f6707ea5d622a8218c8c7d0a47a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">EPosTrans</a></td></tr>
<tr class="memdesc:aaf724f6707ea5d622a8218c8c7d0a47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a <em>positional</em> transpose of an element of this Vec.  <a href="#aaf724f6707ea5d622a8218c8c7d0a47a">More...</a><br /></td></tr>
<tr class="separator:aaf724f6707ea5d622a8218c8c7d0a47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e03a89cd7d90f90d2b77996912f7cf3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a></td></tr>
<tr class="memdesc:a9e03a89cd7d90f90d2b77996912f7cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression ~E*E (default vector and matrix square; symmetric).  <a href="#a9e03a89cd7d90f90d2b77996912f7cf3">More...</a><br /></td></tr>
<tr class="separator:a9e03a89cd7d90f90d2b77996912f7cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f65810f2f99f99286c4de7526944c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a></td></tr>
<tr class="memdesc:aed4f65810f2f99f99286c4de7526944c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the expression E*~E ("row square"; symmetric).  <a href="#aed4f65810f2f99f99286c4de7526944c">More...</a><br /></td></tr>
<tr class="separator:aed4f65810f2f99f99286c4de7526944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7edbf8f2b7e6318eb98feadb1498e6e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a></td></tr>
<tr class="memdesc:ad7edbf8f2b7e6318eb98feadb1498e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of sqrt(E).  <a href="#ad7edbf8f2b7e6318eb98feadb1498e6e">More...</a><br /></td></tr>
<tr class="separator:ad7edbf8f2b7e6318eb98feadb1498e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9328f6e879f0bce93ae861ed3830adfd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a></td></tr>
<tr class="memdesc:a9328f6e879f0bce93ae861ed3830adfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type required to hold the result of abs(E).  <a href="#a9328f6e879f0bce93ae861ed3830adfd">More...</a><br /></td></tr>
<tr class="separator:a9328f6e879f0bce93ae861ed3830adfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc83b9c25967c098119f0e604c15e3c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a></td></tr>
<tr class="memdesc:a0cc83b9c25967c098119f0e604c15e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of standardize(E) method; a packed type that can hold the value of an element after eliminating negator and conjugate types.  <a href="#a0cc83b9c25967c098119f0e604c15e3c">More...</a><br /></td></tr>
<tr class="separator:a0cc83b9c25967c098119f0e604c15e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec08218c1b188793e64d47c3d1b8d87"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a></td></tr>
<tr class="memdesc:aeec08218c1b188793e64d47c3d1b8d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from invert(E), the inverse type of an element.  <a href="#aeec08218c1b188793e64d47c3d1b8d87">More...</a><br /></td></tr>
<tr class="separator:aeec08218c1b188793e64d47c3d1b8d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074ef8ddf4b5863b9c9aa73d08b0b51"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a></td></tr>
<tr class="memdesc:a5074ef8ddf4b5863b9c9aa73d08b0b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed type that can hold the value returned from normalize(E).  <a href="#a5074ef8ddf4b5863b9c9aa73d08b0b51">More...</a><br /></td></tr>
<tr class="separator:a5074ef8ddf4b5863b9c9aa73d08b0b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c170f161ab33a760c6abed022c4e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a></td></tr>
<tr class="memdesc:afb0c170f161ab33a760c6abed022c4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#afb0c170f161ab33a760c6abed022c4e5">More...</a><br /></td></tr>
<tr class="separator:afb0c170f161ab33a760c6abed022c4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa9b9db155c966ec374279b11f7ec8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a></td></tr>
<tr class="memdesc:a43fa9b9db155c966ec374279b11f7ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a43fa9b9db155c966ec374279b11f7ec8">More...</a><br /></td></tr>
<tr class="separator:a43fa9b9db155c966ec374279b11f7ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e9c638c3725abee10ac8c0a0416938"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a></td></tr>
<tr class="memdesc:a16e9c638c3725abee10ac8c0a0416938"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a16e9c638c3725abee10ac8c0a0416938">More...</a><br /></td></tr>
<tr class="separator:a16e9c638c3725abee10ac8c0a0416938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd99fd4db282175335f6b70a09c42d3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a></td></tr>
<tr class="memdesc:a2dd99fd4db282175335f6b70a09c42d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a2dd99fd4db282175335f6b70a09c42d3">More...</a><br /></td></tr>
<tr class="separator:a2dd99fd4db282175335f6b70a09c42d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a2b3875ce3ab44712d2b46c7c8c48f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a></td></tr>
<tr class="memdesc:ab6a2b3875ce3ab44712d2b46c7c8c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ab6a2b3875ce3ab44712d2b46c7c8c48f">More...</a><br /></td></tr>
<tr class="separator:ab6a2b3875ce3ab44712d2b46c7c8c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9df16575296931169e80790f8180ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a></td></tr>
<tr class="memdesc:abb9df16575296931169e80790f8180ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#abb9df16575296931169e80790f8180ee">More...</a><br /></td></tr>
<tr class="separator:abb9df16575296931169e80790f8180ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226b3621ca279d62533bf2c2bc1494cf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">T</a></td></tr>
<tr class="memdesc:a226b3621ca279d62533bf2c2bc1494cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>.  <a href="#a226b3621ca279d62533bf2c2bc1494cf">More...</a><br /></td></tr>
<tr class="separator:a226b3621ca279d62533bf2c2bc1494cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad810229be85191609884e56063b788ce"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a></td></tr>
<tr class="memdesc:ad810229be85191609884e56063b788ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> would have if its elements were interpreted as negated.  <a href="#ad810229be85191609884e56063b788ce">More...</a><br /></td></tr>
<tr class="separator:ad810229be85191609884e56063b788ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f18f1a887b7a31eaab12703b2d56eb5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a></td></tr>
<tr class="memdesc:a5f18f1a887b7a31eaab12703b2d56eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> with negator removed from its element type, if the element is negated.  <a href="#a5f18f1a887b7a31eaab12703b2d56eb5">More...</a><br /></td></tr>
<tr class="separator:a5f18f1a887b7a31eaab12703b2d56eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbc25b0f0f1f9226dfe5796f30d459"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a>, STRIDE *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a></td></tr>
<tr class="memdesc:aebcbc25b0f0f1f9226dfe5796f30d459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> cast to show only the real part of its element; this might affect the stride.  <a href="#aebcbc25b0f0f1f9226dfe5796f30d459">More...</a><br /></td></tr>
<tr class="separator:aebcbc25b0f0f1f9226dfe5796f30d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0a11445fddc280dd6a1b3f9a54d4d3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a>, STRIDE *<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a></td></tr>
<tr class="memdesc:acf0a11445fddc280dd6a1b3f9a54d4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> cast to show only the imaginary part of its element; this might affect the stride.  <a href="#acf0a11445fddc280dd6a1b3f9a54d4d3">More...</a><br /></td></tr>
<tr class="separator:acf0a11445fddc280dd6a1b3f9a54d4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac8c95d23ac09084c957db9e0807af4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a></td></tr>
<tr class="memdesc:a3ac8c95d23ac09084c957db9e0807af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a3ac8c95d23ac09084c957db9e0807af4">More...</a><br /></td></tr>
<tr class="separator:a3ac8c95d23ac09084c957db9e0807af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664440ae833e25958fb6006815b93df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a></td></tr>
<tr class="memdesc:a1664440ae833e25958fb6006815b93df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> after casting to its Hermitian transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> and each element turns into <em>its</em> Hermitian transpose.  <a href="#a1664440ae833e25958fb6006815b93df">More...</a><br /></td></tr>
<tr class="separator:a1664440ae833e25958fb6006815b93df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c96e0dda112e02745075e8bb727651"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, STRIDE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a></td></tr>
<tr class="memdesc:a21c96e0dda112e02745075e8bb727651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> after casting to its positional transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> but the element type remains unchanged.  <a href="#a21c96e0dda112e02745075e8bb727651">More...</a><br /></td></tr>
<tr class="separator:a21c96e0dda112e02745075e8bb727651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a8e6c01acbd2f6f27769abe6f1fb8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">TElement</a></td></tr>
<tr class="memdesc:a306a8e6c01acbd2f6f27769abe6f1fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>.  <a href="#a306a8e6c01acbd2f6f27769abe6f1fb8">More...</a><br /></td></tr>
<tr class="separator:a306a8e6c01acbd2f6f27769abe6f1fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee9814da9f07edf05e10aa8bf5b52a7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">TRow</a></td></tr>
<tr class="memdesc:adee9814da9f07edf05e10aa8bf5b52a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a row of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>, just its element type).  <a href="#adee9814da9f07edf05e10aa8bf5b52a7">More...</a><br /></td></tr>
<tr class="separator:adee9814da9f07edf05e10aa8bf5b52a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bea93707d0d519f3bc680520ed6dba8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">TCol</a></td></tr>
<tr class="memdesc:a3bea93707d0d519f3bc680520ed6dba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a column of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>, the whole thing).  <a href="#a3bea93707d0d519f3bc680520ed6dba8">More...</a><br /></td></tr>
<tr class="separator:a3bea93707d0d519f3bc680520ed6dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d723146f29d99138956fe3b0d71ea6f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a></td></tr>
<tr class="memdesc:a6d723146f29d99138956fe3b0d71ea6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a6d723146f29d99138956fe3b0d71ea6f">More...</a><br /></td></tr>
<tr class="separator:a6d723146f29d99138956fe3b0d71ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429ca3d609af5044f8be5243dfba714b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a></td></tr>
<tr class="memdesc:a429ca3d609af5044f8be5243dfba714b"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a429ca3d609af5044f8be5243dfba714b">More...</a><br /></td></tr>
<tr class="separator:a429ca3d609af5044f8be5243dfba714b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f95f01fde583b2d46c9ef7a31e582e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a></td></tr>
<tr class="memdesc:ad1f95f01fde583b2d46c9ef7a31e582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ad1f95f01fde583b2d46c9ef7a31e582e">More...</a><br /></td></tr>
<tr class="separator:ad1f95f01fde583b2d46c9ef7a31e582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee68a1b3427cdc2a096be35d8b3f1f6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a></td></tr>
<tr class="memdesc:adee68a1b3427cdc2a096be35d8b3f1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#adee68a1b3427cdc2a096be35d8b3f1f6">More...</a><br /></td></tr>
<tr class="separator:adee68a1b3427cdc2a096be35d8b3f1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4d20cd03be610a163f04985d74822d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a></td></tr>
<tr class="memdesc:a5f4d20cd03be610a163f04985d74822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a5f4d20cd03be610a163f04985d74822d">More...</a><br /></td></tr>
<tr class="separator:a5f4d20cd03be610a163f04985d74822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba33f5ae46bd5406b8bead75d3225e08"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a></td></tr>
<tr class="memdesc:aba33f5ae46bd5406b8bead75d3225e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#aba33f5ae46bd5406b8bead75d3225e08">More...</a><br /></td></tr>
<tr class="separator:aba33f5ae46bd5406b8bead75d3225e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af941dd81c240827a807b59925f9353ae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a></td></tr>
<tr class="memdesc:af941dd81c240827a807b59925f9353ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#af941dd81c240827a807b59925f9353ae">More...</a><br /></td></tr>
<tr class="separator:af941dd81c240827a807b59925f9353ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747df15d62910c4e106267ff6a6456c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a></td></tr>
<tr class="memdesc:a2747df15d62910c4e106267ff6a6456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#a2747df15d62910c4e106267ff6a6456c">More...</a><br /></td></tr>
<tr class="separator:a2747df15d62910c4e106267ff6a6456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d06bc21666d641e6e8fc1d2348474"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a></td></tr>
<tr class="memdesc:acd8d06bc21666d641e6e8fc1d2348474"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#acd8d06bc21666d641e6e8fc1d2348474">More...</a><br /></td></tr>
<tr class="separator:acd8d06bc21666d641e6e8fc1d2348474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dcbe4f4c13eab6d32664b39c53067e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a></td></tr>
<tr class="memdesc:ad2dcbe4f4c13eab6d32664b39c53067e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ad2dcbe4f4c13eab6d32664b39c53067e">More...</a><br /></td></tr>
<tr class="separator:ad2dcbe4f4c13eab6d32664b39c53067e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3382cfdf59b23ac5fe16a359b9800e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a></td></tr>
<tr class="memdesc:aed3382cfdf59b23ac5fe16a359b9800e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#aed3382cfdf59b23ac5fe16a359b9800e">More...</a><br /></td></tr>
<tr class="separator:aed3382cfdf59b23ac5fe16a359b9800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41c74dcba45cbeccdafdc3c9276048d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a></td></tr>
<tr class="memdesc:af41c74dcba45cbeccdafdc3c9276048d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#af41c74dcba45cbeccdafdc3c9276048d">More...</a><br /></td></tr>
<tr class="separator:af41c74dcba45cbeccdafdc3c9276048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5410fb3fc14453b32ced2e8134ad36c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a></td></tr>
<tr class="memdesc:ac5410fb3fc14453b32ced2e8134ad36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>).  <a href="#ac5410fb3fc14453b32ced2e8134ad36c">More...</a><br /></td></tr>
<tr class="separator:ac5410fb3fc14453b32ced2e8134ad36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a712141bb4fe924637c14555b1954b66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a712141bb4fe924637c14555b1954b66a">scalarNormSqr</a> () const </td></tr>
<tr class="memdesc:a712141bb4fe924637c14555b1954b66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar norm square is sum( conjugate squares of all underlying scalars ), where conjugate square of scalar s is conj(s)*s.  <a href="#a712141bb4fe924637c14555b1954b66a">More...</a><br /></td></tr>
<tr class="separator:a712141bb4fe924637c14555b1954b66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a37bb45b9fc50d691005df0824af255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6a37bb45b9fc50d691005df0824af255">sqrt</a> () const </td></tr>
<tr class="memdesc:a6a37bb45b9fc50d691005df0824af255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise square root; that is, the return value has the same length as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with each element replaced by whatever it thinks its square root is.  <a href="#a6a37bb45b9fc50d691005df0824af255">More...</a><br /></td></tr>
<tr class="separator:a6a37bb45b9fc50d691005df0824af255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc94c4eaac8216b124ef659ff1d5487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aafc94c4eaac8216b124ef659ff1d5487">abs</a> () const </td></tr>
<tr class="memdesc:aafc94c4eaac8216b124ef659ff1d5487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise absolute value; that is, the return value has the same dimension as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with each element replaced by whatever it thinks its absolute value is.  <a href="#aafc94c4eaac8216b124ef659ff1d5487">More...</a><br /></td></tr>
<tr class="separator:aafc94c4eaac8216b124ef659ff1d5487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af696f3d3ec205726a276a2355104d9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af696f3d3ec205726a276a2355104d9c5">standardize</a> () const </td></tr>
<tr class="memdesc:af696f3d3ec205726a276a2355104d9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with the underlying scalar type converted (if necessary) to one of the C++ standard real or complex floating point types.  <a href="#af696f3d3ec205726a276a2355104d9c5">More...</a><br /></td></tr>
<tr class="separator:af696f3d3ec205726a276a2355104d9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051dc2d9f18a5b8b192e6e33c2dd49b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a051dc2d9f18a5b8b192e6e33c2dd49b4">sum</a> () const </td></tr>
<tr class="memdesc:a051dc2d9f18a5b8b192e6e33c2dd49b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum just adds up all the elements into a single return element that is the same type as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>'s elements except standardized to use one of the C++ built-in real or complex types as its underlying scalars.  <a href="#a051dc2d9f18a5b8b192e6e33c2dd49b4">More...</a><br /></td></tr>
<tr class="separator:a051dc2d9f18a5b8b192e6e33c2dd49b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d52d8c3207d1fd68197233c4a60029c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d52d8c3207d1fd68197233c4a60029c">Vec</a> ()</td></tr>
<tr class="memdesc:a7d52d8c3207d1fd68197233c4a60029c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construction initializes Vec's elements to NaN when debugging but leaves them uninitialized garbage otherwise, so declarations have zero cost in Release builds.  <a href="#a7d52d8c3207d1fd68197233c4a60029c">More...</a><br /></td></tr>
<tr class="separator:a7d52d8c3207d1fd68197233c4a60029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c3d97a17ed494e9f0e5b2829ae419"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad34c3d97a17ed494e9f0e5b2829ae419">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr class="memdesc:ad34c3d97a17ed494e9f0e5b2829ae419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="#ad34c3d97a17ed494e9f0e5b2829ae419">More...</a><br /></td></tr>
<tr class="separator:ad34c3d97a17ed494e9f0e5b2829ae419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee6e2f4bad2e772e4ad019b28c591a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a96ee6e2f4bad2e772e4ad019b28c591a">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;src)</td></tr>
<tr class="memdesc:a96ee6e2f4bad2e772e4ad019b28c591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination.  <a href="#a96ee6e2f4bad2e772e4ad019b28c591a">More...</a><br /></td></tr>
<tr class="separator:a96ee6e2f4bad2e772e4ad019b28c591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd4b510a548add1477a13a1c99cc87"><td class="memTemplParams" colspan="2">template&lt;int SS&gt; </td></tr>
<tr class="memitem:ad6fd4b510a548add1477a13a1c99cc87"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad6fd4b510a548add1477a13a1c99cc87">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:ad6fd4b510a548add1477a13a1c99cc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and element type but with a different stride.  <a href="#ad6fd4b510a548add1477a13a1c99cc87">More...</a><br /></td></tr>
<tr class="separator:ad6fd4b510a548add1477a13a1c99cc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5678f4109bde28c1c7829f030a752"><td class="memTemplParams" colspan="2">template&lt;int SS&gt; </td></tr>
<tr class="memitem:a57a5678f4109bde28c1c7829f030a752"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a57a5678f4109bde28c1c7829f030a752">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:a57a5678f4109bde28c1c7829f030a752"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from a Vec of the same length and <em>negated</em> element type (possibly with a different stride).  <a href="#a57a5678f4109bde28c1c7829f030a752">More...</a><br /></td></tr>
<tr class="separator:a57a5678f4109bde28c1c7829f030a752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9220ca15fa8c7647bb0d5a7aaeb83b5"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:ad9220ca15fa8c7647bb0d5a7aaeb83b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad9220ca15fa8c7647bb0d5a7aaeb83b5">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;src)</td></tr>
<tr class="memdesc:ad9220ca15fa8c7647bb0d5a7aaeb83b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> from a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> of the same length, with any stride.  <a href="#ad9220ca15fa8c7647bb0d5a7aaeb83b5">More...</a><br /></td></tr>
<tr class="separator:ad9220ca15fa8c7647bb0d5a7aaeb83b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe343569bdc62601e22eddccb9b76fa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e)</td></tr>
<tr class="memdesc:abe343569bdc62601e22eddccb9b76fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's element type assigns that value to each element.  <a href="#abe343569bdc62601e22eddccb9b76fa3">More...</a><br /></td></tr>
<tr class="separator:abe343569bdc62601e22eddccb9b76fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d54996ceb0ffdaaf35c0b42d13ffb22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0d54996ceb0ffdaaf35c0b42d13ffb22">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a> &amp;ne)</td></tr>
<tr class="memdesc:a0d54996ceb0ffdaaf35c0b42d13ffb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a single value of this Vec's negated element type assigns that value to each element, requiring floating point negation to be performed once to compute the type-E representation of the type negator&lt;E&gt; value provided.  <a href="#a0d54996ceb0ffdaaf35c0b42d13ffb22">More...</a><br /></td></tr>
<tr class="separator:a0d54996ceb0ffdaaf35c0b42d13ffb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a2921791ea75c7022fb593b45c43f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a58a2921791ea75c7022fb593b45c43f7">Vec</a> (int i)</td></tr>
<tr class="memdesc:a58a2921791ea75c7022fb593b45c43f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an int value, turn it into a suitable floating point number, convert that to element type E and then feed that to the above single-element constructor.  <a href="#a58a2921791ea75c7022fb593b45c43f7">More...</a><br /></td></tr>
<tr class="separator:a58a2921791ea75c7022fb593b45c43f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594d2b0d02e91efc5547af4678d3535c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a594d2b0d02e91efc5547af4678d3535c">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1)</td></tr>
<tr class="memdesc:a594d2b0d02e91efc5547af4678d3535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Vec&lt;2,E&gt; from two elements of type E, etc.  <a href="#a594d2b0d02e91efc5547af4678d3535c">More...</a><br /></td></tr>
<tr class="separator:a594d2b0d02e91efc5547af4678d3535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0a194f6ca013c9026ff72f461bfc46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e0a194f6ca013c9026ff72f461bfc46">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2)</td></tr>
<tr class="separator:a6e0a194f6ca013c9026ff72f461bfc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c9a675a80482caf12e02a34b399bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a71c9a675a80482caf12e02a34b399bb1">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3)</td></tr>
<tr class="separator:a71c9a675a80482caf12e02a34b399bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774e82ed4bb90e65fee729e2082e413b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a774e82ed4bb90e65fee729e2082e413b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4)</td></tr>
<tr class="separator:a774e82ed4bb90e65fee729e2082e413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcac91cb1609810fac49da700e70e77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4dcac91cb1609810fac49da700e70e77">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5)</td></tr>
<tr class="separator:a4dcac91cb1609810fac49da700e70e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978f046474cf4481a5f0470f9558a29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5978f046474cf4481a5f0470f9558a29">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6)</td></tr>
<tr class="separator:a5978f046474cf4481a5f0470f9558a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae204f1902d2834ff3f47f3c84db23385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae204f1902d2834ff3f47f3c84db23385">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7)</td></tr>
<tr class="separator:ae204f1902d2834ff3f47f3c84db23385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f80f6ed39b2a75521423d25b23835b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ad4f80f6ed39b2a75521423d25b23835b">Vec</a> (const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e0, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e1, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e2, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e3, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e4, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e5, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e6, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e7, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;e8)</td></tr>
<tr class="separator:ad4f80f6ed39b2a75521423d25b23835b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66f56b1930d82c36f90142af7fb536"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a9c66f56b1930d82c36f90142af7fb536"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9c66f56b1930d82c36f90142af7fb536">Vec</a> (const EE *p)</td></tr>
<tr class="memdesc:a9c66f56b1930d82c36f90142af7fb536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction from a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="#a9c66f56b1930d82c36f90142af7fb536">More...</a><br /></td></tr>
<tr class="separator:a9c66f56b1930d82c36f90142af7fb536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf45d78264b6e333d79985c371efbf4"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a1bf45d78264b6e333d79985c371efbf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1bf45d78264b6e333d79985c371efbf4">operator=</a> (const EE *p)</td></tr>
<tr class="memdesc:a1bf45d78264b6e333d79985c371efbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E.  <a href="#a1bf45d78264b6e333d79985c371efbf4">More...</a><br /></td></tr>
<tr class="separator:a1bf45d78264b6e333d79985c371efbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced2e90bb014a4c09f2e830846b73ac"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a9ced2e90bb014a4c09f2e830846b73ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9ced2e90bb014a4c09f2e830846b73ac">operator=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;vv)</td></tr>
<tr class="memdesc:a9ced2e90bb014a4c09f2e830846b73ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a conforming Vec, of any element type and stride, provided that the element types are assignment-compatible.  <a href="#a9ced2e90bb014a4c09f2e830846b73ac">More...</a><br /></td></tr>
<tr class="separator:a9ced2e90bb014a4c09f2e830846b73ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8255aebddddbcdb4aaae12736a1b05"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a2a8255aebddddbcdb4aaae12736a1b05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2a8255aebddddbcdb4aaae12736a1b05">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a2a8255aebddddbcdb4aaae12736a1b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="#a2a8255aebddddbcdb4aaae12736a1b05">More...</a><br /></td></tr>
<tr class="separator:a2a8255aebddddbcdb4aaae12736a1b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cc4c59703b5544ac71bc5e57cc0b19"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a51cc4c59703b5544ac71bc5e57cc0b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51cc4c59703b5544ac71bc5e57cc0b19">operator+=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a51cc4c59703b5544ac71bc5e57cc0b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="#a51cc4c59703b5544ac71bc5e57cc0b19">More...</a><br /></td></tr>
<tr class="separator:a51cc4c59703b5544ac71bc5e57cc0b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b643762736321072c6bd58ba141841"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a46b643762736321072c6bd58ba141841"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a46b643762736321072c6bd58ba141841">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:a46b643762736321072c6bd58ba141841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any element type and stride, provided that the element types are addition-compatible.  <a href="#a46b643762736321072c6bd58ba141841">More...</a><br /></td></tr>
<tr class="separator:a46b643762736321072c6bd58ba141841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee444801ca472095d6fc0ff1a103718f"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:aee444801ca472095d6fc0ff1a103718f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aee444801ca472095d6fc0ff1a103718f">operator-=</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;r)</td></tr>
<tr class="memdesc:aee444801ca472095d6fc0ff1a103718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible.  <a href="#aee444801ca472095d6fc0ff1a103718f">More...</a><br /></td></tr>
<tr class="separator:aee444801ca472095d6fc0ff1a103718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a4da394cb53cde9c5a63dc8a098f8d"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a82a4da394cb53cde9c5a63dc8a098f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a82a4da394cb53cde9c5a63dc8a098f8d">conformingAdd</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr class="memdesc:a82a4da394cb53cde9c5a63dc8a098f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector addition &ndash; use operator+ instead.  <a href="#a82a4da394cb53cde9c5a63dc8a098f8d">More...</a><br /></td></tr>
<tr class="separator:a82a4da394cb53cde9c5a63dc8a098f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1a60f240f485bc1f9c844ec1cd733"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a69d1a60f240f485bc1f9c844ec1cd733"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a69d1a60f240f485bc1f9c844ec1cd733">conformingSubtract</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr class="memdesc:a69d1a60f240f485bc1f9c844ec1cd733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector subtraction &ndash; use operator- instead.  <a href="#a69d1a60f240f485bc1f9c844ec1cd733">More...</a><br /></td></tr>
<tr class="separator:a69d1a60f240f485bc1f9c844ec1cd733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9702efd5be91edf3f06f0680303ec0"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a7a9702efd5be91edf3f06f0680303ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; M, M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7a9702efd5be91edf3f06f0680303ec0">conformingMultiply</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr class="memdesc:a7a9702efd5be91edf3f06f0680303ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as outer product (m = col*row) &ndash; use operator* or <a class="el" href="namespaceSimTK.html#a0fd293cad29bd6fa0405ccffca69c738">outer()</a> instead.  <a href="#a7a9702efd5be91edf3f06f0680303ec0">More...</a><br /></td></tr>
<tr class="separator:a7a9702efd5be91edf3f06f0680303ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f554ca51a94f9cfa61a36b495478e5c"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a5f554ca51a94f9cfa61a36b495478e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5f554ca51a94f9cfa61a36b495478e5c">elementwiseMultiply</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr class="memdesc:a5f554ca51a94f9cfa61a36b495478e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiply (Matlab " .* " operator).  <a href="#a5f554ca51a94f9cfa61a36b495478e5c">More...</a><br /></td></tr>
<tr class="separator:a5f554ca51a94f9cfa61a36b495478e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af4163f4d188bf82242584bf985ccb8"><td class="memTemplParams" colspan="2">template&lt;class EE , int SS&gt; </td></tr>
<tr class="memitem:a3af4163f4d188bf82242584bf985ccb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3af4163f4d188bf82242584bf985ccb8">elementwiseDivide</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;r) const </td></tr>
<tr class="memdesc:a3af4163f4d188bf82242584bf985ccb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise divide (Matlab " ./ " operator).  <a href="#a3af4163f4d188bf82242584bf985ccb8">More...</a><br /></td></tr>
<tr class="separator:a3af4163f4d188bf82242584bf985ccb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ecf7f59bd4b7c6b9dfd67566b75449"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab1ecf7f59bd4b7c6b9dfd67566b75449">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:ab1ecf7f59bd4b7c6b9dfd67566b75449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a const reference to it.  <a href="#ab1ecf7f59bd4b7c6b9dfd67566b75449">More...</a><br /></td></tr>
<tr class="separator:ab1ecf7f59bd4b7c6b9dfd67566b75449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc6a710c601343c9fe30e34c20b7bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a32bc6a710c601343c9fe30e34c20b7bf">operator()</a> (int i) const </td></tr>
<tr class="memdesc:a32bc6a710c601343c9fe30e34c20b7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const operator[] above.  <a href="#a32bc6a710c601343c9fe30e34c20b7bf">More...</a><br /></td></tr>
<tr class="separator:a32bc6a710c601343c9fe30e34c20b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a011242e15a9188acf63a6625e6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae44a011242e15a9188acf63a6625e6cc">operator[]</a> (int i)</td></tr>
<tr class="memdesc:ae44a011242e15a9188acf63a6625e6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element of this Vec and return a writable reference to it.  <a href="#ae44a011242e15a9188acf63a6625e6cc">More...</a><br /></td></tr>
<tr class="separator:ae44a011242e15a9188acf63a6625e6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2918c06d3f0b353076c5fa9ce8019509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2918c06d3f0b353076c5fa9ce8019509">operator()</a> (int i)</td></tr>
<tr class="memdesc:a2918c06d3f0b353076c5fa9ce8019509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator[] above.  <a href="#a2918c06d3f0b353076c5fa9ce8019509">More...</a><br /></td></tr>
<tr class="separator:a2918c06d3f0b353076c5fa9ce8019509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95575b22850f63eaa64858660c8c8c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a95575b22850f63eaa64858660c8c8c64">normSqr</a> () const </td></tr>
<tr class="separator:a95575b22850f63eaa64858660c8c8c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcb573b11b780148f1ff3e7f5961997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm</a> () const </td></tr>
<tr class="separator:a5bcb573b11b780148f1ff3e7f5961997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd852b56584cfeda803eab3a95fb7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db">normalize</a> () const </td></tr>
<tr class="memdesc:abbd852b56584cfeda803eab3a95fb7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the elements of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> are scalars, the result is what you get by dividing each element by the <a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm()</a> calculated above.  <a href="#abbd852b56584cfeda803eab3a95fb7db">More...</a><br /></td></tr>
<tr class="separator:abbd852b56584cfeda803eab3a95fb7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cea75e2ed6de1c379a46745849c473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a66cea75e2ed6de1c379a46745849c473">invert</a> () const </td></tr>
<tr class="memdesc:a66cea75e2ed6de1c379a46745849c473"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is not supported for Vec objects.  <a href="#a66cea75e2ed6de1c379a46745849c473">More...</a><br /></td></tr>
<tr class="separator:a66cea75e2ed6de1c379a46745849c473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28bb6b73abb3704de062f751dab4921"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ae28bb6b73abb3704de062f751dab4921">operator+</a> () const </td></tr>
<tr class="memdesc:ae28bb6b73abb3704de062f751dab4921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus does nothing.  <a href="#ae28bb6b73abb3704de062f751dab4921">More...</a><br /></td></tr>
<tr class="separator:ae28bb6b73abb3704de062f751dab4921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d18cd6340b717437a31770499069bfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1d18cd6340b717437a31770499069bfd">operator-</a> () const </td></tr>
<tr class="memdesc:a1d18cd6340b717437a31770499069bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus recasts this Vec to a type that has the opposite interpretation of the sign but is otherwise identical, so no computation or copying is performed here.  <a href="#a1d18cd6340b717437a31770499069bfd">More...</a><br /></td></tr>
<tr class="separator:a1d18cd6340b717437a31770499069bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52644eefd67080b80bba767e5affceb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a52644eefd67080b80bba767e5affceb8">operator-</a> ()</td></tr>
<tr class="memdesc:a52644eefd67080b80bba767e5affceb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to negated type and return a writable reference; writing to this will cause the negated result to be placed in the original Vec.  <a href="#a52644eefd67080b80bba767e5affceb8">More...</a><br /></td></tr>
<tr class="separator:a52644eefd67080b80bba767e5affceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82833142e2b30ae998f1ee357245b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b82833142e2b30ae998f1ee357245b4">operator~</a> () const </td></tr>
<tr class="memdesc:a4b82833142e2b30ae998f1ee357245b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hermitian transpose operator recasts this Vec to a type that specifies the opposite storage order (row vs. column) then returns a reference, so no computation or copying is performed here.  <a href="#a4b82833142e2b30ae998f1ee357245b4">More...</a><br /></td></tr>
<tr class="separator:a4b82833142e2b30ae998f1ee357245b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055c47346d5b16b0a7ced839b91a9aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a055c47346d5b16b0a7ced839b91a9aa4">operator~</a> ()</td></tr>
<tr class="memdesc:a055c47346d5b16b0a7ced839b91a9aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to Hermitian transposed type and return a writable reference; the effect is that writing to elements of the result affects the transposed element of the original Vec.  <a href="#a055c47346d5b16b0a7ced839b91a9aa4">More...</a><br /></td></tr>
<tr class="separator:a055c47346d5b16b0a7ced839b91a9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e24a8076a1aed2b65595b0b382c71f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a99e24a8076a1aed2b65595b0b382c71f">negate</a> () const </td></tr>
<tr class="memdesc:a99e24a8076a1aed2b65595b0b382c71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; just a recast.  <a href="#a99e24a8076a1aed2b65595b0b382c71f">More...</a><br /></td></tr>
<tr class="separator:a99e24a8076a1aed2b65595b0b382c71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5108f85c423f5e00e51a198734ed17c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5108f85c423f5e00e51a198734ed17c3">updNegate</a> ()</td></tr>
<tr class="memdesc:a5108f85c423f5e00e51a198734ed17c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of unary negation; recasts and returns a writable reference.  <a href="#a5108f85c423f5e00e51a198734ed17c3">More...</a><br /></td></tr>
<tr class="separator:a5108f85c423f5e00e51a198734ed17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9d7c001c9594fd65c50365dce0d5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3eb9d7c001c9594fd65c50365dce0d5c">transpose</a> () const </td></tr>
<tr class="memdesc:a3eb9d7c001c9594fd65c50365dce0d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; just a recast.  <a href="#a3eb9d7c001c9594fd65c50365dce0d5c">More...</a><br /></td></tr>
<tr class="separator:a3eb9d7c001c9594fd65c50365dce0d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e181c0844930d9dbec8afb613f762d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a3e181c0844930d9dbec8afb613f762d7">updTranspose</a> ()</td></tr>
<tr class="memdesc:a3e181c0844930d9dbec8afb613f762d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-operator version of Hermitian transpose; recasts and returns a writable reference.  <a href="#a3e181c0844930d9dbec8afb613f762d7">More...</a><br /></td></tr>
<tr class="separator:a3e181c0844930d9dbec8afb613f762d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e92208963211edbb39751c128310a0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1e92208963211edbb39751c128310a0e">positionalTranspose</a> () const </td></tr>
<tr class="memdesc:a1e92208963211edbb39751c128310a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose turns this Vec into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> but does not transpose the individual elements.  <a href="#a1e92208963211edbb39751c128310a0e">More...</a><br /></td></tr>
<tr class="separator:a1e92208963211edbb39751c128310a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021a62d22537c7ad406b7a1c1ca0761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6021a62d22537c7ad406b7a1c1ca0761">updPositionalTranspose</a> ()</td></tr>
<tr class="memdesc:a6021a62d22537c7ad406b7a1c1ca0761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positional transpose returning a writable reference.  <a href="#a6021a62d22537c7ad406b7a1c1ca0761">More...</a><br /></td></tr>
<tr class="separator:a6021a62d22537c7ad406b7a1c1ca0761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891ea80a0181132c2430a349f461d72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ac891ea80a0181132c2430a349f461d72">real</a> () const </td></tr>
<tr class="memdesc:ac891ea80a0181132c2430a349f461d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the real portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="#ac891ea80a0181132c2430a349f461d72">More...</a><br /></td></tr>
<tr class="separator:ac891ea80a0181132c2430a349f461d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc792ec3e435535fc8fe4ad3810d54fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc792ec3e435535fc8fe4ad3810d54fe">real</a> ()</td></tr>
<tr class="memdesc:adc792ec3e435535fc8fe4ad3810d54fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the real portion of this Vec and return a writable reference.  <a href="#adc792ec3e435535fc8fe4ad3810d54fe">More...</a><br /></td></tr>
<tr class="separator:adc792ec3e435535fc8fe4ad3810d54fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff885dcf7ea01c94d7621be973fd1aa9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aff885dcf7ea01c94d7621be973fd1aa9">imag</a> () const </td></tr>
<tr class="memdesc:aff885dcf7ea01c94d7621be973fd1aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the imaginary portion of this Vec if it has complex elements; otherwise the type doesn't change.  <a href="#aff885dcf7ea01c94d7621be973fd1aa9">More...</a><br /></td></tr>
<tr class="separator:aff885dcf7ea01c94d7621be973fd1aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ecf2380f493c8b48ad6d0d50695f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b3ecf2380f493c8b48ad6d0d50695f8">imag</a> ()</td></tr>
<tr class="memdesc:a4b3ecf2380f493c8b48ad6d0d50695f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to show only the imaginary portion of this Vec and return a writable reference.  <a href="#a4b3ecf2380f493c8b48ad6d0d50695f8">More...</a><br /></td></tr>
<tr class="separator:a4b3ecf2380f493c8b48ad6d0d50695f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9283ff051541b8f511d748f862f1eb9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a9283ff051541b8f511d748f862f1eb9b">castAwayNegatorIfAny</a> () const </td></tr>
<tr class="memdesc:a9283ff051541b8f511d748f862f1eb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present; this is handy for simplifying operations where we know the sign can be ignored such as squaring.  <a href="#a9283ff051541b8f511d748f862f1eb9b">More...</a><br /></td></tr>
<tr class="separator:a9283ff051541b8f511d748f862f1eb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2467300a636639eb7195ca7ea37d5ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a2467300a636639eb7195ca7ea37d5ee8">updCastAwayNegatorIfAny</a> ()</td></tr>
<tr class="memdesc:a2467300a636639eb7195ca7ea37d5ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast to remove negators from this Vec's type if present and return a writable reference.  <a href="#a2467300a636639eb7195ca7ea37d5ee8">More...</a><br /></td></tr>
<tr class="separator:a2467300a636639eb7195ca7ea37d5ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b496ee9a8f41defa3250da5ed0014e"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a37b496ee9a8f41defa3250da5ed0014e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a37b496ee9a8f41defa3250da5ed0014e">scalarMultiply</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a37b496ee9a8f41defa3250da5ed0014e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314e384e0d1cc1077562131cb7a773a2"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a314e384e0d1cc1077562131cb7a773a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Mul &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a314e384e0d1cc1077562131cb7a773a2">scalarMultiplyFromLeft</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a314e384e0d1cc1077562131cb7a773a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a9b3263e294d85755e4c777302c2ae"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a97a9b3263e294d85755e4c777302c2ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a97a9b3263e294d85755e4c777302c2ae">scalarDivide</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a97a9b3263e294d85755e4c777302c2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34606c49af85f3f3b54341b54815cf25"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a34606c49af85f3f3b54341b54815cf25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Dvd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a34606c49af85f3f3b54341b54815cf25">scalarDivideFromLeft</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a34606c49af85f3f3b54341b54815cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474088f0218a89d4116358da2ced4fcc"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a474088f0218a89d4116358da2ced4fcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Add &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a474088f0218a89d4116358da2ced4fcc">scalarAdd</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a474088f0218a89d4116358da2ced4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fc2003203268bcd10f9eadf9412695"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a69fc2003203268bcd10f9eadf9412695"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; EE &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a69fc2003203268bcd10f9eadf9412695">scalarSubtract</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a69fc2003203268bcd10f9eadf9412695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee50b918ae4eefc8c8ac1a177d7f7c9"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a5ee50b918ae4eefc8c8ac1a177d7f7c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt; EE &gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt; <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &gt;::Sub &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5ee50b918ae4eefc8c8ac1a177d7f7c9">scalarSubtractFromLeft</a> (const EE &amp;e) const </td></tr>
<tr class="separator:a5ee50b918ae4eefc8c8ac1a177d7f7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace53cca908837b6b13de05a6bbda540"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:aace53cca908837b6b13de05a6bbda540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aace53cca908837b6b13de05a6bbda540">operator=</a> (const EE &amp;e)</td></tr>
<tr class="separator:aace53cca908837b6b13de05a6bbda540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6459937f78236c913e2ec50d328d8d"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a6d6459937f78236c913e2ec50d328d8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6d6459937f78236c913e2ec50d328d8d">operator+=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a6d6459937f78236c913e2ec50d328d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b247dbd3a71bdcef1a0a4af1cece4c7"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a4b247dbd3a71bdcef1a0a4af1cece4c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a4b247dbd3a71bdcef1a0a4af1cece4c7">operator-=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a4b247dbd3a71bdcef1a0a4af1cece4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c865e00508d708562c21012f0cb66e1"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a1c865e00508d708562c21012f0cb66e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1c865e00508d708562c21012f0cb66e1">operator*=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a1c865e00508d708562c21012f0cb66e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273abdf63fc3f9e8d720b6b1c9ebd047"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a273abdf63fc3f9e8d720b6b1c9ebd047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a273abdf63fc3f9e8d720b6b1c9ebd047">operator/=</a> (const EE &amp;e)</td></tr>
<tr class="separator:a273abdf63fc3f9e8d720b6b1c9ebd047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cc5ea1fc0e6db75f4fe78c85772179"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a47cc5ea1fc0e6db75f4fe78c85772179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a47cc5ea1fc0e6db75f4fe78c85772179">scalarEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a47cc5ea1fc0e6db75f4fe78c85772179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9a9f23aeaf38da791ec0173f5b49d8"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a7d9a9f23aeaf38da791ec0173f5b49d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7d9a9f23aeaf38da791ec0173f5b49d8">scalarPlusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a7d9a9f23aeaf38da791ec0173f5b49d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ecc870150f4bbaddacf812bf3a55a4"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:af1ecc870150f4bbaddacf812bf3a55a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af1ecc870150f4bbaddacf812bf3a55a4">scalarMinusEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:af1ecc870150f4bbaddacf812bf3a55a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d049de83f163743bc576395746f0e6"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a11d049de83f163743bc576395746f0e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a11d049de83f163743bc576395746f0e6">scalarMinusEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a11d049de83f163743bc576395746f0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f25b932993267cacda311724882b90"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:af8f25b932993267cacda311724882b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#af8f25b932993267cacda311724882b90">scalarTimesEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:af8f25b932993267cacda311724882b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1549f7c02c5f35b6ae02f3a384ba0461"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a1549f7c02c5f35b6ae02f3a384ba0461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1549f7c02c5f35b6ae02f3a384ba0461">scalarTimesEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a1549f7c02c5f35b6ae02f3a384ba0461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec0b452d52d289345c333b6b1f61c1b"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a5ec0b452d52d289345c333b6b1f61c1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a5ec0b452d52d289345c333b6b1f61c1b">scalarDivideEq</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a5ec0b452d52d289345c333b6b1f61c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6c34551dd57324842f2e630ac5798"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a68d6c34551dd57324842f2e630ac5798"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a68d6c34551dd57324842f2e630ac5798">scalarDivideEqFromLeft</a> (const EE &amp;ee)</td></tr>
<tr class="separator:a68d6c34551dd57324842f2e630ac5798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18982d1fac249ed0050b0497fc1b5fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a18982d1fac249ed0050b0497fc1b5fff">scalarEq</a> (int ee)</td></tr>
<tr class="separator:a18982d1fac249ed0050b0497fc1b5fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e47b406661090c6bbb580bb32f613b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6e47b406661090c6bbb580bb32f613b6">scalarPlusEq</a> (int ee)</td></tr>
<tr class="separator:a6e47b406661090c6bbb580bb32f613b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402c2238f2821d55a97dcdfb36ad0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab402c2238f2821d55a97dcdfb36ad0ba">scalarMinusEq</a> (int ee)</td></tr>
<tr class="separator:ab402c2238f2821d55a97dcdfb36ad0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba57628dc553c6155205ba7ebd0330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a7bba57628dc553c6155205ba7ebd0330">scalarTimesEq</a> (int ee)</td></tr>
<tr class="separator:a7bba57628dc553c6155205ba7ebd0330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafb7930483190b14571c043ccb33ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aeafb7930483190b14571c043ccb33ce0">scalarDivideEq</a> (int ee)</td></tr>
<tr class="separator:aeafb7930483190b14571c043ccb33ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07b8dc8c7690f71f6a2a7232c06f8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ab07b8dc8c7690f71f6a2a7232c06f8b9">scalarMinusEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:ab07b8dc8c7690f71f6a2a7232c06f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695383084e4311219d9c1d86330bc3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a695383084e4311219d9c1d86330bc3fa">scalarTimesEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:a695383084e4311219d9c1d86330bc3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45beaad82e2504367de24345f1b7f60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a45beaad82e2504367de24345f1b7f60c">scalarDivideEqFromLeft</a> (int ee)</td></tr>
<tr class="separator:a45beaad82e2504367de24345f1b7f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b11014a0ad910e4254a26d39f013565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a0b11014a0ad910e4254a26d39f013565">setToNaN</a> ()</td></tr>
<tr class="memdesc:a0b11014a0ad910e4254a26d39f013565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to NaN; this is the default initial value in Debug builds, but not in Release.  <a href="#a0b11014a0ad910e4254a26d39f013565">More...</a><br /></td></tr>
<tr class="separator:a0b11014a0ad910e4254a26d39f013565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25018475a82b7f1c61956d824104b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a25018475a82b7f1c61956d824104b300">setToZero</a> ()</td></tr>
<tr class="memdesc:a25018475a82b7f1c61956d824104b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every scalar in this Vec to zero.  <a href="#a25018475a82b7f1c61956d824104b300">More...</a><br /></td></tr>
<tr class="separator:a25018475a82b7f1c61956d824104b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba184e5623fcecb388ab58eb91232052"><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr class="memitem:aba184e5623fcecb388ab58eb91232052"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aba184e5623fcecb388ab58eb91232052">getSubVec</a> (int i) const </td></tr>
<tr class="memdesc:aba184e5623fcecb388ab58eb91232052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a const reference to a sub-Vec with size known at compile time.  <a href="#aba184e5623fcecb388ab58eb91232052">More...</a><br /></td></tr>
<tr class="separator:aba184e5623fcecb388ab58eb91232052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085715471acf42722ddd05eb8028e13c"><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr class="memitem:a085715471acf42722ddd05eb8028e13c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a085715471acf42722ddd05eb8028e13c">updSubVec</a> (int i)</td></tr>
<tr class="memdesc:a085715471acf42722ddd05eb8028e13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a writable reference to a sub-Vec with size known at compile time.  <a href="#a085715471acf42722ddd05eb8028e13c">More...</a><br /></td></tr>
<tr class="separator:a085715471acf42722ddd05eb8028e13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b31ae5026f2529651aeaad88d705b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M-1, ELT, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa0b31ae5026f2529651aeaad88d705b1">drop1</a> (int p) const </td></tr>
<tr class="memdesc:aa0b31ae5026f2529651aeaad88d705b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one smaller than this one by dropping the element at the indicated position p.  <a href="#aa0b31ae5026f2529651aeaad88d705b1">More...</a><br /></td></tr>
<tr class="separator:aa0b31ae5026f2529651aeaad88d705b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5b268f14abe92735185cafadd888dc"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:acc5b268f14abe92735185cafadd888dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, ELT, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc">append1</a> (const EE &amp;v) const </td></tr>
<tr class="memdesc:acc5b268f14abe92735185cafadd888dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by adding an element to the end.  <a href="#acc5b268f14abe92735185cafadd888dc">More...</a><br /></td></tr>
<tr class="separator:acc5b268f14abe92735185cafadd888dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8f4c92e03d90c4ec80644fb3d7bdc"><td class="memTemplParams" colspan="2">template&lt;class EE &gt; </td></tr>
<tr class="memitem:a19c8f4c92e03d90c4ec80644fb3d7bdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M+1, ELT, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a19c8f4c92e03d90c4ec80644fb3d7bdc">insert1</a> (int p, const EE &amp;v) const </td></tr>
<tr class="memdesc:a19c8f4c92e03d90c4ec80644fb3d7bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector one larger than this one by inserting an element <em>before</em> the indicated one.  <a href="#a19c8f4c92e03d90c4ec80644fb3d7bdc">More...</a><br /></td></tr>
<tr class="separator:a19c8f4c92e03d90c4ec80644fb3d7bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee785192d37052d76ff80d62338a6302"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aee785192d37052d76ff80d62338a6302">isNaN</a> () const </td></tr>
<tr class="memdesc:aee785192d37052d76ff80d62338a6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> contains a NaN anywhere.  <a href="#aee785192d37052d76ff80d62338a6302">More...</a><br /></td></tr>
<tr class="separator:aee785192d37052d76ff80d62338a6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92ef2895e51a3ff4f1a3c264012c4ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa92ef2895e51a3ff4f1a3c264012c4ad">isInf</a> () const </td></tr>
<tr class="memdesc:aa92ef2895e51a3ff4f1a3c264012c4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> contains a +Infinity or -Infinity somewhere but no element contains a NaN anywhere.  <a href="#aa92ef2895e51a3ff4f1a3c264012c4ad">More...</a><br /></td></tr>
<tr class="separator:aa92ef2895e51a3ff4f1a3c264012c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0574822d6633f8b621d9c676a4352a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a1a0574822d6633f8b621d9c676a4352a">isFinite</a> () const </td></tr>
<tr class="memdesc:a1a0574822d6633f8b621d9c676a4352a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if no element of this Vec contains an Infinity or a NaN anywhere.  <a href="#a1a0574822d6633f8b621d9c676a4352a">More...</a><br /></td></tr>
<tr class="separator:a1a0574822d6633f8b621d9c676a4352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862a6d93b3109965ce7104c6beae5de6"><td class="memTemplParams" colspan="2">template&lt;class E2 , int RS2&gt; </td></tr>
<tr class="memitem:a862a6d93b3109965ce7104c6beae5de6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a862a6d93b3109965ce7104c6beae5de6">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v, double tol) const </td></tr>
<tr class="memdesc:a862a6d93b3109965ce7104c6beae5de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a specified tolerance.  <a href="#a862a6d93b3109965ce7104c6beae5de6">More...</a><br /></td></tr>
<tr class="separator:a862a6d93b3109965ce7104c6beae5de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596116b98d5d15f0112d1e052f09aeab"><td class="memTemplParams" colspan="2">template&lt;class E2 , int RS2&gt; </td></tr>
<tr class="memitem:a596116b98d5d15f0112d1e052f09aeab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a596116b98d5d15f0112d1e052f09aeab">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;v) const </td></tr>
<tr class="memdesc:a596116b98d5d15f0112d1e052f09aeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this vector is numerically equal to some other vector with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared.  <a href="#a596116b98d5d15f0112d1e052f09aeab">More...</a><br /></td></tr>
<tr class="separator:a596116b98d5d15f0112d1e052f09aeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576e2e126e4f3bb2f59dc91ef1fbcfc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a576e2e126e4f3bb2f59dc91ef1fbcfc4">isNumericallyEqual</a> (const ELT &amp;e, double tol=<a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a>()) const </td></tr>
<tr class="memdesc:a576e2e126e4f3bb2f59dc91ef1fbcfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether every element of this vector is numerically equal to the given element, using either a specified tolerance or the vector's default tolerance (which is always the same or looser than the default tolerance for one of its elements).  <a href="#a576e2e126e4f3bb2f59dc91ef1fbcfc4">More...</a><br /></td></tr>
<tr class="separator:a576e2e126e4f3bb2f59dc91ef1fbcfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71ef634c8bcf182405248a215acb789"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#aa71ef634c8bcf182405248a215acb789">toString</a> () const </td></tr>
<tr class="memdesc:aa71ef634c8bcf182405248a215acb789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> into a string and return it.  <a href="#aa71ef634c8bcf182405248a215acb789">More...</a><br /></td></tr>
<tr class="separator:aa71ef634c8bcf182405248a215acb789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907c5d98e3f7b29f858c5f56c6e38738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a907c5d98e3f7b29f858c5f56c6e38738">set</a> (int i, const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;value)</td></tr>
<tr class="memdesc:a907c5d98e3f7b29f858c5f56c6e38738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to set ith entry.  <a href="#a907c5d98e3f7b29f858c5f56c6e38738">More...</a><br /></td></tr>
<tr class="separator:a907c5d98e3f7b29f858c5f56c6e38738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc57b3dd6983c252b3654a4d6548f05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a8bc57b3dd6983c252b3654a4d6548f05">get</a> (int i) const </td></tr>
<tr class="memdesc:a8bc57b3dd6983c252b3654a4d6548f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of operator[] that's scripting friendly to get const reference to ith entry.  <a href="#a8bc57b3dd6983c252b3654a4d6548f05">More...</a><br /></td></tr>
<tr class="separator:a8bc57b3dd6983c252b3654a4d6548f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adc9ccbb5060fdbbf1e4446337217b699"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#adc9ccbb5060fdbbf1e4446337217b699">size</a> ()</td></tr>
<tr class="memdesc:adc9ccbb5060fdbbf1e4446337217b699"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> (note that stride does not affect this number.)  <a href="#adc9ccbb5060fdbbf1e4446337217b699">More...</a><br /></td></tr>
<tr class="separator:adc9ccbb5060fdbbf1e4446337217b699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8825fc5c6297c9e0d804f3471d1f1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a99f8825fc5c6297c9e0d804f3471d1f1">nrow</a> ()</td></tr>
<tr class="memdesc:a99f8825fc5c6297c9e0d804f3471d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is the number of elements.  <a href="#a99f8825fc5c6297c9e0d804f3471d1f1">More...</a><br /></td></tr>
<tr class="separator:a99f8825fc5c6297c9e0d804f3471d1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51574e7c675a4662b23b24ba6e430492"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a51574e7c675a4662b23b24ba6e430492">ncol</a> ()</td></tr>
<tr class="memdesc:a51574e7c675a4662b23b24ba6e430492"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is always 1.  <a href="#a51574e7c675a4662b23b24ba6e430492">More...</a><br /></td></tr>
<tr class="separator:a51574e7c675a4662b23b24ba6e430492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ac248ba601828531ca324917dc3ef"><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr class="memitem:a250ac248ba601828531ca324917dc3ef"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a250ac248ba601828531ca324917dc3ef">getSubVec</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;v, int i)</td></tr>
<tr class="memdesc:a250ac248ba601828531ca324917dc3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a const reference to the selected subsequence.  <a href="#a250ac248ba601828531ca324917dc3ef">More...</a><br /></td></tr>
<tr class="separator:a250ac248ba601828531ca324917dc3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3d2b34d4c58321ddd8ebbc997877dc"><td class="memTemplParams" colspan="2">template&lt;int MM&gt; </td></tr>
<tr class="memitem:a6c3d2b34d4c58321ddd8ebbc997877dc"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a6c3d2b34d4c58321ddd8ebbc997877dc">updSubVec</a> (<a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;v, int i)</td></tr>
<tr class="memdesc:a6c3d2b34d4c58321ddd8ebbc997877dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a writable reference to the selected subsequence.  <a href="#a6c3d2b34d4c58321ddd8ebbc997877dc">More...</a><br /></td></tr>
<tr class="separator:a6c3d2b34d4c58321ddd8ebbc997877dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8283cc8bb6cccd44287e439811198d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#abf8283cc8bb6cccd44287e439811198d">getAs</a> (const ELT *p)</td></tr>
<tr class="memdesc:abf8283cc8bb6cccd44287e439811198d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast an ordinary C++ array E[] to a const Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="#abf8283cc8bb6cccd44287e439811198d">More...</a><br /></td></tr>
<tr class="separator:abf8283cc8bb6cccd44287e439811198d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb89a98c7696e0a5fa04a17924e19f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#affb89a98c7696e0a5fa04a17924e19f7">updAs</a> (ELT *p)</td></tr>
<tr class="memdesc:affb89a98c7696e0a5fa04a17924e19f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable ordinary C++ array E[] to a writable Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing.  <a href="#affb89a98c7696e0a5fa04a17924e19f7">More...</a><br /></td></tr>
<tr class="separator:affb89a98c7696e0a5fa04a17924e19f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1b06280e2190f1d4317a04355f12ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#ade1b06280e2190f1d4317a04355f12ee">getNaN</a> ()</td></tr>
<tr class="memdesc:ade1b06280e2190f1d4317a04355f12ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Vec of the same length and element type as this one but with all elements set to NaN.  <a href="#ade1b06280e2190f1d4317a04355f12ee">More...</a><br /></td></tr>
<tr class="separator:ade1b06280e2190f1d4317a04355f12ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781827a50ebc3d83a0736738bc2e2784"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a> ()</td></tr>
<tr class="memdesc:a781827a50ebc3d83a0736738bc2e2784"><td class="mdescLeft">&#160;</td><td class="mdescRight">For approximate comparisions, the default tolerance to use for a vector is the same as its elements' default tolerance.  <a href="#a781827a50ebc3d83a0736738bc2e2784">More...</a><br /></td></tr>
<tr class="separator:a781827a50ebc3d83a0736738bc2e2784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:gaea19f36902b9e41b3774e3103718dab5"><td class="memTemplParams" colspan="2">template&lt;int M, class E , int S&gt; </td></tr>
<tr class="memitem:gaea19f36902b9e41b3774e3103718dab5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5">writeUnformatted</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr class="memdesc:gaea19f36902b9e41b3774e3103718dab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__writeUnformatted.html#gaea19f36902b9e41b3774e3103718dab5">More...</a><br /></td></tr>
<tr class="separator:gaea19f36902b9e41b3774e3103718dab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b4dd0ea98de6059b13e98cabbefb82"><td class="memTemplParams" colspan="2">template&lt;int M, class E , int S&gt; </td></tr>
<tr class="memitem:ga75b4dd0ea98de6059b13e98cabbefb82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, S &gt; &amp;v)</td></tr>
<tr class="memdesc:ga75b4dd0ea98de6059b13e98cabbefb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize for Vec&lt;M,E,S&gt; to delegate to element type E, with spaces separating the elements.  <a href="group__readFromStream.html#ga75b4dd0ea98de6059b13e98cabbefb82">More...</a><br /></td></tr>
<tr class="separator:ga75b4dd0ea98de6059b13e98cabbefb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int M, class ELT, int STRIDE&gt;<br />
class SimTK::Vec&lt; M, ELT, STRIDE &gt;</h3>

<p>This is a fixed-length column vector designed for no-overhead inline computation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The number of rows in the vector. </td></tr>
    <tr><td class="paramname">ELT</td><td>The element type. Must be a composite numerical type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). The default is ELT=Real. </td></tr>
    <tr><td class="paramname">STRIDE</td><td>The spacing from one element to the next in memory, as an integer number of elements of type ELT. The default is STRIDE=1.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Usage</b></p>
<p>The Vec and <a class="el" href="classSimTK_1_1Vector__.html">Vector</a> classes are commonly used to represent tuples of Real values, and have methods like norm() to calculate the vector 2-norm. Use Vec for a small vector whose length is known at compile time; otherwise, use <a class="el" href="classSimTK_1_1Vector__.html">Vector</a>. To collect elements of the same type that do not constitute a tuple, it is more appropriate to use the <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> container. Some common Vec use cases are provided below.</p>
<p><b>Construction</b></p>
<p>The 3-tuple <code>~[0,0,0]</code> can be created in the following ways: </p><div class="fragment"><div class="line">Vec&lt;3,Real&gt;(0,0,0);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>(0,0,0);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>(0);</div></div><!-- fragment --><p> Note that the default element type is Real, and that Vec3 is a typedef for Vec&lt;3&gt;; analogous typedefs exist for vectors of up to 9 elements.</p>
<p><b>Manipulation</b></p>
<p>Standard arithmetic operators can be used, as well as methods like sum() and normalize(). Here are some usage examples, each of which returns <code>~[1,2,3]</code>: </p><div class="fragment"><div class="line"><a class="code" href="group__UncommonMatVecTypedefs.html#ga5ada6a8d10e6b078bc903a5fafdab0c1">Vec9</a>(0,0,0,0,0,1,2,3,0).getSubVec&lt;3&gt;(5);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#ga06ebf8e50473fe4ff867f9a30ca0ef1c">Vec4</a>(1,2,4,3).drop1(2);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(2,3).<a class="code" href="classSimTK_1_1Vec.html#a19c8f4c92e03d90c4ec80644fb3d7bdc">insert1</a>(0,1);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(1,2).<a class="code" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc">append1</a>(3);</div></div><!-- fragment --><p><b>Conversion</b></p>
<p>It may be necessary to convert between a Vec and a Vector (to interface with FactorQTZ, for instance). In the example below, we print a Vec3 created from a 3-element Vector: </p><div class="fragment"><div class="line"><a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> myVector(3);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;myVector.size(); ++i) myVector[i]=i+1;</div><div class="line">std::cout &lt;&lt; <a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>(&amp;myVector[0]) &lt;&lt; std::endl;</div></div><!-- fragment --><p> Converting from a Vec3 to a Vector is also straightforward: </p><div class="fragment"><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> myVec3(1,2,3);</div><div class="line">std::cout &lt;&lt; <a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>(myVec3) &lt;&lt; std::endl;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Vector__.html" title="This is the vector class intended to appear in user code for large, variable size column vectors...">Vector_</a> for handling of large or variable-sized vectors. </dd>
<dd>
<a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, <a class="el" href="classSimTK_1_1Mat.html" title="This class represents a small matrix whose size is known at compile time, containing elements of any ...">Mat</a>, <a class="el" href="classSimTK_1_1Matrix__.html" title="This is the matrix class intended to appear in user code for large, variable size matrices...">Matrix_</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1c4f863a54b68343ab160d46a4dfa107"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELT <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type of this Vec. </p>

</div>
</div>
<a class="anchor" id="a180db0a856dcd33f438ff607fb2d578e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negated version of this Vec's element type; ENeg==negator&lt; E &gt;. </p>

</div>
</div>
<a class="anchor" id="a1688fa5889391ca2510ec85af32c4d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type, stripped of negator&lt;&gt; if it has one. </p>

</div>
</div>
<a class="anchor" id="a9fe820179fbd756adb31a21ea1635c1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type showing just the real part of an element of this Vec if elements are complex; otherwise just the element type. </p>

</div>
</div>
<a class="anchor" id="ac960a48f176aa0870f267e6555489969"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type showing the imaginary part of an element of this Vec as real, if elements are complex; otherwise a type that can hold a zero of the element type. </p>

</div>
</div>
<a class="anchor" id="aa7122a7babdc45b6559fcfb2bcc5ba3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that elements would have if complex, if E is currently real; otherwise just the element type E. </p>

</div>
</div>
<a class="anchor" id="af1a6fe2fbd6109e110319dde19ef8080"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the Hermitian transpose of an element of this Vec. </p>

</div>
</div>
<a class="anchor" id="aaf724f6707ea5d622a8218c8c7d0a47a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aaf724f6707ea5d622a8218c8c7d0a47a">EPosTrans</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a <em>positional</em> transpose of an element of this Vec. </p>

</div>
</div>
<a class="anchor" id="a9e03a89cd7d90f90d2b77996912f7cf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the expression ~E*E (default vector and matrix square; symmetric). </p>

</div>
</div>
<a class="anchor" id="aed4f65810f2f99f99286c4de7526944c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the expression E*~E ("row square"; symmetric). </p>

</div>
</div>
<a class="anchor" id="ad7edbf8f2b7e6318eb98feadb1498e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type required to hold the result of sqrt(E). </p>

</div>
</div>
<a class="anchor" id="a9328f6e879f0bce93ae861ed3830adfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type required to hold the result of abs(E). </p>

</div>
</div>
<a class="anchor" id="a0cc83b9c25967c098119f0e604c15e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return type of standardize(E) method; a packed type that can hold the value of an element after eliminating negator and conjugate types. </p>

</div>
</div>
<a class="anchor" id="aeec08218c1b188793e64d47c3d1b8d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packed type that can hold the value returned from invert(E), the inverse type of an element. </p>

</div>
</div>
<a class="anchor" id="a5074ef8ddf4b5863b9c9aa73d08b0b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packed type that can hold the value returned from normalize(E). </p>

</div>
</div>
<a class="anchor" id="afb0c170f161ab33a760c6abed022c4e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a43fa9b9db155c966ec374279b11f7ec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a16e9c638c3725abee10ac8c0a0416938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a2dd99fd4db282175335f6b70a09c42d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ab6a2b3875ce3ab44712d2b46c7c8c48f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="abb9df16575296931169e80790f8180ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a226b3621ca279d62533bf2c2bc1494cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a226b3621ca279d62533bf2c2bc1494cf">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>. </p>

</div>
</div>
<a class="anchor" id="ad810229be85191609884e56063b788ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> would have if its elements were interpreted as negated. </p>

</div>
</div>
<a class="anchor" id="a5f18f1a887b7a31eaab12703b2d56eb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1688fa5889391ca2510ec85af32c4d27">EWithoutNegator</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> with negator removed from its element type, if the element is negated. </p>

</div>
</div>
<a class="anchor" id="aebcbc25b0f0f1f9226dfe5796f30d459"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a9fe820179fbd756adb31a21ea1635c1b">EReal</a>,STRIDE*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> cast to show only the real part of its element; this might affect the stride. </p>

</div>
</div>
<a class="anchor" id="acf0a11445fddc280dd6a1b3f9a54d4d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#ac960a48f176aa0870f267e6555489969">EImag</a>,STRIDE*<a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197">RealStrideFactor</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> cast to show only the imaginary part of its element; this might affect the stride. </p>

</div>
</div>
<a class="anchor" id="a3ac8c95d23ac09084c957db9e0807af4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aa7122a7babdc45b6559fcfb2bcc5ba3e">EComplex</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3ac8c95d23ac09084c957db9e0807af4">TComplex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a1664440ae833e25958fb6006815b93df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#af1a6fe2fbd6109e110319dde19ef8080">EHerm</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> after casting to its Hermitian transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> and each element turns into <em>its</em> Hermitian transpose. </p>

</div>
</div>
<a class="anchor" id="a21c96e0dda112e02745075e8bb727651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>,STRIDE&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> after casting to its positional transpose; that is, the <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> turns into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> but the element type remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a306a8e6c01acbd2f6f27769abe6f1fb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a306a8e6c01acbd2f6f27769abe6f1fb8">TElement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>. </p>

</div>
</div>
<a class="anchor" id="adee9814da9f07edf05e10aa8bf5b52a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee9814da9f07edf05e10aa8bf5b52a7">TRow</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a row of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>, just its element type). </p>

</div>
</div>
<a class="anchor" id="a3bea93707d0d519f3bc680520ed6dba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a3bea93707d0d519f3bc680520ed6dba8">TCol</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a column of this <a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a> object (for a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>, the whole thing). </p>

</div>
</div>
<a class="anchor" id="a6d723146f29d99138956fe3b0d71ea6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#ad7edbf8f2b7e6318eb98feadb1498e6e">ESqrt</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a429ca3d609af5044f8be5243dfba714b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a9328f6e879f0bce93ae861ed3830adfd">EAbs</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ad1f95f01fde583b2d46c9ef7a31e582e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="adee68a1b3427cdc2a096be35d8b3f1f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aeec08218c1b188793e64d47c3d1b8d87">EInvert</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a5f4d20cd03be610a163f04985d74822d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#a5074ef8ddf4b5863b9c9aa73d08b0b51">ENormalize</a>,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="aba33f5ae46bd5406b8bead75d3225e08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a9e03a89cd7d90f90d2b77996912f7cf3">ESqHermT</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aba33f5ae46bd5406b8bead75d3225e08">TSqHermT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="af941dd81c240827a807b59925f9353ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1SymMat.html">SymMat</a>&lt;M,<a class="el" href="classSimTK_1_1Vec.html#aed4f65810f2f99f99286c4de7526944c">ESqTHerm</a>&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af941dd81c240827a807b59925f9353ae">TSqTHerm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="a2747df15d62910c4e106267ff6a6456c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#afb0c170f161ab33a760c6abed022c4e5">EScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#a2747df15d62910c4e106267ff6a6456c">Scalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="acd8d06bc21666d641e6e8fc1d2348474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a43fa9b9db155c966ec374279b11f7ec8">EULessScalar</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#acd8d06bc21666d641e6e8fc1d2348474">ULessScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ad2dcbe4f4c13eab6d32664b39c53067e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a16e9c638c3725abee10ac8c0a0416938">ENumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ad2dcbe4f4c13eab6d32664b39c53067e">Number</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="aed3382cfdf59b23ac5fe16a359b9800e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#a2dd99fd4db282175335f6b70a09c42d3">EStdNumber</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#aed3382cfdf59b23ac5fe16a359b9800e">StdNumber</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="af41c74dcba45cbeccdafdc3c9276048d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#ab6a2b3875ce3ab44712d2b46c7c8c48f">EPrecision</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#af41c74dcba45cbeccdafdc3c9276048d">Precision</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<a class="anchor" id="ac5410fb3fc14453b32ced2e8134ad36c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Vec.html#abb9df16575296931169e80790f8180ee">EScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These compile-time constants are required of every Composite Numerical Type (<a class="el" href="classSimTK_1_1CNT.html" title="Specialized information about Composite Numerical Types which allows us to define appropriate templat...">CNT</a>). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca4098ba4c994d0a05d79f1f011fe826bb"></a>NRows&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaacb219bca801fa9b299610f154f34a04"></a>NCols&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca71e046bac8a181561519a6122e2da18d"></a>NPackedElements&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaa25980e89b5b6f756347facaa55bd6e5"></a>NActualElements&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcaece1f9f77763466fb8f7c196fd2b8f7a"></a>NActualScalars&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca8f18985bf3fa11ed08b6840c04705116"></a>RowSpacing&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca6d4bd0883fc982185b9e36f48ce39e1c"></a>ColSpacing&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcad531daf9c05933f95244a34b03754cda"></a>ImagOffset&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca6cefb5710f0913d3d08722d01870c197"></a>RealStrideFactor&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca4f5243de94fcb7adbf667f1a107ea625"></a>ArgDepth&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fcade2306ea77a38b5b4eb3c23646f359be"></a>IsScalar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca2a5ac8bb16b80ee3aab25745909e0de4"></a>IsULessScalar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca766b45bc4868d8a042efa4533671d18a"></a>IsNumber&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca2816cf70d3e06a09f6c54fc943689d17"></a>IsStdNumber&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca8f0d38ec0caa44f7307829d6ec454170"></a>IsPrecision&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac68d02035e9fb29b2b7c810a8d3554fca25bedfb632d2832892205ac5572d38be"></a>SignInterpretation&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d52d8c3207d1fd68197233c4a60029c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construction initializes Vec's elements to NaN when debugging but leaves them uninitialized garbage otherwise, so declarations have zero cost in Release builds. </p>

</div>
</div>
<a class="anchor" id="ad34c3d97a17ed494e9f0e5b2829ae419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination. </p>

</div>
</div>
<a class="anchor" id="ad6fd4b510a548add1477a13a1c99cc87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion from a Vec of the same length and element type but with a different stride. </p>

</div>
</div>
<a class="anchor" id="a57a5678f4109bde28c1c7829f030a752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a>, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion from a Vec of the same length and <em>negated</em> element type (possibly with a different stride). </p>

</div>
</div>
<a class="anchor" id="ad9220ca15fa8c7647bb0d5a7aaeb83b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> from a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> of the same length, with any stride. </p>
<p>Works as long as the element types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="abe343569bdc62601e22eddccb9b76fa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction from a single value of this Vec's element type assigns that value to each element. </p>

</div>
</div>
<a class="anchor" id="a0d54996ceb0ffdaaf35c0b42d13ffb22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a180db0a856dcd33f438ff607fb2d578e">ENeg</a> &amp;&#160;</td>
          <td class="paramname"><em>ne</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction from a single value of this Vec's negated element type assigns that value to each element, requiring floating point negation to be performed once to compute the type-E representation of the type negator&lt;E&gt; value provided. </p>

</div>
</div>
<a class="anchor" id="a58a2921791ea75c7022fb593b45c43f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an int value, turn it into a suitable floating point number, convert that to element type E and then feed that to the above single-element constructor. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Vec.html#abe343569bdc62601e22eddccb9b76fa3" title="Construction from a single value of this Vec&#39;s element type assigns that value to each element...">Vec::Vec(const E&amp;)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a594d2b0d02e91efc5547af4678d3535c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a Vec&lt;2,E&gt; from two elements of type E, etc. </p>

</div>
</div>
<a class="anchor" id="a6e0a194f6ca013c9026ff72f461bfc46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a71c9a675a80482caf12e02a34b399bb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a774e82ed4bb90e65fee729e2082e413b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dcac91cb1609810fac49da700e70e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5978f046474cf4481a5f0470f9558a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae204f1902d2834ff3f47f3c84db23385"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4f80f6ed39b2a75521423d25b23835b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>e8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c66f56b1930d82c36f90142af7fb536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::<a class="el" href="classSimTK_1_1Vec.html">Vec</a> </td>
          <td>(</td>
          <td class="paramtype">const EE *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction from a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E. </p>
<p>The supplied pointer cannot be null. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adc9ccbb5060fdbbf1e4446337217b699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of elements in this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> (note that stride does not affect this number.) </p>

</div>
</div>
<a class="anchor" id="a99f8825fc5c6297c9e0d804f3471d1f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::nrow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of rows in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is the number of elements. </p>

</div>
</div>
<a class="anchor" id="a51574e7c675a4662b23b24ba6e430492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::ncol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of columns in a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is always 1. </p>

</div>
</div>
<a class="anchor" id="a712141bb4fe924637c14555b1954b66a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarNormSqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar norm square is sum( conjugate squares of all underlying scalars ), where conjugate square of scalar s is conj(s)*s. </p>

</div>
</div>
<a class="anchor" id="a6a37bb45b9fc50d691005df0824af255"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::sqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise square root; that is, the return value has the same length as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with each element replaced by whatever it thinks its square root is. </p>
<p>The element type may have changed and the stride of the return <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is always 1. </p>

</div>
</div>
<a class="anchor" id="aafc94c4eaac8216b124ef659ff1d5487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a429ca3d609af5044f8be5243dfba714b">TAbs</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise absolute value; that is, the return value has the same dimension as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with each element replaced by whatever it thinks its absolute value is. </p>
<p>The element type may have changed and the stride of the return <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> is always 1. </p>

</div>
</div>
<a class="anchor" id="af696f3d3ec205726a276a2355104d9c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad1f95f01fde583b2d46c9ef7a31e582e">TStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::standardize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> but with the underlying scalar type converted (if necessary) to one of the C++ standard real or complex floating point types. </p>
<p>This may require floating point negations to occur to get read of negator or conjugate types. </p>

</div>
</div>
<a class="anchor" id="a051dc2d9f18a5b8b192e6e33c2dd49b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a0cc83b9c25967c098119f0e604c15e3c">EStandard</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum just adds up all the elements into a single return element that is the same type as this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>'s elements except standardized to use one of the C++ built-in real or complex types as its underlying scalars. </p>

</div>
</div>
<a class="anchor" id="a96ee6e2f4bad2e772e4ad019b28c591a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator copies the logically-included elements from the source Vec; gaps due to stride are not accessed in either source or destination. </p>
<p>OK if source and destination are the same vector; results are unpredictable if they otherwise overlap with elements in common. </p>

</div>
</div>
<a class="anchor" id="a1bf45d78264b6e333d79985c371efbf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const EE *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a pointer to elements of any type EE assumes we're pointing at a C++ array of EE's of the right length, and that EE is assignment compatible with this Vec's element type E. </p>
<p>The supplied pointer cannot be null. </p>

</div>
</div>
<a class="anchor" id="a9ced2e90bb014a4c09f2e830846b73ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a conforming Vec, of any element type and stride, provided that the element types are assignment-compatible. </p>

</div>
</div>
<a class="anchor" id="a2a8255aebddddbcdb4aaae12736a1b05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in a conforming Vec, of any element type and stride, provided that the element types are addition-compatible. </p>

</div>
</div>
<a class="anchor" id="a51cc4c59703b5544ac71bc5e57cc0b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible. </p>
<p>The negation is removed at zero cost by subtracting rather than adding. </p>

</div>
</div>
<a class="anchor" id="a46b643762736321072c6bd58ba141841"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract off a conforming Vec, of any element type and stride, provided that the element types are addition-compatible. </p>

</div>
</div>
<a class="anchor" id="aee444801ca472095d6fc0ff1a103718f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, <a class="el" href="classSimTK_1_1negator.html">negator</a>&lt; EE &gt;, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract off a conforming Vec, of any negated element type and stride, provided that the element types are addition-compatible. </p>
<p>The negation is removed at zero cost by adding rather than subtracting. </p>

</div>
</div>
<a class="anchor" id="a82a4da394cb53cde9c5a63dc8a098f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Add&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::conformingAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector addition &ndash; use operator+ instead. </p>

</div>
</div>
<a class="anchor" id="a69d1a60f240f485bc1f9c844ec1cd733"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::conformingSubtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector subtraction &ndash; use operator- instead. </p>

</div>
</div>
<a class="anchor" id="a7a9702efd5be91edf3f06f0680303ec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;M,M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::conformingMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as outer product (m = col*row) &ndash; use operator* or <a class="el" href="namespaceSimTK.html#a0fd293cad29bd6fa0405ccffca69c738">outer()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a5f554ca51a94f9cfa61a36b495478e5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::elementwiseMultiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise multiply (Matlab " .* " operator). </p>

</div>
</div>
<a class="anchor" id="a3af4163f4d188bf82242584bf985ccb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE , int SS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::elementwiseDivide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, EE, SS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise divide (Matlab " ./ " operator). </p>

</div>
</div>
<a class="anchor" id="ab1ecf7f59bd4b7c6b9dfd67566b75449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element of this Vec and return a const reference to it. </p>
<p>This is range-checked in Debug builds but has zero overhead in Release builds. </p>

</div>
</div>
<a class="anchor" id="a32bc6a710c601343c9fe30e34c20b7bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as const operator[] above. </p>

</div>
</div>
<a class="anchor" id="ae44a011242e15a9188acf63a6625e6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element of this Vec and return a writable reference to it. </p>
<p>This is range-checked in Debug builds but has zero overhead in Release builds. </p>

</div>
</div>
<a class="anchor" id="a2918c06d3f0b353076c5fa9ce8019509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as non-const operator[] above. </p>

</div>
</div>
<a class="anchor" id="a95575b22850f63eaa64858660c8c8c64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::normSqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bcb573b11b780148f1ff3e7f5961997"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#ac5410fb3fc14453b32ced2e8134ad36c">ScalarNormSq</a>&gt;::<a class="el" href="classSimTK_1_1Vec.html#a6d723146f29d99138956fe3b0d71ea6f">TSqrt</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbd852b56584cfeda803eab3a95fb7db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a5f4d20cd03be610a163f04985d74822d">TNormalize</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the elements of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> are scalars, the result is what you get by dividing each element by the <a class="el" href="classSimTK_1_1Vec.html#a5bcb573b11b780148f1ff3e7f5961997">norm()</a> calculated above. </p>
<p>If the elements are <em>not</em> scalars, then the elements are *separately* normalized. That means you will get a different answer from <a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db" title="If the elements of this Vec are scalars, the result is what you get by dividing each element by the n...">Vec&lt;2,Vec3&gt;::normalize()</a> than you would from a <a class="el" href="classSimTK_1_1Vec.html#abbd852b56584cfeda803eab3a95fb7db" title="If the elements of this Vec are scalars, the result is what you get by dividing each element by the n...">Vec&lt;6&gt;::normalize()</a> containing the same scalars.</p>
<p>Normalize returns a vector of the same dimension but in new, packed storage and with a return type that does not include negator&lt;&gt; even if the original Vec&lt;&gt; does, because we can eliminate the negation here almost for free. But we can't standardize (change conjugate to complex) for free, so we'll retain conjugates if there are any. </p>

</div>
</div>
<a class="anchor" id="a66cea75e2ed6de1c379a46745849c473"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#adee68a1b3427cdc2a096be35d8b3f1f6">TInvert</a> <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is not supported for Vec objects. </p>

</div>
</div>
<a class="anchor" id="ae28bb6b73abb3704de062f751dab4921"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary plus does nothing. </p>

</div>
</div>
<a class="anchor" id="a1d18cd6340b717437a31770499069bfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus recasts this Vec to a type that has the opposite interpretation of the sign but is otherwise identical, so no computation or copying is performed here. </p>

</div>
</div>
<a class="anchor" id="a52644eefd67080b80bba767e5affceb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to negated type and return a writable reference; writing to this will cause the negated result to be placed in the original Vec. </p>

</div>
</div>
<a class="anchor" id="a4b82833142e2b30ae998f1ee357245b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Hermitian transpose operator recasts this Vec to a type that specifies the opposite storage order (row vs. column) then returns a reference, so no computation or copying is performed here. </p>

</div>
</div>
<a class="anchor" id="a055c47346d5b16b0a7ced839b91a9aa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to Hermitian transposed type and return a writable reference; the effect is that writing to elements of the result affects the transposed element of the original Vec. </p>

</div>
</div>
<a class="anchor" id="a99e24a8076a1aed2b65595b0b382c71f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-operator version of unary negation; just a recast. </p>

</div>
</div>
<a class="anchor" id="a5108f85c423f5e00e51a198734ed17c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#ad810229be85191609884e56063b788ce">TNeg</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updNegate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-operator version of unary negation; recasts and returns a writable reference. </p>

</div>
</div>
<a class="anchor" id="a3eb9d7c001c9594fd65c50365dce0d5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-operator version of Hermitian transpose; just a recast. </p>

</div>
</div>
<a class="anchor" id="a3e181c0844930d9dbec8afb613f762d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a1664440ae833e25958fb6006815b93df">THerm</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-operator version of Hermitian transpose; recasts and returns a writable reference. </p>

</div>
</div>
<a class="anchor" id="a1e92208963211edbb39751c128310a0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::positionalTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positional transpose turns this Vec into a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> but does not transpose the individual elements. </p>
<p>That is, a <a class="el" href="classSimTK_1_1Vec.html">Vec&lt;2,Vec3&gt;</a> becomes a Row&lt;2,Vec3&gt;, rather than a Row&lt;2,Row3&gt; as would happen with ordinary <a class="el" href="classSimTK_1_1Vec.html#a3eb9d7c001c9594fd65c50365dce0d5c" title="Non-operator version of Hermitian transpose; just a recast. ">transpose()</a>. This is just a recast; no copying or computation is performed here. </p>

</div>
</div>
<a class="anchor" id="a6021a62d22537c7ad406b7a1c1ca0761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a21c96e0dda112e02745075e8bb727651">TPosTrans</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updPositionalTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positional transpose returning a writable reference. </p>

</div>
</div>
<a class="anchor" id="ac891ea80a0181132c2430a349f461d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the real portion of this Vec if it has complex elements; otherwise the type doesn't change. </p>
<p>This is just a recast; no copying or computation is done here. The result may have a different stride than the original since the imaginary parts must be skipped. </p>

</div>
</div>
<a class="anchor" id="adc792ec3e435535fc8fe4ad3810d54fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#aebcbc25b0f0f1f9226dfe5796f30d459">TReal</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to show only the real portion of this Vec and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="aff885dcf7ea01c94d7621be973fd1aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the imaginary portion of this Vec if it has complex elements; otherwise the type doesn't change. </p>
<p>This is just a recast; no copying or computation is done here. The result may have a different stride than the original since the real parts must be skipped. </p>

</div>
</div>
<a class="anchor" id="a4b3ecf2380f493c8b48ad6d0d50695f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#acf0a11445fddc280dd6a1b3f9a54d4d3">TImag</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to show only the imaginary portion of this Vec and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="a9283ff051541b8f511d748f862f1eb9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::castAwayNegatorIfAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to remove negators from this Vec's type if present; this is handy for simplifying operations where we know the sign can be ignored such as squaring. </p>

</div>
</div>
<a class="anchor" id="a2467300a636639eb7195ca7ea37d5ee8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html#a5f18f1a887b7a31eaab12703b2d56eb5">TWithoutNegator</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updCastAwayNegatorIfAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast to remove negators from this Vec's type if present and return a writable reference. </p>

</div>
</div>
<a class="anchor" id="a37b496ee9a8f41defa3250da5ed0014e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMultiply </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a314e384e0d1cc1077562131cb7a773a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Mul&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMultiplyFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a97a9b3263e294d85755e4c777302c2ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivide </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34606c49af85f3f3b54341b54815cf25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Dvd&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivideFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a474088f0218a89d4116358da2ced4fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Add&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarAdd </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a69fc2003203268bcd10f9eadf9412695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;EE&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarSubtract </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ee50b918ae4eefc8c8ac1a177d7f7c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M, typename <a class="el" href="classSimTK_1_1CNT.html">CNT</a>&lt;EE&gt;::template <a class="el" href="structSimTK_1_1Vec_1_1Result.html">Result</a>&lt;<a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&gt;::Sub&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarSubtractFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aace53cca908837b6b13de05a6bbda540"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d6459937f78236c913e2ec50d328d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b247dbd3a71bdcef1a0a4af1cece4c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1c865e00508d708562c21012f0cb66e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a273abdf63fc3f9e8d720b6b1c9ebd047"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47cc5ea1fc0e6db75f4fe78c85772179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarEq </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d9a9f23aeaf38da791ec0173f5b49d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarPlusEq </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af1ecc870150f4bbaddacf812bf3a55a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMinusEq </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a11d049de83f163743bc576395746f0e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMinusEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af8f25b932993267cacda311724882b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarTimesEq </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1549f7c02c5f35b6ae02f3a384ba0461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarTimesEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ec0b452d52d289345c333b6b1f61c1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivideEq </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68d6c34551dd57324842f2e630ac5798"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivideEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18982d1fac249ed0050b0497fc1b5fff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e47b406661090c6bbb580bb32f613b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarPlusEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab402c2238f2821d55a97dcdfb36ad0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMinusEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7bba57628dc553c6155205ba7ebd0330"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarTimesEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeafb7930483190b14571c043ccb33ce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivideEq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab07b8dc8c7690f71f6a2a7232c06f8b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarMinusEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a695383084e4311219d9c1d86330bc3fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarTimesEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a45beaad82e2504367de24345f1b7f60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::scalarDivideEqFromLeft </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b11014a0ad910e4254a26d39f013565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::setToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set every scalar in this Vec to NaN; this is the default initial value in Debug builds, but not in Release. </p>

</div>
</div>
<a class="anchor" id="a25018475a82b7f1c61956d824104b300"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::setToZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set every scalar in this Vec to zero. </p>

</div>
</div>
<a class="anchor" id="aba184e5623fcecb388ab58eb91232052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;MM,ELT,STRIDE&gt;&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::getSubVec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a const reference to a sub-Vec with size known at compile time. </p>
<p>This must be called with an explicit template argument for the size, for example, getSubVec&lt;3&gt;(i). This is only a recast; no copying or computation is performed. The size and index are range checked in Debug builds but not in Release builds. </p>

</div>
</div>
<a class="anchor" id="a085715471acf42722ddd05eb8028e13c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;MM,ELT,STRIDE&gt;&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updSubVec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a writable reference to a sub-Vec with size known at compile time. </p>
<p>This must be called with an explicit template argument for the size, for example, updSubVec&lt;3&gt;(i). This is only a recast; no copying or computation is performed. The size and index are range checked in Debug builds but not in Release builds. </p>

</div>
</div>
<a class="anchor" id="a250ac248ba601828531ca324917dc3ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::getSubVec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a const reference to the selected subsequence. </p>

</div>
</div>
<a class="anchor" id="a6c3d2b34d4c58321ddd8ebbc997877dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;int MM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updSubVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; MM, ELT, STRIDE &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a subvector of type Vec from a longer one that has the same element type and stride, and return a writable reference to the selected subsequence. </p>

</div>
</div>
<a class="anchor" id="aa0b31ae5026f2529651aeaad88d705b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M-1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::drop1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector one smaller than this one by dropping the element at the indicated position p. </p>
<p>The result is a packed copy with the same element type as this one. </p>

</div>
</div>
<a class="anchor" id="acc5b268f14abe92735185cafadd888dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M+1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::append1 </td>
          <td>(</td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector one larger than this one by adding an element to the end. </p>
<p>The result is a packed copy with the same element type as this one. Works for any assignment compatible element. </p>

</div>
</div>
<a class="anchor" id="a19c8f4c92e03d90c4ec80644fb3d7bdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class EE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M+1,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::insert1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EE &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a vector one larger than this one by inserting an element <em>before</em> the indicated one. </p>
<p>The result is a packed copy with the same element type as this one. Works for any assignment compatible element. The index can be one greater than normally allowed in which case the element is appended (but use <a class="el" href="classSimTK_1_1Vec.html#acc5b268f14abe92735185cafadd888dc" title="Return a vector one larger than this one by adding an element to the end. ">append1()</a> if you know you're appending). </p>

</div>
</div>
<a class="anchor" id="abf8283cc8bb6cccd44287e439811198d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::getAs </td>
          <td>(</td>
          <td class="paramtype">const ELT *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast an ordinary C++ array E[] to a const Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing. </p>

</div>
</div>
<a class="anchor" id="affb89a98c7696e0a5fa04a17924e19f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::updAs </td>
          <td>(</td>
          <td class="paramtype">ELT *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast a writable ordinary C++ array E[] to a writable Vec&lt;M,E,S&gt;; assumes compatible length, stride, and packing. </p>

</div>
</div>
<a class="anchor" id="ade1b06280e2190f1d4317a04355f12ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;M,ELT,1&gt; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::getNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Vec of the same length and element type as this one but with all elements set to NaN. </p>
<p>The result is packed (stride==1) regardless of the stride of this Vec. </p>

</div>
</div>
<a class="anchor" id="aee785192d37052d76ff80d62338a6302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> contains a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="aa92ef2895e51a3ff4f1a3c264012c4ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any element of this <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> contains a +Infinity or -Infinity somewhere but no element contains a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="a1a0574822d6633f8b621d9c676a4352a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if no element of this Vec contains an Infinity or a NaN anywhere. </p>

</div>
</div>
<a class="anchor" id="a781827a50ebc3d83a0736738bc2e2784"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::getDefaultTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For approximate comparisions, the default tolerance to use for a vector is the same as its elements' default tolerance. </p>

</div>
</div>
<a class="anchor" id="a862a6d93b3109965ce7104c6beae5de6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class E2 , int RS2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isNumericallyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether this vector is numerically equal to some other vector with the same shape, using a specified tolerance. </p>

</div>
</div>
<a class="anchor" id="a596116b98d5d15f0112d1e052f09aeab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<div class="memtemplate">
template&lt;class E2 , int RS2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isNumericallyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; M, E2, RS2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether this vector is numerically equal to some other vector with the same shape, using a default tolerance which is the looser of the default tolerances of the two objects being compared. </p>

</div>
</div>
<a class="anchor" id="a576e2e126e4f3bb2f59dc91ef1fbcfc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::isNumericallyEqual </td>
          <td>(</td>
          <td class="paramtype">const ELT &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="classSimTK_1_1Vec.html#a781827a50ebc3d83a0736738bc2e2784">getDefaultTolerance</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether every element of this vector is numerically equal to the given element, using either a specified tolerance or the vector's default tolerance (which is always the same or looser than the default tolerance for one of its elements). </p>

</div>
</div>
<a class="anchor" id="aa71ef634c8bcf182405248a215acb789"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> into a string and return it. </p>
<p>Please refer to operator&lt;&lt; for details. </p>

</div>
</div>
<a class="anchor" id="a907c5d98e3f7b29f858c5f56c6e38738"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of operator[] that's scripting friendly to set ith entry. </p>

</div>
</div>
<a class="anchor" id="a8bc57b3dd6983c252b3654a4d6548f05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int M, class ELT, int STRIDE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html#a1c4f863a54b68343ab160d46a4dfa107">E</a>&amp; <a class="el" href="classSimTK_1_1Vec.html">SimTK::Vec</a>&lt; M, ELT, STRIDE &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of operator[] that's scripting friendly to get const reference to ith entry. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h_source.html">SimTKcommon/include/SimTKcommon/internal/common.h</a></li>
<li><a class="el" href="Vec_8h_source.html">Vec.h</a></li>
<li><a class="el" href="Serialize_8h_source.html">Serialize.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Vec.html">Vec</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:26 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
