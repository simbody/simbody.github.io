<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Inertia_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Inertia__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Inertia__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Inertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The physical meaning of an inertia is the distribution of a rigid body's mass about a <em>particular</em> point.  
 <a href="classSimTK_1_1Inertia__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Inertia_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Inertia__.png" usemap="#SimTK::Inertia_5F_3C_20P_20_3E_map" alt=""/>
  <map id="SimTK::Inertia_5F_3C_20P_20_3E_map" name="SimTK::Inertia_&lt; P &gt;_map">
<area href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i..." alt="SimTK::UnitInertia_&lt; P &gt;" shape="rect" coords="0,56,148,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2b329d1fc62a9c7b952d1b3c88dff71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa2b329d1fc62a9c7b952d1b3c88dff71">Inertia_</a> ()</td></tr>
<tr class="memdesc:aa2b329d1fc62a9c7b952d1b3c88dff71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="#aa2b329d1fc62a9c7b952d1b3c88dff71">More...</a><br /></td></tr>
<tr class="separator:aa2b329d1fc62a9c7b952d1b3c88dff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd5c9309fe5d443af3964bd030d2f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a67cd5c9309fe5d443af3964bd030d2f9">Inertia_</a> (const RealP &amp;moment)</td></tr>
<tr class="memdesc:a67cd5c9309fe5d443af3964bd030d2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix with identical diagonal elements, like a sphere where moment=2/5 m r^2, or a cube where moment=1/6 m s^2, with m the total mass, r the sphere's radius and s the length of a side of the cube.  <a href="#a67cd5c9309fe5d443af3964bd030d2f9">More...</a><br /></td></tr>
<tr class="separator:a67cd5c9309fe5d443af3964bd030d2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e29578287d59727cfc7427d0047c88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af3e29578287d59727cfc7427d0047c88">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass)</td></tr>
<tr class="memdesc:af3e29578287d59727cfc7427d0047c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point mass at a given location, measured from the origin OF of the implicit frame F, and expressed in F.  <a href="#af3e29578287d59727cfc7427d0047c88">More...</a><br /></td></tr>
<tr class="separator:af3e29578287d59727cfc7427d0047c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757715dbe6c947a0fee42b40899b39f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a6757715dbe6c947a0fee42b40899b39f">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a6757715dbe6c947a0fee42b40899b39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="#a6757715dbe6c947a0fee42b40899b39f">More...</a><br /></td></tr>
<tr class="separator:a6757715dbe6c947a0fee42b40899b39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe875cb713abfe04736892484d7d51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afffe875cb713abfe04736892484d7d51">Inertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:afffe875cb713abfe04736892484d7d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix (only non-zero on diagonal).  <a href="#afffe875cb713abfe04736892484d7d51">More...</a><br /></td></tr>
<tr class="separator:afffe875cb713abfe04736892484d7d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170b86e5d3b138e93108721fb598b90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5170b86e5d3b138e93108721fb598b90">Inertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:a5170b86e5d3b138e93108721fb598b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general inertia matrix.  <a href="#a5170b86e5d3b138e93108721fb598b90">More...</a><br /></td></tr>
<tr class="separator:a5170b86e5d3b138e93108721fb598b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c68f0d0e0814fcd57eea00e5eb21234"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0c68f0d0e0814fcd57eea00e5eb21234">Inertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;inertia)</td></tr>
<tr class="memdesc:a0c68f0d0e0814fcd57eea00e5eb21234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia from a symmetric 3x3 matrix.  <a href="#a0c68f0d0e0814fcd57eea00e5eb21234">More...</a><br /></td></tr>
<tr class="separator:a0c68f0d0e0814fcd57eea00e5eb21234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafd3401dc8ca2b5c2dac17e43701549"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aaafd3401dc8ca2b5c2dac17e43701549">Inertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:aaafd3401dc8ca2b5c2dac17e43701549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia matrix from a 3x3 symmetric matrix.  <a href="#aaafd3401dc8ca2b5c2dac17e43701549">More...</a><br /></td></tr>
<tr class="separator:aaafd3401dc8ca2b5c2dac17e43701549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef4b5dc3fdac7589ae14a9f0e79e6b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a1ef4b5dc3fdac7589ae14a9f0e79e6b1">setInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:a1ef4b5dc3fdac7589ae14a9f0e79e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an inertia matrix to have only principal moments (that is, it will be diagonal).  <a href="#a1ef4b5dc3fdac7589ae14a9f0e79e6b1">More...</a><br /></td></tr>
<tr class="separator:a1ef4b5dc3fdac7589ae14a9f0e79e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b76c4a2fa12cb3f5346feabb1688e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51b76c4a2fa12cb3f5346feabb1688e5">setInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a51b76c4a2fa12cb3f5346feabb1688e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="#a51b76c4a2fa12cb3f5346feabb1688e5">More...</a><br /></td></tr>
<tr class="separator:a51b76c4a2fa12cb3f5346feabb1688e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172f5d103b854fe80b7b175cbdf1b165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a172f5d103b854fe80b7b175cbdf1b165">setInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:a172f5d103b854fe80b7b175cbdf1b165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this Inertia to a general matrix.  <a href="#a172f5d103b854fe80b7b175cbdf1b165">More...</a><br /></td></tr>
<tr class="separator:a172f5d103b854fe80b7b175cbdf1b165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f2d580d93155eac72b30e1d5d4ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a232f2d580d93155eac72b30e1d5d4ea5">operator+=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:a232f2d580d93155eac72b30e1d5d4ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in another inertia matrix.  <a href="#a232f2d580d93155eac72b30e1d5d4ea5">More...</a><br /></td></tr>
<tr class="separator:a232f2d580d93155eac72b30e1d5d4ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761fb58e427c6bbc9c1a1abd3d29a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af761fb58e427c6bbc9c1a1abd3d29a4e">operator-=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:af761fb58e427c6bbc9c1a1abd3d29a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off another inertia matrix.  <a href="#af761fb58e427c6bbc9c1a1abd3d29a4e">More...</a><br /></td></tr>
<tr class="separator:af761fb58e427c6bbc9c1a1abd3d29a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d1bec66484957bb0ebe1be4d1736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2b50d1bec66484957bb0ebe1be4d1736">operator*=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2b50d1bec66484957bb0ebe1be4d1736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this inertia matrix by a scalar. Cost is 6 flops.  <a href="#a2b50d1bec66484957bb0ebe1be4d1736">More...</a><br /></td></tr>
<tr class="separator:a2b50d1bec66484957bb0ebe1be4d1736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d583c80cb337680c60b88dc455e8eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2d583c80cb337680c60b88dc455e8eed">operator/=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2d583c80cb337680c60b88dc455e8eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide this inertia matrix by a scalar.  <a href="#a2d583c80cb337680c60b88dc455e8eed">More...</a><br /></td></tr>
<tr class="separator:a2d583c80cb337680c60b88dc455e8eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000e4873c70bd977a2ecaba19be60794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a000e4873c70bd977a2ecaba19be60794">shiftToMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF, const RealP &amp;mass) const </td></tr>
<tr class="memdesc:a000e4873c70bd977a2ecaba19be60794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="#a000e4873c70bd977a2ecaba19be60794">More...</a><br /></td></tr>
<tr class="separator:a000e4873c70bd977a2ecaba19be60794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faa542f554572d91f36d013fa531aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a7faa542f554572d91f36d013fa531aa2">shiftToMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF, const RealP &amp;mass)</td></tr>
<tr class="memdesc:a7faa542f554572d91f36d013fa531aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="#a7faa542f554572d91f36d013fa531aa2">More...</a><br /></td></tr>
<tr class="separator:a7faa542f554572d91f36d013fa531aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad56af59c6eb1c306dd7dca0f77f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a9cad56af59c6eb1c306dd7dca0f77f27">shiftFromMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass) const </td></tr>
<tr class="memdesc:a9cad56af59c6eb1c306dd7dca0f77f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="#a9cad56af59c6eb1c306dd7dca0f77f27">More...</a><br /></td></tr>
<tr class="separator:a9cad56af59c6eb1c306dd7dca0f77f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c57dbb5548ab99a910bb24f1c07d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa86c57dbb5548ab99a910bb24f1c07d5">shiftFromMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass)</td></tr>
<tr class="memdesc:aa86c57dbb5548ab99a910bb24f1c07d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="#aa86c57dbb5548ab99a910bb24f1c07d5">More...</a><br /></td></tr>
<tr class="separator:aa86c57dbb5548ab99a910bb24f1c07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded5c13f1f5cee2aec5319953eb401c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a8ded5c13f1f5cee2aec5319953eb401c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="#a8ded5c13f1f5cee2aec5319953eb401c">More...</a><br /></td></tr>
<tr class="separator:a8ded5c13f1f5cee2aec5319953eb401c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c802f5dab0c8aba78da00df82a73f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a73c802f5dab0c8aba78da00df82a73f4">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a73c802f5dab0c8aba78da00df82a73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a73c802f5dab0c8aba78da00df82a73f4">More...</a><br /></td></tr>
<tr class="separator:a73c802f5dab0c8aba78da00df82a73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a49f053e7c11240ad4e802786f254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4c4a49f053e7c11240ad4e802786f254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c" title="Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="#a4c4a49f053e7c11240ad4e802786f254">More...</a><br /></td></tr>
<tr class="separator:a4c4a49f053e7c11240ad4e802786f254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021fe4887710d1285fc6d1c5bd728aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4021fe4887710d1285fc6d1c5bd728aa">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4021fe4887710d1285fc6d1c5bd728aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress in place using an inverse rotation to avoid having to convert it.  <a href="#a4021fe4887710d1285fc6d1c5bd728aa">More...</a><br /></td></tr>
<tr class="separator:a4021fe4887710d1285fc6d1c5bd728aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23859436a032c1e574cf1436330e50dc"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a23859436a032c1e574cf1436330e50dc">trace</a> () const </td></tr>
<tr class="separator:a23859436a032c1e574cf1436330e50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c83f66b07a3633caf070d8896e17b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae1c83f66b07a3633caf070d8896e17b7">operator const SymMat33P &amp;</a> () const </td></tr>
<tr class="memdesc:ae1c83f66b07a3633caf070d8896e17b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to a const SymMat33.  <a href="#ae1c83f66b07a3633caf070d8896e17b7">More...</a><br /></td></tr>
<tr class="separator:ae1c83f66b07a3633caf070d8896e17b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab156ca728529e3f6641003b840d51acc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab156ca728529e3f6641003b840d51acc">asSymMat33</a> () const </td></tr>
<tr class="memdesc:ab156ca728529e3f6641003b840d51acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the underlying symmetric matrix type.  <a href="#ab156ca728529e3f6641003b840d51acc">More...</a><br /></td></tr>
<tr class="separator:ab156ca728529e3f6641003b840d51acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c0ed7f30e9a7c6a4789bfb5b05775c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a36c0ed7f30e9a7c6a4789bfb5b05775c">toMat33</a> () const </td></tr>
<tr class="memdesc:a36c0ed7f30e9a7c6a4789bfb5b05775c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the internal packed representation into a full 3x3 symmetric matrix with all elements set.  <a href="#a36c0ed7f30e9a7c6a4789bfb5b05775c">More...</a><br /></td></tr>
<tr class="separator:a36c0ed7f30e9a7c6a4789bfb5b05775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12695d09b41d77ca188b70ac9fa454c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a12695d09b41d77ca188b70ac9fa454c3">getMoments</a> () const </td></tr>
<tr class="memdesc:a12695d09b41d77ca188b70ac9fa454c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3 ordered xx, yy, zz.  <a href="#a12695d09b41d77ca188b70ac9fa454c3">More...</a><br /></td></tr>
<tr class="separator:a12695d09b41d77ca188b70ac9fa454c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8518a3d580aef33a332fca0c264db96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab8518a3d580aef33a332fca0c264db96">getProducts</a> () const </td></tr>
<tr class="memdesc:ab8518a3d580aef33a332fca0c264db96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia products (off-diagonals of the Inertia matrix) as a Vec3 with elements ordered xy, xz, yz.  <a href="#ab8518a3d580aef33a332fca0c264db96">More...</a><br /></td></tr>
<tr class="separator:ab8518a3d580aef33a332fca0c264db96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23a4618b211aa416301b7639fbc9dc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab23a4618b211aa416301b7639fbc9dc3">isNaN</a> () const </td></tr>
<tr class="separator:ab23a4618b211aa416301b7639fbc9dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff49432033de46bc8d43ace62269461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5ff49432033de46bc8d43ace62269461">isInf</a> () const </td></tr>
<tr class="separator:a5ff49432033de46bc8d43ace62269461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d1d61b83d7a7b17d9728d1211a9ebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a68d1d61b83d7a7b17d9728d1211a9ebb">isFinite</a> () const </td></tr>
<tr class="separator:a68d1d61b83d7a7b17d9728d1211a9ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1dc63b25c031af43cae91862ae9c74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a3f1dc63b25c031af43cae91862ae9c74">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other) const </td></tr>
<tr class="memdesc:a3f1dc63b25c031af43cae91862ae9c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a default numerical tolerance.  <a href="#a3f1dc63b25c031af43cae91862ae9c74">More...</a><br /></td></tr>
<tr class="separator:a3f1dc63b25c031af43cae91862ae9c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e057e5f4b948bb560b5d9a8e812e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af7e057e5f4b948bb560b5d9a8e812e40">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other, double tol) const </td></tr>
<tr class="memdesc:af7e057e5f4b948bb560b5d9a8e812e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a specified numerical tolerance.  <a href="#af7e057e5f4b948bb560b5d9a8e812e40">More...</a><br /></td></tr>
<tr class="separator:af7e057e5f4b948bb560b5d9a8e812e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09065c454fb39eec2dee757f63ff277e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a09065c454fb39eec2dee757f63ff277e">isValidInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a09065c454fb39eec2dee757f63ff277e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid Inertia matrix.  <a href="#a09065c454fb39eec2dee757f63ff277e">More...</a><br /></td></tr>
<tr class="separator:a09065c454fb39eec2dee757f63ff277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf11cafc9975fd5e6072f12548a467f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#adaf11cafc9975fd5e6072f12548a467f">pointMassAtOrigin</a> ()</td></tr>
<tr class="memdesc:adaf11cafc9975fd5e6072f12548a467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point located at the origin &ndash; that is, an all-zero matrix.  <a href="#adaf11cafc9975fd5e6072f12548a467f">More...</a><br /></td></tr>
<tr class="separator:adaf11cafc9975fd5e6072f12548a467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa644c212473bd29473a768d15caf291e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa644c212473bd29473a768d15caf291e">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;m)</td></tr>
<tr class="memdesc:aa644c212473bd29473a768d15caf291e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point of a given mass, located at a given location measured from the origin of the implicit F frame.  <a href="#aa644c212473bd29473a768d15caf291e">More...</a><br /></td></tr>
<tr class="separator:aa644c212473bd29473a768d15caf291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unit inertia matrix factories</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These return UnitInertia matrices (inertias of unit-mass objects) converted to Inertias.</p>
<p>Multiply the result by the actual mass to get the Inertia of an actual object of this shape. See the UnitInertia class for more information. </p>
</div></td></tr>
<tr class="memitem:a0079ce02a6ce9ddb2c3cdf26f5c88fac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0079ce02a6ce9ddb2c3cdf26f5c88fac">sphere</a> (const RealP &amp;r)</td></tr>
<tr class="memdesc:a0079ce02a6ce9ddb2c3cdf26f5c88fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="#a0079ce02a6ce9ddb2c3cdf26f5c88fac">More...</a><br /></td></tr>
<tr class="separator:a0079ce02a6ce9ddb2c3cdf26f5c88fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731715abc3e23d14716ed8778c3a41db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a731715abc3e23d14716ed8778c3a41db">cylinderAlongZ</a> (const RealP &amp;r, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a731715abc3e23d14716ed8778c3a41db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="#a731715abc3e23d14716ed8778c3a41db">More...</a><br /></td></tr>
<tr class="separator:a731715abc3e23d14716ed8778c3a41db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7fa18382bb190462ec90cee793c618"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afb7fa18382bb190462ec90cee793c618">cylinderAlongY</a> (const RealP &amp;r, const RealP &amp;hy)</td></tr>
<tr class="memdesc:afb7fa18382bb190462ec90cee793c618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="#afb7fa18382bb190462ec90cee793c618">More...</a><br /></td></tr>
<tr class="separator:afb7fa18382bb190462ec90cee793c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d2690f9520647fc41426d2da97a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab408d2690f9520647fc41426d2da97a5">cylinderAlongX</a> (const RealP &amp;r, const RealP &amp;hx)</td></tr>
<tr class="memdesc:ab408d2690f9520647fc41426d2da97a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="#ab408d2690f9520647fc41426d2da97a5">More...</a><br /></td></tr>
<tr class="separator:ab408d2690f9520647fc41426d2da97a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1dc7f12543454dadb1ea0ab243b2a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3">brick</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:afe1dc7f12543454dadb1ea0ab243b2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="#afe1dc7f12543454dadb1ea0ab243b2a3">More...</a><br /></td></tr>
<tr class="separator:afe1dc7f12543454dadb1ea0ab243b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e344c2ae3ff6b5ac4a84f632c4c7f8e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a6e344c2ae3ff6b5ac4a84f632c4c7f8e">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a6e344c2ae3ff6b5ac4a84f632c4c7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths.  <a href="#a6e344c2ae3ff6b5ac4a84f632c4c7f8e">More...</a><br /></td></tr>
<tr class="separator:a6e344c2ae3ff6b5ac4a84f632c4c7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce85ba36aeec4e390d1adb99d34b33d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d">ellipsoid</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a2ce85ba36aeec4e390d1adb99d34b33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="#a2ce85ba36aeec4e390d1adb99d34b33d">More...</a><br /></td></tr>
<tr class="separator:a2ce85ba36aeec4e390d1adb99d34b33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc60ba4fe2d9bf269bfb9789a3433b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ac4bc60ba4fe2d9bf269bfb9789a3433b">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:ac4bc60ba4fe2d9bf269bfb9789a3433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="#ac4bc60ba4fe2d9bf269bfb9789a3433b">More...</a><br /></td></tr>
<tr class="separator:ac4bc60ba4fe2d9bf269bfb9789a3433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9f881a10d5ca19fad90ad60b5491fbf5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a9f881a10d5ca19fad90ad60b5491fbf5">getAsUnitInertia</a> () const </td></tr>
<tr class="separator:a9f881a10d5ca19fad90ad60b5491fbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542289a1b1ae02d15d2e6ca581b5f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2542289a1b1ae02d15d2e6ca581b5f03">updAsUnitInertia</a> ()</td></tr>
<tr class="separator:a2542289a1b1ae02d15d2e6ca581b5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96544452d94f01b0f5167c8be260d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ada96544452d94f01b0f5167c8be260d7">errChk</a> (const char *methodName) const </td></tr>
<tr class="separator:ada96544452d94f01b0f5167c8be260d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a12f924bcb499f181af8687660f939d04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a12f924bcb499f181af8687660f939d04">I_OF_F</a></td></tr>
<tr class="separator:a12f924bcb499f181af8687660f939d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa13a2386109b73510feedacbc00dcb06">operator+</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:aa13a2386109b73510feedacbc00dcb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two compatible inertia matrices, meaning they must be taken about the same point and expressed in the same frame.  <a href="#aa13a2386109b73510feedacbc00dcb06">More...</a><br /></td></tr>
<tr class="separator:aa13a2386109b73510feedacbc00dcb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad11356749d9b854ac7c54941f8898123">operator-</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:ad11356749d9b854ac7c54941f8898123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from one inertia matrix another one which is compatible, meaning that both must be taken about the same point and expressed in the same frame.  <a href="#ad11356749d9b854ac7c54941f8898123">More...</a><br /></td></tr>
<tr class="separator:ad11356749d9b854ac7c54941f8898123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0e0178f717c4a3c324ae9e7acbe670b5">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a0e0178f717c4a3c324ae9e7acbe670b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="#a0e0178f717c4a3c324ae9e7acbe670b5">More...</a><br /></td></tr>
<tr class="separator:a0e0178f717c4a3c324ae9e7acbe670b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a81c2f71a5c2f03e9ae1be20477721e51">operator*</a> (const P &amp;r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a81c2f71a5c2f03e9ae1be20477721e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="#a81c2f71a5c2f03e9ae1be20477721e51">More...</a><br /></td></tr>
<tr class="separator:a81c2f71a5c2f03e9ae1be20477721e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4f803c5be5d23c79883c07160c1b3fff">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a4f803c5be5d23c79883c07160c1b3fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="#a4f803c5be5d23c79883c07160c1b3fff">More...</a><br /></td></tr>
<tr class="separator:a4f803c5be5d23c79883c07160c1b3fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a11dbacbcdcafff80ec99c068987b8323">operator*</a> (int r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a11dbacbcdcafff80ec99c068987b8323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="#a11dbacbcdcafff80ec99c068987b8323">More...</a><br /></td></tr>
<tr class="separator:a11dbacbcdcafff80ec99c068987b8323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4d2db9435adf44e235f3165f8274d58b">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a4d2db9435adf44e235f3165f8274d58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar.  <a href="#a4d2db9435adf44e235f3165f8274d58b">More...</a><br /></td></tr>
<tr class="separator:a4d2db9435adf44e235f3165f8274d58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51fba91692c4dd54851b29a7ccac6317">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a51fba91692c4dd54851b29a7ccac6317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar provided as an int.  <a href="#a51fba91692c4dd54851b29a7ccac6317">More...</a><br /></td></tr>
<tr class="separator:a51fba91692c4dd54851b29a7ccac6317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5c8ce4e99ab6b63e6786f47f4647f939">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;<a class="el" href="group__TypedNumConstants.html#ga89110fa308da931e7b5b69f62b143bd3">I</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;w)</td></tr>
<tr class="memdesc:a5c8ce4e99ab6b63e6786f47f4647f939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix I on the right by a vector w giving the vector result I*w.  <a href="#a5c8ce4e99ab6b63e6786f47f4647f939">More...</a><br /></td></tr>
<tr class="separator:a5c8ce4e99ab6b63e6786f47f4647f939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad3306602216739add773fc2b00440560">operator==</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i1, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i2)</td></tr>
<tr class="memdesc:ad3306602216739add773fc2b00440560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two inertia matrices for exact (bitwise) equality.  <a href="#ad3306602216739add773fc2b00440560">More...</a><br /></td></tr>
<tr class="separator:ad3306602216739add773fc2b00440560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8cb59637de516910c73d319d793f53db">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a8cb59637de516910c73d319d793f53db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a human-readable representation of an inertia matrix to the indicated stream.  <a href="#a8cb59637de516910c73d319d793f53db">More...</a><br /></td></tr>
<tr class="separator:a8cb59637de516910c73d319d793f53db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::Inertia_&lt; P &gt;</h3>

<p>The physical meaning of an inertia is the distribution of a rigid body's mass about a <em>particular</em> point. </p>
<p>If that point is the center of mass of the body, then the measured inertia is called the "central inertia" of that body. To write down the inertia, we need to calculate the six scalars of the inertia tensor, which is a symmetric 3x3 matrix. These scalars must be expressed in an arbitrary but specified coordinate system. So an Inertia is meaningful only in conjunction with a particular set of axes, fixed to the body, whose origin is the point about which the inertia is being measured, and in whose coordinate system this measurement is being expressed. Note that changing the reference point results in a new physical quantity, but changing the reference axes only affects the measure numbers of that quantity. For any reference point, there is a unique set of reference axes in which the inertia tensor is diagonal; those are called the "principal axes" of the body at that point, and the resulting diagonal elements are the "principal moments of inertia". When we speak of an inertia being "in" a frame, we mean the physical quantity measured about the frame's origin and then expressed in the frame's axes.</p>
<p>This low-level Inertia class does not attempt to keep track of <em>which</em> frame it is in. It provides construction and operations involving inertia that can proceed using only an implicit frame F. Clients of this class are responsible for keeping track of that frame. In particular, in order to shift the inertia's "measured-about" point one must know whether either the starting or final inertia is central, because we must always shift inertias by passing through the central inertia. So this class provides operations for doing the shifting, but expects to be told by the client where to find the center of mass.</p>
<p>Re-expressing an Inertia in a different coordinate system does not entail a change of physical meaning in the way that shifting it to a different point does. Note that because inertia is a tensor, there is a "left frame" and "right frame". For our purposes, these will always be the same so we'll only indicate the frame once, as in 'I_pt_frame'. This should be understood to mean 'frame_I_pt_frame' and re-expressing an Inertia requires both a left and right multiply by the rotation matrix. So I_OB_B is the inertia about body B's origin point OB, expressed in B, while I_OB_G is the same physical quantity but expressed in Ground (the latter is a component of the Spatial Inertia which we usually want in the Ground frame). Frame conversion is done logically like this: </p><pre>
   I_OB_G = R_GB * I_OB_B * R_BG  (R_BG=~R_GB)
</pre><p> but we can save computation time by performing this as a single operation.</p>
<p>The central inertia would be I_CB_B for body B.</p>
<p>A Inertia is a symmetric matrix and is positive definite for nonsingular bodies (that is, a body composed of at least three noncollinear point masses).</p>
<p>Some attempt is made to check the validity of an Inertia matrix, at least when running in Debug mode. Some conditions it must satisfy are:</p><ul>
<li>must be symmetric</li>
<li>all diagonal elements must be nonnegative</li>
<li>diagonal elements must satisfy the triangle inequality (sum of any two is greater than or equal the other one)</li>
</ul>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1Inertia__.html" title="The physical meaning of an inertia is the distribution of a rigid body&#39;s mass about a particular poin...">Inertia_</a>&lt;P&gt;:</p><ul>
<li><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#ac0bfa6ada6b7f313bca2c045b437a2a5">fInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#a84c419f8747bdcbeb1ef97d96343e01d">dInertia</a> for double precision </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa2b329d1fc62a9c7b952d1b3c88dff71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default is a NaN-ed out mess to avoid accidents, even in Release mode. </p>
<p>Other than this value, an Inertia matrix should always be valid. </p>

</div>
</div>
<a class="anchor" id="a67cd5c9309fe5d443af3964bd030d2f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>moment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal inertia matrix with identical diagonal elements, like a sphere where moment=2/5 m r^2, or a cube where moment=1/6 m s^2, with m the total mass, r the sphere's radius and s the length of a side of the cube. </p>
<p>Note that many rigid bodies of different shapes and masses can have the same inertia matrix. </p>

</div>
</div>
<a class="anchor" id="af3e29578287d59727cfc7427d0047c88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Inertia matrix for a point mass at a given location, measured from the origin OF of the implicit frame F, and expressed in F. </p>
<p>Cost is 14 flops. </p>

</div>
</div>
<a class="anchor" id="a6757715dbe6c947a0fee42b40899b39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals). </p>
<p>Moments are in the order xx,yy,zz; products are xy,xz,yz. </p>

</div>
</div>
<a class="anchor" id="afffe875cb713abfe04736892484d7d51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal inertia matrix (only non-zero on diagonal). </p>

</div>
</div>
<a class="anchor" id="a5170b86e5d3b138e93108721fb598b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a general inertia matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. </p>

</div>
</div>
<a class="anchor" id="a0c68f0d0e0814fcd57eea00e5eb21234"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Inertia from a symmetric 3x3 matrix. </p>
<p>The diagonals must be nonnegative and satisfy the triangle inequality. </p>

</div>
</div>
<a class="anchor" id="aaafd3401dc8ca2b5c2dac17e43701549"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Inertia matrix from a 3x3 symmetric matrix. </p>
<p>In Debug mode we'll test that the supplied matrix is numerically close to symmetric, and that it satisfies other requirements of an Inertia matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1ef4b5dc3fdac7589ae14a9f0e79e6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::setInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an inertia matrix to have only principal moments (that is, it will be diagonal). </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a51b76c4a2fa12cb3f5346feabb1688e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::setInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set principal moments and optionally off-diagonal terms. </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a172f5d103b854fe80b7b175cbdf1b165"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::setInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this Inertia to a general matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. Behaves like an assignment statement. Will throw an error message in Debug mode if the supplied elements do not constitute a valid Inertia matrix. </p>

</div>
</div>
<a class="anchor" id="a232f2d580d93155eac72b30e1d5d4ea5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add in another inertia matrix. </p>
<p>Frames and reference point must be the same but we can't check. (6 flops) </p>

</div>
</div>
<a class="anchor" id="af761fb58e427c6bbc9c1a1abd3d29a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract off another inertia matrix. </p>
<p>Frames and reference point must be the same but we can't check. (6 flops) </p>

</div>
</div>
<a class="anchor" id="a2b50d1bec66484957bb0ebe1be4d1736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this inertia matrix by a scalar. Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a2d583c80cb337680c60b88dc455e8eed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide this inertia matrix by a scalar. </p>
<p>Cost is about 20 flops (a divide and 6 multiplies). </p>

</div>
</div>
<a class="anchor" id="a000e4873c70bd977a2ecaba19be60794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::shiftToMassCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume that the current inertia is about the F frame's origin OF, and expressed in F. </p>
<p>Given the vector from OF to the body center of mass CF, and the mass m of the body, we can shift the inertia to the center of mass. This produces a new Inertia I' whose (implicit) frame F' is aligned with F but has origin CF (an inertia like that is called a "central
inertia". I' = I - Icom where Icom is the inertia of a fictitious point mass of mass m (that is, the same as the body mass) located at CF (measured in F) about OF. Cost is 20 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#a7faa542f554572d91f36d013fa531aa2" title="Assume that the current inertia is about the F frame&#39;s origin OF, and expressed in F...">shiftToMassCenterInPlace()</a>, <a class="el" href="classSimTK_1_1Inertia__.html#a9cad56af59c6eb1c306dd7dca0f77f27" title="Assuming that the current inertia I is a central inertia (that is, it is inertia about the body cente...">shiftFromMassCenter()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7faa542f554572d91f36d013fa531aa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::shiftToMassCenterInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume that the current inertia is about the F frame's origin OF, and expressed in F. </p>
<p>Given the vector from OF to the body center of mass CF, and the mass m of the body, we can shift the inertia to the center of mass. This produces a new Inertia I' whose (implicit) frame F' is aligned with F but has origin CF (an inertia like that is called a "central
inertia". I' = I - Icom where Icom is the inertia of a fictitious point mass of mass m (that is, the same as the body mass) located at CF (measured in F) about OF. Cost is 20 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#a000e4873c70bd977a2ecaba19be60794" title="Assume that the current inertia is about the F frame&#39;s origin OF, and expressed in F...">shiftToMassCenter()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1Inertia__.html#aa86c57dbb5548ab99a910bb24f1c07d5" title="Assuming that the current inertia I is a central inertia (that is, it is inertia about the body cente...">shiftFromMassCenterInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cad56af59c6eb1c306dd7dca0f77f27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::shiftFromMassCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass. </p>
<p>This produces a new inertia I' about the point p given by I' = I + Ip where Ip is the inertia of a fictitious point mass of mass mtot (the total body mass) located at p, about CF. Cost is 20 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#aa86c57dbb5548ab99a910bb24f1c07d5" title="Assuming that the current inertia I is a central inertia (that is, it is inertia about the body cente...">shiftFromMassCenterInPlace()</a>, <a class="el" href="classSimTK_1_1Inertia__.html#a000e4873c70bd977a2ecaba19be60794" title="Assume that the current inertia is about the F frame&#39;s origin OF, and expressed in F...">shiftToMassCenter()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa86c57dbb5548ab99a910bb24f1c07d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::shiftFromMassCenterInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass. </p>
<p>This produces a new inertia I' about the point p given by I' = I + Ip where Ip is the inertia of a fictitious point mass of mass mtot (the total body mass) located at p, about CF. Cost is 20 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#a9cad56af59c6eb1c306dd7dca0f77f27" title="Assuming that the current inertia I is a central inertia (that is, it is inertia about the body cente...">shiftFromMassCenter()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1Inertia__.html#a7faa542f554572d91f36d013fa531aa2" title="Assume that the current inertia is about the F frame&#39;s origin OF, and expressed in F...">shiftToMassCenterInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ded5c13f1f5cee2aec5319953eb401c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged). </p>
<p>Call this inertia matrix I_OF_F, that is, it is taken about the origin of some frame F, and expressed in F. We want to return I_OF_B, the same inertia matrix, still taken about the origin of F, but expressed in the B frame, given by I_OF_B=R_BF*I_OF_F*R_FB where R_FB is the rotation matrix giving the orientation of frame B in F. This is handled here by a special method of the Rotation class which rotates a symmetric tensor at a cost of 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254" title="Re-express this inertia matrix in another frame, changing the object in place; see reexpress() if you...">reexpressInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a73c802f5dab0c8aba78da00df82a73f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpress(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a4c4a49f053e7c11240ad4e802786f254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c" title="Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point...">reexpress()</a> if you want to leave this object unmolested and get a new one instead. </p>
<p>Cost is 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c" title="Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a class="anchor" id="a4021fe4887710d1285fc6d1c5bd728aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress in place using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a23859436a032c1e574cf1436330e50dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1c83f66b07a3633caf070d8896e17b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::operator const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to a const SymMat33. </p>

</div>
</div>
<a class="anchor" id="ab156ca728529e3f6641003b840d51acc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::asSymMat33 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a reference to the underlying symmetric matrix type. </p>

</div>
</div>
<a class="anchor" id="a36c0ed7f30e9a7c6a4789bfb5b05775c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::toMat33 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the internal packed representation into a full 3x3 symmetric matrix with all elements set. </p>

</div>
</div>
<a class="anchor" id="a12695d09b41d77ca188b70ac9fa454c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::getMoments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3 ordered xx, yy, zz. </p>

</div>
</div>
<a class="anchor" id="ab8518a3d580aef33a332fca0c264db96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::getProducts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the inertia products (off-diagonals of the Inertia matrix) as a Vec3 with elements ordered xy, xz, yz. </p>

</div>
</div>
<a class="anchor" id="ab23a4618b211aa416301b7639fbc9dc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ff49432033de46bc8d43ace62269461"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isInf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68d1d61b83d7a7b17d9728d1211a9ebb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f1dc63b25c031af43cae91862ae9c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isNumericallyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare this inertia matrix with another one and return true if they are close to within a default numerical tolerance. </p>
<p>Cost is about 30 flops. </p>

</div>
</div>
<a class="anchor" id="af7e057e5f4b948bb560b5d9a8e812e40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isNumericallyEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare this inertia matrix with another one and return true if they are close to within a specified numerical tolerance. </p>
<p>Cost is about 30 flops. </p>

</div>
</div>
<a class="anchor" id="a09065c454fb39eec2dee757f63ff277e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::isValidInertiaMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test some conditions that must hold for a valid Inertia matrix. </p>
<p>Cost is about 25 flops. </p>

</div>
</div>
<a class="anchor" id="adaf11cafc9975fd5e6072f12548a467f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::pointMassAtOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Inertia matrix for a point located at the origin &ndash; that is, an all-zero matrix. </p>

</div>
</div>
<a class="anchor" id="aa644c212473bd29473a768d15caf291e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::pointMassAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Inertia matrix for a point of a given mass, located at a given location measured from the origin of the implicit F frame. </p>
<p>This is equivalent to m*crossMatSq(p) but is implemented elementwise here for speed, giving a cost of 14 flops. </p>

</div>
</div>
<a class="anchor" id="a0079ce02a6ce9ddb2c3cdf26f5c88fac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::sphere </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a731715abc3e23d14716ed8778c3a41db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::cylinderAlongZ </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along z axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hz=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="afb7fa18382bb190462ec90cee793c618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::cylinderAlongY </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along y axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hy=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="ab408d2690f9520647fc41426d2da97a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::cylinderAlongX </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along x axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hx=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="afe1dc7f12543454dadb1ea0ab243b2a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass brick given by half-lengths in each direction. </p>
<p>One dimension zero gives inertia of a thin rectangular sheet; two zero gives inertia of a thin rod in the remaining direction. </p>

</div>
</div>
<a class="anchor" id="a6e344c2ae3ff6b5ac4a84f632c4c7f8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<a class="anchor" id="a2ce85ba36aeec4e390d1adb99d34b33d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass ellipsoid given by half-lengths in each direction. </p>

</div>
</div>
<a class="anchor" id="ac4bc60ba4fe2d9bf269bfb9789a3433b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<a class="anchor" id="a9f881a10d5ca19fad90ad60b5491fbf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::getAsUnitInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2542289a1b1ae02d15d2e6ca581b5f03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::updAsUnitInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ada96544452d94f01b0f5167c8be260d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::errChk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>methodName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa13a2386109b73510feedacbc00dcb06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add two compatible inertia matrices, meaning they must be taken about the same point and expressed in the same frame. </p>
<p>There is no way to verify compatibility; make sure you know what you're doing. Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="ad11356749d9b854ac7c54941f8898123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract from one inertia matrix another one which is compatible, meaning that both must be taken about the same point and expressed in the same frame. </p>
<p>There is no way to verify compatibility; make sure you know what you're doing. Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a0e0178f717c4a3c324ae9e7acbe670b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply an inertia matrix by a scalar. </p>
<p>Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a81c2f71a5c2f03e9ae1be20477721e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply an inertia matrix by a scalar. </p>
<p>Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a4f803c5be5d23c79883c07160c1b3fff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply an inertia matrix by a scalar given as an int. </p>
<p>Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a11dbacbcdcafff80ec99c068987b8323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply an inertia matrix by a scalar given as an int. </p>
<p>Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a4d2db9435adf44e235f3165f8274d58b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide an inertia matrix by a scalar. </p>
<p>Cost is about 20 flops (one divide and six multiplies). </p>

</div>
</div>
<a class="anchor" id="a51fba91692c4dd54851b29a7ccac6317"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide an inertia matrix by a scalar provided as an int. </p>
<p>Cost is about 20 flops (one divide and six multiplies). </p>

</div>
</div>
<a class="anchor" id="a5c8ce4e99ab6b63e6786f47f4647f939"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply an inertia matrix I on the right by a vector w giving the vector result I*w. </p>

</div>
</div>
<a class="anchor" id="ad3306602216739add773fc2b00440560"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two inertia matrices for exact (bitwise) equality. </p>
<p>This is too strict for most purposes; use <a class="el" href="classSimTK_1_1Inertia__.html#a3f1dc63b25c031af43cae91862ae9c74" title="Compare this inertia matrix with another one and return true if they are close to within a default nu...">Inertia::isNumericallyEqual()</a> instead to test for approximate equality. Cost here is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a8cb59637de516910c73d319d793f53db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a human-readable representation of an inertia matrix to the indicated stream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a12f924bcb499f181af8687660f939d04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_</a>&lt; P &gt;::I_OF_F</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:15 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
