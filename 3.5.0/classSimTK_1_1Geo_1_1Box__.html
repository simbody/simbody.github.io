<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Geo::Box_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Geo_1_1Box__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSimTK_1_1Geo_1_1Box__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Geo::Box_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A 3d rectangular box aligned with an unspecified frame F and centered at that frame's origin.  
 <a href="classSimTK_1_1Geo_1_1Box__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44db3efe102f5f0fbf2d2ce6e8fd40d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a44db3efe102f5f0fbf2d2ce6e8fd40d7">Box_</a> ()</td></tr>
<tr class="memdesc:a44db3efe102f5f0fbf2d2ce6e8fd40d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized Box object; the dimensions will be garbage.  <a href="#a44db3efe102f5f0fbf2d2ce6e8fd40d7">More...</a><br /></td></tr>
<tr class="separator:a44db3efe102f5f0fbf2d2ce6e8fd40d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e900e18b2090062ecc5f410a524cb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a86e900e18b2090062ecc5f410a524cb0">Box_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a86e900e18b2090062ecc5f410a524cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Box with the given nonnegative half-dimensions.  <a href="#a86e900e18b2090062ecc5f410a524cb0">More...</a><br /></td></tr>
<tr class="separator:a86e900e18b2090062ecc5f410a524cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9923ff1ea4f5c0e2bdcaa1f57d4900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a7e9923ff1ea4f5c0e2bdcaa1f57d4900">setHalfLengths</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a7e9923ff1ea4f5c0e2bdcaa1f57d4900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the half-dimensions of this box.  <a href="#a7e9923ff1ea4f5c0e2bdcaa1f57d4900">More...</a><br /></td></tr>
<tr class="separator:a7e9923ff1ea4f5c0e2bdcaa1f57d4900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a27732ef2d83dc3c6cd730ed5f073b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#af8a27732ef2d83dc3c6cd730ed5f073b">addToHalfLengths</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;incr)</td></tr>
<tr class="memdesc:af8a27732ef2d83dc3c6cd730ed5f073b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the half-dimensions of this box by adding the given vector.  <a href="#af8a27732ef2d83dc3c6cd730ed5f073b">More...</a><br /></td></tr>
<tr class="separator:af8a27732ef2d83dc3c6cd730ed5f073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e857fb609122d49462c1724ff06b2ae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a2e857fb609122d49462c1724ff06b2ae">getHalfLengths</a> () const </td></tr>
<tr class="memdesc:a2e857fb609122d49462c1724ff06b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the half-lengths of this box as a Vec3 from the center to the first quadrant vertex.  <a href="#a2e857fb609122d49462c1724ff06b2ae">More...</a><br /></td></tr>
<tr class="separator:a2e857fb609122d49462c1724ff06b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd5d71b7d6a122b2afd727bbcc49742"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a8bd5d71b7d6a122b2afd727bbcc49742">getOrderedHalfLength</a> (int i) const </td></tr>
<tr class="memdesc:a8bd5d71b7d6a122b2afd727bbcc49742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lengths in order shortest to longest; 0 is shortest, 2 is longest.  <a href="#a8bd5d71b7d6a122b2afd727bbcc49742">More...</a><br /></td></tr>
<tr class="separator:a8bd5d71b7d6a122b2afd727bbcc49742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4ffb37fb0ebf2e48460d898e455143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#afc4ffb37fb0ebf2e48460d898e455143">getOrderedAxis</a> (int i) const </td></tr>
<tr class="memdesc:afc4ffb37fb0ebf2e48460d898e455143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get axes in order shortest to longest; 0 is shortest, 2 is longest.  <a href="#afc4ffb37fb0ebf2e48460d898e455143">More...</a><br /></td></tr>
<tr class="separator:afc4ffb37fb0ebf2e48460d898e455143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1f4633d8bca0191f6a5ad547c51ba"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a8ab1f4633d8bca0191f6a5ad547c51ba">findVolume</a> () const </td></tr>
<tr class="memdesc:a8ab1f4633d8bca0191f6a5ad547c51ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the volume of this box.  <a href="#a8ab1f4633d8bca0191f6a5ad547c51ba">More...</a><br /></td></tr>
<tr class="separator:a8ab1f4633d8bca0191f6a5ad547c51ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10856888ec88cda3c5c1c205fe0121"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3c10856888ec88cda3c5c1c205fe0121">findArea</a> () const </td></tr>
<tr class="memdesc:a3c10856888ec88cda3c5c1c205fe0121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the surface area of this box, ignoring degeneracy (meaning that all pairs of sides are counted even if coincident).  <a href="#a3c10856888ec88cda3c5c1c205fe0121">More...</a><br /></td></tr>
<tr class="separator:a3c10856888ec88cda3c5c1c205fe0121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e4213edc0aa7b0ad65bf32bc855b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a24e4213edc0aa7b0ad65bf32bc855b77">containsPoint</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;pt) const </td></tr>
<tr class="memdesc:a24e4213edc0aa7b0ad65bf32bc855b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point measured and expressed in the box frame, determine whether it is inside the box (we count touching the surface as inside).  <a href="#a24e4213edc0aa7b0ad65bf32bc855b77">More...</a><br /></td></tr>
<tr class="separator:a24e4213edc0aa7b0ad65bf32bc855b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3772f7c3ac0d8be1087a2e941d9b942d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3772f7c3ac0d8be1087a2e941d9b942d">findClosestPointOfSolidBox</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;pt, bool &amp;ptWasInside) const </td></tr>
<tr class="memdesc:a3772f7c3ac0d8be1087a2e941d9b942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point location in the box frame, return the closest point of the solid box, and a flag saying whether the given point was inside the box, using the same definition of "inside" as the <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a24e4213edc0aa7b0ad65bf32bc855b77" title="Given a point measured and expressed in the box frame, determine whether it is inside the box (we cou...">containsPoint()</a> method.  <a href="#a3772f7c3ac0d8be1087a2e941d9b942d">More...</a><br /></td></tr>
<tr class="separator:a3772f7c3ac0d8be1087a2e941d9b942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5641e8334db4cc82aa20ef2a5654bdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a5641e8334db4cc82aa20ef2a5654bdd3">findClosestPointOnSurface</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;pt, bool &amp;ptWasInside) const </td></tr>
<tr class="memdesc:a5641e8334db4cc82aa20ef2a5654bdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point location in the box frame, return the closest point on the box surface, and a flag saying whether the given point was inside the box, using the same definition of "inside" as the <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a24e4213edc0aa7b0ad65bf32bc855b77" title="Given a point measured and expressed in the box frame, determine whether it is inside the box (we cou...">containsPoint()</a> method.  <a href="#a5641e8334db4cc82aa20ef2a5654bdd3">More...</a><br /></td></tr>
<tr class="separator:a5641e8334db4cc82aa20ef2a5654bdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d929d6ca719f97044e58f18e72e9a4"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a48d929d6ca719f97044e58f18e72e9a4">findDistanceSqrToPoint</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;pt) const </td></tr>
<tr class="memdesc:a48d929d6ca719f97044e58f18e72e9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the distance from this box to a given point whose location is measured from and expressed in the box frame (at the box center).  <a href="#a48d929d6ca719f97044e58f18e72e9a4">More...</a><br /></td></tr>
<tr class="separator:a48d929d6ca719f97044e58f18e72e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c9e32f1433eaae78dfc94a96658c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#ad6c9e32f1433eaae78dfc94a96658c80">findSupportPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d) const </td></tr>
<tr class="memdesc:ad6c9e32f1433eaae78dfc94a96658c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a supporting point on the surface of the box in the given direction, which must be expressed in the box frame.  <a href="#ad6c9e32f1433eaae78dfc94a96658c80">More...</a><br /></td></tr>
<tr class="separator:ad6c9e32f1433eaae78dfc94a96658c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97013eb81d8876a136254af44cbd3e57"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a97013eb81d8876a136254af44cbd3e57">findDistanceSqrToSphere</a> (const <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt; P &gt; &amp;sphere) const </td></tr>
<tr class="memdesc:a97013eb81d8876a136254af44cbd3e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the distance from this box to a given sphere whose center location is measured from and expressed in the box frame (at the box center).  <a href="#a97013eb81d8876a136254af44cbd3e57">More...</a><br /></td></tr>
<tr class="separator:a97013eb81d8876a136254af44cbd3e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135743b60e4d2cfd5e7b5ae9f0d457c9"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a135743b60e4d2cfd5e7b5ae9f0d457c9">findDistanceSqrToAlignedBox</a> (const <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt; &amp;aab) const </td></tr>
<tr class="memdesc:a135743b60e4d2cfd5e7b5ae9f0d457c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the distance from this box to an axis-aligned box whose center location is measured from and expressed in this box frame (at the box center).  <a href="#a135743b60e4d2cfd5e7b5ae9f0d457c9">More...</a><br /></td></tr>
<tr class="separator:a135743b60e4d2cfd5e7b5ae9f0d457c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e13096fb8e6091950fd67a3e6b9bae7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a7e13096fb8e6091950fd67a3e6b9bae7">intersectsSphere</a> (const <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt; P &gt; &amp;sphere) const </td></tr>
<tr class="memdesc:a7e13096fb8e6091950fd67a3e6b9bae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sphere with center measured and expressed in the box frame, return true if the box and sphere intersect.  <a href="#a7e13096fb8e6091950fd67a3e6b9bae7">More...</a><br /></td></tr>
<tr class="separator:a7e13096fb8e6091950fd67a3e6b9bae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73088e847420c68b355c88ceeed37de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#aa73088e847420c68b355c88ceeed37de">intersectsAlignedBox</a> (const <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt; &amp;aab) const </td></tr>
<tr class="memdesc:aa73088e847420c68b355c88ceeed37de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an aligned box with center measured and expressed in the from of this box, return true if the two boxes intersect.  <a href="#aa73088e847420c68b355c88ceeed37de">More...</a><br /></td></tr>
<tr class="separator:aa73088e847420c68b355c88ceeed37de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da81043ed1cfc3a4615f802e713a6a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3da81043ed1cfc3a4615f802e713a6a5">intersectsOrientedBox</a> (const <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt; &amp;ob) const </td></tr>
<tr class="memdesc:a3da81043ed1cfc3a4615f802e713a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes intersect.  <a href="#a3da81043ed1cfc3a4615f802e713a6a5">More...</a><br /></td></tr>
<tr class="separator:a3da81043ed1cfc3a4615f802e713a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d99b3406bf0c6ba64cb12898904b64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#ad7d99b3406bf0c6ba64cb12898904b64">mayIntersectOrientedBox</a> (const <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt; &amp;ob) const </td></tr>
<tr class="memdesc:ad7d99b3406bf0c6ba64cb12898904b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes may be intersecting.  <a href="#ad7d99b3406bf0c6ba64cb12898904b64">More...</a><br /></td></tr>
<tr class="separator:ad7d99b3406bf0c6ba64cb12898904b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Box mesh methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp70e7e5c561964b21ceccddcfd2469f1b"></a>Methods to use if you want to think of the box as a convex mesh. </p>
</td></tr>
<tr class="memitem:a01948d4d169c1079c6374a634e6ef97b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a01948d4d169c1079c6374a634e6ef97b">getVertexPos</a> (int vx) const </td></tr>
<tr class="memdesc:a01948d4d169c1079c6374a634e6ef97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use bits in the vertex number to pick the signs, with 0=negative, 1=positive:  <a href="#a01948d4d169c1079c6374a634e6ef97b">More...</a><br /></td></tr>
<tr class="separator:a01948d4d169c1079c6374a634e6ef97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8627cbdf1a897dd4195c7b94dece232b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a8627cbdf1a897dd4195c7b94dece232b">findSupportVertex</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;d) const </td></tr>
<tr class="memdesc:a8627cbdf1a897dd4195c7b94dece232b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex (0-7) that is furthest in the direction d, which is given in the box frame.  <a href="#a8627cbdf1a897dd4195c7b94dece232b">More...</a><br /></td></tr>
<tr class="separator:a8627cbdf1a897dd4195c7b94dece232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2f03633ad522b55605b8950b495d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a36a2f03633ad522b55605b8950b495d6">getVertexNormal</a> (int vx) const </td></tr>
<tr class="memdesc:a36a2f03633ad522b55605b8950b495d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex normals point diagonally outwards from the box corners.  <a href="#a36a2f03633ad522b55605b8950b495d6">More...</a><br /></td></tr>
<tr class="separator:a36a2f03633ad522b55605b8950b495d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6ff85f7466c5fc7227d8437e3b966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3fe6ff85f7466c5fc7227d8437e3b966">getEdgeCenter</a> (int ex) const </td></tr>
<tr class="memdesc:a3fe6ff85f7466c5fc7227d8437e3b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the center point of the specified edge, in the box frame.  <a href="#a3fe6ff85f7466c5fc7227d8437e3b966">More...</a><br /></td></tr>
<tr class="separator:a3fe6ff85f7466c5fc7227d8437e3b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fb8eeb0462952a7a8bbde63eb23737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a05fb8eeb0462952a7a8bbde63eb23737">getEdgeNormal</a> (int ex) const </td></tr>
<tr class="memdesc:a05fb8eeb0462952a7a8bbde63eb23737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge normals point diagonally outwards from the edge.  <a href="#a05fb8eeb0462952a7a8bbde63eb23737">More...</a><br /></td></tr>
<tr class="separator:a05fb8eeb0462952a7a8bbde63eb23737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8b0367c0f273438001025380303b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a52e8b0367c0f273438001025380303b5">getEdgeCoordinateDirection</a> (int ex) const </td></tr>
<tr class="memdesc:a52e8b0367c0f273438001025380303b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the direction of an edge, going from its first vertex to its second vertex, as a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a>.  <a href="#a52e8b0367c0f273438001025380303b5">More...</a><br /></td></tr>
<tr class="separator:a52e8b0367c0f273438001025380303b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de6621e6960ca4f9c24bc437c191f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a5de6621e6960ca4f9c24bc437c191f5a">getEdgeDirection</a> (int ex) const </td></tr>
<tr class="memdesc:a5de6621e6960ca4f9c24bc437c191f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unit vector aligned with the selected edge, pointing in the direction from the first vertex towards the second vertex, in the box frame.  <a href="#a5de6621e6960ca4f9c24bc437c191f5a">More...</a><br /></td></tr>
<tr class="separator:a5de6621e6960ca4f9c24bc437c191f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c9d1130ded1d4c32d1a0aaa5c0118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a002c9d1130ded1d4c32d1a0aaa5c0118">getFaceCoordinateDirection</a> (int fx) const </td></tr>
<tr class="memdesc:a002c9d1130ded1d4c32d1a0aaa5c0118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the outward normal for the given face as a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a>.  <a href="#a002c9d1130ded1d4c32d1a0aaa5c0118">More...</a><br /></td></tr>
<tr class="separator:a002c9d1130ded1d4c32d1a0aaa5c0118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfaf8758dcfaee55c6daad156723da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a6cfaf8758dcfaee55c6daad156723da3">getFaceCenter</a> (int fx) const </td></tr>
<tr class="memdesc:a6cfaf8758dcfaee55c6daad156723da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the center point position for the given face.  <a href="#a6cfaf8758dcfaee55c6daad156723da3">More...</a><br /></td></tr>
<tr class="separator:a6cfaf8758dcfaee55c6daad156723da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7bb6ce8f0637838bd47224656af6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a1c7bb6ce8f0637838bd47224656af6d0">getFaceNormal</a> (int fx) const </td></tr>
<tr class="memdesc:a1c7bb6ce8f0637838bd47224656af6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the outward normal for the given face as a unit vector in the box frame.  <a href="#a1c7bb6ce8f0637838bd47224656af6d0">More...</a><br /></td></tr>
<tr class="separator:a1c7bb6ce8f0637838bd47224656af6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9875ab14e71950d2be05dfe773f5fa08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a9875ab14e71950d2be05dfe773f5fa08">getFaceVertices</a> (int fx, int v[4]) const </td></tr>
<tr class="memdesc:a9875ab14e71950d2be05dfe773f5fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">A face has four vertices ordered counterclockwise about the face normal.  <a href="#a9875ab14e71950d2be05dfe773f5fa08">More...</a><br /></td></tr>
<tr class="separator:a9875ab14e71950d2be05dfe773f5fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9db5e8ebf58e700a7df67b21d0f7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a5e9db5e8ebf58e700a7df67b21d0f7f6">getVertexFaces</a> (int vx, int f[3], int w[3]) const </td></tr>
<tr class="memdesc:a5e9db5e8ebf58e700a7df67b21d0f7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each vertex has three incident faces.  <a href="#a5e9db5e8ebf58e700a7df67b21d0f7f6">More...</a><br /></td></tr>
<tr class="separator:a5e9db5e8ebf58e700a7df67b21d0f7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db4744c77a3b3ae43c551f16f4fd54d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a1db4744c77a3b3ae43c551f16f4fd54d">getEdgeVertices</a> (int ex, int v[2]) const </td></tr>
<tr class="memdesc:a1db4744c77a3b3ae43c551f16f4fd54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge connects two vertices.  <a href="#a1db4744c77a3b3ae43c551f16f4fd54d">More...</a><br /></td></tr>
<tr class="separator:a1db4744c77a3b3ae43c551f16f4fd54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261b1acdf77e184d7e1b9615d1dd8c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a261b1acdf77e184d7e1b9615d1dd8c69">getVertexEdges</a> (int vx, int e[3], int w[3]) const </td></tr>
<tr class="memdesc:a261b1acdf77e184d7e1b9615d1dd8c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each vertex has three incident edges.  <a href="#a261b1acdf77e184d7e1b9615d1dd8c69">More...</a><br /></td></tr>
<tr class="separator:a261b1acdf77e184d7e1b9615d1dd8c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c35a548c94f0a591b3b58ed9008d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a15c35a548c94f0a591b3b58ed9008d0d">getFaceEdges</a> (int fx, int e[4]) const </td></tr>
<tr class="memdesc:a15c35a548c94f0a591b3b58ed9008d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A face has four edges, ordered by the vertex ordering: v0-v1, v1-v2, v2-v3, v3-v1.  <a href="#a15c35a548c94f0a591b3b58ed9008d0d">More...</a><br /></td></tr>
<tr class="separator:a15c35a548c94f0a591b3b58ed9008d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b0583dea6c07f07697877b04a0c00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#af2b0583dea6c07f07697877b04a0c00a">getEdgeFaces</a> (int ex, int f[2], int w[2]) const </td></tr>
<tr class="memdesc:af2b0583dea6c07f07697877b04a0c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge is between two faces.  <a href="#af2b0583dea6c07f07697877b04a0c00a">More...</a><br /></td></tr>
<tr class="separator:af2b0583dea6c07f07697877b04a0c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c5a37ab12106710aa77f32db91eadb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a55c5a37ab12106710aa77f32db91eadb">getNumVertices</a> ()</td></tr>
<tr class="memdesc:a55c5a37ab12106710aa77f32db91eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use bits in the vertex number to pick the signs, with 0=negative, 1=positive:  <a href="#a55c5a37ab12106710aa77f32db91eadb">More...</a><br /></td></tr>
<tr class="separator:a55c5a37ab12106710aa77f32db91eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3182af8ecd4564206fba553bd843b40a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3182af8ecd4564206fba553bd843b40a">getNumEdges</a> ()</td></tr>
<tr class="memdesc:a3182af8ecd4564206fba553bd843b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use bits in the vertex number to pick the signs, with 0=negative, 1=positive:  <a href="#a3182af8ecd4564206fba553bd843b40a">More...</a><br /></td></tr>
<tr class="separator:a3182af8ecd4564206fba553bd843b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01870838a4d1dff42258c7aed5b9778"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html#aa01870838a4d1dff42258c7aed5b9778">getNumFaces</a> ()</td></tr>
<tr class="memdesc:aa01870838a4d1dff42258c7aed5b9778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use bits in the vertex number to pick the signs, with 0=negative, 1=positive:  <a href="#aa01870838a4d1dff42258c7aed5b9778">More...</a><br /></td></tr>
<tr class="separator:aa01870838a4d1dff42258c7aed5b9778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::Geo::Box_&lt; P &gt;</h3>

<p>A 3d rectangular box aligned with an unspecified frame F and centered at that frame's origin. </p>
<p>The box has a local frame B, centered at the box center and oriented along the box edges, and B==F. We keep track of the relative edge lengths to facilitate short-to-long processing. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a44db3efe102f5f0fbf2d2ce6e8fd40d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an uninitialized Box object; the dimensions will be garbage. </p>

</div>
</div>
<a class="anchor" id="a86e900e18b2090062ecc5f410a524cb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a Box with the given nonnegative half-dimensions. </p>
<p>Cost is 4 flops to sort the edges. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7e9923ff1ea4f5c0e2bdcaa1f57d4900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a>&amp; <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::setHalfLengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the half-dimensions of this box. </p>
<p>Dimensions must be nonnegative. Cost is 4 flops to sort the edges. </p>

</div>
</div>
<a class="anchor" id="af8a27732ef2d83dc3c6cd730ed5f073b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a>&amp; <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::addToHalfLengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>incr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the half-dimensions of this box by adding the given vector. </p>
<p>The result must be nonnegative. Cost is 7 flops, including resorting the edges. </p>

</div>
</div>
<a class="anchor" id="a2e857fb609122d49462c1724ff06b2ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&amp; <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getHalfLengths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the half-lengths of this box as a Vec3 from the center to the first quadrant vertex. </p>

</div>
</div>
<a class="anchor" id="a8bd5d71b7d6a122b2afd727bbcc49742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getOrderedHalfLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get lengths in order shortest to longest; 0 is shortest, 2 is longest. </p>

</div>
</div>
<a class="anchor" id="afc4ffb37fb0ebf2e48460d898e455143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CoordinateAxis.html">CoordinateAxis</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getOrderedAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get axes in order shortest to longest; 0 is shortest, 2 is longest. </p>

</div>
</div>
<a class="anchor" id="a8ab1f4633d8bca0191f6a5ad547c51ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the volume of this box. </p>
<p>Cost is 4 flops. </p>

</div>
</div>
<a class="anchor" id="a3c10856888ec88cda3c5c1c205fe0121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the surface area of this box, ignoring degeneracy (meaning that all pairs of sides are counted even if coincident). </p>
<p>Cost is 6 flops. </p>

</div>
</div>
<a class="anchor" id="a24e4213edc0aa7b0ad65bf32bc855b77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::containsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a point measured and expressed in the box frame, determine whether it is inside the box (we count touching the surface as inside). </p>
<p>The point must be measured from the box center. Cost is about 5 flops. </p>

</div>
</div>
<a class="anchor" id="a3772f7c3ac0d8be1087a2e941d9b942d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findClosestPointOfSolidBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ptWasInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a point location in the box frame, return the closest point of the solid box, and a flag saying whether the given point was inside the box, using the same definition of "inside" as the <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a24e4213edc0aa7b0ad65bf32bc855b77" title="Given a point measured and expressed in the box frame, determine whether it is inside the box (we cou...">containsPoint()</a> method. </p>
<p>Here we define the closest point to an inside point to be the point itself. Cost is about 9 flops. </p>

</div>
</div>
<a class="anchor" id="a5641e8334db4cc82aa20ef2a5654bdd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findClosestPointOnSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ptWasInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a point location in the box frame, return the closest point on the box surface, and a flag saying whether the given point was inside the box, using the same definition of "inside" as the <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a24e4213edc0aa7b0ad65bf32bc855b77" title="Given a point measured and expressed in the box frame, determine whether it is inside the box (we cou...">containsPoint()</a> method. </p>
<p>Cost is about 9 flops for outside points, 18 for inside points. </p>

</div>
</div>
<a class="anchor" id="a48d929d6ca719f97044e58f18e72e9a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findDistanceSqrToPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the distance from this box to a given point whose location is measured from and expressed in the box frame (at the box center). </p>
<p>If the point is on or inside the box the returned distance is zero. Cost is about 14 flops. </p>

</div>
</div>
<a class="anchor" id="ad6c9e32f1433eaae78dfc94a96658c80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findSupportPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a supporting point on the surface of the box in the given direction, which must be expressed in the box frame. </p>
<p>The direction vector does not have to be a unit vector. The returned point will always be one of the eight vertices; we treat zeroes here as positive. Consequently if the input vector is exactly zero, the vertex in the positive orthant is returned as it would be if the input direction were (1,1,1). Cost is about 5 flops. </p>

</div>
</div>
<a class="anchor" id="a97013eb81d8876a136254af44cbd3e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findDistanceSqrToSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the distance from this box to a given sphere whose center location is measured from and expressed in the box frame (at the box center). </p>
<p>If the sphere intersects the box the returned distance is zero. Cost is about 17 flops. </p>

</div>
</div>
<a class="anchor" id="a135743b60e4d2cfd5e7b5ae9f0d457c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findDistanceSqrToAlignedBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>aab</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of the distance from this box to an axis-aligned box whose center location is measured from and expressed in this box frame (at the box center). </p>
<p>If the boxes intersect the returned distance is zero. Cost is about 17 flops. </p>

</div>
</div>
<a class="anchor" id="a7e13096fb8e6091950fd67a3e6b9bae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::intersectsSphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphere</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a sphere with center measured and expressed in the box frame, return true if the box and sphere intersect. </p>
<p>We are treating both objects as solids, so we'll say yes even if one object completely contains the other. We also return true if they are just touching. Cost is about 8 flops. </p>

</div>
</div>
<a class="anchor" id="aa73088e847420c68b355c88ceeed37de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::intersectsAlignedBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>aab</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an aligned box with center measured and expressed in the from of this box, return true if the two boxes intersect. </p>
<p>We are treating both objects as solids, so we'll say yes even if one box completely contains the other. We also return true if they are just touching. Cost is about 8 flops. </p>

</div>
</div>
<a class="anchor" id="a3da81043ed1cfc3a4615f802e713a6a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::intersectsOrientedBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes intersect. </p>
<p>We are treating both objects as solids, so we'll say yes even if one box completely contains the other. We also return true if they are just touching. This is an exact but fairly expensive test if the boxes are separated; if you don't mind some false positives, use <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#ad7d99b3406bf0c6ba64cb12898904b64" title="Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes may be intersecting. ">mayIntersectOrientedBox()</a> instead. Cost is about 200 flops worst case (when boxes are intersecting) although it can return <code>false</code> in as few as 16 flops. </p>

</div>
</div>
<a class="anchor" id="ad7d99b3406bf0c6ba64cb12898904b64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::mayIntersectOrientedBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes may be intersecting. </p>
<p>Only relatively cheap operations are performed at the expense of returning false positives sometimes (allegedly less than 10% of the time). If you need an exact determination, use <a class="el" href="classSimTK_1_1Geo_1_1Box__.html#a3da81043ed1cfc3a4615f802e713a6a5" title="Given an oriented box whose pose is measured and expressed in the frame of this box, return true if the two boxes intersect. ">intersectsOrientedBox()</a>. Cost is about 75 flops worst case (when boxes appear to be intersecting) but can return <code>false</code> in as few as 16 flops. </p>

</div>
</div>
<a class="anchor" id="a55c5a37ab12106710aa77f32db91eadb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use bits in the vertex number to pick the signs, with 0=negative, 1=positive: </p>
<pre>
    000  -hx -hy -hz
    001  -hx -hy  hz
    ...
    111   hx  hy  hz
</pre> 
</div>
</div>
<a class="anchor" id="a3182af8ecd4564206fba553bd843b40a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use bits in the vertex number to pick the signs, with 0=negative, 1=positive: </p>
<pre>
    000  -hx -hy -hz
    001  -hx -hy  hz
    ...
    111   hx  hy  hz
</pre> 
</div>
</div>
<a class="anchor" id="aa01870838a4d1dff42258c7aed5b9778"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use bits in the vertex number to pick the signs, with 0=negative, 1=positive: </p>
<pre>
    000  -hx -hy -hz
    001  -hx -hy  hz
    ...
    111   hx  hy  hz
</pre> 
</div>
</div>
<a class="anchor" id="a01948d4d169c1079c6374a634e6ef97b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getVertexPos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use bits in the vertex number to pick the signs, with 0=negative, 1=positive: </p>
<pre>
    000  -hx -hy -hz
    001  -hx -hy  hz
    ...
    111   hx  hy  hz
</pre> 
</div>
</div>
<a class="anchor" id="a8627cbdf1a897dd4195c7b94dece232b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::findSupportVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vertex (0-7) that is furthest in the direction d, which is given in the box frame. </p>
<p>Zero coordinates in d are treated as though positive. </p>

</div>
</div>
<a class="anchor" id="a36a2f03633ad522b55605b8950b495d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getVertexNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vertex normals point diagonally outwards from the box corners. </p>
<p>These are unit vectors with each coordinate +/- 1/sqrt(3). </p>

</div>
</div>
<a class="anchor" id="a3fe6ff85f7466c5fc7227d8437e3b966"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeCenter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the center point of the specified edge, in the box frame. </p>

</div>
</div>
<a class="anchor" id="a05fb8eeb0462952a7a8bbde63eb23737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Edge normals point diagonally outwards from the edge. </p>
<p>These are unit vectors with one coordinate zero and the others +/- 1/sqrt(2). </p>

</div>
</div>
<a class="anchor" id="a52e8b0367c0f273438001025380303b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeCoordinateDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the direction of an edge, going from its first vertex to its second vertex, as a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a>. </p>

</div>
</div>
<a class="anchor" id="a5de6621e6960ca4f9c24bc437c191f5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unit vector aligned with the selected edge, pointing in the direction from the first vertex towards the second vertex, in the box frame. </p>
<p>For a box, all edges are aligned with the coordinate system axes so the returned vector will have only one non-zero component which will be 1 or -1. </p>

</div>
</div>
<a class="anchor" id="a002c9d1130ded1d4c32d1a0aaa5c0118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1CoordinateDirection.html">CoordinateDirection</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getFaceCoordinateDirection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the outward normal for the given face as a <a class="el" href="classSimTK_1_1CoordinateDirection.html" title="A CoordinateDirection is a CoordinateAxis plus a direction indicating the positive or negative direct...">CoordinateDirection</a>. </p>

</div>
</div>
<a class="anchor" id="a6cfaf8758dcfaee55c6daad156723da3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getFaceCenter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the center point position for the given face. </p>
<p>This will be a vector with one non-zero component of magnitude equal to one of the box half-dimensions, with the appropriate sign. </p>

</div>
</div>
<a class="anchor" id="a1c7bb6ce8f0637838bd47224656af6d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getFaceNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the outward normal for the given face as a unit vector in the box frame. </p>
<p>This will have only one non-zero component which will be 1 or -1. </p>

</div>
</div>
<a class="anchor" id="a9875ab14e71950d2be05dfe773f5fa08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getFaceVertices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A face has four vertices ordered counterclockwise about the face normal. </p>

</div>
</div>
<a class="anchor" id="a5e9db5e8ebf58e700a7df67b21d0f7f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getVertexFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each vertex has three incident faces. </p>
<p>Return the face numbers (0-5) and which of the four face vertices is this one (0-3). </p>

</div>
</div>
<a class="anchor" id="a1db4744c77a3b3ae43c551f16f4fd54d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeVertices </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An edge connects two vertices. </p>

</div>
</div>
<a class="anchor" id="a261b1acdf77e184d7e1b9615d1dd8c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getVertexEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each vertex has three incident edges. </p>
<p>Return the edge numbers (0-11) and which of the two edge vertices is this one (0-1). </p>

</div>
</div>
<a class="anchor" id="a15c35a548c94f0a591b3b58ed9008d0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getFaceEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A face has four edges, ordered by the vertex ordering: v0-v1, v1-v2, v2-v3, v3-v1. </p>

</div>
</div>
<a class="anchor" id="af2b0583dea6c07f07697877b04a0c00a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1Box__.html">SimTK::Geo::Box_</a>&lt; P &gt;::getEdgeFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An edge is between two faces. </p>
<p>Return the face numbers (0-5) and which one of the four edges on each face is this edge (0-3). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Geo_8h_source.html">Geo.h</a></li>
<li><a class="el" href="Geo__Box_8h_source.html">Geo_Box.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Geo.html">Geo</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Geo_1_1Box__.html">Box_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:14 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
