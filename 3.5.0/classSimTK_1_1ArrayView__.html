<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::ArrayView_&lt; T, X &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1ArrayView__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classSimTK_1_1ArrayView__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ArrayView_&lt; T, X &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, extending <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> to add the ability to modify elements, but not the ability to change size or reallocate.  
 <a href="classSimTK_1_1ArrayView__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::ArrayView_&lt; T, X &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1ArrayView__.png" usemap="#SimTK::ArrayView_5F_3C_20T_2C_20X_20_3E_map" alt=""/>
  <map id="SimTK::ArrayView_5F_3C_20T_2C_20X_20_3E_map" name="SimTK::ArrayView_&lt; T, X &gt;_map">
<area href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we..." alt="SimTK::ArrayViewConst_&lt; T, X &gt;" shape="rect" coords="0,0,202,24"/>
<area href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l..." alt="SimTK::Array_&lt; T, X &gt;" shape="rect" coords="0,112,202,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types required of STL containers, plus index_type which is an extension, and packed_size_type which is an implementation detail.</p>
</div></td></tr>
<tr class="memitem:aeb29ff328a71341945e442234f50e253"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253">value_type</a></td></tr>
<tr class="separator:aeb29ff328a71341945e442234f50e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79baa909a71d2f8c75b1120776ccca3"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3">index_type</a></td></tr>
<tr class="separator:ae79baa909a71d2f8c75b1120776ccca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fd72f5f77716f823f8c0a9a87974"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974">pointer</a></td></tr>
<tr class="separator:a3950fd72f5f77716f823f8c0a9a87974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8dabb125276c7fcdaa215b23f808f"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f">const_pointer</a></td></tr>
<tr class="separator:ad6e8dabb125276c7fcdaa215b23f808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b454ffabc27881011e3dcfea4014"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014">reference</a></td></tr>
<tr class="separator:ab4b4b454ffabc27881011e3dcfea4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611de0d81f0e43b256704e817d63ae47"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47">const_reference</a></td></tr>
<tr class="separator:a611de0d81f0e43b256704e817d63ae47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566e08689eb53ae89a2b000ed4a4140"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140">iterator</a></td></tr>
<tr class="separator:a6566e08689eb53ae89a2b000ed4a4140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14185eed75d43f044775a366c02590c0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0">const_iterator</a></td></tr>
<tr class="separator:a14185eed75d43f044775a366c02590c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e9c961a4621efd1bfe21bf099ca77"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77">reverse_iterator</a></td></tr>
<tr class="separator:a704e9c961a4621efd1bfe21bf099ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1232d267e9b8c139cca1512b412a6d1"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1">const_reverse_iterator</a></td></tr>
<tr class="separator:ac1232d267e9b8c139cca1512b412a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e901cbddbca41c54b22c6216ac804b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b">size_type</a></td></tr>
<tr class="separator:ab6e901cbddbca41c54b22c6216ac804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad962ee7e4110ac6c20bdfa340f81dc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc">difference_type</a></td></tr>
<tr class="separator:abad962ee7e4110ac6c20bdfa340f81dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536141dcc61cfc646bb1f2062e5e558"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558">packed_size_type</a></td></tr>
<tr class="separator:a9536141dcc61cfc646bb1f2062e5e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td></tr>
<tr class="memdesc:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored in this container.  <a href="#a39bda86e859db1597f4d49d8037d0660">More...</a><br /></td></tr>
<tr class="separator:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td></tr>
<tr class="memdesc:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (an extension).  <a href="#af92bca96f3089b5f0d4133fce9c7cded">More...</a><br /></td></tr>
<tr class="separator:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td></tr>
<tr class="memdesc:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable pointer to a value_type.  <a href="#a2825bef320398cbf8d8f2e2b8631632e">More...</a><br /></td></tr>
<tr class="separator:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td></tr>
<tr class="memdesc:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const pointer to a value_type.  <a href="#a7fdc551f402dc69766e819733ee6f08b">More...</a><br /></td></tr>
<tr class="separator:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td></tr>
<tr class="memdesc:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable value_type reference.  <a href="#aacce6f572b1deffcefa3f3aae5263b1c">More...</a><br /></td></tr>
<tr class="separator:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td></tr>
<tr class="memdesc:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const value_type reference.  <a href="#a460302f601c4a2c2d63837cb1e5d875a">More...</a><br /></td></tr>
<tr class="separator:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td></tr>
<tr class="memdesc:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable iterator for this container (same as pointer here).  <a href="#a416a8bff8ad197d4dfb2d41866acbd23">More...</a><br /></td></tr>
<tr class="separator:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td></tr>
<tr class="memdesc:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for this container (same as const_pointer here).  <a href="#a76215b9c0677fca5706f11038f496963">More...</a><br /></td></tr>
<tr class="separator:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td></tr>
<tr class="memdesc:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable reverse iterator for this container.  <a href="#a4b566573f0b94c804a6b6e0514c78bce">More...</a><br /></td></tr>
<tr class="separator:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reverse iterator for this container.  <a href="#ab26d002d51080ddd32f8899e5ea3ea40">More...</a><br /></td></tr>
<tr class="separator:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td></tr>
<tr class="memdesc:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integral type suitable for all indices and sizes for this array.  <a href="#abaaff64afd3daaed43f1acecbe2bbfe7">More...</a><br /></td></tr>
<tr class="separator:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td></tr>
<tr class="memdesc:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference between any two legitimate index values for this array.  <a href="#a1f604d5e70ddbe7eb0bf9a80a236951e">More...</a><br /></td></tr>
<tr class="separator:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td></tr>
<tr class="memdesc:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type we actually use internally to store size_type values.  <a href="#af01fd47de6bffe601337c1ef0a45e88d">More...</a><br /></td></tr>
<tr class="separator:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, conversion, and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructors here are limited to those that don't allocate new data, however they can reference writable data.</p>
</div></td></tr>
<tr class="memitem:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">ArrayView_</a> ()</td></tr>
<tr class="memdesc:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#aa8e89ce2da1f241ae70e38cfe63ba980">More...</a><br /></td></tr>
<tr class="separator:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddf75311833fc599a934c3f3d5a57d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">ArrayView_</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:ad1ddf75311833fc599a934c3f3d5a57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow.  <a href="#ad1ddf75311833fc599a934c3f3d5a57d">More...</a><br /></td></tr>
<tr class="separator:ad1ddf75311833fc599a934c3f3d5a57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6104f869055379b0fbd146aeefa919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">ArrayView_</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a8e6104f869055379b0fbd146aeefa919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a range of writable memory.  <a href="#a8e6104f869055379b0fbd146aeefa919">More...</a><br /></td></tr>
<tr class="separator:a8e6104f869055379b0fbd146aeefa919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">ArrayView_</a> (std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a176653cfecc6ee9dd5cbb08f53725a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct to reference memory owned by a writable std::vector.  <a href="#a176653cfecc6ee9dd5cbb08f53725a34">More...</a><br /></td></tr>
<tr class="separator:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee82e038ccd001ede9b1104969fdfa3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee82e038ccd001ede9b1104969fdfa3c">operator const Array_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:aee82e038ccd001ede9b1104969fdfa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost).  <a href="#aee82e038ccd001ede9b1104969fdfa3c">More...</a><br /></td></tr>
<tr class="separator:aee82e038ccd001ede9b1104969fdfa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7f785e236628b37192a5380d0a479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">operator Array_&lt; T, X &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a6ef7f785e236628b37192a5380d0a479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost).  <a href="#a6ef7f785e236628b37192a5380d0a479">More...</a><br /></td></tr>
<tr class="separator:a6ef7f785e236628b37192a5380d0a479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848acb2e30474663b3d708e80f2b6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">disconnect</a> ()</td></tr>
<tr class="memdesc:a7848acb2e30474663b3d708e80f2b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method – clears the handle without doing anything to the data...">disconnect()</a> method &ndash; clears the handle without doing anything to the data.  <a href="#a7848acb2e30474663b3d708e80f2b6bc">More...</a><br /></td></tr>
<tr class="separator:a7848acb2e30474663b3d708e80f2b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">~ArrayView_</a> ()</td></tr>
<tr class="memdesc:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information.  <a href="#a509b38ff0b42a6ff6b38cd3b26f4096f">More...</a><br /></td></tr>
<tr class="separator:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Assignment is permitted only if the source and destination are the same size.</p>
<p>The semantics here are different than for a resizeable <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> object: here the meaning is elementwise assignment rather than destruction followed by copy construction. That is, if our elements are of type T, and the source elements are of type T2, we will use the operator of T that best matches the signature T::operator=(const T2&amp;) to perform the assignments. When the source also has type T, this is just T's copy assignment operator. We never perform any element destruction or construction here. </p>
</div></td></tr>
<tr class="memitem:a1a3e84580379c69d92ab24d96fa6c180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:a1a3e84580379c69d92ab24d96fa6c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment; source must be the same size as this array.  <a href="#a1a3e84580379c69d92ab24d96fa6c180">More...</a><br /></td></tr>
<tr class="separator:a1a3e84580379c69d92ab24d96fa6c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a7f8826e1792377e63d47b9c9a3c53584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a7f8826e1792377e63d47b9c9a3c53584">More...</a><br /></td></tr>
<tr class="separator:a7f8826e1792377e63d47b9c9a3c53584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:acb5dc46e5a1126a8e30882e53a86c62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#acb5dc46e5a1126a8e30882e53a86c62d">More...</a><br /></td></tr>
<tr class="separator:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a45bc77b91b7751a909ca6524346c9e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a45bc77b91b7751a909ca6524346c9e8d">More...</a><br /></td></tr>
<tr class="separator:a45bc77b91b7751a909ca6524346c9e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">operator=</a> (const std::vector&lt; T2, A2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a68daffa0f934e5f3d6f75adcb5d93367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="#a68daffa0f934e5f3d6f75adcb5d93367">More...</a><br /></td></tr>
<tr class="separator:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6a21ecbf455765267d5d12bde8628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">operator=</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a29e6a21ecbf455765267d5d12bde8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill assignment &ndash; all elements are set to fillValue.  <a href="#a29e6a21ecbf455765267d5d12bde8628">More...</a><br /></td></tr>
<tr class="separator:a29e6a21ecbf455765267d5d12bde8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbebca5377888478d004f882a6c24e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a1dbebca5377888478d004f882a6c24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element.  <a href="#a1dbebca5377888478d004f882a6c24e2">More...</a><br /></td></tr>
<tr class="separator:a1dbebca5377888478d004f882a6c24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a7d28c5d7a0586b39260b4a167f10c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a06a7d28c5d7a0586b39260b4a167f10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size.  <a href="#a06a7d28c5d7a0586b39260b4a167f10c">More...</a><br /></td></tr>
<tr class="separator:a06a7d28c5d7a0586b39260b4a167f10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a39312ebedf1ce457f129b39c69d4515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array.  <a href="#a39312ebedf1ce457f129b39c69d4515a">More...</a><br /></td></tr>
<tr class="separator:a39312ebedf1ce457f129b39c69d4515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:afb5c2516d03bb21d24ea4e87af777136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant).  <a href="#afb5c2516d03bb21d24ea4e87af777136">More...</a><br /></td></tr>
<tr class="separator:afb5c2516d03bb21d24ea4e87af777136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide read and write access to individual elements that are currently present in the array; the ArrayViewConst_&lt;T,X&gt; base class provides the read-only (const) methods.</p>
</div></td></tr>
<tr class="memitem:a1802aff86a94788eab5bf63e5fd704df"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1802aff86a94788eab5bf63e5fd704df">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a1802aff86a94788eab5bf63e5fd704df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#a1802aff86a94788eab5bf63e5fd704df">More...</a><br /></td></tr>
<tr class="separator:a1802aff86a94788eab5bf63e5fd704df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c9a87081523151ddbf1d22a853e4e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a943c9a87081523151ddbf1d22a853e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="#a943c9a87081523151ddbf1d22a853e4e">More...</a><br /></td></tr>
<tr class="separator:a943c9a87081523151ddbf1d22a853e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cae4892293f33c0ffb5e615beda7a5"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a99cae4892293f33c0ffb5e615beda7a5">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a99cae4892293f33c0ffb5e615beda7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a99cae4892293f33c0ffb5e615beda7a5">More...</a><br /></td></tr>
<tr class="separator:a99cae4892293f33c0ffb5e615beda7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f3650f5d31037f0051431eb02b57b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:ab93f3650f5d31037f0051431eb02b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#ab93f3650f5d31037f0051431eb02b57b">More...</a><br /></td></tr>
<tr class="separator:ab93f3650f5d31037f0051431eb02b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9514b4dc81e3aee1fcf2d5b8acc3973"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae9514b4dc81e3aee1fcf2d5b8acc3973">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:ae9514b4dc81e3aee1fcf2d5b8acc3973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#ae9514b4dc81e3aee1fcf2d5b8acc3973">More...</a><br /></td></tr>
<tr class="separator:ae9514b4dc81e3aee1fcf2d5b8acc3973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538c58736523ef56cafe9d926ec6e8f5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a538c58736523ef56cafe9d926ec6e8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a538c58736523ef56cafe9d926ec6e8f5">More...</a><br /></td></tr>
<tr class="separator:a538c58736523ef56cafe9d926ec6e8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95912a09cf7bd29259ef8d4473720424"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a95912a09cf7bd29259ef8d4473720424">front</a> () const </td></tr>
<tr class="memdesc:a95912a09cf7bd29259ef8d4473720424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="#a95912a09cf7bd29259ef8d4473720424">More...</a><br /></td></tr>
<tr class="separator:a95912a09cf7bd29259ef8d4473720424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">front</a> ()</td></tr>
<tr class="memdesc:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="#a1c3c26db7d7178a3e3c0b4603c7d0fcd">More...</a><br /></td></tr>
<tr class="separator:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460ec7ea1179ddf927e473d5bae34e1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0460ec7ea1179ddf927e473d5bae34e1">back</a> () const </td></tr>
<tr class="memdesc:a0460ec7ea1179ddf927e473d5bae34e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="#a0460ec7ea1179ddf927e473d5bae34e1">More...</a><br /></td></tr>
<tr class="separator:a0460ec7ea1179ddf927e473d5bae34e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707303e5e68fb5147fa36862c2bc57"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">back</a> ()</td></tr>
<tr class="memdesc:abf707303e5e68fb5147fa36862c2bc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="#abf707303e5e68fb5147fa36862c2bc57">More...</a><br /></td></tr>
<tr class="separator:abf707303e5e68fb5147fa36862c2bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying).  <a href="#ab89285bb25b06bc6a1b53fca6e63e3b7">More...</a><br /></td></tr>
<tr class="separator:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a33b3799cc9d10a4e4a6781292f7bdc15">More...</a><br /></td></tr>
<tr class="separator:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods deal in iterators, which are STL generalized pointers.</p>
<p>For this class, iterators are just ordinary pointers to T, and you may depend on that. By necessity, reverse iterators can't be just pointers; however, they contain an ordinary iterator (i.e. a pointer) that can be obtained by calling the reverse iterator's base() method. </p>
</div></td></tr>
<tr class="memitem:aab22f2833fec6ab0cf54c865e4b982b5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5">cbegin</a> () const </td></tr>
<tr class="memdesc:aab22f2833fec6ab0cf54c865e4b982b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>, which may be null (0) in that case but does not have to be.  <a href="#aab22f2833fec6ab0cf54c865e4b982b5">More...</a><br /></td></tr>
<tr class="separator:aab22f2833fec6ab0cf54c865e4b982b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4365a113f327e918eaeb4e82aefdb0e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad4365a113f327e918eaeb4e82aefdb0e">begin</a> () const </td></tr>
<tr class="memdesc:ad4365a113f327e918eaeb4e82aefdb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#ad4365a113f327e918eaeb4e82aefdb0e">More...</a><br /></td></tr>
<tr class="separator:ad4365a113f327e918eaeb4e82aefdb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa468711f19b67b25232650df6eeea608"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">begin</a> ()</td></tr>
<tr class="memdesc:aa468711f19b67b25232650df6eeea608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>.  <a href="#aa468711f19b67b25232650df6eeea608">More...</a><br /></td></tr>
<tr class="separator:aa468711f19b67b25232650df6eeea608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24067da9c7c229cdbd78f368191936"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936">cend</a> () const </td></tr>
<tr class="memdesc:add24067da9c7c229cdbd78f368191936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#add24067da9c7c229cdbd78f368191936">More...</a><br /></td></tr>
<tr class="separator:add24067da9c7c229cdbd78f368191936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c075d504a14643b27c226d20d5807d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab7c075d504a14643b27c226d20d5807d">end</a> () const </td></tr>
<tr class="memdesc:ab7c075d504a14643b27c226d20d5807d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#ab7c075d504a14643b27c226d20d5807d">More...</a><br /></td></tr>
<tr class="separator:ab7c075d504a14643b27c226d20d5807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5b2a07f725b6e943d45ad786bf02cb"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">end</a> ()</td></tr>
<tr class="memdesc:ace5b2a07f725b6e943d45ad786bf02cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="#ace5b2a07f725b6e943d45ad786bf02cb">More...</a><br /></td></tr>
<tr class="separator:ace5b2a07f725b6e943d45ad786bf02cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444e0272a509be58aa47bd4a661924ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca">crbegin</a> () const </td></tr>
<tr class="memdesc:a444e0272a509be58aa47bd4a661924ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#a444e0272a509be58aa47bd4a661924ca">More...</a><br /></td></tr>
<tr class="separator:a444e0272a509be58aa47bd4a661924ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d11403e60b499d439790bde90ffaeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa4d11403e60b499d439790bde90ffaeb">rbegin</a> () const </td></tr>
<tr class="memdesc:aa4d11403e60b499d439790bde90ffaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#aa4d11403e60b499d439790bde90ffaeb">More...</a><br /></td></tr>
<tr class="separator:aa4d11403e60b499d439790bde90ffaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add040a16da503b139f280a9e1a41c61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">rbegin</a> ()</td></tr>
<tr class="memdesc:add040a16da503b139f280a9e1a41c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="#add040a16da503b139f280a9e1a41c61d">More...</a><br /></td></tr>
<tr class="separator:add040a16da503b139f280a9e1a41c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2e82bd573b9e0fe365f76e929f92c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0">crend</a> () const </td></tr>
<tr class="memdesc:aba2e82bd573b9e0fe365f76e929f92c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#aba2e82bd573b9e0fe365f76e929f92c0">More...</a><br /></td></tr>
<tr class="separator:aba2e82bd573b9e0fe365f76e929f92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6852373084f7377944ead91c6f1ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee6852373084f7377944ead91c6f1ab4">rend</a> () const </td></tr>
<tr class="memdesc:aee6852373084f7377944ead91c6f1ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#aee6852373084f7377944ead91c6f1ab4">More...</a><br /></td></tr>
<tr class="separator:aee6852373084f7377944ead91c6f1ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe28b711d20b58b18f5ad1bce34145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">rend</a> ()</td></tr>
<tr class="memdesc:a70fe28b711d20b58b18f5ad1bce34145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a70fe28b711d20b58b18f5ad1bce34145">More...</a><br /></td></tr>
<tr class="separator:a70fe28b711d20b58b18f5ad1bce34145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ee8a10102bcd47f53fe0e6c28d64c"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c">cdata</a> () const </td></tr>
<tr class="memdesc:a1e0ee8a10102bcd47f53fe0e6c28d64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#a1e0ee8a10102bcd47f53fe0e6c28d64c">More...</a><br /></td></tr>
<tr class="separator:a1e0ee8a10102bcd47f53fe0e6c28d64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a58e82529049f52e953a347aeb30e"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7a6a58e82529049f52e953a347aeb30e">data</a> () const </td></tr>
<tr class="memdesc:a7a6a58e82529049f52e953a347aeb30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#a7a6a58e82529049f52e953a347aeb30e">More...</a><br /></td></tr>
<tr class="separator:a7a6a58e82529049f52e953a347aeb30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318481efdb8fd67f17e28e67cc8cce24"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">data</a> ()</td></tr>
<tr class="memdesc:a318481efdb8fd67f17e28e67cc8cce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="#a318481efdb8fd67f17e28e67cc8cce24">More...</a><br /></td></tr>
<tr class="separator:a318481efdb8fd67f17e28e67cc8cce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#a6008f8ca816619f1b4a67c94027a2d59">More...</a><br /></td></tr>
<tr class="separator:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">ArrayViewConst_</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> &amp;src)</td></tr>
<tr class="memdesc:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; the constructed const array object will be referencing the original source data.  <a href="#a5412fa0b837f5e090f343180b2dbcdc8">More...</a><br /></td></tr>
<tr class="separator:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">ArrayViewConst_</a> (const T *first, const T *last1)</td></tr>
<tr class="memdesc:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data.  <a href="#aba351ab4073da6f9d4c13855b039df6b">More...</a><br /></td></tr>
<tr class="separator:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">ArrayViewConst_</a> (const std::vector&lt; T, A &gt; &amp;src)</td></tr>
<tr class="memdesc:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion.  <a href="#acbb823ad8bafa05dae5c1a06b426c4a8">More...</a><br /></td></tr>
<tr class="separator:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a00cef62772e0c408bd3e0529417b8948">operator const ArrayView_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements.  <a href="#a00cef62772e0c408bd3e0529417b8948">More...</a><br /></td></tr>
<tr class="separator:a00cef62772e0c408bd3e0529417b8948 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a306a0b84ff4f9dd8981c5a978e2750f5">operator const Array_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data.  <a href="#a306a0b84ff4f9dd8981c5a978e2750f5">More...</a><br /></td></tr>
<tr class="separator:a306a0b84ff4f9dd8981c5a978e2750f5 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">disconnect</a> ()</td></tr>
<tr class="memdesc:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed.  <a href="#ace600fbc0738888ceef29cc7c0846643">More...</a><br /></td></tr>
<tr class="separator:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">~ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information.  <a href="#a5f34fb008e433a59e3957ab27b811839">More...</a><br /></td></tr>
<tr class="separator:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3">size</a> () const </td></tr>
<tr class="memdesc:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="#a4571082d90592c7b0f6761140e11edb3">More...</a><br /></td></tr>
<tr class="separator:a4571082d90592c7b0f6761140e11edb3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea">max_size</a> () const </td></tr>
<tr class="memdesc:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="#a4dff9e3f09bd7f0ca14dec2861a626ea">More...</a><br /></td></tr>
<tr class="separator:a4dff9e3f09bd7f0ca14dec2861a626ea inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c">empty</a> () const </td></tr>
<tr class="memdesc:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="#ad45ba916abcb168e7337b80890c8d68c">More...</a><br /></td></tr>
<tr class="separator:ad45ba916abcb168e7337b80890c8d68c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f">capacity</a> () const </td></tr>
<tr class="memdesc:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="#a3df09ea748ac2750e730981e7563526f">More...</a><br /></td></tr>
<tr class="separator:a3df09ea748ac2750e730981e7563526f inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a">allocated</a> () const </td></tr>
<tr class="memdesc:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="#a3c1c27ea8ca7b9f3411d438693fd8a2a">More...</a><br /></td></tr>
<tr class="separator:a3c1c27ea8ca7b9f3411d438693fd8a2a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1">isOwner</a> () const </td></tr>
<tr class="memdesc:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="#a30c40081730e9681d6102972f42904f1">More...</a><br /></td></tr>
<tr class="separator:a30c40081730e9681d6102972f42904f1 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#afa06a13341105ac7773a9c6bcd6a851c">More...</a><br /></td></tr>
<tr class="separator:afa06a13341105ac7773a9c6bcd6a851c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a4b5d31ec735550ba4b262b8e5f387020">More...</a><br /></td></tr>
<tr class="separator:a4b5d31ec735550ba4b262b8e5f387020 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a2af8a30f98edabfef434169ac33831e2">More...</a><br /></td></tr>
<tr class="separator:a2af8a30f98edabfef434169ac33831e2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554">front</a> () const </td></tr>
<tr class="memdesc:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a14d5eed816397cc84bc47af96645e554">More...</a><br /></td></tr>
<tr class="separator:a14d5eed816397cc84bc47af96645e554 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b">back</a> () const </td></tr>
<tr class="memdesc:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a26683b980dcd87bafd5c6446d8f8b25b">More...</a><br /></td></tr>
<tr class="separator:a26683b980dcd87bafd5c6446d8f8b25b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying).  <a href="#ab1816a17c6b643eb0967f954cdd96635">More...</a><br /></td></tr>
<tr class="separator:ab1816a17c6b643eb0967f954cdd96635 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a288833be443e0f02d958f5cfe74312ba">More...</a><br /></td></tr>
<tr class="separator:a288833be443e0f02d958f5cfe74312ba inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b">cbegin</a> () const </td></tr>
<tr class="memdesc:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="#ac3e34902f0533ffbda435880fd8ce34b">More...</a><br /></td></tr>
<tr class="separator:ac3e34902f0533ffbda435880fd8ce34b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4">cend</a> () const </td></tr>
<tr class="memdesc:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#a0664dc29fe9f3d2d3f38433774d9c3a4">More...</a><br /></td></tr>
<tr class="separator:a0664dc29fe9f3d2d3f38433774d9c3a4 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108">begin</a> () const </td></tr>
<tr class="memdesc:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#a0f8cb9dedb2d0710570621910a016108">More...</a><br /></td></tr>
<tr class="separator:a0f8cb9dedb2d0710570621910a016108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8">end</a> () const </td></tr>
<tr class="memdesc:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#a6349807c889c1155e01d429e264b08e8">More...</a><br /></td></tr>
<tr class="separator:a6349807c889c1155e01d429e264b08e8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824">crbegin</a> () const </td></tr>
<tr class="memdesc:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#aaca9a931016a896c03b783f7a5bb2824">More...</a><br /></td></tr>
<tr class="separator:aaca9a931016a896c03b783f7a5bb2824 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b">crend</a> () const </td></tr>
<tr class="memdesc:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a4736f16ae05ebee9e34077072496436b">More...</a><br /></td></tr>
<tr class="separator:a4736f16ae05ebee9e34077072496436b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256">rbegin</a> () const </td></tr>
<tr class="memdesc:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256" title="The const version of rbegin() is the same as crbegin(). ">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#a4de43406f71aed2fc534da92c4005256">More...</a><br /></td></tr>
<tr class="separator:a4de43406f71aed2fc534da92c4005256 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c">rend</a> () const </td></tr>
<tr class="memdesc:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c" title="The const version of rend() is the same as crend(). ">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#a6e0d66ba65094d8b6cf75922d846ff3c">More...</a><br /></td></tr>
<tr class="separator:a6e0d66ba65094d8b6cf75922d846ff3c inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388">cdata</a> () const </td></tr>
<tr class="memdesc:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#a4b2cf338eaf2590b4085bfb110470388">More...</a><br /></td></tr>
<tr class="separator:a4b2cf338eaf2590b4085bfb110470388 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d">data</a> () const </td></tr>
<tr class="memdesc:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#aa9f2581b552a2df91b8f2b7f9abae43d">More...</a><br /></td></tr>
<tr class="separator:aa9f2581b552a2df91b8f2b7f9abae43d inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Array_&lt;T&gt; serialization and I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are at namespace scope but are logically part of the Array classes.</p>
<p>These deal with reading and writing Arrays from and to streams, which places an additional requirement on the element type T: the element must support the same operation you are trying to do on the Array as a whole. </p>
</div></td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a2f916862f035a63e2406b6c47c57a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read.  <a href="#a2f916862f035a63e2406b6c47c57a2f3">More...</a><br /></td></tr>
<tr class="separator:a2f916862f035a63e2406b6c47c57a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:aa87616be589a0d76e0461c1d7c869e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView. ">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array.  <a href="#aa87616be589a0d76e0461c1d7c869e91">More...</a><br /></td></tr>
<tr class="separator:aa87616be589a0d76e0461c1d7c869e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">fillArrayViewFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a3c0c0d7769abbfe61b560361afe19f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an ArrayView.  <a href="#a3c0c0d7769abbfe61b560361afe19f03">More...</a><br /></td></tr>
<tr class="separator:a3c0c0d7769abbfe61b560361afe19f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:acc7c28435897527058bfecae5e2f407a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces.  <a href="#acc7c28435897527058bfecae5e2f407a">More...</a><br /></td></tr>
<tr class="separator:acc7c28435897527058bfecae5e2f407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Size and capacity</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbd71f01ce73bf54e552955f1e1aa56bf"></a>These methods report the number of elements (size) or the amount of allocated heap space (capacity) or both but cannot be used to change size.</p>
</td></tr>
<tr class="memitem:af93f8c651dab26b475900d4b768ae926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size</a> () const </td></tr>
<tr class="separator:af93f8c651dab26b475900d4b768ae926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35a88ad9923d73872f79308600821f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa35a88ad9923d73872f79308600821f1">max_size</a> () const </td></tr>
<tr class="separator:aa35a88ad9923d73872f79308600821f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75af4aca965b5170efc9b38956cac7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab75af4aca965b5170efc9b38956cac7c">empty</a> () const </td></tr>
<tr class="separator:ab75af4aca965b5170efc9b38956cac7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51052b7d71f1ba291a6a1dcfbafa6e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a51052b7d71f1ba291a6a1dcfbafa6e80">capacity</a> () const </td></tr>
<tr class="separator:a51052b7d71f1ba291a6a1dcfbafa6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573c73360997d8e1beb0a22f6b8452f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa573c73360997d8e1beb0a22f6b8452f">allocated</a> () const </td></tr>
<tr class="separator:aa573c73360997d8e1beb0a22f6b8452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa22264fa554e99c1266d9404404e32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9aa22264fa554e99c1266d9404404e32">isOwner</a> () const </td></tr>
<tr class="separator:a9aa22264fa554e99c1266d9404404e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X&gt;<br />
class SimTK::ArrayView_&lt; T, X &gt;</h3>

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, extending <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> to add the ability to modify elements, but not the ability to change size or reallocate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored in this container. </td></tr>
    <tr><td class="paramname">X</td><td>The type to be used for indexing this container, with default unsigned (not size_t). Any integral type may be used, as well as user types that satisfy the requirements discussed with class <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aeb29ff328a71341945e442234f50e253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae79baa909a71d2f8c75b1120776ccca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3950fd72f5f77716f823f8c0a9a87974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6e8dabb125276c7fcdaa215b23f808f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4b4b454ffabc27881011e3dcfea4014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a611de0d81f0e43b256704e817d63ae47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6566e08689eb53ae89a2b000ed4a4140"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a14185eed75d43f044775a366c02590c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a704e9c961a4621efd1bfe21bf099ca77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1232d267e9b8c139cca1512b412a6d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6e901cbddbca41c54b22c6216ac804b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abad962ee7e4110ac6c20bdfa340f81dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9536141dcc61cfc646bb1f2062e5e558"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ArrayIndexPackType&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa8e89ce2da1f241ae70e38cfe63ba980"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor allocates no heap space and is very fast. </p>

</div>
</div>
<a class="anchor" id="ad1ddf75311833fc599a934c3f3d5a57d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is shallow. </p>

</div>
</div>
<a class="anchor" id="a8e6104f869055379b0fbd146aeefa919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a range of writable memory. </p>

</div>
</div>
<a class="anchor" id="a176653cfecc6ee9dd5cbb08f53725a34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct to reference memory owned by a writable std::vector. </p>

</div>
</div>
<a class="anchor" id="a509b38ff0b42a6ff6b38cd3b26f4096f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::~<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aee82e038ccd001ede9b1104969fdfa3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost). </p>

</div>
</div>
<a class="anchor" id="a6ef7f785e236628b37192a5380d0a479"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>&amp; (zero cost). </p>

</div>
</div>
<a class="anchor" id="a7848acb2e30474663b3d708e80f2b6bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method – clears the handle without doing anything to the data...">disconnect()</a> method &ndash; clears the handle without doing anything to the data. </p>

</div>
</div>
<a class="anchor" id="a1a3e84580379c69d92ab24d96fa6c180"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment; source must be the same size as this array. </p>

</div>
</div>
<a class="anchor" id="a7f8826e1792377e63d47b9c9a3c53584"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="acb5dc46e5a1126a8e30882e53a86c62d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="a45bc77b91b7751a909ca6524346c9e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="a68daffa0f934e5f3d6f75adcb5d93367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a class="anchor" id="a29e6a21ecbf455765267d5d12bde8628"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill assignment &ndash; all elements are set to fillValue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbebca5377888478d004f882a6c24e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element. </p>
<p>Note that this also serves to allow fill from an object whose type T2 is different from T, as long as there is a constructor T(T2) that works since that can be invoked (implicitly or explicitly) to convert the T2 object to type T prior to the call. </p>

</div>
</div>
<a class="anchor" id="a06a7d28c5d7a0586b39260b4a167f10c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size. </p>

</div>
</div>
<a class="anchor" id="a39312ebedf1ce457f129b39c69d4515a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array. </p>
<p>It is not allowed for the source range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a T=T2 assignment operator that works. Note that although the source arguments are pointers, those may be iterators for some container depending on implementation details of the container. Specifically, any <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>, or <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> iterator is an ordinary pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>A pointer to the first element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A pointer to the element one past the last element to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1-first == <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The T=T2 assignment operator will be called exactly <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> times. </dd></dl>

</div>
</div>
<a class="anchor" id="afb5c2516d03bb21d24ea4e87af777136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant). </p>
<p>It is not allowed for this range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a T=T2 operator that works.</p>
<p>The source must have the same number of elements as the current (fixed) size of this ArrayView. For input_iterators we'll be happy if we get enough elements and won't insist that the input stream is empty after that. For forward_ and bidirectional_iterators we'll copy the elements and complain at the end if there are too few or too many. For random_access_iterators we'll check in advance since we can do that fast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>An iterator pointing to the element one past the last element to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This variant of <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> will not be called when the iterators are forward iterators from <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>, or <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> objects since those are ordinary pointers.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1 is reachable from first </dd>
<dd>
distance(first,last1)==<a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The T=T2 assignment operator will be called exactly <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> times. </dd></dl>

</div>
</div>
<a class="anchor" id="a1802aff86a94788eab5bf63e5fd704df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a const reference. </p>
<p>Note that only a value of the array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a943c9a87081523151ddbf1d22a853e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a writable (lvalue) reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a99cae4892293f33c0ffb5e615beda7a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab93f3650f5d31037f0051431eb02b57b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9514b4dc81e3aee1fcf2d5b8acc3973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::getElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a class="anchor" id="a538c58736523ef56cafe9d926ec6e8f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::updElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a class="anchor" id="a95912a09cf7bd29259ef8d4473720424"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c3c26db7d7178a3e3c0b4603c7d0fcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a0460ec7ea1179ddf927e473d5bae34e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="abf707303e5e68fb5147fa36862c2bc57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab89285bb25b06bc6a1b53fca6e63e3b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the first element to be included in the subarray; this can be one past the end of the array if <em>length</em> is zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the subarray to be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new ArrayView_&lt;T,X&gt; object referencing the original data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em>length==0</em> the returned array will be in a default-constructed, all-zero and null state with no connection to the original data. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>index</em> &gt;= 0, <em>length</em> &gt;= 0 </dd>
<dd>
<em>index</em> + <em>length</em> &lt;= <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> </dd>
<dd>
We'll validate preconditions in Debug builds but not Release. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap; no element construction or destruction or heap allocation is required. </dd></dl>

</div>
</div>
<a class="anchor" id="a33b3799cc9d10a4e4a6781292f7bdc15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::updSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a class="anchor" id="aab22f2833fec6ab0cf54c865e4b982b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>, which may be null (0) in that case but does not have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="ad4365a113f327e918eaeb4e82aefdb0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be. ">cbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="aa468711f19b67b25232650df6eeea608"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a>. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a> == <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a class="anchor" id="add24067da9c7c229cdbd78f368191936"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="ab7c075d504a14643b27c226d20d5807d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>. </p>

</div>
</div>
<a class="anchor" id="ace5b2a07f725b6e943d45ad786bf02cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to what would be the element just after the last one in this array. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end(). ">begin()</a>==<a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array...">end()</a> for an empty array. </p>

</div>
</div>
<a class="anchor" id="a444e0272a509be58aa47bd4a661924ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty. </p>

</div>
</div>
<a class="anchor" id="aa4d11403e60b499d439790bde90ffaeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a444e0272a509be58aa47bd4a661924ca" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="add040a16da503b139f280a9e1a41c61d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty. </p>

</div>
</div>
<a class="anchor" id="aba2e82bd573b9e0fe365f76e929f92c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a class="anchor" id="aee6852373084f7377944ead91c6f1ab4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#aba2e82bd573b9e0fe365f76e929f92c0" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>. </p>

</div>
</div>
<a class="anchor" id="a70fe28b711d20b58b18f5ad1bce34145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a class="anchor" id="a1e0ee8a10102bcd47f53fe0e6c28d64c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a> does not appear to be in the C++0x standard although it would seem obvious in view of the <a class="el" href="classSimTK_1_1ArrayView__.html#aab22f2833fec6ab0cf54c865e4b982b5" title="Return a const pointer to the first element of this array if any, otherwise end(), which may be null (0) in that case but does not have to be. ">cbegin()</a> and <a class="el" href="classSimTK_1_1ArrayView__.html#add24067da9c7c229cdbd78f368191936" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a> methods that had to be added. The C++0x overloaded const <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is also available. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a6a58e82529049f52e953a347aeb30e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#a1e0ee8a10102bcd47f53fe0e6c28d64c" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the proposed C++0x std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a318481efdb8fd67f17e28e67cc8cce24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the proposed C++0x std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af93f8c651dab26b475900d4b768ae926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa35a88ad9923d73872f79308600821f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab75af4aca965b5170efc9b38956cac7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51052b7d71f1ba291a6a1dcfbafa6e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa573c73360997d8e1beb0a22f6b8452f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9aa22264fa554e99c1266d9404404e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::isOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2f916862f035a63e2406b6c47c57a2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read. </p>
<p>If fewer are available we fail. </p>

</div>
</div>
<a class="anchor" id="aa87616be589a0d76e0461c1d7c869e91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readFormatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView. ">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView. ">fillArrayViewFromStream()</a> for details </dd></dl>

</div>
</div>
<a class="anchor" id="a3c0c0d7769abbfe61b560361afe19f03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; fillArrayViewFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a fixed number of elements from a stream into an ArrayView. </p>
<p>See <a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> for more information; this works the same way. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array. ">fillArrayFromStream()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc7c28435897527058bfecae5e2f407a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces. </p>
<p>If there are no delimiters then we will read <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> values and then stop. Otherwise, there must be exactly <a class="el" href="classSimTK_1_1ArrayView__.html#af93f8c651dab26b475900d4b768ae926">size()</a> values within the brackets. Each element is read in with its own operator "&gt;&gt;" so this won't work if no such operator is defined for type T. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:06 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
