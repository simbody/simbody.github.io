<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Xml::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Xml_1_1Node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Xml_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Xml::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract handle for holding any kind of node in an XML tree.  
 <a href="classSimTK_1_1Xml_1_1Node.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Xml::Node:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Xml_1_1Node.png" usemap="#SimTK::Xml::Node_map" alt=""/>
  <map id="SimTK::Xml::Node_map" name="SimTK::Xml::Node_map">
<area href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. " alt="SimTK::Xml::Comment" shape="rect" coords="0,56,131,80"/>
<area href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch..." alt="SimTK::Xml::Element" shape="rect" coords="141,56,272,80"/>
<area href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. " alt="SimTK::Xml::Text" shape="rect" coords="282,56,413,80"/>
<area href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. " alt="SimTK::Xml::Unknown" shape="rect" coords="423,56,554,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9523850db5f393008f00c3900fa753b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8">operator==</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const </td></tr>
<tr class="memdesc:a9523850db5f393008f00c3900fa753b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparing Nodes for equality means asking if the two <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles are referring to exactly the same object; two different nodes that happen to have the same properties will not test equal by this criteria.  <a href="#a9523850db5f393008f00c3900fa753b8">More...</a><br /></td></tr>
<tr class="separator:a9523850db5f393008f00c3900fa753b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50231fc82d308d4827cbb13f882747ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a50231fc82d308d4827cbb13f882747ee">operator!=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const </td></tr>
<tr class="memdesc:a50231fc82d308d4827cbb13f882747ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test using same criteria as <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8" title="Comparing Nodes for equality means asking if the two Node handles are referring to exactly the same o...">operator==()</a>.  <a href="#a50231fc82d308d4827cbb13f882747ee">More...</a><br /></td></tr>
<tr class="separator:a50231fc82d308d4827cbb13f882747ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are mostly used by the derived node classes; Nodes are not generally created directly in user code.</p>
</div></td></tr>
<tr class="memitem:a6086556201f425213e56d7d35d5a770f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f">Node</a> ()</td></tr>
<tr class="memdesc:a6086556201f425213e56d7d35d5a770f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle that can be used to hold a reference to any kind of <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>.  <a href="#a6086556201f425213e56d7d35d5a770f">More...</a><br /></td></tr>
<tr class="separator:a6086556201f425213e56d7d35d5a770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a4a32f7bcd56d7e045def2c0721504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504">Node</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:a37a4a32f7bcd56d7e045def2c0721504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; that is, this handle will refer to the same node as the source.  <a href="#a37a4a32f7bcd56d7e045def2c0721504">More...</a><br /></td></tr>
<tr class="separator:a37a4a32f7bcd56d7e045def2c0721504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ad2654deb98cc0d755cedef628102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ac73ad2654deb98cc0d755cedef628102">operator=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:ac73ad2654deb98cc0d755cedef628102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is shallow; the handle is first cleared and then will refer to the same node as the source.  <a href="#ac73ad2654deb98cc0d755cedef628102">More...</a><br /></td></tr>
<tr class="separator:ac73ad2654deb98cc0d755cedef628102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc94baed587a767bc743a6922a1caa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4">clone</a> () const </td></tr>
<tr class="memdesc:a1bc94baed587a767bc743a6922a1caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4" title="The clone() method makes a deep copy of this Node and its children and returns a new orphan Node with...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> with the same contents; ordinary assignment and copy construction is shallow.  <a href="#a1bc94baed587a767bc743a6922a1caa4">More...</a><br /></td></tr>
<tr class="separator:a1bc94baed587a767bc743a6922a1caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54089650958823d1a7d070cf27c1741"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741">~Node</a> ()</td></tr>
<tr class="memdesc:ae54089650958823d1a7d070cf27c1741"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle destructor does not recover heap space so if you create orphan nodes and then don't put them in a document there will be a memory leak unless you explicitly destruct them first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a>.  <a href="#ae54089650958823d1a7d070cf27c1741">More...</a><br /></td></tr>
<tr class="separator:ae54089650958823d1a7d070cf27c1741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc212921b30a4a7b95f339224b115b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#acc212921b30a4a7b95f339224b115b47">clear</a> ()</td></tr>
<tr class="memdesc:acc212921b30a4a7b95f339224b115b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method restores the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle to its default-constructed state but does not recover any heap space; use <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a> if you know this node was never put into a document.  <a href="#acc212921b30a4a7b95f339224b115b47">More...</a><br /></td></tr>
<tr class="separator:acc212921b30a4a7b95f339224b115b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af526ba1e54d03561336ec39eba5a3fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8">clearOrphan</a> ()</td></tr>
<tr class="memdesc:af526ba1e54d03561336ec39eba5a3fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method explictly frees the heap space for an orphan node that was created but never inserted into a document.  <a href="#af526ba1e54d03561336ec39eba5a3fe8">More...</a><br /></td></tr>
<tr class="separator:af526ba1e54d03561336ec39eba5a3fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node classification</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can find out what concrete type of node this abstract <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is referring to (if any), who owns the node, and if it is owned by a parent element you can get access to the parent.</p>
</div></td></tr>
<tr class="memitem:a02af9c337d25add562a5b3dfd75c963c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a02af9c337d25add562a5b3dfd75c963c">getNodeType</a> () const </td></tr>
<tr class="memdesc:a02af9c337d25add562a5b3dfd75c963c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">Xml::NodeType</a> of this node.  <a href="#a02af9c337d25add562a5b3dfd75c963c">More...</a><br /></td></tr>
<tr class="separator:a02af9c337d25add562a5b3dfd75c963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2d94932a97f4c5eb5bd28b20748f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8b2d94932a97f4c5eb5bd28b20748f3b">getNodeTypeAsString</a> () const </td></tr>
<tr class="memdesc:a8b2d94932a97f4c5eb5bd28b20748f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> type as a string; an empty handle returns "NoNode".  <a href="#a8b2d94932a97f4c5eb5bd28b20748f3b">More...</a><br /></td></tr>
<tr class="separator:a8b2d94932a97f4c5eb5bd28b20748f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08c6ea7d9b3362a5b2af3b7012d09a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a">isValid</a> () const </td></tr>
<tr class="memdesc:a8a08c6ea7d9b3362a5b2af3b7012d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is referencing some node, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="#a8a08c6ea7d9b3362a5b2af3b7012d09a">More...</a><br /></td></tr>
<tr class="separator:a8a08c6ea7d9b3362a5b2af3b7012d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa939cc4a494ad2f8117bc058171a3d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aaa939cc4a494ad2f8117bc058171a3d0">isTopLevelNode</a> () const </td></tr>
<tr class="memdesc:aaa939cc4a494ad2f8117bc058171a3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by the top-level <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> or is an orphan, or if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="#aaa939cc4a494ad2f8117bc058171a3d0">More...</a><br /></td></tr>
<tr class="separator:aaa939cc4a494ad2f8117bc058171a3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55413e3118a107e93cd58b1186ac99e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ab55413e3118a107e93cd58b1186ac99e">isOrphan</a> () const </td></tr>
<tr class="memdesc:ab55413e3118a107e93cd58b1186ac99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an orphan, meaning that it is not empty, but is not owned by any element or top-level document.  <a href="#ab55413e3118a107e93cd58b1186ac99e">More...</a><br /></td></tr>
<tr class="separator:ab55413e3118a107e93cd58b1186ac99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0803126f86e88a10ffa31437115f5814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0803126f86e88a10ffa31437115f5814">hasParentElement</a> () const </td></tr>
<tr class="memdesc:a0803126f86e88a10ffa31437115f5814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this node has a parent, i.e.  <a href="#a0803126f86e88a10ffa31437115f5814">More...</a><br /></td></tr>
<tr class="separator:a0803126f86e88a10ffa31437115f5814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad45b2ef59c93d755edb25334f501a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aad45b2ef59c93d755edb25334f501a17">getParentElement</a> ()</td></tr>
<tr class="memdesc:aad45b2ef59c93d755edb25334f501a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle referencing this node's parent if it has one, otherwise throws an error; check first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0803126f86e88a10ffa31437115f5814" title="Return true if this node has a parent, i.e. ">hasParentElement()</a> if you aren't sure.  <a href="#aad45b2ef59c93d755edb25334f501a17">More...</a><br /></td></tr>
<tr class="separator:aad45b2ef59c93d755edb25334f501a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to node contents</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Usually contents inspection is handled at the concrete node class level; here we can only provide information for which you don't need to know what kind of node this is.</p>
</div></td></tr>
<tr class="memitem:a0091f53a29b7082e51f8682ab8e36643"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0091f53a29b7082e51f8682ab8e36643">getNodeText</a> () const </td></tr>
<tr class="memdesc:a0091f53a29b7082e51f8682ab8e36643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a text value associated with this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> (<em>not</em> including its child nodes if any); the behavior depends on the NodeType.  <a href="#a0091f53a29b7082e51f8682ab8e36643">More...</a><br /></td></tr>
<tr class="separator:a0091f53a29b7082e51f8682ab8e36643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c79035793ee0090d3826623535706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a577c79035793ee0090d3826623535706">writeToString</a> (<a class="el" href="classSimTK_1_1String.html">String</a> &amp;out, bool compact=false) const </td></tr>
<tr class="memdesc:a577c79035793ee0090d3826623535706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this node (and everything it contains) to the given <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>.  <a href="#a577c79035793ee0090d3826623535706">More...</a><br /></td></tr>
<tr class="separator:a577c79035793ee0090d3826623535706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6da91779d499b1ad3035fe196aecd99a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a6da91779d499b1ad3035fe196aecd99a">Xml</a></td></tr>
<tr class="separator:a6da91779d499b1ad3035fe196aecd99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e46e94e7cf9a3d870ce5f7444f2899"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a93e46e94e7cf9a3d870ce5f7444f2899">Xml::Impl</a></td></tr>
<tr class="separator:a93e46e94e7cf9a3d870ce5f7444f2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b9de807f55aaefbf3329e1da7874ed"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a66b9de807f55aaefbf3329e1da7874ed">Xml::node_iterator</a></td></tr>
<tr class="separator:a66b9de807f55aaefbf3329e1da7874ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc68234fdd04ea25b3b4906c59460129"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#afc68234fdd04ea25b3b4906c59460129">Xml::Comment</a></td></tr>
<tr class="separator:afc68234fdd04ea25b3b4906c59460129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac058de0e0e9bc866bc00bb8e4fcb40d8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ac058de0e0e9bc866bc00bb8e4fcb40d8">Xml::Unknown</a></td></tr>
<tr class="separator:ac058de0e0e9bc866bc00bb8e4fcb40d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37512fe7e1bedb57d57ff5799cce6e59"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a37512fe7e1bedb57d57ff5799cce6e59">Xml::Text</a></td></tr>
<tr class="separator:a37512fe7e1bedb57d57ff5799cce6e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad573bea5abccc16b7d355fda4a8a6ff4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ad573bea5abccc16b7d355fda4a8a6ff4">Xml::Element</a></td></tr>
<tr class="separator:ad573bea5abccc16b7d355fda4a8a6ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a80c0f5ebe69e44375f32f508ba2c19ce"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Xml::Node</a> &amp;xmlNode)</td></tr>
<tr class="memdesc:a80c0f5ebe69e44375f32f508ba2c19ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a "pretty printed" textual representation of the given XML node (and all its contents) to an std::ostream.  <a href="#a80c0f5ebe69e44375f32f508ba2c19ce">More...</a><br /></td></tr>
<tr class="separator:a80c0f5ebe69e44375f32f508ba2c19ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract handle for holding any kind of node in an XML tree. </p>
<p>The concrete node handle types derived from <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> are: <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a>, <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a>, <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a>, and <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. Only an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node may contain other nodes.</p>
<p>A node may be classified by who owns it. There are three possibilities:</p><ul>
<li>Top-level node: The node belongs to the top-level <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document and does not have a parent node.</li>
<li>Child node: The node belongs to an element, which may be the root element or any lower-level element. The element that owns it is its "parent".</li>
<li>Orphan node: The node is not yet part of any <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document and does not belong to an element. In that case the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle serves as the owner and the node does not have a parent node.</li>
</ul>
<p>A <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle may also be empty, meaning it refers to no node at all so there is nothing to own.</p>
<p>Top-level nodes can only be <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> nodes, <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> nodes, or the lone root <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node. Child nodes and orphans can be of <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> type also. Normally orphans exist only briefly during the time a new node is constructed and the time it is adopted by some element (usually in the same constructor) so you can ignore them for the most part. But if you must keep orphan nodes around, be aware that they must be referenced by only one handle at a time to avoid ownership conflicts. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6086556201f425213e56d7d35d5a770f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle that can be used to hold a reference to any kind of <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a37a4a32f7bcd56d7e045def2c0721504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is shallow; that is, this handle will refer to the same node as the source. </p>
<p>Note that this handle will provide write access to the underlying node, even if the source was const. </p>

</div>
</div>
<a class="anchor" id="ae54089650958823d1a7d070cf27c1741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle destructor does not recover heap space so if you create orphan nodes and then don't put them in a document there will be a memory leak unless you explicitly destruct them first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac73ad2654deb98cc0d755cedef628102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&amp; SimTK::Xml::Node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment is shallow; the handle is first cleared and then will refer to the same node as the source. </p>
<p>Note that this handle will provide write access to the underlying node even if the source handle was const. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Node.html#acc212921b30a4a7b95f339224b115b47" title="This method restores the Node handle to its default-constructed state but does not recover any heap s...">clear()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bc94baed587a767bc743a6922a1caa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> SimTK::Xml::Node::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4" title="The clone() method makes a deep copy of this Node and its children and returns a new orphan Node with...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> with the same contents; ordinary assignment and copy construction is shallow. </p>

</div>
</div>
<a class="anchor" id="acc212921b30a4a7b95f339224b115b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Node::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method restores the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle to its default-constructed state but does not recover any heap space; use <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a> if you know this node was never put into a document. </p>

</div>
</div>
<a class="anchor" id="af526ba1e54d03561336ec39eba5a3fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Node::clearOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method explictly frees the heap space for an orphan node that was created but never inserted into a document. </p>
<p>It is an error to call this if the node is in a document. </p>

</div>
</div>
<a class="anchor" id="a02af9c337d25add562a5b3dfd75c963c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> SimTK::Xml::Node::getNodeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">Xml::NodeType</a> of this node. </p>
<p>If this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty, the returned NodeType will be "Xml::NoNode". </p>

</div>
</div>
<a class="anchor" id="a8b2d94932a97f4c5eb5bd28b20748f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::Node::getNodeTypeAsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> type as a string; an empty handle returns "NoNode". </p>

</div>
</div>
<a class="anchor" id="a8a08c6ea7d9b3362a5b2af3b7012d09a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is referencing some node, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty. </p>

</div>
</div>
<a class="anchor" id="aaa939cc4a494ad2f8117bc058171a3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::isTopLevelNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by the top-level <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> or is an orphan, or if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty. </p>

</div>
</div>
<a class="anchor" id="ab55413e3118a107e93cd58b1186ac99e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::isOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an orphan, meaning that it is not empty, but is not owned by any element or top-level document. </p>
<p>This is typically a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> object that has just been constructed, or one that has been cloned from another <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a0803126f86e88a10ffa31437115f5814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::hasParentElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this node has a parent, i.e. </p>
<p>it is owned by an element; the root element and other top-level nodes are owned by the document and thus do not have a parent. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aad45b2ef59c93d755edb25334f501a17" title="Return a handle referencing this node&#39;s parent if it has one, otherwise throws an error; check first ...">getParentElement()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad45b2ef59c93d755edb25334f501a17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Node::getParentElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a handle referencing this node's parent if it has one, otherwise throws an error; check first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0803126f86e88a10ffa31437115f5814" title="Return true if this node has a parent, i.e. ">hasParentElement()</a> if you aren't sure. </p>

</div>
</div>
<a class="anchor" id="a0091f53a29b7082e51f8682ab8e36643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Node::getNodeText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a text value associated with this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> (<em>not</em> including its child nodes if any); the behavior depends on the NodeType. </p>
<p>This is a convenience that saves downcasting a generic <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a concrete type when all you want to do is dump out the text. It is not particularly useful for <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes. Here is what you get for each type of node:</p><ul>
<li><a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a>: everything between "&lt;!--" and "--&gt;"</li>
<li><a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a>: everything between "&lt;" and "&gt;"</li>
<li><a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a>: the text</li>
<li><a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>: the element's tag word (<em>not</em> the element's value)</li>
<li>None: (i.e., an empty handle) throw an error. </li>
</ul>

</div>
</div>
<a class="anchor" id="a577c79035793ee0090d3826623535706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Node::writeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize this node (and everything it contains) to the given <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>. </p>
<p>The output will be "pretty printed" and terminated with a newline unless you specify <em>compact</em> = true in which case indents and newlines will be suppressed. Pretty printing uses the containing <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>'s indent string, if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is in a document, otherwise the default of four spaces for each indent level is used. </p>

</div>
</div>
<a class="anchor" id="a9523850db5f393008f00c3900fa753b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparing Nodes for equality means asking if the two <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles are referring to exactly the same object; two different nodes that happen to have the same properties will not test equal by this criteria. </p>

</div>
</div>
<a class="anchor" id="a50231fc82d308d4827cbb13f882747ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Node::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality test using same criteria as <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8" title="Comparing Nodes for equality means asking if the two Node handles are referring to exactly the same o...">operator==()</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6da91779d499b1ad3035fe196aecd99a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml.html">Xml</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93e46e94e7cf9a3d870ce5f7444f2899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class Xml::Impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66b9de807f55aaefbf3329e1da7874ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">Xml::node_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc68234fdd04ea25b3b4906c59460129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Comment.html">Xml::Comment</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac058de0e0e9bc866bc00bb8e4fcb40d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html">Xml::Unknown</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37512fe7e1bedb57d57ff5799cce6e59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Text.html">Xml::Text</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad573bea5abccc16b7d355fda4a8a6ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a80c0f5ebe69e44375f32f508ba2c19ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Xml::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>xmlNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a "pretty printed" textual representation of the given XML node (and all its contents) to an std::ostream. </p>
<p>Pretty printing uses the indent string from the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>'s containing <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>, if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is in a document, otherwise the default of four spaces for each indent level is used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml.html">Xml</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:28 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
