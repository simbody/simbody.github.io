<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::PIMPLHandle&lt; HANDLE, IMPL, PTR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1PIMPLHandle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classSimTK_1_1PIMPLHandle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::PIMPLHandle&lt; HANDLE, IMPL, PTR &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides some infrastructure useful in making <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> Private Implementation (PIMPL) classes.  
 <a href="classSimTK_1_1PIMPLHandle.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6b925b77482930c9ef55955fa1e48b45"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a></td></tr>
<tr class="separator:a6b925b77482930c9ef55955fa1e48b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b0b3d07fe975bdbeb5c1642e8e9c8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae31b0b3d07fe975bdbeb5c1642e8e9c8">ParentHandle</a></td></tr>
<tr class="separator:ae31b0b3d07fe975bdbeb5c1642e8e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7d17772c38115b341ee2e12aeeac36f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f">isEmptyHandle</a> () const </td></tr>
<tr class="memdesc:ab7d17772c38115b341ee2e12aeeac36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is empty, that is, does not refer to any implementation object.  <a href="#ab7d17772c38115b341ee2e12aeeac36f">More...</a><br /></td></tr>
<tr class="separator:ab7d17772c38115b341ee2e12aeeac36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d9f8e49a5b828a9143b44a42e94f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3a6d9f8e49a5b828a9143b44a42e94f5">isOwnerHandle</a> () const </td></tr>
<tr class="memdesc:a3a6d9f8e49a5b828a9143b44a42e94f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is the owner of the implementation object to which it refers.  <a href="#a3a6d9f8e49a5b828a9143b44a42e94f5">More...</a><br /></td></tr>
<tr class="separator:a3a6d9f8e49a5b828a9143b44a42e94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb05874b5a826344472105dbd649249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a1cb05874b5a826344472105dbd649249">isSameHandle</a> (const HANDLE &amp;other) const </td></tr>
<tr class="memdesc:a1cb05874b5a826344472105dbd649249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is the same object as "this" <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a>.  <a href="#a1cb05874b5a826344472105dbd649249">More...</a><br /></td></tr>
<tr class="separator:a1cb05874b5a826344472105dbd649249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc78d673f2db6a98f3bb4cdf14fd2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a53fc78d673f2db6a98f3bb4cdf14fd2f">disown</a> (HANDLE &amp;newOwner)</td></tr>
<tr class="memdesc:a53fc78d673f2db6a98f3bb4cdf14fd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give up ownership of the implementation to an empty handle.  <a href="#a53fc78d673f2db6a98f3bb4cdf14fd2f">More...</a><br /></td></tr>
<tr class="separator:a53fc78d673f2db6a98f3bb4cdf14fd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ec0d1cdd705d051a485a89c32f6e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9">referenceAssign</a> (const HANDLE &amp;source)</td></tr>
<tr class="memdesc:a878ec0d1cdd705d051a485a89c32f6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Copy" assignment but with shallow (pointer) semantics.  <a href="#a878ec0d1cdd705d051a485a89c32f6e9">More...</a><br /></td></tr>
<tr class="separator:a878ec0d1cdd705d051a485a89c32f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de72469fd5f56985b944f696e9e79ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae">copyAssign</a> (const HANDLE &amp;source)</td></tr>
<tr class="memdesc:a2de72469fd5f56985b944f696e9e79ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is real copy assignment, with ordinary C++ object ("value") semantics.  <a href="#a2de72469fd5f56985b944f696e9e79ae">More...</a><br /></td></tr>
<tr class="separator:a2de72469fd5f56985b944f696e9e79ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a485a9ef857781b8029ffd829fa636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636">clearHandle</a> ()</td></tr>
<tr class="memdesc:a46a485a9ef857781b8029ffd829fa636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this an empty handle, deleting the implementation object if this handle is the owner of it.  <a href="#a46a485a9ef857781b8029ffd829fa636">More...</a><br /></td></tr>
<tr class="separator:a46a485a9ef857781b8029ffd829fa636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66906a41755f8dae64f3bd945b949c74"><td class="memItemLeft" align="right" valign="top">const IMPL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a66906a41755f8dae64f3bd945b949c74">getImpl</a> () const </td></tr>
<tr class="memdesc:a66906a41755f8dae64f3bd945b949c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the implementation associated with this Handle.  <a href="#a66906a41755f8dae64f3bd945b949c74">More...</a><br /></td></tr>
<tr class="separator:a66906a41755f8dae64f3bd945b949c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cea00ca400bace6ccb795e5ba54d4ef"><td class="memItemLeft" align="right" valign="top">IMPL &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3cea00ca400bace6ccb795e5ba54d4ef">updImpl</a> ()</td></tr>
<tr class="memdesc:a3cea00ca400bace6ccb795e5ba54d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to the implementation associated with this Handle.  <a href="#a3cea00ca400bace6ccb795e5ba54d4ef">More...</a><br /></td></tr>
<tr class="separator:a3cea00ca400bace6ccb795e5ba54d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e940afd133cc244c156b54a177529bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a0e940afd133cc244c156b54a177529bd">getImplHandleCount</a> () const </td></tr>
<tr class="memdesc:a0e940afd133cc244c156b54a177529bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of handles the implementation believes are referencing it.  <a href="#a0e940afd133cc244c156b54a177529bd">More...</a><br /></td></tr>
<tr class="separator:a0e940afd133cc244c156b54a177529bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae66aa14c4a664f31d22289e2bb604441"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae66aa14c4a664f31d22289e2bb604441">PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:ae66aa14c4a664f31d22289e2bb604441"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor makes this an empty handle.  <a href="#ae66aa14c4a664f31d22289e2bb604441">More...</a><br /></td></tr>
<tr class="separator:ae66aa14c4a664f31d22289e2bb604441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9451ca6b7502c54447d10449662a483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#aa9451ca6b7502c54447d10449662a483">PIMPLHandle</a> (IMPL *p)</td></tr>
<tr class="memdesc:aa9451ca6b7502c54447d10449662a483"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides consruction of a handle referencing an existing implementation object.  <a href="#aa9451ca6b7502c54447d10449662a483">More...</a><br /></td></tr>
<tr class="separator:aa9451ca6b7502c54447d10449662a483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cabb439c294d4b696f9ec0a9534b6e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a5cabb439c294d4b696f9ec0a9534b6e3">~PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:a5cabb439c294d4b696f9ec0a9534b6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that the destructor is non-virtual.  <a href="#a5cabb439c294d4b696f9ec0a9534b6e3">More...</a><br /></td></tr>
<tr class="separator:a5cabb439c294d4b696f9ec0a9534b6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f661f13ccfd6ca41d8a9fc3435e32e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6f661f13ccfd6ca41d8a9fc3435e32e7">PIMPLHandle</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a6f661f13ccfd6ca41d8a9fc3435e32e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor makes either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer
semantics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a6f661f13ccfd6ca41d8a9fc3435e32e7">More...</a><br /></td></tr>
<tr class="separator:a6f661f13ccfd6ca41d8a9fc3435e32e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c83a6a5f2b7fb96834981442d30f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a39c83a6a5f2b7fb96834981442d30f8d">operator=</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a39c83a6a5f2b7fb96834981442d30f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer sematics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a39c83a6a5f2b7fb96834981442d30f8d">More...</a><br /></td></tr>
<tr class="separator:a39c83a6a5f2b7fb96834981442d30f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59892732781a567f4ad30b982acb2c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a59892732781a567f4ad30b982acb2c27">setImpl</a> (IMPL *p)</td></tr>
<tr class="memdesc:a59892732781a567f4ad30b982acb2c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation for this empty handle.  <a href="#a59892732781a567f4ad30b982acb2c27">More...</a><br /></td></tr>
<tr class="separator:a59892732781a567f4ad30b982acb2c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666ec4c8e626e771aa5d058605fa840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3666ec4c8e626e771aa5d058605fa840">hasSameImplementation</a> (const HANDLE &amp;other) const </td></tr>
<tr class="memdesc:a3666ec4c8e626e771aa5d058605fa840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is a reference to the same implementation object as is referenced by "this" <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a>.  <a href="#a3666ec4c8e626e771aa5d058605fa840">More...</a><br /></td></tr>
<tr class="separator:a3666ec4c8e626e771aa5d058605fa840"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class HANDLE, class IMPL, bool PTR = false&gt;<br />
class SimTK::PIMPLHandle&lt; HANDLE, IMPL, PTR &gt;</h3>

<p>This class provides some infrastructure useful in making <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> Private Implementation (PIMPL) classes. </p>
<p>These consist of a "handle" class and an "implementation" class. The handle contains only a single pointer, which points to the implementation class whose definition is unknown to the <a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a> client. The implementation class has a pointer back to *one* of the handles that points to it &ndash; that one is called the "owner
handle" and is the only one which will delete the implementation object when the handle is deleted or goes out of scope. All other handles are merely references to the implementation object, and must not be used after the owner handle is deleted.</p>
<p>The methods defined below require a definition for the implementation class, so can't be instantiated on the client side. Instead they are instantiated on the library side when needed in the implementation of the PIMPL handle class derived from the <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> base.</p>
<p>By the time of instantiation, we must have a definition for the IMPL class supplied to the templatized base class. We expect that the IMPL class will be derived from <a class="el" href="classSimTK_1_1PIMPLImplementation.html" title="This class provides some infrastructure useful in creating PIMPL Implementation classes (the ones ref...">PIMPLImplementation</a> declared below. We also expect to find certain methods defined, with these names and meanings:</p>
<p>IMPL* IMPL::clone() const This creates an implementation object identical to the one we have, except that its owner handle is set to null. We expect the owner handle to be filled in by the derived Handle class, which should have initiated the <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> operation which had the need to clone().</p>
<p>const HANDLE&amp; IMPL::getOwnerHandle() const If the IMPL object does not have an owner, this is expected to assert(); that would indicate that the derived Handle class did not properly register itself as the owner upon construction. Otherwise, this routine returns a reference to the *derived* Handle class, NOT to the <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> parent class! We expect, however that the Handle class was derived from this <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> so that we can static_cast up here and then compare with 'this'.</p>
<p>Usage: class MySecretImpl; class MyHandle : public PIMPLHandle&lt;MyHandle,MySecretImpl&gt;</p>
<p>There is an optional third template argument, a bool, which can be set true if you want the handle to have pointer semantics rather than the usual object ("value") semantics. Pointer semantics objects have shallow copy constuctor and copy assignment implementations so that they are normally references to objects rather than owners, and pointer semantics owner handles can't be the target of an assignment. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a6b925b77482930c9ef55955fa1e48b45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt;HANDLE, IMPL, PTR&gt; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::<a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae31b0b3d07fe975bdbeb5c1642e8e9c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a> <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::<a class="el" href="classSimTK_1_1PIMPLHandle.html#ae31b0b3d07fe975bdbeb5c1642e8e9c8">ParentHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae66aa14c4a664f31d22289e2bb604441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::<a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor makes this an empty handle. </p>

</div>
</div>
<a class="anchor" id="aa9451ca6b7502c54447d10449662a483"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL, bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::<a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> </td>
          <td>(</td>
          <td class="paramtype">IMPL *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This provides consruction of a handle referencing an existing implementation object. </p>
<p>If the supplied pointer is null the result is the same as the default constructor. </p>

</div>
</div>
<a class="anchor" id="a5cabb439c294d4b696f9ec0a9534b6e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL , bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::~<a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note that the destructor is non-virtual. </p>
<p>This is a concrete class and so should be all the handle classes derived from it. If this handle is the owner of its implementation, the destructor will destroy the implementation object as well. Any other handles referencing the same implementation will then be invalid, although there will be automated detection of that. Be very careful to ensure that owner handles always outlive their reference handles. </p>

</div>
</div>
<a class="anchor" id="a6f661f13ccfd6ca41d8a9fc3435e32e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL, bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::<a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor makes either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer
semantics" (PTR=true) or "object (value) semantics" (PTR=false, default) class. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9" title="&quot;Copy&quot; assignment but with shallow (pointer) semantics. ">referenceAssign</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae" title="This is real copy assignment, with ordinary C++ object (&quot;value&quot;) semantics. ">copyAssign</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab7d17772c38115b341ee2e12aeeac36f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::isEmptyHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this handle is empty, that is, does not refer to any implementation object. </p>

</div>
</div>
<a class="anchor" id="a3a6d9f8e49a5b828a9143b44a42e94f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::isOwnerHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this handle is the owner of the implementation object to which it refers. </p>
<p>An empty handle is <em>not</em> considered by this method to be an owner. You can check for an empty handle using <a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f" title="Returns true if this handle is empty, that is, does not refer to any implementation object...">isEmptyHandle()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f" title="Returns true if this handle is empty, that is, does not refer to any implementation object...">isEmptyHandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1cb05874b5a826344472105dbd649249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::isSameHandle </td>
          <td>(</td>
          <td class="paramtype">const HANDLE &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the supplied handle is the same object as "this" <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a>. </p>

</div>
</div>
<a class="anchor" id="a53fc78d673f2db6a98f3bb4cdf14fd2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::disown </td>
          <td>(</td>
          <td class="paramtype">HANDLE &amp;&#160;</td>
          <td class="paramname"><em>newOwner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give up ownership of the implementation to an empty handle. </p>
<p>The current handle retains a reference to the implementation but is no longer its owner. This method requires the current handle to be an owner, and the supplied handle to be empty. </p>

</div>
</div>
<a class="anchor" id="a878ec0d1cdd705d051a485a89c32f6e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt; &amp; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::referenceAssign </td>
          <td>(</td>
          <td class="paramtype">const HANDLE &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Copy" assignment but with shallow (pointer) semantics. </p>
<p>As long as this is not an owner handle already, make it reference the source implementation. It is not allowed for an <em>owner</em> handle to be the target of a reference assignment; clear the handle explicitly first with <a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636" title="Make this an empty handle, deleting the implementation object if this handle is the owner of it...">clearHandle()</a> if you want to do that. This is the default copy and assignment behavior for pointer semantics handle classes (that is, those which set the PTR template argument to true). Caution: although the <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a> is taken const here, we obtain a writable pointer to the implementation, meaning that it can be modified through the reference handle if that handle is non-const. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae" title="This is real copy assignment, with ordinary C++ object (&quot;value&quot;) semantics. ">copyAssign()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1PIMPLHandle.html#a39c83a6a5f2b7fb96834981442d30f8d" title="Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the sup...">operator=()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636" title="Make this an empty handle, deleting the implementation object if this handle is the owner of it...">clearHandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2de72469fd5f56985b944f696e9e79ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt; &amp; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::copyAssign </td>
          <td>(</td>
          <td class="paramtype">const HANDLE &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is real copy assignment, with ordinary C++ object ("value") semantics. </p>
<p>Deletes the current implementation if owned; then replaces with a new copy of the source implementation, of which this handle will be the owner. This is the default copy and assignment behavior for normal handle objects, that is, those that let the PTR template argument default or set it to false explicitly. Use <a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9" title="&quot;Copy&quot; assignment but with shallow (pointer) semantics. ">referenceAssign()</a> to make a handle refer to an existing implementation rather than creating a new copy. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9" title="&quot;Copy&quot; assignment but with shallow (pointer) semantics. ">referenceAssign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a46a485a9ef857781b8029ffd829fa636"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::clearHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this an empty handle, deleting the implementation object if this handle is the owner of it. </p>
<p>A call to <a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f" title="Returns true if this handle is empty, that is, does not refer to any implementation object...">isEmptyHandle()</a> will return true after this. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f" title="Returns true if this handle is empty, that is, does not refer to any implementation object...">isEmptyHandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66906a41755f8dae64f3bd945b949c74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IMPL&amp; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::getImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the implementation associated with this Handle. </p>
<p>This will throw an exception if there is no implementation. </p>

</div>
</div>
<a class="anchor" id="a3cea00ca400bace6ccb795e5ba54d4ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL, bool PTR = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMPL&amp; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::updImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable reference to the implementation associated with this Handle. </p>
<p>Note that this requires writable access to the handle also. This will throw an exception if there is no implementation. </p>

</div>
</div>
<a class="anchor" id="a0e940afd133cc244c156b54a177529bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL , bool PTR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::getImplHandleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of handles the implementation believes are referencing it. </p>
<p>Throws an exception if there is no implementation. This is for degugging and consistency checking and shouldn't normally be used. </p>

</div>
</div>
<a class="anchor" id="a39c83a6a5f2b7fb96834981442d30f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL , bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt; &amp; <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer sematics" (PTR=true) or "object (value) semantics" (PTR=false, default) class. </p>
<p>In the case of a pointer semantics class, an owner handle can <em>not</em> be the target of an assignment. You can call <a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae" title="This is real copy assignment, with ordinary C++ object (&quot;value&quot;) semantics. ">copyAssign()</a> directly if you want to make a fresh copy of the source, or you can clear this handle first with <a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636" title="Make this an empty handle, deleting the implementation object if this handle is the owner of it...">clearHandle()</a> and then use <a class="el" href="classSimTK_1_1PIMPLHandle.html#a39c83a6a5f2b7fb96834981442d30f8d" title="Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the sup...">operator=()</a> or <a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9" title="&quot;Copy&quot; assignment but with shallow (pointer) semantics. ">referenceAssign()</a> to turn this handle into a mere reference to the source. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9" title="&quot;Copy&quot; assignment but with shallow (pointer) semantics. ">referenceAssign</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae" title="This is real copy assignment, with ordinary C++ object (&quot;value&quot;) semantics. ">copyAssign</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59892732781a567f4ad30b982acb2c27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE , class IMPL, bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::setImpl </td>
          <td>(</td>
          <td class="paramtype">IMPL *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the implementation for this empty handle. </p>
<p>This may result in either an owner or reference handle, depending on the owner handle reference stored in the implementation object. This will throw an exception if the handle is already occupied; it <em>cannot</em> be used to replace one implementation with another. </p>

</div>
</div>
<a class="anchor" id="a3666ec4c8e626e771aa5d058605fa840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HANDLE, class IMPL , bool PTR&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle</a>&lt; HANDLE, IMPL, PTR &gt;::hasSameImplementation </td>
          <td>(</td>
          <td class="paramtype">const HANDLE &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the supplied handle is a reference to the same implementation object as is referenced by "this" <a class="el" href="classSimTK_1_1PIMPLHandle.html" title="This class provides some infrastructure useful in making SimTK Private Implementation (PIMPL) classes...">PIMPLHandle</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="PrivateImplementation_8h_source.html">PrivateImplementation.h</a></li>
<li><a class="el" href="PrivateImplementation__Defs_8h_source.html">PrivateImplementation_Defs.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:22 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
