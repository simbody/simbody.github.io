<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Xml Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Xml.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Xml-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Xml Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides a minimalist capability for reading and writing XML documents, as files or strings.  
 <a href="classSimTK_1_1Xml.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elements can have attributes, which are name="value" pairs that appear within the element start tag in an XML document; this class represents the in-memory representation of one of those attributes and can be used to examine or modify the name or value.  <a href="classSimTK_1_1Xml_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes within an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, for writable access.  <a href="classSimTK_1_1Xml_1_1attribute__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Comment.html">Comment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comment contains only uninterpreted text.  <a href="classSimTK_1_1Xml_1_1Comment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes.  <a href="classSimTK_1_1Xml_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a bidirectional iterator suitable for moving forward or backward within a list of <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes, for writable access.  <a href="classSimTK_1_1Xml_1_1element__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract handle for holding any kind of node in an XML tree.  <a href="classSimTK_1_1Xml_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes, for writable access.  <a href="classSimTK_1_1Xml_1_1node__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Text.html">Text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the "leaf" content of an element.  <a href="classSimTK_1_1Xml_1_1Text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Unknown.html">Unknown</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is something we don't understand but can carry around.  <a href="classSimTK_1_1Xml_1_1Unknown.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7a166f7c2fb7f77beb467f74b3f766bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> { <br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca1ac71fe4a533a82860b70f93cb690a73">NoNode</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9e989384ca13f6904a03508b95daca5e">ElementNode</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcafa3611893e7ad0de926231eca098bba1">TextNode</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcac9c4cd9ab6736ab5bf6f18b751109727">CommentNode</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bcac9b7672fa07db7c0f3890080f6ff8832">UnknownNode</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9cd1e2482a4f2d4c2cb78a8ae0a93cca">NoJunkNodes</a> = ElementNode|TextNode, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3745575a8cd6e85844d07f37be7e17e6">JunkNodes</a> = CommentNode|UnknownNode, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a> = NoJunkNodes|JunkNodes
<br />
 }<tr class="memdesc:a7a166f7c2fb7f77beb467f74b3f766bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NodeType enum serves as the actual type of a node and as a filter for allowable node types during an iteration over nodes.  <a href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7a166f7c2fb7f77beb467f74b3f766bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdb969e738738b79de0e31825ac8a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1Xml.html">Xml</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Document</a></td></tr>
<tr class="memdesc:a0fcdb969e738738b79de0e31825ac8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef allows <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to be used as the type of the document which is more conventional than using just <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a>, and provides future compatibility should we decide to upgrade <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to a class.  <a href="#a0fcdb969e738738b79de0e31825ac8a8">More...</a><br /></td></tr>
<tr class="separator:a0fcdb969e738738b79de0e31825ac8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can start with an empty <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> or initialize it from a file.</p>
</div></td></tr>
<tr class="memitem:abbe5a3ed6b8ff412ce2e36ff9b0d9bf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8">Xml</a> ()</td></tr>
<tr class="memdesc:abbe5a3ed6b8ff412ce2e36ff9b0d9bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty XML Document with default declaration and default root element with tag "_Root". (You should invoke this as <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document()</a> instead of just <a class="el" href="classSimTK_1_1Xml.html#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8" title="Create an empty XML Document with default declaration and default root element with tag &quot;_Root&quot;...">Xml()</a>.)  <a href="#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8">More...</a><br /></td></tr>
<tr class="separator:abbe5a3ed6b8ff412ce2e36ff9b0d9bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697125e016291a73196fc426fb23b66d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a697125e016291a73196fc426fb23b66d">Xml</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:a697125e016291a73196fc426fb23b66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new XML document and initialize it from the contents of the given file name. (You should invoke this as <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document()</a> instead of just <a class="el" href="classSimTK_1_1Xml.html#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8" title="Create an empty XML Document with default declaration and default root element with tag &quot;_Root&quot;...">Xml()</a>.)  <a href="#a697125e016291a73196fc426fb23b66d">More...</a><br /></td></tr>
<tr class="separator:a697125e016291a73196fc426fb23b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ea14faa1957fabf892b5796ae55c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a207ea14faa1957fabf892b5796ae55c9">Xml</a> (const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;source)</td></tr>
<tr class="memdesc:a207ea14faa1957fabf892b5796ae55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor makes a deep copy of the entire source document; nothing is shared between the source and the copy.  <a href="#a207ea14faa1957fabf892b5796ae55c9">More...</a><br /></td></tr>
<tr class="separator:a207ea14faa1957fabf892b5796ae55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494c2cafb8ba3000141b1d19171a344b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a494c2cafb8ba3000141b1d19171a344b">operator=</a> (const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;souce)</td></tr>
<tr class="memdesc:a494c2cafb8ba3000141b1d19171a344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment frees all heap space associated with the current <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> and then makes a deep copy of the source document; nothing is shared between the source and the copy.  <a href="#a494c2cafb8ba3000141b1d19171a344b">More...</a><br /></td></tr>
<tr class="separator:a494c2cafb8ba3000141b1d19171a344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a5c4dff53014486815bea5842dedc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a62a5c4dff53014486815bea5842dedc8">~Xml</a> ()</td></tr>
<tr class="memdesc:a62a5c4dff53014486815bea5842dedc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor cleans up all heap space associated with this document.  <a href="#a62a5c4dff53014486815bea5842dedc8">More...</a><br /></td></tr>
<tr class="separator:a62a5c4dff53014486815bea5842dedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae881ca3f2a8a980c745b724415700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#acbae881ca3f2a8a980c745b724415700">clear</a> ()</td></tr>
<tr class="memdesc:acbae881ca3f2a8a980c745b724415700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore this document to its default-constructed state.  <a href="#acbae881ca3f2a8a980c745b724415700">More...</a><br /></td></tr>
<tr class="separator:acbae881ca3f2a8a980c745b724415700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Top-level node manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide access to the top-level nodes, that is, those that are directly owned by the <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>.</p>
<p><a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> and <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> nodes are allowed anywhere at the top level, but <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes are not allowed and there is just one distinguished <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node, the root element. If you want to add <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> or <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes, add them to the root element rather than at the document level. </p>
</div></td></tr>
<tr class="memitem:af658576e98e402f8c8b02fd7a9bfade1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#af658576e98e402f8c8b02fd7a9bfade1">getRootElement</a> ()</td></tr>
<tr class="memdesc:af658576e98e402f8c8b02fd7a9bfade1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle referencing the top-level element in this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>, known as the "root element".  <a href="#af658576e98e402f8c8b02fd7a9bfade1">More...</a><br /></td></tr>
<tr class="separator:af658576e98e402f8c8b02fd7a9bfade1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b8b2b41c70f56892e87df3171d3788"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a78b8b2b41c70f56892e87df3171d3788">getRootTag</a> () const </td></tr>
<tr class="memdesc:a78b8b2b41c70f56892e87df3171d3788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for getting the tag word of the root element which is usually the document type.  <a href="#a78b8b2b41c70f56892e87df3171d3788">More...</a><br /></td></tr>
<tr class="separator:a78b8b2b41c70f56892e87df3171d3788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fade2e1c78914b098bb426190801ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a1fade2e1c78914b098bb426190801ef0">setRootTag</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a1fade2e1c78914b098bb426190801ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for changing the tag word of the root element which is usually the document type.  <a href="#a1fade2e1c78914b098bb426190801ef0">More...</a><br /></td></tr>
<tr class="separator:a1fade2e1c78914b098bb426190801ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e64a15d8bb3de04580054a377411c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a1e64a15d8bb3de04580054a377411c97">insertTopLevelNodeAfter</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;afterThis, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> insertThis)</td></tr>
<tr class="memdesc:a1e64a15d8bb3de04580054a377411c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node just <em>after</em> the location indicated by the <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>, or at the end of the list if the iterator is <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a>.  <a href="#a1e64a15d8bb3de04580054a377411c97">More...</a><br /></td></tr>
<tr class="separator:a1e64a15d8bb3de04580054a377411c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20a9fa8b105a5240e84a25d87e090b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#ae20a9fa8b105a5240e84a25d87e090b2">insertTopLevelNodeBefore</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;beforeThis, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> insertThis)</td></tr>
<tr class="memdesc:ae20a9fa8b105a5240e84a25d87e090b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node just <em>before</em> the location indicated by the <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>.  <a href="#ae20a9fa8b105a5240e84a25d87e090b2">More...</a><br /></td></tr>
<tr class="separator:ae20a9fa8b105a5240e84a25d87e090b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0228f501f4b48a1f8effe50b6f1af9eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a0228f501f4b48a1f8effe50b6f1af9eb">eraseTopLevelNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;deleteThis)</td></tr>
<tr class="memdesc:a0228f501f4b48a1f8effe50b6f1af9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated top-level node, which must not be the root element, and must not be <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a>.  <a href="#a0228f501f4b48a1f8effe50b6f1af9eb">More...</a><br /></td></tr>
<tr class="separator:a0228f501f4b48a1f8effe50b6f1af9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8336e611dccdc7501ae7d66863f8eb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a8336e611dccdc7501ae7d66863f8eb02">removeTopLevelNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;removeThis)</td></tr>
<tr class="memdesc:a8336e611dccdc7501ae7d66863f8eb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated top-level node from the document, returning it as an orphan rather than erasing it.  <a href="#a8336e611dccdc7501ae7d66863f8eb02">More...</a><br /></td></tr>
<tr class="separator:a8336e611dccdc7501ae7d66863f8eb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iteration through top-level nodes (rarely used)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If you want to run through this document's top-level nodes (of which the "root element" is one), these methods provide begin and end iterators.</p>
<p>By default you'll see all the nodes (types <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a>, <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a>, and the lone top-level <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>) but you can restrict the node types that you'll see via the NodeType mask. Iteration is rarely used at this top level since you almost never care about about the <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> and <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> nodes here and you can get to the root element directly using <a class="el" href="classSimTK_1_1Xml.html#af658576e98e402f8c8b02fd7a9bfade1" title="Return an Element handle referencing the top-level element in this Xml::Document, known as the &quot;root ...">getRootElement()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#af658576e98e402f8c8b02fd7a9bfade1" title="Return an Element handle referencing the top-level element in this Xml::Document, known as the &quot;root ...">getRootElement()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:aa9781ee20875a317341495a4cabe944a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#aa9781ee20875a317341495a4cabe944a">node_begin</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr class="memdesc:aa9781ee20875a317341495a4cabe944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an iterator to all the top-level nodes or a subset restricted via the <em>allowed</em> NodeType mask.  <a href="#aa9781ee20875a317341495a4cabe944a">More...</a><br /></td></tr>
<tr class="separator:aa9781ee20875a317341495a4cabe944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6562804e39c61cbc3e307cc686c6d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8">node_end</a> () const </td></tr>
<tr class="memdesc:a4a6562804e39c61cbc3e307cc686c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a> iterator indicates the end of a sequence of nodes regardless of the NodeType restriction on the iterator being used.  <a href="#a4a6562804e39c61cbc3e307cc686c6d8">More...</a><br /></td></tr>
<tr class="separator:a4a6562804e39c61cbc3e307cc686c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">XML Declaration attributes (rarely used)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods deal with the mysterious XML "declaration" line that comes at the beginning of every XML document; that is the line that begins with "&lt;?xml" and ends with "?&gt;".</p>
<p>There are at most three of these attributes and they have well-defined names that are always the same (default values shown):</p><ul>
<li><em>version</em> = "1.0": to what version of the XML standard does this document adhere?</li>
<li><em>encoding</em> = "UTF-8": what Unicode encoding is used to represent the character in this document? Typically this is UTF-8, an 8-bit encoding in which the first 128 codes match standard ASCII but where other characters are represented in variable-length multibyte sequences.</li>
<li><em>standalone</em> = "yes": can this document be correctly parsed without consulting other documents?</li>
</ul>
<p>You can examine and change these attributes with the methods in this section, however unless you really know what you're doing you should just leave the declaration alone; you'll get reasonable behavior automatically. </p>
</div></td></tr>
<tr class="memitem:adcd72cab6e8402e36082e3bd20af8b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#adcd72cab6e8402e36082e3bd20af8b12">getXmlVersion</a> () const </td></tr>
<tr class="memdesc:adcd72cab6e8402e36082e3bd20af8b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "version" attribute as a string (from the declaration line at the beginning of the document).  <a href="#adcd72cab6e8402e36082e3bd20af8b12">More...</a><br /></td></tr>
<tr class="separator:adcd72cab6e8402e36082e3bd20af8b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d5c318bef02efa5e9138103adb4f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#ae1d5c318bef02efa5e9138103adb4f4e">getXmlEncoding</a> () const </td></tr>
<tr class="memdesc:ae1d5c318bef02efa5e9138103adb4f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "encoding" attribute as a string (from the declaration line at the beginning of the document).  <a href="#ae1d5c318bef02efa5e9138103adb4f4e">More...</a><br /></td></tr>
<tr class="separator:ae1d5c318bef02efa5e9138103adb4f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416af3af667e4bc51e51f90fbe851f89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a416af3af667e4bc51e51f90fbe851f89">getXmlIsStandalone</a> () const </td></tr>
<tr class="memdesc:a416af3af667e4bc51e51f90fbe851f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "standalone" attribute as a bool (from the declaration line at the beginning of the document); default is true ("yes" in a file), meaning that the document can be parsed correctly without any other documents.  <a href="#a416af3af667e4bc51e51f90fbe851f89">More...</a><br /></td></tr>
<tr class="separator:a416af3af667e4bc51e51f90fbe851f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc538adac36b233cc14c400f9a21ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a84fc538adac36b233cc14c400f9a21ca">setXmlVersion</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;version)</td></tr>
<tr class="memdesc:a84fc538adac36b233cc14c400f9a21ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "version" attribute; this will be written to the "declaration" line which is first in any <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document.  <a href="#a84fc538adac36b233cc14c400f9a21ca">More...</a><br /></td></tr>
<tr class="separator:a84fc538adac36b233cc14c400f9a21ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c9ed30b36f9f4cd7891493917b74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#aec4c9ed30b36f9f4cd7891493917b74a">setXmlEncoding</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;encoding)</td></tr>
<tr class="memdesc:aec4c9ed30b36f9f4cd7891493917b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "encoding" attribute; this doesn't affect the in-memory representation but can affect how the document gets written out.  <a href="#aec4c9ed30b36f9f4cd7891493917b74a">More...</a><br /></td></tr>
<tr class="separator:aec4c9ed30b36f9f4cd7891493917b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bba1c25bc97cc49daa43f912af883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a100bba1c25bc97cc49daa43f912af883">setXmlIsStandalone</a> (bool isStandalone)</td></tr>
<tr class="memdesc:a100bba1c25bc97cc49daa43f912af883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "standalone" attribute; this is normally true (corresponding to standalone="yes") and won't appear in the declaration line in that case when we write it out.  <a href="#a100bba1c25bc97cc49daa43f912af883">More...</a><br /></td></tr>
<tr class="separator:a100bba1c25bc97cc49daa43f912af883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aadf2186f772655f244a5fe116dc126a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#aadf2186f772655f244a5fe116dc126a0">getNodeTypeAsString</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> type)</td></tr>
<tr class="memdesc:aadf2186f772655f244a5fe116dc126a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a NodeType to a human-readable string.  <a href="#aadf2186f772655f244a5fe116dc126a0">More...</a><br /></td></tr>
<tr class="separator:aadf2186f772655f244a5fe116dc126a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a6db9d28bd448a131448276ee03de1e6d">Node</a></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:adeed202918b23025e38c1219d176d312"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#adeed202918b23025e38c1219d176d312">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;doc)</td></tr>
<tr class="memdesc:adeed202918b23025e38c1219d176d312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a "pretty printed" textual representation of the given <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to an std::ostream, using the document's current indent string for formatting.  <a href="#adeed202918b23025e38c1219d176d312">More...</a><br /></td></tr>
<tr class="separator:adeed202918b23025e38c1219d176d312"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Serializing and I/O</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd64947c2b196aeed267b4dd8425723ea"></a>These methods deal with conversion to and from the in-memory representation of the XML document from and to files and strings.</p>
</td></tr>
<tr class="memitem:a108f40e6cfcb9e942681f9d576048a6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a108f40e6cfcb9e942681f9d576048a6f">setXmlCondenseWhiteSpace</a> (bool shouldCondense)</td></tr>
<tr class="memdesc:a108f40e6cfcb9e942681f9d576048a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global mode to control whether white space is preserved or condensed down to a single space (affects all subsequent document reads; not document specific).  <a href="#a108f40e6cfcb9e942681f9d576048a6f">More...</a><br /></td></tr>
<tr class="separator:a108f40e6cfcb9e942681f9d576048a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a4a8485a23f2095e2f3dfef2fad98b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#ab2a4a8485a23f2095e2f3dfef2fad98b">isXmlWhiteSpaceCondensed</a> ()</td></tr>
<tr class="memdesc:ab2a4a8485a23f2095e2f3dfef2fad98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current setting of the global "condense white space" option.  <a href="#ab2a4a8485a23f2095e2f3dfef2fad98b">More...</a><br /></td></tr>
<tr class="separator:ab2a4a8485a23f2095e2f3dfef2fad98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d072eaf38e8c34bd135416ef599120"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#af4d072eaf38e8c34bd135416ef599120">readFromFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname)</td></tr>
<tr class="memdesc:af4d072eaf38e8c34bd135416ef599120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> from the file whose pathname is supplied.  <a href="#af4d072eaf38e8c34bd135416ef599120">More...</a><br /></td></tr>
<tr class="separator:af4d072eaf38e8c34bd135416ef599120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82553cd8e89212779343ca40f813ce57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a82553cd8e89212779343ca40f813ce57">writeToFile</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;pathname) const </td></tr>
<tr class="memdesc:a82553cd8e89212779343ca40f813ce57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of this in-memory <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to the file whose pathname is supplied.  <a href="#a82553cd8e89212779343ca40f813ce57">More...</a><br /></td></tr>
<tr class="separator:a82553cd8e89212779343ca40f813ce57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca19a1616e62cb50c86ccd7bc59d385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a6ca19a1616e62cb50c86ccd7bc59d385">readFromString</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;xmlDocument)</td></tr>
<tr class="memdesc:a6ca19a1616e62cb50c86ccd7bc59d385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> from the supplied string.  <a href="#a6ca19a1616e62cb50c86ccd7bc59d385">More...</a><br /></td></tr>
<tr class="separator:a6ca19a1616e62cb50c86ccd7bc59d385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d1b567ba88a5f490e02e9f02d2469f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a42d1b567ba88a5f490e02e9f02d2469f">readFromString</a> (const char *xmlDocument)</td></tr>
<tr class="memdesc:a42d1b567ba88a5f490e02e9f02d2469f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate form that reads from a null-terminated C string (char*) rather than a C++ string object.  <a href="#a42d1b567ba88a5f490e02e9f02d2469f">More...</a><br /></td></tr>
<tr class="separator:a42d1b567ba88a5f490e02e9f02d2469f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f93ae9b285db17fb8cfdc04d24fc6de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a9f93ae9b285db17fb8cfdc04d24fc6de">writeToString</a> (<a class="el" href="classSimTK_1_1String.html">String</a> &amp;xmlDocument, bool compact=false) const </td></tr>
<tr class="memdesc:a9f93ae9b285db17fb8cfdc04d24fc6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of this in-memory <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to the supplied string.  <a href="#a9f93ae9b285db17fb8cfdc04d24fc6de">More...</a><br /></td></tr>
<tr class="separator:a9f93ae9b285db17fb8cfdc04d24fc6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55d97926c7feba70324d0154c3ea39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a9e55d97926c7feba70324d0154c3ea39">setIndentString</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;indent)</td></tr>
<tr class="memdesc:a9e55d97926c7feba70324d0154c3ea39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the string to be used for indentation when we produce a "pretty-printed" serialized form of this document. The default is to use four spaces for each level of indentation.  <a href="#a9e55d97926c7feba70324d0154c3ea39">More...</a><br /></td></tr>
<tr class="separator:a9e55d97926c7feba70324d0154c3ea39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7538e2ed9c571f3659df6da03f56abf9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml.html#a7538e2ed9c571f3659df6da03f56abf9">getIndentString</a> () const </td></tr>
<tr class="memdesc:a7538e2ed9c571f3659df6da03f56abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current value of the indent string. The default is four spaces.  <a href="#a7538e2ed9c571f3659df6da03f56abf9">More...</a><br /></td></tr>
<tr class="separator:a7538e2ed9c571f3659df6da03f56abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a minimalist capability for reading and writing XML documents, as files or strings. </p>
<p>This is based with gratitude on the excellent open source XML parser TinyXML (<a href="http://www.grinninglizard.com/tinyxml/">http://www.grinninglizard.com/tinyxml/</a>). Note that this is a <em>non-validating</em> parser, meaning it deals only with the XML file itself and not with a Document Type Definition (DTD), XML Schema, or any other description of the XML file's expected contents. Instead, the structure of your code that uses this class encodes the expected structure and contents of the XML document.</p>
<p>Our in-memory model of an XML document is simplified even further than TinyXML's. There a lot to know about XML; you could start here: <a href="http://en.wikipedia.org/wiki/XML">http://en.wikipedia.org/wiki/XML</a>. However, everything you need to know in order to read and write XML documents with the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">SimTK::Xml</a> class is described below.</p>
<p>Much of the detailed documention is in the class <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>; be sure to look there as well as at this overview.</p>
<h2>Our in-memory model of an XML document</h2>
<p>We consider an XML document to be a tree of "Nodes". There are only four types of nodes: Comments, Unknowns, Text, and Elements. Only Elements can contain <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> and other nodes, including recursively child <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes. Elements can also have "Attributes" which are name:value pairs (not nodes).</p>
<p>The XML document as a whole is represented by an object of class <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>. The <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> object directly contains a short list of nodes, consisting only of Comments, Unknowns, and a single Element called the "root element". The tag word associated with the root element is called the "root tag" and conventionally identifies the kind of document this is. For example, XML files produced by VTK begin with a root tag "&lt;VTKFile&gt;".</p>
<p>We go to some pain to make sure every <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> fits the above model so that you don't have to think about anything else. For example, if the file as read in has multiple root-level elements, or has document-level text, we will enclose all the element and text nodes within document start tag "&lt;_Root&gt;" and end tag "&lt;/_Root&gt;" thus making it fit the description above. We call this "canonicalizing" the document.</p>
<h3>Value Elements</h3>
<p><a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes can be classified into "value elements" and "compound
elements". A value element is a "leaf" element (no child elements) that contains at most one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node. For example, a document might contain value elements like these: </p><div class="fragment"><div class="line">&lt;name&gt;John Doe&lt;/name&gt;</div><div class="line">&lt;rating&gt;7.2&lt;/rating&gt;</div><div class="line">&lt;winnings currency=euro&gt;3429&lt;/winnings&gt;</div><div class="line">&lt;preferences/&gt;</div><div class="line">&lt;vector&gt;1.2 -4 2e-3&lt;/vector&gt;</div></div><!-- fragment --><p> All of these have a unique value so it makes sense to talk about "the" value of these elements (the empty "preferences" element has a null value). These are very common in XML documents, and the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a> class makes them very easy to work with. For example, if <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> elt is the "&lt;vector&gt;" element from the example, you could retrieve its value as a Vec3 like this: </p><div class="fragment"><div class="line"><a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> v = elt.getValueAs&lt;<a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;(); </div></div><!-- fragment --><p> This would automatically throw an error if the element wasn't a value element or if its value didn't have the right format to convert to a Vec3.</p>
<p>Note that it is okay for a value element to have attributes; those are ignored in determining the element's value. Any element that is not a value element is a "compound element", meaning it has either child elements and/or more than one Text node.</p>
<h2>Reading an XML document</h2>
<p>To read an XML document, you create an <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> object and tell it to read in the document from a file or from a string. The document will be parsed and canonicalized into the in-memory model described above. Then to rummage around in the document, you ask the <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> object for its root element, and check the root tag to see that it is the type of document you are expecting. You can check the root element's attributes, and then process its contents (child nodes). Iterators are provided for running through all the attributes, all the child nodes contained in the element, or all the child nodes of a particular type. For a child node that is an element, you check the tag and then pass the element to some piece of code that knows how to deal with that kind of element and its children recursively.</p>
<p>Here is a complete example of reading in an <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> file "example.xml", printing the root tag and then the types of all the document-level nodes, in STL iterator style: </p><div class="fragment"><div class="line"><a class="code" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> doc(<span class="stringliteral">&quot;example.xml&quot;</span>);</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Root tag: &quot;</span> &lt;&lt; ex.getRootTag() &lt;&lt; endl;</div><div class="line"><span class="keywordflow">for</span> (Xml::node_iterator p=doc.node_begin(); p != doc.node_end(); ++p)</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Node type: &quot;</span> &lt;&lt; p-&gt;getNodeTypeAsString() &lt;&lt; endl;</div></div><!-- fragment --><p> Exactly one of the above nodes will have type "ElementNode"; that is the root element. To print out the types of nodes contained in the root element, you could write: </p><div class="fragment"><div class="line">Xml::Element root = ex.getRootElement();</div><div class="line"><span class="keywordflow">for</span> (Xml::node_iterator p=root.node_begin(); p != root.node_end(); ++p)</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Node type: &quot;</span> &lt;&lt; p-&gt;getNodeTypeAsString() &lt;&lt; endl;</div></div><!-- fragment --><p>(Some confessions: despite appearances, "Xml" is not a namespace, it is a class with the other <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> classes being internal classes of <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a>. An object of type <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> is an XML document; the name <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> is a typedef synonymous with <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a>.)</p>
<h2>Writing an XML document</h2>
<p>You can insert, remove, and modify nodes and attributes in a document, or create a document from scratch. Then you can write the results in a "pretty-printed" or compact format to a file or a string; for pretty-printing you can override the default indentation string (four spaces). Whenever we write an XML document, we write it in canoncial format, regardless of how it looked when we found it.</p>
<p>At the document level, you can only insert <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> and <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> nodes. <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> and <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> nodes can be inserted only at the root element level and below.</p>
<h2>Details about XML</h2>
<p>This section provides detailed information about the syntax of XML files as we accept and produce them. You won't have to know these details to read and write XML files using the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">SimTK::Xml</a> class, but you may find this helpful for when you have to look at an XML file in a text editor.</p>
<h3>Lexical elements</h3>
<p>(Ignore the quote characters below; those are present so I can get this text through Doxygen.)</p><ul>
<li>An XML document is a string of Unicode characters; all metadata is case sensitive.</li>
<li>The file begins with a "declaration" tag beginning with "&lt;?xml" and ending with "?&gt;"</li>
<li>Comments look like this: "&lt;!--" <em>anything</em> "--&gt;"</li>
<li>The characters in an XML file represent <em>markup</em> and <em>content</em> </li>
<li>Markup consists of "tags" delimited by "&lt;" and "&gt;", <em>attributes</em> denoted by <em>name="value"</em>, and character escapes delimited by "&amp;" and ";".</li>
<li>Tags come in three flavors: <em>start</em> tags like "&lt;word&gt;", <em>end</em> tags like "&lt;/word&gt;" and <em>empty element</em> tags like "&lt;word/&gt;". Tag words must begin with a letter or an underscore and are case sensitive; "xml" is reserved; don't use it.</li>
<li>Attributes are recognized only in start tags, empty element tags, and declaration tags. In standard XML the value must be quoted with single or double quotes, but we'll supply missing quotes if there are none. <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> names are case sensitive and must be unique within a tag; but if we see duplicates we'll just ignore all but the last.</li>
<li>There are five pre-defined escapes: "&amp;lt;" and "&amp;gt;" representing "&lt;" and "&gt;", "&amp;amp;" for ampersand, "&amp;apos;" for apostrophe (single quote) and "&amp;quot;" for double quote.</li>
<li>There are also "numeric character reference" escapes of the form "&amp;#nnnnn;" (decimal) or "&amp;#xnnnn;" (hex), with only as many digits as needed.</li>
<li>Text set off by "&lt;![CDATA[" and "]]&gt;" is interpreted as a raw byte stream.</li>
<li>Tags that begin "&lt;x" where x is not a letter or underscore and isn't one of the above recognized patterns will be passed through uninterpreted.</li>
<li>Anything else is Unicode text.</li>
</ul>
<h3>File structure</h3>
<p>An XML file contains a single <em>document</em> which consists at the top level of</p><ul>
<li>a declaration</li>
<li>comments and unknowns</li>
<li>a root element</li>
<li>more comments and unknowns</li>
</ul>
<p>Elements can be containers of other nodes and are thus the basis for the tree structure of XML files. Elements can contain:</p><ul>
<li>comments</li>
<li>unknowns</li>
<li>text</li>
<li>child elements, recursively</li>
<li>attributes</li>
</ul>
<p>A declaration (see below) also has attributes, but there are only three: version, encoding, and standalone ('yes' or 'no'). Unknowns are constructs found in the file that are not recognized; they might be errors but they are likely to be more sophisticated uses of XML that our feeble parser doesn't understand. Unknowns are tags where the tag word doesn't begin with a letter or underscore and isn't one of the very few other tags we recognize, like comments. As an example, a DTD tag like this would come through as an <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node here: </p><div class="fragment"><div class="line">&lt;!DOCTYPE note SYSTEM <span class="stringliteral">&quot;Note.dtd&quot;</span>&gt;</div></div><!-- fragment --><p>Here is the top-level structure we expect of a well-formed XML document, and we will impose this structure on XML documents that don't have it. This allows us to simplify the in-memory model as discussed above. </p><div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div><div class="line">&lt;!-- maybe comments and unknowns --&gt;</div><div class="line">&lt;roottag attr=value ... &gt;</div><div class="line">    ... contents ...</div><div class="line">&lt;/roottag&gt;</div><div class="line">&lt;!-- maybe comments and unknowns --&gt;</div></div><!-- fragment --><p> That is, the first line should be a declaration, most commonly exactly the characters shown above, without the "standalone" attribute which will default to "yes". If we don't see a declaration when reading an XML document, we'll assume we read the one above. Then the document should contain exactly one root element representing the type of document and document-level attributes. The tag for the root element is not literally "roottag" but some name that makes sense for the given document. Note that the root element is an ordinary element so "contents" can contain text and child elements (as well as comments and unknowns).</p>
<p>When reading an XML document, if it has exactly one document-level element and no document-level text, we'll take the document as-is. If there is more than one document-level element, or we find some document-level text, we'll assume that the root element is missing and act as though we had seen a root element "&lt;_Root&gt;" at the beginning and "&lt;/_Root&gt;" at the end so the root tag will be "_Root". Note that this means that we will interpret even a plain text file as a well-formed XML document: </p><div class="fragment"><div class="line">A file consisting            &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span> ?&gt;</div><div class="line">of just text         ==&gt;     &lt;_Root&gt;</div><div class="line">like this.                   A file consisting of just text like this.</div><div class="line">                             &lt;/_Root&gt;</div></div><!-- fragment --><p> The above XML document has a single document-level element and that element contains one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node whose value is the original text.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Xml::Element</a>, <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Xml::Node</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0fcdb969e738738b79de0e31825ac8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1Xml.html">Xml</a> <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">SimTK::Xml::Document</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef allows <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to be used as the type of the document which is more conventional than using just <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a>, and provides future compatibility should we decide to upgrade <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to a class. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">SimTK::Xml::NodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The NodeType enum serves as the actual type of a node and as a filter for allowable node types during an iteration over nodes. </p>
<p>We consider <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes to be meaningful, while <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> and <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> nodes are meaningless junk. However, you are free to extract some meaning from them if you know how. In particular, DTD nodes end up as <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bca1ac71fe4a533a82860b70f93cb690a73"></a>NoNode&#160;</td><td class="fielddoc">
<p>Type of empty <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle, or null filter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bca9e989384ca13f6904a03508b95daca5e"></a>ElementNode&#160;</td><td class="fielddoc">
<p><a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node type and only-Elements filter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bcafa3611893e7ad0de926231eca098bba1"></a>TextNode&#160;</td><td class="fielddoc">
<p><a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node type and only-Text nodes filter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bcac9c4cd9ab6736ab5bf6f18b751109727"></a>CommentNode&#160;</td><td class="fielddoc">
<p><a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> node type and only-Comments filter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bcac9b7672fa07db7c0f3890080f6ff8832"></a>UnknownNode&#160;</td><td class="fielddoc">
<p><a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node type and only-Unknowns filter. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bca9cd1e2482a4f2d4c2cb78a8ae0a93cca"></a>NoJunkNodes&#160;</td><td class="fielddoc">
<p>Filter out meaningless nodes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bca3745575a8cd6e85844d07f37be7e17e6"></a>JunkNodes&#160;</td><td class="fielddoc">
<p>Filter out meaningful nodes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0"></a>AnyNodes&#160;</td><td class="fielddoc">
<p>Allow all nodes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abbe5a3ed6b8ff412ce2e36ff9b0d9bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Xml </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty XML Document with default declaration and default root element with tag "_Root". (You should invoke this as <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document()</a> instead of just <a class="el" href="classSimTK_1_1Xml.html#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8" title="Create an empty XML Document with default declaration and default root element with tag &quot;_Root&quot;...">Xml()</a>.) </p>
<p>If you were to print out this document now you would see: </p><div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span>?&gt;</div><div class="line">&lt;_Root /&gt;                                      </div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a697125e016291a73196fc426fb23b66d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Xml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new XML document and initialize it from the contents of the given file name. (You should invoke this as <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document()</a> instead of just <a class="el" href="classSimTK_1_1Xml.html#abbe5a3ed6b8ff412ce2e36ff9b0d9bf8" title="Create an empty XML Document with default declaration and default root element with tag &quot;_Root&quot;...">Xml()</a>.) </p>
<p>An exception will be thrown if the file doesn't exist or can't be parsed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#af4d072eaf38e8c34bd135416ef599120" title="Read the contents of this Xml::Document from the file whose pathname is supplied. ...">readFromFile()</a>, <a class="el" href="classSimTK_1_1Xml.html#a6ca19a1616e62cb50c86ccd7bc59d385" title="Read the contents of this Xml::Document from the supplied string. ">readFromString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a207ea14faa1957fabf892b5796ae55c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Xml </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor makes a deep copy of the entire source document; nothing is shared between the source and the copy. </p>

</div>
</div>
<a class="anchor" id="a62a5c4dff53014486815bea5842dedc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::~Xml </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor cleans up all heap space associated with this document. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aadf2186f772655f244a5fe116dc126a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::getNodeTypeAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a NodeType to a human-readable string. </p>

</div>
</div>
<a class="anchor" id="a494c2cafb8ba3000141b1d19171a344b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a>&amp; SimTK::Xml::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;&#160;</td>
          <td class="paramname"><em>souce</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment frees all heap space associated with the current <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> and then makes a deep copy of the source document; nothing is shared between the source and the copy. </p>

</div>
</div>
<a class="anchor" id="acbae881ca3f2a8a980c745b724415700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore this document to its default-constructed state. </p>

</div>
</div>
<a class="anchor" id="af4d072eaf38e8c34bd135416ef599120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::readFromFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> from the file whose pathname is supplied. </p>
<p>This first clears the current document so the new one completely replaces the old one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a6ca19a1616e62cb50c86ccd7bc59d385" title="Read the contents of this Xml::Document from the supplied string. ">readFromString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a82553cd8e89212779343ca40f813ce57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::writeToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the contents of this in-memory <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to the file whose pathname is supplied. </p>
<p>The file will be created if it doesn't exist, overwritten if it does exist. The file will be "pretty-printed" using the current indent string. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a9e55d97926c7feba70324d0154c3ea39" title="Set the string to be used for indentation when we produce a &quot;pretty-printed&quot; serialized form of this ...">setIndentString()</a>, <a class="el" href="classSimTK_1_1Xml.html#a9f93ae9b285db17fb8cfdc04d24fc6de" title="Write the contents of this in-memory Xml::Document to the supplied string. ">writeToString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ca19a1616e62cb50c86ccd7bc59d385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::readFromString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>xmlDocument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the contents of this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> from the supplied string. </p>
<p>This first clears the current document so the new one completely replaces the old one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#af4d072eaf38e8c34bd135416ef599120" title="Read the contents of this Xml::Document from the file whose pathname is supplied. ...">readFromFile()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42d1b567ba88a5f490e02e9f02d2469f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::readFromString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>xmlDocument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate form that reads from a null-terminated C string (char*) rather than a C++ string object. </p>
<p>This would otherwise be implicitly converted to string first which would require copying. </p>

</div>
</div>
<a class="anchor" id="a9f93ae9b285db17fb8cfdc04d24fc6de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::writeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>xmlDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the contents of this in-memory <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to the supplied string. </p>
<p>The string cleared first so will be completely overwritten. Normally the output is "pretty-printed" as it is for a file, but if you set <em>compact</em> to true the tabs and newlines will be suppressed to make a more compact representation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a9e55d97926c7feba70324d0154c3ea39" title="Set the string to be used for indentation when we produce a &quot;pretty-printed&quot; serialized form of this ...">setIndentString()</a>, <a class="el" href="classSimTK_1_1Xml.html#a82553cd8e89212779343ca40f813ce57" title="Write the contents of this in-memory Xml::Document to the file whose pathname is supplied. ">writeToFile()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e55d97926c7feba70324d0154c3ea39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::setIndentString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>indent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the string to be used for indentation when we produce a "pretty-printed" serialized form of this document. The default is to use four spaces for each level of indentation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a82553cd8e89212779343ca40f813ce57" title="Write the contents of this in-memory Xml::Document to the file whose pathname is supplied. ">writeToFile()</a>, <a class="el" href="classSimTK_1_1Xml.html#a9f93ae9b285db17fb8cfdc04d24fc6de" title="Write the contents of this in-memory Xml::Document to the supplied string. ">writeToString()</a>, <a class="el" href="classSimTK_1_1Xml.html#a7538e2ed9c571f3659df6da03f56abf9" title="Return the current value of the indent string. The default is four spaces. ">getIndentString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7538e2ed9c571f3659df6da03f56abf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::getIndentString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current value of the indent string. The default is four spaces. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a9e55d97926c7feba70324d0154c3ea39" title="Set the string to be used for indentation when we produce a &quot;pretty-printed&quot; serialized form of this ...">setIndentString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a108f40e6cfcb9e942681f9d576048a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::Xml::setXmlCondenseWhiteSpace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCondense</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global mode to control whether white space is preserved or condensed down to a single space (affects all subsequent document reads; not document specific). </p>
<p>The default is to condense. </p>

</div>
</div>
<a class="anchor" id="ab2a4a8485a23f2095e2f3dfef2fad98b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Xml::isXmlWhiteSpaceCondensed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current setting of the global "condense white space" option. </p>
<p>Note that this option affects all <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> reads; it is not document specific. </p>

</div>
</div>
<a class="anchor" id="af658576e98e402f8c8b02fd7a9bfade1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::getRootElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle referencing the top-level element in this <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a>, known as the "root element". </p>
<p>The tag word of this element is usually the type of document. This is the <em>only</em> top-level element; all others are its children and descendents. Once you have the root <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle, you can also use any of the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> methods to manipulate it. If you need a <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> that refers to the root element (perhaps to use one of the top-level insert methods), use <a class="el" href="classSimTK_1_1Xml.html#aa9781ee20875a317341495a4cabe944a" title="Obtain an iterator to all the top-level nodes or a subset restricted via the allowed NodeType mask...">node_begin()</a> with a NodeType filter: </p><div class="fragment"><div class="line">Xml::node_iterator rootp = <a class="code" href="classSimTK_1_1Xml.html#aa9781ee20875a317341495a4cabe944a">Xml::node_begin</a>(<a class="code" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca9e989384ca13f6904a03508b95daca5e">Xml::ElementNode</a>);</div></div><!-- fragment --><p> That works since there is only one element at this level. </p>

</div>
</div>
<a class="anchor" id="a78b8b2b41c70f56892e87df3171d3788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::getRootTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for getting the tag word of the root element which is usually the document type. </p>
<p>This is the same as <a class="el" href="classSimTK_1_1Xml.html#af658576e98e402f8c8b02fd7a9bfade1" title="Return an Element handle referencing the top-level element in this Xml::Document, known as the &quot;root ...">getRootElement()</a>.getElementTag(). </p>

</div>
</div>
<a class="anchor" id="a1fade2e1c78914b098bb426190801ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::setRootTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for changing the tag word of the root element which is usually the document type. </p>
<p>This is the same as <a class="el" href="classSimTK_1_1Xml.html#af658576e98e402f8c8b02fd7a9bfade1" title="Return an Element handle referencing the top-level element in this Xml::Document, known as the &quot;root ...">getRootElement()</a>.setElementTag(tag). </p>

</div>
</div>
<a class="anchor" id="a1e64a15d8bb3de04580054a377411c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::insertTopLevelNodeAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>afterThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>insertThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node just <em>after</em> the location indicated by the <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>, or at the end of the list if the iterator is <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a>. </p>
<p>The iterator must refer to a top-level node. The <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> takes over ownership of the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> which must be a <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node and must have been an orphan. The supplied <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle will retain a reference to the node within the document and can still be used to make changes, but will no longer by an orphan. </p>

</div>
</div>
<a class="anchor" id="ae20a9fa8b105a5240e84a25d87e090b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::insertTopLevelNodeBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>beforeThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>insertThis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node just <em>before</em> the location indicated by the <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>. </p>
<p>See <a class="el" href="classSimTK_1_1Xml.html#a1e64a15d8bb3de04580054a377411c97" title="Insert a top-level Comment or Unknown node just after the location indicated by the node_iterator...">insertTopLevelNodeAfter()</a> for details. </p>

</div>
</div>
<a class="anchor" id="a0228f501f4b48a1f8effe50b6f1af9eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::eraseTopLevelNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the indicated top-level node, which must not be the root element, and must not be <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a>. </p>
<p>That is, it must be a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node which will be removed from the <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> and deleted. The iterator is invalid after this call; be sure not to use it again. Also, there must not be any handles referencing the now-deleted node. </p>

</div>
</div>
<a class="anchor" id="a8336e611dccdc7501ae7d66863f8eb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> SimTK::Xml::removeTopLevelNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>removeThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the indicated top-level node from the document, returning it as an orphan rather than erasing it. </p>
<p>The node must not be the root element, and must not be <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a>. That is, it must be a top-level <a class="el" href="classSimTK_1_1Xml_1_1Comment.html" title="A comment contains only uninterpreted text. ">Comment</a> or <a class="el" href="classSimTK_1_1Xml_1_1Unknown.html" title="This is something we don&#39;t understand but can carry around. ">Unknown</a> node which will be removed from the <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> and returned as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>. The iterator is invalid after this call; be sure not to use it again. </p>

</div>
</div>
<a class="anchor" id="aa9781ee20875a317341495a4cabe944a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::node_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an iterator to all the top-level nodes or a subset restricted via the <em>allowed</em> NodeType mask. </p>

</div>
</div>
<a class="anchor" id="a4a6562804e39c61cbc3e307cc686c6d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::node_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml.html#a4a6562804e39c61cbc3e307cc686c6d8" title="This node_end() iterator indicates the end of a sequence of nodes regardless of the NodeType restrict...">node_end()</a> iterator indicates the end of a sequence of nodes regardless of the NodeType restriction on the iterator being used. </p>

</div>
</div>
<a class="anchor" id="adcd72cab6e8402e36082e3bd20af8b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::getXmlVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "version" attribute as a string (from the declaration line at the beginning of the document). </p>

</div>
</div>
<a class="anchor" id="ae1d5c318bef02efa5e9138103adb4f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::getXmlEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "encoding" attribute as a string (from the declaration line at the beginning of the document). </p>

</div>
</div>
<a class="anchor" id="a416af3af667e4bc51e51f90fbe851f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::getXmlIsStandalone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "standalone" attribute as a bool (from the declaration line at the beginning of the document); default is true ("yes" in a file), meaning that the document can be parsed correctly without any other documents. </p>
<p>We won't include "standalone" in the declaration line for any <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> documents we generate unless the value is false ("no" in a file). </p>

</div>
</div>
<a class="anchor" id="a84fc538adac36b233cc14c400f9a21ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::setXmlVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "version" attribute; this will be written to the "declaration" line which is first in any <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document. </p>

</div>
</div>
<a class="anchor" id="aec4c9ed30b36f9f4cd7891493917b74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::setXmlEncoding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "encoding" attribute; this doesn't affect the in-memory representation but can affect how the document gets written out. </p>

</div>
</div>
<a class="anchor" id="a100bba1c25bc97cc49daa43f912af883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::setXmlIsStandalone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isStandalone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> "standalone" attribute; this is normally true (corresponding to standalone="yes") and won't appear in the declaration line in that case when we write it out. </p>
<p>If you set this to false then standalone="no" will appear in the declaration line when it is written. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a6db9d28bd448a131448276ee03de1e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adeed202918b23025e38c1219d176d312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8">Xml::Document</a> &amp;&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output a "pretty printed" textual representation of the given <a class="el" href="classSimTK_1_1Xml.html#a0fcdb969e738738b79de0e31825ac8a8" title="This typedef allows Xml::Document to be used as the type of the document which is more conventional t...">Xml::Document</a> to an std::ostream, using the document's current indent string for formatting. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml.html#a9e55d97926c7feba70324d0154c3ea39" title="Set the string to be used for indentation when we produce a &quot;pretty-printed&quot; serialized form of this ...">Xml::setIndentString()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml.html">Xml</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:28 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
