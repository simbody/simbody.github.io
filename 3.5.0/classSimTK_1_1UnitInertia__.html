<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::UnitInertia_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1UnitInertia__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classSimTK_1_1UnitInertia__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::UnitInertia_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass.  
 <a href="classSimTK_1_1UnitInertia__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::UnitInertia_&lt; P &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1UnitInertia__.png" usemap="#SimTK::UnitInertia_5F_3C_20P_20_3E_map" alt=""/>
  <map id="SimTK::UnitInertia_5F_3C_20P_20_3E_map" name="SimTK::UnitInertia_&lt; P &gt;_map">
<area href="classSimTK_1_1Inertia__.html" title="The physical meaning of an inertia is the distribution of a rigid body&#39;s mass about a particular poin..." alt="SimTK::Inertia_&lt; P &gt;" shape="rect" coords="0,0,148,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ae99be8ef0c02a608415ac09cd4c08d9e">UnitInertia_</a> ()</td></tr>
<tr class="memdesc:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="#ae99be8ef0c02a608415ac09cd4c08d9e">More...</a><br /></td></tr>
<tr class="separator:ae99be8ef0c02a608415ac09cd4c08d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387d94e0b21d63c31abee6e38d13a3c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a387d94e0b21d63c31abee6e38d13a3c2">UnitInertia_</a> (const RealP &amp;moment)</td></tr>
<tr class="memdesc:a387d94e0b21d63c31abee6e38d13a3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix with identical diagonal elements.  <a href="#a387d94e0b21d63c31abee6e38d13a3c2">More...</a><br /></td></tr>
<tr class="separator:a387d94e0b21d63c31abee6e38d13a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428d474987b57e275010e899df64b634"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a428d474987b57e275010e899df64b634">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a428d474987b57e275010e899df64b634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="#a428d474987b57e275010e899df64b634">More...</a><br /></td></tr>
<tr class="separator:a428d474987b57e275010e899df64b634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acece1584634f71dc9d42338275358438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#acece1584634f71dc9d42338275358438">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:acece1584634f71dc9d42338275358438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal unit inertia matrix (only non-zero on diagonal).  <a href="#acece1584634f71dc9d42338275358438">More...</a><br /></td></tr>
<tr class="separator:acece1584634f71dc9d42338275358438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0c1914d9c3632de7777d1e14ccb24"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af3a0c1914d9c3632de7777d1e14ccb24">UnitInertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:af3a0c1914d9c3632de7777d1e14ccb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general unit inertia matrix.  <a href="#af3a0c1914d9c3632de7777d1e14ccb24">More...</a><br /></td></tr>
<tr class="separator:af3a0c1914d9c3632de7777d1e14ccb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e06c431d9332364cbd7a32055a452b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a2e06c431d9332364cbd7a32055a452b4">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a2e06c431d9332364cbd7a32055a452b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a symmetric 3x3 matrix.  <a href="#a2e06c431d9332364cbd7a32055a452b4">More...</a><br /></td></tr>
<tr class="separator:a2e06c431d9332364cbd7a32055a452b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd367dbd9f823d671489dca9d7f8a37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#adbd367dbd9f823d671489dca9d7f8a37">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:adbd367dbd9f823d671489dca9d7f8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia from a 3x3 symmetric matrix.  <a href="#adbd367dbd9f823d671489dca9d7f8a37">More...</a><br /></td></tr>
<tr class="separator:adbd367dbd9f823d671489dca9d7f8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917a355a7e10746a3c18683b501a60e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a917a355a7e10746a3c18683b501a60e2">UnitInertia_</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a917a355a7e10746a3c18683b501a60e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a UnitInertia matrix from an Inertia matrix.  <a href="#a917a355a7e10746a3c18683b501a60e2">More...</a><br /></td></tr>
<tr class="separator:a917a355a7e10746a3c18683b501a60e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965913951efebcc88457a3fb2309e44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a965913951efebcc88457a3fb2309e44d">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:a965913951efebcc88457a3fb2309e44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal).  <a href="#a965913951efebcc88457a3fb2309e44d">More...</a><br /></td></tr>
<tr class="separator:a965913951efebcc88457a3fb2309e44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941ff2a084bb33e57b81bb78f6792d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a941ff2a084bb33e57b81bb78f6792d8b">setUnitInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a941ff2a084bb33e57b81bb78f6792d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="#a941ff2a084bb33e57b81bb78f6792d8b">More...</a><br /></td></tr>
<tr class="separator:a941ff2a084bb33e57b81bb78f6792d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af519b525445b103c7b97bec214c28788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#af519b525445b103c7b97bec214c28788">setUnitInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:af519b525445b103c7b97bec214c28788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this UnitInertia to a general matrix.  <a href="#af519b525445b103c7b97bec214c28788">More...</a><br /></td></tr>
<tr class="separator:af519b525445b103c7b97bec214c28788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2535890d3b9e0ca3b8519d252f8cf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7">shiftToCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF) const </td></tr>
<tr class="memdesc:a9c2535890d3b9e0ca3b8519d252f8cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF.  <a href="#a9c2535890d3b9e0ca3b8519d252f8cf7">More...</a><br /></td></tr>
<tr class="separator:a9c2535890d3b9e0ca3b8519d252f8cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed">shiftToCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF)</td></tr>
<tr class="memdesc:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF.  <a href="#a86344e7cc8a70d606ba5a8c16511d4ed">More...</a><br /></td></tr>
<tr class="separator:a86344e7cc8a70d606ba5a8c16511d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f981071de25c9d3f263643b31850a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04">shiftFromCentroid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p) const </td></tr>
<tr class="memdesc:a4f981071de25c9d3f263643b31850a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid.  <a href="#a4f981071de25c9d3f263643b31850a04">More...</a><br /></td></tr>
<tr class="separator:a4f981071de25c9d3f263643b31850a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8">shiftFromCentroidInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr class="memdesc:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid.  <a href="#a9e4d4d72a9d1890c1f6a45067d5c88c8">More...</a><br /></td></tr>
<tr class="separator:a9e4d4d72a9d1890c1f6a45067d5c88c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82227844aba875e9fa4063bff68a3451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a82227844aba875e9fa4063bff68a3451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="#a82227844aba875e9fa4063bff68a3451">More...</a><br /></td></tr>
<tr class="separator:a82227844aba875e9fa4063bff68a3451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f8a4eba1df68a53839ae02025f5507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a76f8a4eba1df68a53839ae02025f5507">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a76f8a4eba1df68a53839ae02025f5507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a76f8a4eba1df68a53839ae02025f5507">More...</a><br /></td></tr>
<tr class="separator:a76f8a4eba1df68a53839ae02025f5507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b820a2338b949af9816a70343940a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4b820a2338b949af9816a70343940a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="#a4b820a2338b949af9816a70343940a07">More...</a><br /></td></tr>
<tr class="separator:a4b820a2338b949af9816a70343940a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0b740b16c447193af134d6dcfc8a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a9f0b740b16c447193af134d6dcfc8a29">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a9f0b740b16c447193af134d6dcfc8a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a9f0b740b16c447193af134d6dcfc8a29">More...</a><br /></td></tr>
<tr class="separator:a9f0b740b16c447193af134d6dcfc8a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf30c07af59a472f872e6867ef8a14df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aaf30c07af59a472f872e6867ef8a14df">operator const SymMat33P &amp;</a> () const </td></tr>
<tr class="memdesc:aaf30c07af59a472f872e6867ef8a14df"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const SymMat33.  <a href="#aaf30c07af59a472f872e6867ef8a14df">More...</a><br /></td></tr>
<tr class="separator:aaf30c07af59a472f872e6867ef8a14df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad2f3845459ee8d4a99857160b67238"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4ad2f3845459ee8d4a99857160b67238">asUnitInertia</a> () const </td></tr>
<tr class="memdesc:a4ad2f3845459ee8d4a99857160b67238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast this UnitInertia matrix as a unit inertia matrix.  <a href="#a4ad2f3845459ee8d4a99857160b67238">More...</a><br /></td></tr>
<tr class="separator:a4ad2f3845459ee8d4a99857160b67238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbd0500e52f995dd5f11639a073969d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a4fbd0500e52f995dd5f11639a073969d">setFromUnitInertia</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a4fbd0500e52f995dd5f11639a073969d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set from a unit inertia matrix.  <a href="#a4fbd0500e52f995dd5f11639a073969d">More...</a><br /></td></tr>
<tr class="separator:a4fbd0500e52f995dd5f11639a073969d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa2b329d1fc62a9c7b952d1b3c88dff71">Inertia_</a> ()</td></tr>
<tr class="memdesc:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default is a NaN-ed out mess to avoid accidents, even in Release mode.  <a href="#aa2b329d1fc62a9c7b952d1b3c88dff71">More...</a><br /></td></tr>
<tr class="separator:aa2b329d1fc62a9c7b952d1b3c88dff71 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd5c9309fe5d443af3964bd030d2f9 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a67cd5c9309fe5d443af3964bd030d2f9">Inertia_</a> (const RealP &amp;moment)</td></tr>
<tr class="memdesc:a67cd5c9309fe5d443af3964bd030d2f9 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix with identical diagonal elements, like a sphere where moment=2/5 m r^2, or a cube where moment=1/6 m s^2, with m the total mass, r the sphere's radius and s the length of a side of the cube.  <a href="#a67cd5c9309fe5d443af3964bd030d2f9">More...</a><br /></td></tr>
<tr class="separator:a67cd5c9309fe5d443af3964bd030d2f9 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e29578287d59727cfc7427d0047c88 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af3e29578287d59727cfc7427d0047c88">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass)</td></tr>
<tr class="memdesc:af3e29578287d59727cfc7427d0047c88 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point mass at a given location, measured from the origin OF of the implicit frame F, and expressed in F.  <a href="#af3e29578287d59727cfc7427d0047c88">More...</a><br /></td></tr>
<tr class="separator:af3e29578287d59727cfc7427d0047c88 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757715dbe6c947a0fee42b40899b39f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a6757715dbe6c947a0fee42b40899b39f">Inertia_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a6757715dbe6c947a0fee42b40899b39f inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals).  <a href="#a6757715dbe6c947a0fee42b40899b39f">More...</a><br /></td></tr>
<tr class="separator:a6757715dbe6c947a0fee42b40899b39f inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe875cb713abfe04736892484d7d51 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afffe875cb713abfe04736892484d7d51">Inertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:afffe875cb713abfe04736892484d7d51 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a principal inertia matrix (only non-zero on diagonal).  <a href="#afffe875cb713abfe04736892484d7d51">More...</a><br /></td></tr>
<tr class="separator:afffe875cb713abfe04736892484d7d51 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170b86e5d3b138e93108721fb598b90 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5170b86e5d3b138e93108721fb598b90">Inertia_</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:a5170b86e5d3b138e93108721fb598b90 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a general inertia matrix.  <a href="#a5170b86e5d3b138e93108721fb598b90">More...</a><br /></td></tr>
<tr class="separator:a5170b86e5d3b138e93108721fb598b90 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c68f0d0e0814fcd57eea00e5eb21234 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0c68f0d0e0814fcd57eea00e5eb21234">Inertia_</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;inertia)</td></tr>
<tr class="memdesc:a0c68f0d0e0814fcd57eea00e5eb21234 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia from a symmetric 3x3 matrix.  <a href="#a0c68f0d0e0814fcd57eea00e5eb21234">More...</a><br /></td></tr>
<tr class="separator:a0c68f0d0e0814fcd57eea00e5eb21234 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafd3401dc8ca2b5c2dac17e43701549 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aaafd3401dc8ca2b5c2dac17e43701549">Inertia_</a> (const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;m)</td></tr>
<tr class="memdesc:aaafd3401dc8ca2b5c2dac17e43701549 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Inertia matrix from a 3x3 symmetric matrix.  <a href="#aaafd3401dc8ca2b5c2dac17e43701549">More...</a><br /></td></tr>
<tr class="separator:aaafd3401dc8ca2b5c2dac17e43701549 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef4b5dc3fdac7589ae14a9f0e79e6b1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a1ef4b5dc3fdac7589ae14a9f0e79e6b1">setInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz)</td></tr>
<tr class="memdesc:a1ef4b5dc3fdac7589ae14a9f0e79e6b1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an inertia matrix to have only principal moments (that is, it will be diagonal).  <a href="#a1ef4b5dc3fdac7589ae14a9f0e79e6b1">More...</a><br /></td></tr>
<tr class="separator:a1ef4b5dc3fdac7589ae14a9f0e79e6b1 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b76c4a2fa12cb3f5346feabb1688e5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51b76c4a2fa12cb3f5346feabb1688e5">setInertia</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;moments, const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;products=<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0))</td></tr>
<tr class="memdesc:a51b76c4a2fa12cb3f5346feabb1688e5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set principal moments and optionally off-diagonal terms.  <a href="#a51b76c4a2fa12cb3f5346feabb1688e5">More...</a><br /></td></tr>
<tr class="separator:a51b76c4a2fa12cb3f5346feabb1688e5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172f5d103b854fe80b7b175cbdf1b165 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a172f5d103b854fe80b7b175cbdf1b165">setInertia</a> (const RealP &amp;xx, const RealP &amp;yy, const RealP &amp;zz, const RealP &amp;xy, const RealP &amp;xz, const RealP &amp;yz)</td></tr>
<tr class="memdesc:a172f5d103b854fe80b7b175cbdf1b165 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this Inertia to a general matrix.  <a href="#a172f5d103b854fe80b7b175cbdf1b165">More...</a><br /></td></tr>
<tr class="separator:a172f5d103b854fe80b7b175cbdf1b165 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a232f2d580d93155eac72b30e1d5d4ea5">operator+=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in another inertia matrix.  <a href="#a232f2d580d93155eac72b30e1d5d4ea5">More...</a><br /></td></tr>
<tr class="separator:a232f2d580d93155eac72b30e1d5d4ea5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af761fb58e427c6bbc9c1a1abd3d29a4e">operator-=</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;inertia)</td></tr>
<tr class="memdesc:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract off another inertia matrix.  <a href="#af761fb58e427c6bbc9c1a1abd3d29a4e">More...</a><br /></td></tr>
<tr class="separator:af761fb58e427c6bbc9c1a1abd3d29a4e inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2b50d1bec66484957bb0ebe1be4d1736">operator*=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this inertia matrix by a scalar. Cost is 6 flops.  <a href="#a2b50d1bec66484957bb0ebe1be4d1736">More...</a><br /></td></tr>
<tr class="separator:a2b50d1bec66484957bb0ebe1be4d1736 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2d583c80cb337680c60b88dc455e8eed">operator/=</a> (const P &amp;s)</td></tr>
<tr class="memdesc:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide this inertia matrix by a scalar.  <a href="#a2d583c80cb337680c60b88dc455e8eed">More...</a><br /></td></tr>
<tr class="separator:a2d583c80cb337680c60b88dc455e8eed inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000e4873c70bd977a2ecaba19be60794 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a000e4873c70bd977a2ecaba19be60794">shiftToMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF, const RealP &amp;mass) const </td></tr>
<tr class="memdesc:a000e4873c70bd977a2ecaba19be60794 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="#a000e4873c70bd977a2ecaba19be60794">More...</a><br /></td></tr>
<tr class="separator:a000e4873c70bd977a2ecaba19be60794 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faa542f554572d91f36d013fa531aa2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a7faa542f554572d91f36d013fa531aa2">shiftToMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;CF, const RealP &amp;mass)</td></tr>
<tr class="memdesc:a7faa542f554572d91f36d013fa531aa2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume that the current inertia is about the F frame's origin OF, and expressed in F.  <a href="#a7faa542f554572d91f36d013fa531aa2">More...</a><br /></td></tr>
<tr class="separator:a7faa542f554572d91f36d013fa531aa2 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad56af59c6eb1c306dd7dca0f77f27 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a9cad56af59c6eb1c306dd7dca0f77f27">shiftFromMassCenter</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass) const </td></tr>
<tr class="memdesc:a9cad56af59c6eb1c306dd7dca0f77f27 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="#a9cad56af59c6eb1c306dd7dca0f77f27">More...</a><br /></td></tr>
<tr class="separator:a9cad56af59c6eb1c306dd7dca0f77f27 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c57dbb5548ab99a910bb24f1c07d5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa86c57dbb5548ab99a910bb24f1c07d5">shiftFromMassCenterInPlace</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;mass)</td></tr>
<tr class="memdesc:aa86c57dbb5548ab99a910bb24f1c07d5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming that the current inertia I is a central inertia (that is, it is inertia about the body center of mass CF), shift it to some other point p measured from the center of mass.  <a href="#aa86c57dbb5548ab99a910bb24f1c07d5">More...</a><br /></td></tr>
<tr class="separator:aa86c57dbb5548ab99a910bb24f1c07d5 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded5c13f1f5cee2aec5319953eb401c inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c">reexpress</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a8ded5c13f1f5cee2aec5319953eb401c inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged).  <a href="#a8ded5c13f1f5cee2aec5319953eb401c">More...</a><br /></td></tr>
<tr class="separator:a8ded5c13f1f5cee2aec5319953eb401c inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c802f5dab0c8aba78da00df82a73f4 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a73c802f5dab0c8aba78da00df82a73f4">reexpress</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB) const </td></tr>
<tr class="memdesc:a73c802f5dab0c8aba78da00df82a73f4 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress using an inverse rotation to avoid having to convert it.  <a href="#a73c802f5dab0c8aba78da00df82a73f4">More...</a><br /></td></tr>
<tr class="separator:a73c802f5dab0c8aba78da00df82a73f4 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4c4a49f053e7c11240ad4e802786f254">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1Inertia__.html#a8ded5c13f1f5cee2aec5319953eb401c" title="Return a new inertia matrix like this one but re-expressed in another frame (leaving the origin point...">reexpress()</a> if you want to leave this object unmolested and get a new one instead.  <a href="#a4c4a49f053e7c11240ad4e802786f254">More...</a><br /></td></tr>
<tr class="separator:a4c4a49f053e7c11240ad4e802786f254 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4021fe4887710d1285fc6d1c5bd728aa">reexpressInPlace</a> (const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;R_FB)</td></tr>
<tr class="memdesc:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rexpress in place using an inverse rotation to avoid having to convert it.  <a href="#a4021fe4887710d1285fc6d1c5bd728aa">More...</a><br /></td></tr>
<tr class="separator:a4021fe4887710d1285fc6d1c5bd728aa inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23859436a032c1e574cf1436330e50dc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a23859436a032c1e574cf1436330e50dc">trace</a> () const </td></tr>
<tr class="separator:a23859436a032c1e574cf1436330e50dc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c83f66b07a3633caf070d8896e17b7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ae1c83f66b07a3633caf070d8896e17b7">operator const SymMat33P &amp;</a> () const </td></tr>
<tr class="memdesc:ae1c83f66b07a3633caf070d8896e17b7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to a const SymMat33.  <a href="#ae1c83f66b07a3633caf070d8896e17b7">More...</a><br /></td></tr>
<tr class="separator:ae1c83f66b07a3633caf070d8896e17b7 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab156ca728529e3f6641003b840d51acc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab156ca728529e3f6641003b840d51acc">asSymMat33</a> () const </td></tr>
<tr class="memdesc:ab156ca728529e3f6641003b840d51acc inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the underlying symmetric matrix type.  <a href="#ab156ca728529e3f6641003b840d51acc">More...</a><br /></td></tr>
<tr class="separator:ab156ca728529e3f6641003b840d51acc inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c0ed7f30e9a7c6a4789bfb5b05775c inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Mat.html">Mat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a36c0ed7f30e9a7c6a4789bfb5b05775c">toMat33</a> () const </td></tr>
<tr class="memdesc:a36c0ed7f30e9a7c6a4789bfb5b05775c inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the internal packed representation into a full 3x3 symmetric matrix with all elements set.  <a href="#a36c0ed7f30e9a7c6a4789bfb5b05775c">More...</a><br /></td></tr>
<tr class="separator:a36c0ed7f30e9a7c6a4789bfb5b05775c inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12695d09b41d77ca188b70ac9fa454c3 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a12695d09b41d77ca188b70ac9fa454c3">getMoments</a> () const </td></tr>
<tr class="memdesc:a12695d09b41d77ca188b70ac9fa454c3 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia moments (diagonal of the Inertia matrix) as a Vec3 ordered xx, yy, zz.  <a href="#a12695d09b41d77ca188b70ac9fa454c3">More...</a><br /></td></tr>
<tr class="separator:a12695d09b41d77ca188b70ac9fa454c3 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8518a3d580aef33a332fca0c264db96 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab8518a3d580aef33a332fca0c264db96">getProducts</a> () const </td></tr>
<tr class="memdesc:ab8518a3d580aef33a332fca0c264db96 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inertia products (off-diagonals of the Inertia matrix) as a Vec3 with elements ordered xy, xz, yz.  <a href="#ab8518a3d580aef33a332fca0c264db96">More...</a><br /></td></tr>
<tr class="separator:ab8518a3d580aef33a332fca0c264db96 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23a4618b211aa416301b7639fbc9dc3 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab23a4618b211aa416301b7639fbc9dc3">isNaN</a> () const </td></tr>
<tr class="separator:ab23a4618b211aa416301b7639fbc9dc3 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff49432033de46bc8d43ace62269461 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5ff49432033de46bc8d43ace62269461">isInf</a> () const </td></tr>
<tr class="separator:a5ff49432033de46bc8d43ace62269461 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d1d61b83d7a7b17d9728d1211a9ebb inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a68d1d61b83d7a7b17d9728d1211a9ebb">isFinite</a> () const </td></tr>
<tr class="separator:a68d1d61b83d7a7b17d9728d1211a9ebb inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1dc63b25c031af43cae91862ae9c74 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a3f1dc63b25c031af43cae91862ae9c74">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other) const </td></tr>
<tr class="memdesc:a3f1dc63b25c031af43cae91862ae9c74 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a default numerical tolerance.  <a href="#a3f1dc63b25c031af43cae91862ae9c74">More...</a><br /></td></tr>
<tr class="separator:a3f1dc63b25c031af43cae91862ae9c74 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e057e5f4b948bb560b5d9a8e812e40 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#af7e057e5f4b948bb560b5d9a8e812e40">isNumericallyEqual</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;other, double tol) const </td></tr>
<tr class="memdesc:af7e057e5f4b948bb560b5d9a8e812e40 inherit pub_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this inertia matrix with another one and return true if they are close to within a specified numerical tolerance.  <a href="#af7e057e5f4b948bb560b5d9a8e812e40">More...</a><br /></td></tr>
<tr class="separator:af7e057e5f4b948bb560b5d9a8e812e40 inherit pub_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0747db2089594f1958363401e7a75a3e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a0747db2089594f1958363401e7a75a3e">isValidUnitInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a0747db2089594f1958363401e7a75a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid UnitInertia matrix.  <a href="#a0747db2089594f1958363401e7a75a3e">More...</a><br /></td></tr>
<tr class="separator:a0747db2089594f1958363401e7a75a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">UnitInertia matrix factories</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are UnitInertia matrix factories for some common 3D solids.</p>
<p>Each defines its own frame aligned (when possible) with principal moments. Each has unit mass and its center of mass located at the origin (usually). Use this with <a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> to move it somewhere else, and with <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> to express the UnitInertia matrix in another frame. </p>
</div></td></tr>
<tr class="memitem:a1e27445e87e048350c0733f282a14d4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a1e27445e87e048350c0733f282a14d4a">pointMassAtOrigin</a> ()</td></tr>
<tr class="memdesc:a1e27445e87e048350c0733f282a14d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point located at the origin &ndash; that is, an all-zero matrix.  <a href="#a1e27445e87e048350c0733f282a14d4a">More...</a><br /></td></tr>
<tr class="separator:a1e27445e87e048350c0733f282a14d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#ad12590783e2b1cc3dc3715f6c4c8f3ef">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p)</td></tr>
<tr class="memdesc:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix).  <a href="#ad12590783e2b1cc3dc3715f6c4c8f3ef">More...</a><br /></td></tr>
<tr class="separator:ad12590783e2b1cc3dc3715f6c4c8f3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6dff2244b2e884fc5ae7747b4489c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aea6dff2244b2e884fc5ae7747b4489c2">sphere</a> (const RealP &amp;r)</td></tr>
<tr class="memdesc:aea6dff2244b2e884fc5ae7747b4489c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="#aea6dff2244b2e884fc5ae7747b4489c2">More...</a><br /></td></tr>
<tr class="separator:aea6dff2244b2e884fc5ae7747b4489c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aae6b90b2feeb28272a15ac0ee431b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a22aae6b90b2feeb28272a15ac0ee431b">cylinderAlongZ</a> (const RealP &amp;r, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a22aae6b90b2feeb28272a15ac0ee431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="#a22aae6b90b2feeb28272a15ac0ee431b">More...</a><br /></td></tr>
<tr class="separator:a22aae6b90b2feeb28272a15ac0ee431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b955d92ee92f053e4c90301b2537e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a433b955d92ee92f053e4c90301b2537e">cylinderAlongY</a> (const RealP &amp;r, const RealP &amp;hy)</td></tr>
<tr class="memdesc:a433b955d92ee92f053e4c90301b2537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="#a433b955d92ee92f053e4c90301b2537e">More...</a><br /></td></tr>
<tr class="separator:a433b955d92ee92f053e4c90301b2537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3c0caf76077405e5eca28662214dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a89f3c0caf76077405e5eca28662214dc">cylinderAlongX</a> (const RealP &amp;r, const RealP &amp;hx)</td></tr>
<tr class="memdesc:a89f3c0caf76077405e5eca28662214dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="#a89f3c0caf76077405e5eca28662214dc">More...</a><br /></td></tr>
<tr class="separator:a89f3c0caf76077405e5eca28662214dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b">brick</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="#aa765bcf7ca1430d4bb0ee35964b6a87b">More...</a><br /></td></tr>
<tr class="separator:aa765bcf7ca1430d4bb0ee35964b6a87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6727b53f8dc2470095ead9162f74df1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a6727b53f8dc2470095ead9162f74df1e">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a6727b53f8dc2470095ead9162f74df1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths.  <a href="#a6727b53f8dc2470095ead9162f74df1e">More...</a><br /></td></tr>
<tr class="separator:a6727b53f8dc2470095ead9162f74df1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4918161a3aa2b765b10834420f2006"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006">ellipsoid</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:afb4918161a3aa2b765b10834420f2006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="#afb4918161a3aa2b765b10834420f2006">More...</a><br /></td></tr>
<tr class="separator:afb4918161a3aa2b765b10834420f2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617357823ece8ff6c7f03c6cb34ab31e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1UnitInertia__.html#a617357823ece8ff6c7f03c6cb34ab31e">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a617357823ece8ff6c7f03c6cb34ab31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="#a617357823ece8ff6c7f03c6cb34ab31e">More...</a><br /></td></tr>
<tr class="separator:a617357823ece8ff6c7f03c6cb34ab31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:a09065c454fb39eec2dee757f63ff277e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a09065c454fb39eec2dee757f63ff277e">isValidInertiaMatrix</a> (const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;m)</td></tr>
<tr class="memdesc:a09065c454fb39eec2dee757f63ff277e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test some conditions that must hold for a valid Inertia matrix.  <a href="#a09065c454fb39eec2dee757f63ff277e">More...</a><br /></td></tr>
<tr class="separator:a09065c454fb39eec2dee757f63ff277e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#adaf11cafc9975fd5e6072f12548a467f">pointMassAtOrigin</a> ()</td></tr>
<tr class="memdesc:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point located at the origin &ndash; that is, an all-zero matrix.  <a href="#adaf11cafc9975fd5e6072f12548a467f">More...</a><br /></td></tr>
<tr class="separator:adaf11cafc9975fd5e6072f12548a467f inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa644c212473bd29473a768d15caf291e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa644c212473bd29473a768d15caf291e">pointMassAt</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;p, const RealP &amp;m)</td></tr>
<tr class="memdesc:aa644c212473bd29473a768d15caf291e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Inertia matrix for a point of a given mass, located at a given location measured from the origin of the implicit F frame.  <a href="#aa644c212473bd29473a768d15caf291e">More...</a><br /></td></tr>
<tr class="separator:aa644c212473bd29473a768d15caf291e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079ce02a6ce9ddb2c3cdf26f5c88fac inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0079ce02a6ce9ddb2c3cdf26f5c88fac">sphere</a> (const RealP &amp;r)</td></tr>
<tr class="memdesc:a0079ce02a6ce9ddb2c3cdf26f5c88fac inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin.  <a href="#a0079ce02a6ce9ddb2c3cdf26f5c88fac">More...</a><br /></td></tr>
<tr class="separator:a0079ce02a6ce9ddb2c3cdf26f5c88fac inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731715abc3e23d14716ed8778c3a41db inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a731715abc3e23d14716ed8778c3a41db">cylinderAlongZ</a> (const RealP &amp;r, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a731715abc3e23d14716ed8778c3a41db inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along z axis; use radius and half-length.  <a href="#a731715abc3e23d14716ed8778c3a41db">More...</a><br /></td></tr>
<tr class="separator:a731715abc3e23d14716ed8778c3a41db inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7fa18382bb190462ec90cee793c618 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afb7fa18382bb190462ec90cee793c618">cylinderAlongY</a> (const RealP &amp;r, const RealP &amp;hy)</td></tr>
<tr class="memdesc:afb7fa18382bb190462ec90cee793c618 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along y axis; use radius and half-length.  <a href="#afb7fa18382bb190462ec90cee793c618">More...</a><br /></td></tr>
<tr class="separator:afb7fa18382bb190462ec90cee793c618 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab408d2690f9520647fc41426d2da97a5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ab408d2690f9520647fc41426d2da97a5">cylinderAlongX</a> (const RealP &amp;r, const RealP &amp;hx)</td></tr>
<tr class="memdesc:ab408d2690f9520647fc41426d2da97a5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass cylinder aligned along x axis; use radius and half-length.  <a href="#ab408d2690f9520647fc41426d2da97a5">More...</a><br /></td></tr>
<tr class="separator:ab408d2690f9520647fc41426d2da97a5 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1dc7f12543454dadb1ea0ab243b2a3 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3">brick</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:afe1dc7f12543454dadb1ea0ab243b2a3 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass brick given by half-lengths in each direction.  <a href="#afe1dc7f12543454dadb1ea0ab243b2a3">More...</a><br /></td></tr>
<tr class="separator:afe1dc7f12543454dadb1ea0ab243b2a3 inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e344c2ae3ff6b5ac4a84f632c4c7f8e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a6e344c2ae3ff6b5ac4a84f632c4c7f8e">brick</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:a6e344c2ae3ff6b5ac4a84f632c4c7f8e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#afe1dc7f12543454dadb1ea0ab243b2a3" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths.  <a href="#a6e344c2ae3ff6b5ac4a84f632c4c7f8e">More...</a><br /></td></tr>
<tr class="separator:a6e344c2ae3ff6b5ac4a84f632c4c7f8e inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce85ba36aeec4e390d1adb99d34b33d inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d">ellipsoid</a> (const RealP &amp;hx, const RealP &amp;hy, const RealP &amp;hz)</td></tr>
<tr class="memdesc:a2ce85ba36aeec4e390d1adb99d34b33d inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-mass ellipsoid given by half-lengths in each direction.  <a href="#a2ce85ba36aeec4e390d1adb99d34b33d">More...</a><br /></td></tr>
<tr class="separator:a2ce85ba36aeec4e390d1adb99d34b33d inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc60ba4fe2d9bf269bfb9789a3433b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ac4bc60ba4fe2d9bf269bfb9789a3433b">ellipsoid</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;halfLengths)</td></tr>
<tr class="memdesc:ac4bc60ba4fe2d9bf269bfb9789a3433b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate interface to <a class="el" href="classSimTK_1_1Inertia__.html#a2ce85ba36aeec4e390d1adb99d34b33d" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths.  <a href="#ac4bc60ba4fe2d9bf269bfb9789a3433b">More...</a><br /></td></tr>
<tr class="separator:ac4bc60ba4fe2d9bf269bfb9789a3433b inherit pub_static_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:a9f881a10d5ca19fad90ad60b5491fbf5 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a9f881a10d5ca19fad90ad60b5491fbf5">getAsUnitInertia</a> () const </td></tr>
<tr class="separator:a9f881a10d5ca19fad90ad60b5491fbf5 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542289a1b1ae02d15d2e6ca581b5f03 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&lt; P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a2542289a1b1ae02d15d2e6ca581b5f03">updAsUnitInertia</a> ()</td></tr>
<tr class="separator:a2542289a1b1ae02d15d2e6ca581b5f03 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96544452d94f01b0f5167c8be260d7 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ada96544452d94f01b0f5167c8be260d7">errChk</a> (const char *methodName) const </td></tr>
<tr class="separator:ada96544452d94f01b0f5167c8be260d7 inherit pro_methods_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:a12f924bcb499f181af8687660f939d04 inherit pro_attribs_classSimTK_1_1Inertia__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a12f924bcb499f181af8687660f939d04">I_OF_F</a></td></tr>
<tr class="separator:a12f924bcb499f181af8687660f939d04 inherit pro_attribs_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1Inertia__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Inertia__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Inertia__.html">SimTK::Inertia_&lt; P &gt;</a></td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#aa13a2386109b73510feedacbc00dcb06">operator+</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two compatible inertia matrices, meaning they must be taken about the same point and expressed in the same frame.  <a href="#aa13a2386109b73510feedacbc00dcb06">More...</a><br /></td></tr>
<tr class="separator:aa13a2386109b73510feedacbc00dcb06 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad11356749d9b854ac7c54941f8898123">operator-</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;l, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;r)</td></tr>
<tr class="memdesc:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from one inertia matrix another one which is compatible, meaning that both must be taken about the same point and expressed in the same frame.  <a href="#ad11356749d9b854ac7c54941f8898123">More...</a><br /></td></tr>
<tr class="separator:ad11356749d9b854ac7c54941f8898123 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a0e0178f717c4a3c324ae9e7acbe670b5">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="#a0e0178f717c4a3c324ae9e7acbe670b5">More...</a><br /></td></tr>
<tr class="separator:a0e0178f717c4a3c324ae9e7acbe670b5 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a81c2f71a5c2f03e9ae1be20477721e51">operator*</a> (const P &amp;r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar.  <a href="#a81c2f71a5c2f03e9ae1be20477721e51">More...</a><br /></td></tr>
<tr class="separator:a81c2f71a5c2f03e9ae1be20477721e51 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4f803c5be5d23c79883c07160c1b3fff">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="#a4f803c5be5d23c79883c07160c1b3fff">More...</a><br /></td></tr>
<tr class="separator:a4f803c5be5d23c79883c07160c1b3fff inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a11dbacbcdcafff80ec99c068987b8323">operator*</a> (int r, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i)</td></tr>
<tr class="memdesc:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix by a scalar given as an int.  <a href="#a11dbacbcdcafff80ec99c068987b8323">More...</a><br /></td></tr>
<tr class="separator:a11dbacbcdcafff80ec99c068987b8323 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a4d2db9435adf44e235f3165f8274d58b">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, const P &amp;r)</td></tr>
<tr class="memdesc:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar.  <a href="#a4d2db9435adf44e235f3165f8274d58b">More...</a><br /></td></tr>
<tr class="separator:a4d2db9435adf44e235f3165f8274d58b inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a51fba91692c4dd54851b29a7ccac6317">operator/</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i, int r)</td></tr>
<tr class="memdesc:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide an inertia matrix by a scalar provided as an int.  <a href="#a51fba91692c4dd54851b29a7ccac6317">More...</a><br /></td></tr>
<tr class="separator:a51fba91692c4dd54851b29a7ccac6317 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a5c8ce4e99ab6b63e6786f47f4647f939">operator*</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;<a class="el" href="group__TypedNumConstants.html#ga89110fa308da931e7b5b69f62b143bd3">I</a>, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 3, P &gt; &amp;w)</td></tr>
<tr class="memdesc:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an inertia matrix I on the right by a vector w giving the vector result I*w.  <a href="#a5c8ce4e99ab6b63e6786f47f4647f939">More...</a><br /></td></tr>
<tr class="separator:a5c8ce4e99ab6b63e6786f47f4647f939 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#ad3306602216739add773fc2b00440560">operator==</a> (const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i1, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;i2)</td></tr>
<tr class="memdesc:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two inertia matrices for exact (bitwise) equality.  <a href="#ad3306602216739add773fc2b00440560">More...</a><br /></td></tr>
<tr class="separator:ad3306602216739add773fc2b00440560 inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memTemplParams" colspan="2">template&lt;class P &gt; </td></tr>
<tr class="memitem:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Inertia__.html#a8cb59637de516910c73d319d793f53db">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;inertia)</td></tr>
<tr class="memdesc:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a human-readable representation of an inertia matrix to the indicated stream.  <a href="#a8cb59637de516910c73d319d793f53db">More...</a><br /></td></tr>
<tr class="separator:a8cb59637de516910c73d319d793f53db inherit related_classSimTK_1_1Inertia__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::UnitInertia_&lt; P &gt;</h3>

<p>A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying it by the actual body mass. </p>
<p>Functionality is limited here to those few operations which ensure unit mass; most operations on a UnitInertia matrix result in a general Inertia instead. You can use a UnitInertia object wherever an Inertia is expected but not vice versa.</p>
<p>When constructing a UnitInertia matrix, note that we cannot verify that it actually has unit mass because every legal Inertia matrix can be viewed as the UnitInertia matrix for some differently-scaled object.</p>
<p>Unit inertia matrices are sometimes called "gyration" matrices; we will often represent them with the symbol "G" to avoid confusion with general inertia matrices for which the symbol "I" (or sometimes "J") is used.</p>
<h3>Abbreviations</h3>
<p>Typedefs exist for the most common invocations of <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a>&lt;P&gt;:</p><ul>
<li><a class="el" href="namespaceSimTK.html#af4586b331c8fbbb1f3c18d2a1a03ce92">UnitInertia</a> for default Real precision (this is almost always used)</li>
<li><a class="el" href="namespaceSimTK.html#a477722ebc554f08856ea0f612b27b8c3">fUnitInertia</a> for single (float) precision</li>
<li><a class="el" href="namespaceSimTK.html#adcce13c4ad58d5aee947072ef9cd3586">dUnitInertia</a> for double precision </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae99be8ef0c02a608415ac09cd4c08d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default is a NaN-ed out mess to avoid accidents, even in Release mode. </p>
<p>Other than this value, a <a class="el" href="classSimTK_1_1UnitInertia__.html" title="A UnitInertia matrix is a unit-mass inertia matrix; you can convert it to an Inertia by multiplying i...">UnitInertia_</a> should always be valid. </p>

</div>
</div>
<a class="anchor" id="a387d94e0b21d63c31abee6e38d13a3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>moment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal unit inertia matrix with identical diagonal elements. </p>
<p>This is the unit inertia matrix of a unit mass sphere of radius r = sqrt(5/2 * moment) centered on the origin. </p>

</div>
</div>
<a class="anchor" id="a428d474987b57e275010e899df64b634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a unit inertia matrix from a vector of the <em>moments</em> of inertia (the inertia matrix diagonal) and optionally a vector of the <em>products</em> of inertia (the off-diagonals). </p>
<p>Moments are in the order xx,yy,zz; products are xy,xz,yz. </p>

</div>
</div>
<a class="anchor" id="acece1584634f71dc9d42338275358438"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a principal unit inertia matrix (only non-zero on diagonal). </p>

</div>
</div>
<a class="anchor" id="af3a0c1914d9c3632de7777d1e14ccb24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a general unit inertia matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. </p>

</div>
</div>
<a class="anchor" id="a2e06c431d9332364cbd7a32055a452b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia from a symmetric 3x3 matrix. </p>
<p>The diagonals must be nonnegative and satisfy the triangle inequality. </p>

</div>
</div>
<a class="anchor" id="adbd367dbd9f823d671489dca9d7f8a37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Mat.html">Mat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia from a 3x3 symmetric matrix. </p>
<p>In Debug mode we'll test that the supplied matrix is numerically close to symmetric, and that it satisfies other requirements of an inertia matrix. </p>

</div>
</div>
<a class="anchor" id="a917a355a7e10746a3c18683b501a60e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a UnitInertia matrix from an Inertia matrix. </p>
<p>Note that there is no way to check whether this is really a unit inertia &ndash; <em>any</em> inertia matrix may be interpreted as a unit inertia for some shape. So be sure you know what you're doing before you use this constructor! </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a965913951efebcc88457a3fb2309e44d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a UnitInertia matrix to have only principal moments (that is, it will be diagonal). </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a941ff2a084bb33e57b81bb78f6792d8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>moments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em> = <code><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set principal moments and optionally off-diagonal terms. </p>
<p>Returns a reference to "this" like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="af519b525445b103c7b97bec214c28788"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>zz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>xz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>yz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this UnitInertia to a general matrix. </p>
<p>Note the order of these arguments: moments of inertia first, then products of inertia. Behaves like an assignment statement. Will throw an error message in Debug mode if the supplied elements do not constitute a valid inertia matrix. </p>

</div>
</div>
<a class="anchor" id="a9c2535890d3b9e0ca3b8519d252f8cf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftToCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, produce a new unit inertia matrix which is the same as this one except measured about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia matrix G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. (17 flops) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a86344e7cc8a70d606ba5a8c16511d4ed" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86344e7cc8a70d606ba5a8c16511d4ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftToCentroidInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>CF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that this unit inertia matrix is currently taken about some (implicit) frame F's origin OF, modify it so that it is instead taken about the body's centroid CF. </p>
<p>We are given the vector from OF to the centroid CF, expressed in F. This produces a new UnitInertia G' whose (implicit) frame F' is aligned with F but has origin CF (an inertia matrix like that is called "central" or "centroidal"). From the parallel axis theorem for inertias, G' = G - Gcom where Gcom is the inertia matrix of a fictitious, unit-mass point located at CF (measured in F) taken about OF. A reference to the modified object is returned so that you can chain this method in the manner of assignment operators. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
<a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f981071de25c9d3f263643b31850a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftFromCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), create a new object that is the same as this one except shifted to some other point p measured from the centroid. </p>
<p>This produces a new inertia G' about the point p given by G' = G + Gp where Gp is the inertia of a fictitious point located at p, taken about CF. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a9e4d4d72a9d1890c1f6a45067d5c88c8" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroidInPlace()</a>, <a class="el" href="classSimTK_1_1UnitInertia__.html#a9c2535890d3b9e0ca3b8519d252f8cf7" title="Assuming that this unit inertia matrix is currently taken about some (implicit) frame F&#39;s origin OF...">shiftToCentroid()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4d4d72a9d1890c1f6a45067d5c88c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::shiftFromCentroidInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body centroid CF), shift it in place to some other point p measured from the centroid. </p>
<p>This changes G to a modified inertia G' taken about the point p, with the parallel axis theorem for inertia giving G' = G + Gp where Gp is the inertia of a fictitious, unit-mass point located at p, taken about CF. Cost is 17 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a4f981071de25c9d3f263643b31850a04" title="Assuming that the current UnitInertia G is a central inertia (that is, it is inertia about the body c...">shiftFromCentroid()</a> if you want to leave this object unmolested. </dd>
<dd>
shitToCentroidInPlace() </dd></dl>

</div>
</div>
<a class="anchor" id="a82227844aba875e9fa4063bff68a3451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin point unchanged). </p>
<p>Call this inertia matrix G_OF_F, that is, it is taken about the origin of some frame F, and expressed in F. We want to return G_OF_B, the same unit inertia matrix, still taken about the origin of F, but expressed in the B frame, given by G_OF_B=R_BF*G_OF_F*R_FB where R_FB is the rotation matrix giving the orientation of frame B in F. This is handled here by a special method of the Rotation class which rotates a symmetric tensor at a cost of 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a4b820a2338b949af9816a70343940a07" title="Re-express this unit inertia matrix in another frame, changing the object in place; see reexpress() i...">reexpressInPlace()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76f8a4eba1df68a53839ae02025f5507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpress(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="a4b820a2338b949af9816a70343940a07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Rotation__.html">Rotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this unit inertia matrix in another frame, changing the object in place; see <a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested and get a new one instead. </p>
<p>Cost is 57 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1UnitInertia__.html#a82227844aba875e9fa4063bff68a3451" title="Return a new unit inertia matrix like this one but re-expressed in another frame (leaving the origin ...">reexpress()</a> if you want to leave this object unmolested. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f0b740b16c447193af134d6dcfc8a29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::reexpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1InverseRotation__.html">InverseRotation_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rexpress using an inverse rotation to avoid having to convert it. </p>
<dl class="section see"><dt>See also</dt><dd>rexpressInPlace(Rotation) for information </dd></dl>

</div>
</div>
<a class="anchor" id="aaf30c07af59a472f872e6867ef8a14df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::operator const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to const SymMat33. </p>

</div>
</div>
<a class="anchor" id="a4ad2f3845459ee8d4a99857160b67238"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt;P&gt;&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::asUnitInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast this UnitInertia matrix as a unit inertia matrix. </p>
<p>This is just for emphasis; a UnitInertia matrix is already a kind of Inertia matrix by inheritance. </p>

</div>
</div>
<a class="anchor" id="a4fbd0500e52f995dd5f11639a073969d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a>&amp; <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::setFromUnitInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Inertia__.html">Inertia_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set from a unit inertia matrix. </p>
<p>Note that we can't check; every Inertia matrix can be interpreted as a unit inertia for some shape. </p>

</div>
</div>
<a class="anchor" id="a0747db2089594f1958363401e7a75a3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::isValidUnitInertiaMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SymMat.html">SymMat33P</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test some conditions that must hold for a valid UnitInertia matrix. </p>
<p>Cost is about 9 flops. TODO: this may not be comprehensive. </p>

</div>
</div>
<a class="anchor" id="a1e27445e87e048350c0733f282a14d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::pointMassAtOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a point located at the origin &ndash; that is, an all-zero matrix. </p>

</div>
</div>
<a class="anchor" id="ad12590783e2b1cc3dc3715f6c4c8f3ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::pointMassAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a point of unit mass located at a given location measured from origin OF and expressed in F (where F is the implicit frame of this UnitInertia matrix). </p>
<p>Cost is 11 flops. </p>

</div>
</div>
<a class="anchor" id="aea6dff2244b2e884fc5ae7747b4489c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::sphere </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a UnitInertia matrix for a unit mass sphere of radius <em>r</em> centered at the origin. </p>

</div>
</div>
<a class="anchor" id="a22aae6b90b2feeb28272a15ac0ee431b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongZ </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along z axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hz=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="a433b955d92ee92f053e4c90301b2537e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongY </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along y axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hy=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="a89f3c0caf76077405e5eca28662214dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::cylinderAlongX </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass cylinder aligned along x axis; use radius and half-length. </p>
<p>If r==0 this is a thin rod; hx=0 it is a thin disk. </p>

</div>
</div>
<a class="anchor" id="aa765bcf7ca1430d4bb0ee35964b6a87b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass brick given by half-lengths in each direction. </p>
<p>One dimension zero gives inertia of a thin rectangular sheet; two zero gives inertia of a thin rod in the remaining direction. </p>

</div>
</div>
<a class="anchor" id="a6727b53f8dc2470095ead9162f74df1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::brick </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#aa765bcf7ca1430d4bb0ee35964b6a87b" title="Unit-mass brick given by half-lengths in each direction. ">brick()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<a class="anchor" id="afb4918161a3aa2b765b10834420f2006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealP &amp;&#160;</td>
          <td class="paramname"><em>hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit-mass ellipsoid given by half-lengths in each direction. </p>

</div>
</div>
<a class="anchor" id="a617357823ece8ff6c7f03c6cb34ab31e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a> <a class="el" href="classSimTK_1_1UnitInertia__.html">SimTK::UnitInertia_</a>&lt; P &gt;::ellipsoid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &amp;&#160;</td>
          <td class="paramname"><em>halfLengths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate interface to <a class="el" href="classSimTK_1_1UnitInertia__.html#afb4918161a3aa2b765b10834420f2006" title="Unit-mass ellipsoid given by half-lengths in each direction. ">ellipsoid()</a> that takes a Vec3 for the half lengths. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MassProperties_8h_source.html">MassProperties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1UnitInertia__.html">UnitInertia_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:26 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
