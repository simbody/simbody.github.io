<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Xml::Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Xml_1_1Element.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="classSimTK_1_1Xml_1_1Element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Xml::Element Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes.  
 <a href="classSimTK_1_1Xml_1_1Element.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Xml::Element:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Xml_1_1Element.png" usemap="#SimTK::Xml::Element_map" alt=""/>
  <map id="SimTK::Xml::Element_map" name="SimTK::Xml::Element_map">
<area href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. " alt="SimTK::Xml::Node" shape="rect" coords="0,0,124,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As discussed elsewhere, elements come in two varieties: value elements and compound elements.</p>
<p>New value elements can be created easily since they are essentially just a name,value pair. Compound elements require a series of method calls to create the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node and then add child nodes to it. In either case you may want to add attributes also. </p>
</div></td></tr>
<tr class="memitem:ace92fc2051430e6dc12eec23135bc409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">Element</a> ()</td></tr>
<tr class="memdesc:ace92fc2051430e6dc12eec23135bc409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements.  <a href="#ace92fc2051430e6dc12eec23135bc409">More...</a><br /></td></tr>
<tr class="separator:ace92fc2051430e6dc12eec23135bc409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab436c4a5dd786608a8083cae30a93388"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab436c4a5dd786608a8083cae30a93388">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value=&quot;&quot;)</td></tr>
<tr class="memdesc:ab436c4a5dd786608a8083cae30a93388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value.  <a href="#ab436c4a5dd786608a8083cae30a93388">More...</a><br /></td></tr>
<tr class="separator:ab436c4a5dd786608a8083cae30a93388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aeeea0c8fd0fe18efb95f2907ac055451">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const T &amp;value)</td></tr>
<tr class="memdesc:aeeea0c8fd0fe18efb95f2907ac055451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#aeeea0c8fd0fe18efb95f2907ac055451">More...</a><br /></td></tr>
<tr class="separator:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa31891cf84e151e7657630ef628fcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4">clone</a> () const </td></tr>
<tr class="memdesc:aaa31891cf84e151e7657630ef628fcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow.  <a href="#aaa31891cf84e151e7657630ef628fcd4">More...</a><br /></td></tr>
<tr class="separator:aaa31891cf84e151e7657630ef628fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bffec933fcbf26da23323fe35eaf448"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6bffec933fcbf26da23323fe35eaf448">getElementTag</a> () const </td></tr>
<tr class="memdesc:a6bffec933fcbf26da23323fe35eaf448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element tag word.  <a href="#a6bffec933fcbf26da23323fe35eaf448">More...</a><br /></td></tr>
<tr class="separator:a6bffec933fcbf26da23323fe35eaf448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6b5bf3c6e351f7dd9afa52fcff07af52">setElementTag</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the tag word that is used to bracket this element.  <a href="#a6b5bf3c6e351f7dd9afa52fcff07af52">More...</a><br /></td></tr>
<tr class="separator:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79c09e3f397a48c65f40f86d113664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a4e79c09e3f397a48c65f40f86d113664">insertNodeBefore</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr class="memdesc:a4e79c09e3f397a48c65f40f86d113664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a4e79c09e3f397a48c65f40f86d113664">More...</a><br /></td></tr>
<tr class="separator:a4e79c09e3f397a48c65f40f86d113664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9bdc6b7182e6308f1bd9e08c830566b9">insertNodeAfter</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr class="memdesc:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a9bdc6b7182e6308f1bd9e08c830566b9">More...</a><br /></td></tr>
<tr class="separator:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3822acf6439f7b502ef0d6778ede972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ac3822acf6439f7b502ef0d6778ede972">eraseNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;deleteThis)</td></tr>
<tr class="memdesc:ac3822acf6439f7b502ef0d6778ede972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>.  <a href="#ac3822acf6439f7b502ef0d6778ede972">More...</a><br /></td></tr>
<tr class="separator:ac3822acf6439f7b502ef0d6778ede972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5b6dd8506bfb5221631df7dad4de4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#afd5b6dd8506bfb5221631df7dad4de4d">removeNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;removeThis)</td></tr>
<tr class="memdesc:afd5b6dd8506bfb5221631df7dad4de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>.  <a href="#afd5b6dd8506bfb5221631df7dad4de4d">More...</a><br /></td></tr>
<tr class="separator:afd5b6dd8506bfb5221631df7dad4de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Value elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As described elsewhere, value elements are those that have no child elements and only a single <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, whose contents can be considered as the element's value.</p>
<p>Methods in this section allow you to work conveniently with value elements, getting direct access to the value string or interpreting it as some other type. You can easily modify the value by obtaining a writable refence to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> object that holds it. We provide methods for working with this element's value (if it is a value element) and with an element's children's values (if this element is compound). </p>
</div></td></tr>
<tr class="memitem:aae65d97f9b00e4418d5602e77bb5fb66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66">isValueElement</a> () const </td></tr>
<tr class="memdesc:aae65d97f9b00e4418d5602e77bb5fb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes and no child elements.  <a href="#aae65d97f9b00e4418d5602e77bb5fb66">More...</a><br /></td></tr>
<tr class="separator:aae65d97f9b00e4418d5602e77bb5fb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42eeb91fc1f6d3ad570d0db925870ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce">getValue</a> () const </td></tr>
<tr class="memdesc:ab42eeb91fc1f6d3ad570d0db925870ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of this value element.  <a href="#ab42eeb91fc1f6d3ad570d0db925870ce">More...</a><br /></td></tr>
<tr class="separator:ab42eeb91fc1f6d3ad570d0db925870ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe1243e8e2e83ceb3925659181065d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d">updValue</a> ()</td></tr>
<tr class="memdesc:a6fbe1243e8e2e83ceb3925659181065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element.  <a href="#a6fbe1243e8e2e83ceb3925659181065d">More...</a><br /></td></tr>
<tr class="separator:a6fbe1243e8e2e83ceb3925659181065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d99f6f31da37e122ee14dcb7281238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238">setValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr class="memdesc:a87d99f6f31da37e122ee14dcb7281238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the text value of this value element.  <a href="#a87d99f6f31da37e122ee14dcb7281238">More...</a><br /></td></tr>
<tr class="separator:a87d99f6f31da37e122ee14dcb7281238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fd52a31abb8f1626d7902c747b02d4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a03fd52a31abb8f1626d7902c747b02d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4">setValueAs</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a03fd52a31abb8f1626d7902c747b02d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#a03fd52a31abb8f1626d7902c747b02d4">More...</a><br /></td></tr>
<tr class="separator:a03fd52a31abb8f1626d7902c747b02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3250133e91118e41e46f925f05556cec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3250133e91118e41e46f925f05556cec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec">getValueAs</a> () const </td></tr>
<tr class="memdesc:a3250133e91118e41e46f925f05556cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming this is a "value element", convert its text value to the type of the template argument T.  <a href="#a3250133e91118e41e46f925f05556cec">More...</a><br /></td></tr>
<tr class="separator:a3250133e91118e41e46f925f05556cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665fafcd7535ac1db55c9ed81caea4c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a665fafcd7535ac1db55c9ed81caea4c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a665fafcd7535ac1db55c9ed81caea4c3">getValueAs</a> (T &amp;out) const </td></tr>
<tr class="memdesc:a665fafcd7535ac1db55c9ed81caea4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects.  <a href="#a665fafcd7535ac1db55c9ed81caea4c3">More...</a><br /></td></tr>
<tr class="separator:a665fafcd7535ac1db55c9ed81caea4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af527410d9e2b0483da3b7384d8c497ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af527410d9e2b0483da3b7384d8c497ec">getRequiredElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr class="memdesc:af527410d9e2b0483da3b7384d8c497ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>must</em> be present in this element.  <a href="#af527410d9e2b0483da3b7384d8c497ec">More...</a><br /></td></tr>
<tr class="separator:af527410d9e2b0483da3b7384d8c497ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeab5895d7485590ab1fec6177c7a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaeeab5895d7485590ab1fec6177c7a91">getOptionalElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const </td></tr>
<tr class="memdesc:aaeeab5895d7485590ab1fec6177c7a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string.  <a href="#aaeeab5895d7485590ab1fec6177c7a91">More...</a><br /></td></tr>
<tr class="separator:aaeeab5895d7485590ab1fec6177c7a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd51b037e620848e76d1591cdb26a457"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd51b037e620848e76d1591cdb26a457"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#acd51b037e620848e76d1591cdb26a457">getRequiredElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr class="memdesc:acd51b037e620848e76d1591cdb26a457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required child value element to the type of the template argument T.  <a href="#acd51b037e620848e76d1591cdb26a457">More...</a><br /></td></tr>
<tr class="separator:acd51b037e620848e76d1591cdb26a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf04099eb57a7ce81de228ba6b2c034"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2bf04099eb57a7ce81de228ba6b2c034"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2bf04099eb57a7ce81de228ba6b2c034">getOptionalElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const T &amp;def) const </td></tr>
<tr class="memdesc:a2bf04099eb57a7ce81de228ba6b2c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of an optional child value element, if present, to the type of the template argument T.  <a href="#a2bf04099eb57a7ce81de228ba6b2c034">More...</a><br /></td></tr>
<tr class="separator:a2bf04099eb57a7ce81de228ba6b2c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can add, modify, and remove element attributes with the methods in this section.</p>
<p>You can work directly with individual attributes by name, or you can iterate through the list of attributes. </p>
</div></td></tr>
<tr class="memitem:ab6545733fba05a6349cee654d8d2167b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab6545733fba05a6349cee654d8d2167b">hasAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr class="memdesc:ab6545733fba05a6349cee654d8d2167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has an attribute of this name.  <a href="#ab6545733fba05a6349cee654d8d2167b">More...</a><br /></td></tr>
<tr class="separator:ab6545733fba05a6349cee654d8d2167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c04ffb38dc3e908fd559c7c542ad559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8c04ffb38dc3e908fd559c7c542ad559">setAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr class="memdesc:a8c04ffb38dc3e908fd559c7c542ad559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one.  <a href="#a8c04ffb38dc3e908fd559c7c542ad559">More...</a><br /></td></tr>
<tr class="separator:a8c04ffb38dc3e908fd559c7c542ad559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03e4d7a877ad3a514412e78e3efc6ce7">eraseAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute of this element if it exists, otherwise do nothing.  <a href="#a03e4d7a877ad3a514412e78e3efc6ce7">More...</a><br /></td></tr>
<tr class="separator:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d6cb52b56efd3d9a1202ac827e1812"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65d6cb52b56efd3d9a1202ac827e1812">getRequiredAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr class="memdesc:a65d6cb52b56efd3d9a1202ac827e1812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string and throw an error if that attribute is not present.  <a href="#a65d6cb52b56efd3d9a1202ac827e1812">More...</a><br /></td></tr>
<tr class="separator:a65d6cb52b56efd3d9a1202ac827e1812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c6820ae4a6507752eefd1ea960fd46"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12c6820ae4a6507752eefd1ea960fd46"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a12c6820ae4a6507752eefd1ea960fd46">getRequiredAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const </td></tr>
<tr class="memdesc:a12c6820ae4a6507752eefd1ea960fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required attribute to the type of the template argument T.  <a href="#a12c6820ae4a6507752eefd1ea960fd46">More...</a><br /></td></tr>
<tr class="separator:a12c6820ae4a6507752eefd1ea960fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54dacef8bea4acac95a89ce5aefb44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae54dacef8bea4acac95a89ce5aefb44d">getOptionalAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const </td></tr>
<tr class="memdesc:ae54dacef8bea4acac95a89ce5aefb44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value.  <a href="#ae54dacef8bea4acac95a89ce5aefb44d">More...</a><br /></td></tr>
<tr class="separator:ae54dacef8bea4acac95a89ce5aefb44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d8bc6dc30f3d97af5a393a7b057b83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a24d8bc6dc30f3d97af5a393a7b057b83"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a24d8bc6dc30f3d97af5a393a7b057b83">getOptionalAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const T &amp;def) const </td></tr>
<tr class="memdesc:a24d8bc6dc30f3d97af5a393a7b057b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the value of an optional attribute, if present, from a string to the type of the template argument T.  <a href="#a24d8bc6dc30f3d97af5a393a7b057b83">More...</a><br /></td></tr>
<tr class="separator:a24d8bc6dc30f3d97af5a393a7b057b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904c330f4cec26a4e5793bed0441445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad904c330f4cec26a4e5793bed0441445">getRequiredAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:ad904c330f4cec26a4e5793bed0441445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present.  <a href="#ad904c330f4cec26a4e5793bed0441445">More...</a><br /></td></tr>
<tr class="separator:ad904c330f4cec26a4e5793bed0441445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd827d22b75b6202b7461b2ab90ddeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aacd827d22b75b6202b7461b2ab90ddeb">getOptionalAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:aacd827d22b75b6202b7461b2ab90ddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present.  <a href="#aacd827d22b75b6202b7461b2ab90ddeb">More...</a><br /></td></tr>
<tr class="separator:aacd827d22b75b6202b7461b2ab90ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d797fd21a8b3d851616dc8d00241a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a34d797fd21a8b3d851616dc8d00241a6">getAllAttributes</a> ()</td></tr>
<tr class="memdesc:a34d797fd21a8b3d851616dc8d00241a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element.  <a href="#a34d797fd21a8b3d851616dc8d00241a6">More...</a><br /></td></tr>
<tr class="separator:a34d797fd21a8b3d851616dc8d00241a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">attribute_begin</a> ()</td></tr>
<tr class="memdesc:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through all the attributes of this element.  <a href="#a2e80bd8d9c3421ba9d1113579f9acf47">More...</a><br /></td></tr>
<tr class="separator:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ba2c678473eaab3218db79e67e671c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c">attribute_end</a> () const </td></tr>
<tr class="memdesc:ab4ba2c678473eaab3218db79e67e671c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a> iterator indicates the end of a sequence of attributes.  <a href="#ab4ba2c678473eaab3218db79e67e671c">More...</a><br /></td></tr>
<tr class="separator:ab4ba2c678473eaab3218db79e67e671c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compound elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Many elements contain child nodes, including other elements.</p>
<p>When there is just a single child <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node and no child elements, we call the element a "value element" and it is easiest to work with using the methods in the "Value elements" section. When there are child elements and/or multiple <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes, the element is called a "compound element" and you need a way to iterate and recurse through its contents. The methods in this section support looking through all contained nodes, nodes of specified types, element nodes, or element nodes with a specified tags. You can obtain handles to child Nodes or Elements and then iterate through those recursively. </p>
</div></td></tr>
<tr class="memitem:af295f46c76adc5bbdfac98b6f1a80b82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af295f46c76adc5bbdfac98b6f1a80b82">hasElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const </td></tr>
<tr class="memdesc:af295f46c76adc5bbdfac98b6f1a80b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has a child element with this tag.  <a href="#af295f46c76adc5bbdfac98b6f1a80b82">More...</a><br /></td></tr>
<tr class="separator:af295f46c76adc5bbdfac98b6f1a80b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1495f916a3d8924d4ead80592c2034ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1495f916a3d8924d4ead80592c2034ce">hasNode</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>) const </td></tr>
<tr class="memdesc:a1495f916a3d8924d4ead80592c2034ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#a1495f916a3d8924d4ead80592c2034ce">More...</a><br /></td></tr>
<tr class="separator:a1495f916a3d8924d4ead80592c2034ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1ee99cd86e3e413234c7b4bf9e2d5bf6">getRequiredElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>must</em> be present in this element.  <a href="#a1ee99cd86e3e413234c7b4bf9e2d5bf6">More...</a><br /></td></tr>
<tr class="separator:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3772785ece91bcccba9da75e89eecbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3772785ece91bcccba9da75e89eecbdd">getOptionalElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a3772785ece91bcccba9da75e89eecbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle.  <a href="#a3772785ece91bcccba9da75e89eecbdd">More...</a><br /></td></tr>
<tr class="separator:a3772785ece91bcccba9da75e89eecbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c43f8749c9def7a0b65136e8fc1329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329">getAllElements</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr class="memdesc:af9c43f8749c9def7a0b65136e8fc1329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word).  <a href="#af9c43f8749c9def7a0b65136e8fc1329">More...</a><br /></td></tr>
<tr class="separator:af9c43f8749c9def7a0b65136e8fc1329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f0a78da097f84bf67bef22bb5b5372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a60f0a78da097f84bf67bef22bb5b5372">getAllNodes</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr class="memdesc:a60f0a78da097f84bf67bef22bb5b5372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types.  <a href="#a60f0a78da097f84bf67bef22bb5b5372">More...</a><br /></td></tr>
<tr class="separator:a60f0a78da097f84bf67bef22bb5b5372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">element_begin</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied.  <a href="#a8f9e8c86fb08bd3c0ffd397e0186acb0">More...</a><br /></td></tr>
<tr class="separator:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1f3e8fced7b1bb5b081b9cb5af9fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2">element_end</a> () const </td></tr>
<tr class="memdesc:a7c1f3e8fced7b1bb5b081b9cb5af9fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used.  <a href="#a7c1f3e8fced7b1bb5b081b9cb5af9fa2">More...</a><br /></td></tr>
<tr class="separator:a7c1f3e8fced7b1bb5b081b9cb5af9fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3c5ff58a4653ffac14b19447f8c718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">node_begin</a> (<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr class="memdesc:a9d3c5ff58a4653ffac14b19447f8c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#a9d3c5ff58a4653ffac14b19447f8c718">More...</a><br /></td></tr>
<tr class="separator:a9d3c5ff58a4653ffac14b19447f8c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74f7074ef8b528f9e9ac5fed950790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790">node_end</a> () const </td></tr>
<tr class="memdesc:aad74f7074ef8b528f9e9ac5fed950790"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used.  <a href="#aad74f7074ef8b528f9e9ac5fed950790">More...</a><br /></td></tr>
<tr class="separator:aad74f7074ef8b528f9e9ac5fed950790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Xml_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Xml_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Xml_1_1Node.html">SimTK::Xml::Node</a></td></tr>
<tr class="memitem:a9523850db5f393008f00c3900fa753b8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8">operator==</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const </td></tr>
<tr class="memdesc:a9523850db5f393008f00c3900fa753b8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparing Nodes for equality means asking if the two <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles are referring to exactly the same object; two different nodes that happen to have the same properties will not test equal by this criteria.  <a href="#a9523850db5f393008f00c3900fa753b8">More...</a><br /></td></tr>
<tr class="separator:a9523850db5f393008f00c3900fa753b8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50231fc82d308d4827cbb13f882747ee inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a50231fc82d308d4827cbb13f882747ee">operator!=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const </td></tr>
<tr class="memdesc:a50231fc82d308d4827cbb13f882747ee inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test using same criteria as <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a9523850db5f393008f00c3900fa753b8" title="Comparing Nodes for equality means asking if the two Node handles are referring to exactly the same o...">operator==()</a>.  <a href="#a50231fc82d308d4827cbb13f882747ee">More...</a><br /></td></tr>
<tr class="separator:a50231fc82d308d4827cbb13f882747ee inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f">Node</a> ()</td></tr>
<tr class="memdesc:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle that can be used to hold a reference to any kind of <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>.  <a href="#a6086556201f425213e56d7d35d5a770f">More...</a><br /></td></tr>
<tr class="separator:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504">Node</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; that is, this handle will refer to the same node as the source.  <a href="#a37a4a32f7bcd56d7e045def2c0721504">More...</a><br /></td></tr>
<tr class="separator:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ac73ad2654deb98cc0d755cedef628102">operator=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is shallow; the handle is first cleared and then will refer to the same node as the source.  <a href="#ac73ad2654deb98cc0d755cedef628102">More...</a><br /></td></tr>
<tr class="separator:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc94baed587a767bc743a6922a1caa4 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4">clone</a> () const </td></tr>
<tr class="memdesc:a1bc94baed587a767bc743a6922a1caa4 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1bc94baed587a767bc743a6922a1caa4" title="The clone() method makes a deep copy of this Node and its children and returns a new orphan Node with...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> with the same contents; ordinary assignment and copy construction is shallow.  <a href="#a1bc94baed587a767bc743a6922a1caa4">More...</a><br /></td></tr>
<tr class="separator:a1bc94baed587a767bc743a6922a1caa4 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741">~Node</a> ()</td></tr>
<tr class="memdesc:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle destructor does not recover heap space so if you create orphan nodes and then don't put them in a document there will be a memory leak unless you explicitly destruct them first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a>.  <a href="#ae54089650958823d1a7d070cf27c1741">More...</a><br /></td></tr>
<tr class="separator:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#acc212921b30a4a7b95f339224b115b47">clear</a> ()</td></tr>
<tr class="memdesc:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method restores the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle to its default-constructed state but does not recover any heap space; use <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explictly frees the heap space for an orphan node that was created but never inserted int...">clearOrphan()</a> if you know this node was never put into a document.  <a href="#acc212921b30a4a7b95f339224b115b47">More...</a><br /></td></tr>
<tr class="separator:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8">clearOrphan</a> ()</td></tr>
<tr class="memdesc:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method explictly frees the heap space for an orphan node that was created but never inserted into a document.  <a href="#af526ba1e54d03561336ec39eba5a3fe8">More...</a><br /></td></tr>
<tr class="separator:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02af9c337d25add562a5b3dfd75c963c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a02af9c337d25add562a5b3dfd75c963c">getNodeType</a> () const </td></tr>
<tr class="memdesc:a02af9c337d25add562a5b3dfd75c963c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The NodeType enum serves as the actual type of a node and as a filter for allowable node types during...">Xml::NodeType</a> of this node.  <a href="#a02af9c337d25add562a5b3dfd75c963c">More...</a><br /></td></tr>
<tr class="separator:a02af9c337d25add562a5b3dfd75c963c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2d94932a97f4c5eb5bd28b20748f3b inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8b2d94932a97f4c5eb5bd28b20748f3b">getNodeTypeAsString</a> () const </td></tr>
<tr class="memdesc:a8b2d94932a97f4c5eb5bd28b20748f3b inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> type as a string; an empty handle returns "NoNode".  <a href="#a8b2d94932a97f4c5eb5bd28b20748f3b">More...</a><br /></td></tr>
<tr class="separator:a8b2d94932a97f4c5eb5bd28b20748f3b inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a08c6ea7d9b3362a5b2af3b7012d09a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a">isValid</a> () const </td></tr>
<tr class="memdesc:a8a08c6ea7d9b3362a5b2af3b7012d09a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is referencing some node, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="#a8a08c6ea7d9b3362a5b2af3b7012d09a">More...</a><br /></td></tr>
<tr class="separator:a8a08c6ea7d9b3362a5b2af3b7012d09a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa939cc4a494ad2f8117bc058171a3d0 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aaa939cc4a494ad2f8117bc058171a3d0">isTopLevelNode</a> () const </td></tr>
<tr class="memdesc:aaa939cc4a494ad2f8117bc058171a3d0 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by the top-level <a class="el" href="classSimTK_1_1Xml.html" title="This class provides a minimalist capability for reading and writing XML documents, as files or strings. ">Xml</a> document, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> or is an orphan, or if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="#aaa939cc4a494ad2f8117bc058171a3d0">More...</a><br /></td></tr>
<tr class="separator:aaa939cc4a494ad2f8117bc058171a3d0 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55413e3118a107e93cd58b1186ac99e inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ab55413e3118a107e93cd58b1186ac99e">isOrphan</a> () const </td></tr>
<tr class="memdesc:ab55413e3118a107e93cd58b1186ac99e inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an orphan, meaning that it is not empty, but is not owned by any element or top-level document.  <a href="#ab55413e3118a107e93cd58b1186ac99e">More...</a><br /></td></tr>
<tr class="separator:ab55413e3118a107e93cd58b1186ac99e inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0803126f86e88a10ffa31437115f5814 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0803126f86e88a10ffa31437115f5814">hasParentElement</a> () const </td></tr>
<tr class="memdesc:a0803126f86e88a10ffa31437115f5814 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this node has a parent, i.e.  <a href="#a0803126f86e88a10ffa31437115f5814">More...</a><br /></td></tr>
<tr class="separator:a0803126f86e88a10ffa31437115f5814 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aad45b2ef59c93d755edb25334f501a17">getParentElement</a> ()</td></tr>
<tr class="memdesc:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle referencing this node's parent if it has one, otherwise throws an error; check first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0803126f86e88a10ffa31437115f5814" title="Return true if this node has a parent, i.e. ">hasParentElement()</a> if you aren't sure.  <a href="#aad45b2ef59c93d755edb25334f501a17">More...</a><br /></td></tr>
<tr class="separator:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0091f53a29b7082e51f8682ab8e36643 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0091f53a29b7082e51f8682ab8e36643">getNodeText</a> () const </td></tr>
<tr class="memdesc:a0091f53a29b7082e51f8682ab8e36643 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a text value associated with this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> (<em>not</em> including its child nodes if any); the behavior depends on the NodeType.  <a href="#a0091f53a29b7082e51f8682ab8e36643">More...</a><br /></td></tr>
<tr class="separator:a0091f53a29b7082e51f8682ab8e36643 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c79035793ee0090d3826623535706 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a577c79035793ee0090d3826623535706">writeToString</a> (<a class="el" href="classSimTK_1_1String.html">String</a> &amp;out, bool compact=false) const </td></tr>
<tr class="memdesc:a577c79035793ee0090d3826623535706 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this node (and everything it contains) to the given <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>.  <a href="#a577c79035793ee0090d3826623535706">More...</a><br /></td></tr>
<tr class="separator:a577c79035793ee0090d3826623535706 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion to Element from Node</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If you have a handle to a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>, such as would be returned by a <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>, you can check whether that <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and if so cast it to one.</p>
</div></td></tr>
<tr class="memitem:a569474bd297296231c6078cc050a8521"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521">isA</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;)</td></tr>
<tr class="memdesc:a569474bd297296231c6078cc050a8521"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an element node.  <a href="#a569474bd297296231c6078cc050a8521">More...</a><br /></td></tr>
<tr class="separator:a569474bd297296231c6078cc050a8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b394c523a22dc160a5990850457e3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3">getAs</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a869b394c523a22dc160a5990850457e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node.  <a href="#a869b394c523a22dc160a5990850457e3">More...</a><br /></td></tr>
<tr class="separator:a869b394c523a22dc160a5990850457e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f74e7946e1abb0026eff29803cbd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad15f74e7946e1abb0026eff29803cbd2">getAs</a> (<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:ad15f74e7946e1abb0026eff29803cbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node.  <a href="#ad15f74e7946e1abb0026eff29803cbd2">More...</a><br /></td></tr>
<tr class="separator:ad15f74e7946e1abb0026eff29803cbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aee787d4b6e5639c308b632173814ece7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aee787d4b6e5639c308b632173814ece7">Xml::Node</a></td></tr>
<tr class="separator:aee787d4b6e5639c308b632173814ece7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ee202f3a1549ce45c613ddce919565"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad4ee202f3a1549ce45c613ddce919565">Xml::element_iterator</a></td></tr>
<tr class="separator:ad4ee202f3a1549ce45c613ddce919565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header related_classSimTK_1_1Xml_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Xml_1_1Node')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Xml_1_1Node.html">SimTK::Xml::Node</a></td></tr>
<tr class="memitem:a80c0f5ebe69e44375f32f508ba2c19ce inherit related_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Xml::Node</a> &amp;xmlNode)</td></tr>
<tr class="memdesc:a80c0f5ebe69e44375f32f508ba2c19ce inherit related_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a "pretty printed" textual representation of the given XML node (and all its contents) to an std::ostream.  <a href="#a80c0f5ebe69e44375f32f508ba2c19ce">More...</a><br /></td></tr>
<tr class="separator:a80c0f5ebe69e44375f32f508ba2c19ce inherit related_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes. </p>
<p>The tag word, which begins with an underscore or a letter, can serve as either the type or the name of the element depending on context. The nodes can be comments, unknowns, text, and child elements (recursively). It is common for "leaf" elements (elements with no child elements) to be supplied simply for their values, for example mass might be provided via an element "&lt;mass&gt; 29.3 &lt;/mass&gt;". We call such elements "value
elements" since they have a uniquely identifiable value similar to that of attributes. Value elements have no more than one text node. They may have attributes, and may also have comment and unknown nodes but they cannot have any child elements. This class provides a special set of methods for dealing with value nodes very conveniently; they will fail if you attempt to use them on an element that is not a value element. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace92fc2051430e6dc12eec23135bc409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements. </p>

</div>
</div>
<a class="anchor" id="ab436c4a5dd786608a8083cae30a93388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value. </p>
<p>Note that although you provide the initial value as a string, you can access it as any type T to which that string can be converted, using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a> templatized method.</p>
<p>If no initial value is provided, then the element will be empty so would print as "&lt;tagWord /&gt;". If you provide a value (say "contents") here or add one later, it will print as "&lt;tagWord&gt;contents&lt;/tagWord&gt;". In general you can add child elements and other node types with subsequent method calls; that would change this element from a value element to a compound element. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element. ">getValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element. ">updValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element. ">setValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeeea0c8fd0fe18efb95f2907ac055451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaa31891cf84e151e7657630ef628fcd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aaa31891cf84e151e7657630ef628fcd4" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow. </p>

</div>
</div>
<a class="anchor" id="a6bffec933fcbf26da23323fe35eaf448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getElementTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element tag word. </p>
<p>This may represent the name or type of the element depending on context. </p>

</div>
</div>
<a class="anchor" id="a6b5bf3c6e351f7dd9afa52fcff07af52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setElementTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the tag word that is used to bracket this element. </p>

</div>
</div>
<a class="anchor" id="a4e79c09e3f397a48c65f40f86d113664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::insertNodeBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a class="anchor" id="a9bdc6b7182e6308f1bd9e08c830566b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::insertNodeAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a class="anchor" id="ac3822acf6439f7b502ef0d6778ede972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::eraseNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>
<p>The node will be removed from this element and deleted. The iterator is invalid after this call; be sure not to use it again. Also, there must not be any handles referencing the now-deleted node. </p>

</div>
</div>
<a class="anchor" id="afd5b6dd8506bfb5221631df7dad4de4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> SimTK::Xml::Element::removeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>removeThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>. </p>
<p>The node must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. The node will be removed from this element and returned as an orphan. The iterator is invalid after this call; be sure not to use it again. </p>

</div>
</div>
<a class="anchor" id="aae65d97f9b00e4418d5602e77bb5fb66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::isValueElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes and no child elements. </p>
<p>You can treat a value element as you would an attribute &ndash; it can be viewed as having a single value, which is just the value of its lone <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node (or a null string if it doesn't have any text). </p>

</div>
</div>
<a class="anchor" id="ab42eeb91fc1f6d3ad570d0db925870ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the text value of this value element. </p>
<p>An error will be thrown if this is not a "value element". See the comments for this class for the definition of a "value element". </p><dl class="section note"><dt>Note</dt><dd>This does not return the same text as the base class method <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a0091f53a29b7082e51f8682ab8e36643" title="Return a text value associated with this Node (not including its child nodes if any); the behavior de...">Node::getNodeText()</a> does in the case of an element node; that returns the element tag word not its contents. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element. ">setValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element. ">updValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6fbe1243e8e2e83ceb3925659181065d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::updValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, one will be added to it here with a null-string value so that we can return a reference to it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab42eeb91fc1f6d3ad570d0db925870ce" title="Get the text value of this value element. ">getValue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87d99f6f31da37e122ee14dcb7281238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the text value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, one will be added to it here so that we have a place to hold the <em>value</em>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aae65d97f9b00e4418d5602e77bb5fb66" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03fd52a31abb8f1626d7902c747b02d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setValueAs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a80c0f5ebe69e44375f32f508ba2c19ce" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>

</div>
</div>
<a class="anchor" id="a3250133e91118e41e46f925f05556cec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getValueAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming this is a "value element", convert its text value to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a665fafcd7535ac1db55c9ed81caea4c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::getValueAs </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3250133e91118e41e46f925f05556cec" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects. </p>

</div>
</div>
<a class="anchor" id="af527410d9e2b0483da3b7384d8c497ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getRequiredElementValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text value of a child value element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one this refers to the first one. Then the element is expected to contain either zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes; if none we'll return a null string, otherwise the value of the <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node. Thus an element like "&lt;tag&gt;stuff&lt;/tag&gt;" will have the value "stuff". An error will be thrown if either the element is not found or it is not a "value element". </p>

</div>
</div>
<a class="anchor" id="aaeeab5895d7485590ab1fec6177c7a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::Element::getOptionalElementValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string. </p>
<p>If the child element is found, it must be a "value element" as defined above. </p>

</div>
</div>
<a class="anchor" id="acd51b037e620848e76d1591cdb26a457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getRequiredElementValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of a required child value element to the type of the template argument T. </p>
<p>It is an error if the element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the required child text element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the text element, converted to an object of type T. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf04099eb57a7ce81de228ba6b2c034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getOptionalElementValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of an optional child value element, if present, to the type of the template argument T. </p>
<p>It is an error if the child element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) If the child element is not present, then return a supplied default value of type T. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the optional child element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if child element is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of element <em>tag</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6545733fba05a6349cee654d8d2167b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this element has an attribute of this name. </p>

</div>
</div>
<a class="anchor" id="a8c04ffb38dc3e908fd559c7c542ad559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one. </p>

</div>
</div>
<a class="anchor" id="a03e4d7a877ad3a514412e78e3efc6ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::eraseAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an attribute of this element if it exists, otherwise do nothing. </p>
<p>If you need to know if the attribute exists, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab6545733fba05a6349cee654d8d2167b" title="Return true if this element has an attribute of this name. ">hasAttribute()</a>. There is no removeAttribute() that orphans an existing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>, but you can easily recreate one with the same name and value. </p>

</div>
</div>
<a class="anchor" id="a65d6cb52b56efd3d9a1202ac827e1812"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getRequiredAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an attribute as a string and throw an error if that attribute is not present. </p>

</div>
</div>
<a class="anchor" id="a12c6820ae4a6507752eefd1ea960fd46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getRequiredAttributeValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of a required attribute to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae54dacef8bea4acac95a89ce5aefb44d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::Element::getOptionalAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The string to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default string <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a24d8bc6dc30f3d97af5a393a7b057b83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getOptionalAttributeValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the value of an optional attribute, if present, from a string to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) If the attribute is not present, then return a supplied default value of type T. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad904c330f4cec26a4e5793bed0441445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> SimTK::Xml::Element::getRequiredAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present. </p>

</div>
</div>
<a class="anchor" id="aacd827d22b75b6202b7461b2ab90ddeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> SimTK::Xml::Element::getOptionalAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present. </p>

</div>
</div>
<a class="anchor" id="a34d797fd21a8b3d851616dc8d00241a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&gt; SimTK::Xml::Element::getAllAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element. </p>
<p>Attributes are returned in the order that they appear in the element tag. <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> names within a tag are unique; if the source document had repeated attribute names only the last one to appear is retained and that's the only one we'll find here. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Attribute&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">attribute_begin</a>(), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c">attribute_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2e80bd8d9c3421ba9d1113579f9acf47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> SimTK::Xml::Element::attribute_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through all the attributes of this element. </p>
<p>If there are no attributes then the returned <a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a>. </p>

</div>
</div>
<a class="anchor" id="ab4ba2c678473eaab3218db79e67e671c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> SimTK::Xml::Element::attribute_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab4ba2c678473eaab3218db79e67e671c" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a> iterator indicates the end of a sequence of attributes. </p>

</div>
</div>
<a class="anchor" id="af295f46c76adc5bbdfac98b6f1a80b82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this element has a child element with this tag. </p>

</div>
</div>
<a class="anchor" id="a1495f916a3d8924d4ead80592c2034ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>

</div>
</div>
<a class="anchor" id="a1ee99cd86e3e413234c7b4bf9e2d5bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::getRequiredElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to a child element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one only the first one is returned. If you want to see all children with this tag, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329" title="Return an array containing Element handles referencing all the immediate child elements contained in ...">getAllElements()</a> or use an <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>. </p>

</div>
</div>
<a class="anchor" id="a3772785ece91bcccba9da75e89eecbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::getOptionalElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle. </p>
<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a8a08c6ea7d9b3362a5b2af3b7012d09a" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid()</a> method. </p>

</div>
</div>
<a class="anchor" id="af9c43f8749c9def7a0b65136e8fc1329"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&gt; SimTK::Xml::Element::getAllElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word). </p>
<p>Elements are returned in the order they are seen in the document. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Element&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">element_begin</a>(tag), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2">element_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a60f0a78da097f84bf67bef22bb5b5372"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&gt; SimTK::Xml::Element::getAllNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types. </p>
<p>Nodes are returned in the order they are seen in the document. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Node&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">node_begin</a>(allowed), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790">node_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8f9e8c86fb08bd3c0ffd397e0186acb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> SimTK::Xml::Element::element_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied. </p>
<p>If there are no children with the <em>allowed</em> tag then the returned <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a>. </p>

</div>
</div>
<a class="anchor" id="a7c1f3e8fced7b1bb5b081b9cb5af9fa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> SimTK::Xml::Element::element_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7c1f3e8fced7b1bb5b081b9cb5af9fa2" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used. </p>

</div>
</div>
<a class="anchor" id="a9d3c5ff58a4653ffac14b19447f8c718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::Element::node_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="classSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>
<p>If there are no children of the <em>allowed</em> types then the returned <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>

</div>
</div>
<a class="anchor" id="aad74f7074ef8b528f9e9ac5fed950790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::Element::node_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad74f7074ef8b528f9e9ac5fed950790" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used. </p>

</div>
</div>
<a class="anchor" id="a569474bd297296231c6078cc050a8521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Xml::Element::isA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an element node. </p>

</div>
</div>
<a class="anchor" id="a869b394c523a22dc160a5990850457e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; SimTK::Xml::Element::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node. ">isA()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad15f74e7946e1abb0026eff29803cbd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; SimTK::Xml::Element::getAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node. ">isA()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aee787d4b6e5639c308b632173814ece7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Xml::Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4ee202f3a1549ce45c613ddce919565"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">Xml::element_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml.html">Xml</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:28 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
