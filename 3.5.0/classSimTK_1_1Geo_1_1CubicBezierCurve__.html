<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::Geo::CubicBezierCurve_&lt; P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1Geo_1_1CubicBezierCurve__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSimTK_1_1Geo_1_1CubicBezierCurve__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Geo::CubicBezierCurve_&lt; P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a primitive useful for computations involving a single cubic Bezier curve segment.  
 <a href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36ce498f865ed44de40873147f81a28b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a36ce498f865ed44de40873147f81a28b">CubicBezierCurve_</a> ()</td></tr>
<tr class="memdesc:a36ce498f865ed44de40873147f81a28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an uninitialized curve; control points will be garbage.  <a href="#a36ce498f865ed44de40873147f81a28b">More...</a><br /></td></tr>
<tr class="separator:a36ce498f865ed44de40873147f81a28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08404d6fa1d73a3675611dc4a234bdb7"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a08404d6fa1d73a3675611dc4a234bdb7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a08404d6fa1d73a3675611dc4a234bdb7">CubicBezierCurve_</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;controlPoints)</td></tr>
<tr class="memdesc:a08404d6fa1d73a3675611dc4a234bdb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a cubic Bezier curve using the given control points B=[b0 b1 b2 b3].  <a href="#a08404d6fa1d73a3675611dc4a234bdb7">More...</a><br /></td></tr>
<tr class="separator:a08404d6fa1d73a3675611dc4a234bdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a6db7c799b247175be025cefacd742"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:af7a6db7c799b247175be025cefacd742"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#af7a6db7c799b247175be025cefacd742">CubicBezierCurve_</a> (const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;controlPoints)</td></tr>
<tr class="memdesc:af7a6db7c799b247175be025cefacd742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature accepts a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> of control points, although they are stored internally as a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>.  <a href="#af7a6db7c799b247175be025cefacd742">More...</a><br /></td></tr>
<tr class="separator:af7a6db7c799b247175be025cefacd742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b6a6db263373ce49ebe85734b9fede"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#aa3b6a6db263373ce49ebe85734b9fede">getControlPoints</a> () const </td></tr>
<tr class="memdesc:aa3b6a6db263373ce49ebe85734b9fede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the Bezier control points B=[b0 b1 b2 b3] that are stored in this object.  <a href="#aa3b6a6db263373ce49ebe85734b9fede">More...</a><br /></td></tr>
<tr class="separator:aa3b6a6db263373ce49ebe85734b9fede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d1e9154951994c03974ad9bba413c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac1d1e9154951994c03974ad9bba413c0">calcAlgebraicCoefficients</a> () const </td></tr>
<tr class="memdesc:ac1d1e9154951994c03974ad9bba413c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the algebraic coefficients A=[a3 a2 a1 a0] from the stored Bezier control points.  <a href="#ac1d1e9154951994c03974ad9bba413c0">More...</a><br /></td></tr>
<tr class="separator:ac1d1e9154951994c03974ad9bba413c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237940a1e0a1dafac24997d5c8518b12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a237940a1e0a1dafac24997d5c8518b12">calcHermiteCoefficients</a> () const </td></tr>
<tr class="memdesc:a237940a1e0a1dafac24997d5c8518b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Hermite (geometric) coefficients H=[h0 h1 hu0 hu1] from the stored Bezier control points.  <a href="#a237940a1e0a1dafac24997d5c8518b12">More...</a><br /></td></tr>
<tr class="separator:a237940a1e0a1dafac24997d5c8518b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4071407185cdc4fc64d22f046fc344ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a4071407185cdc4fc64d22f046fc344ee">evalP</a> (RealP u) const </td></tr>
<tr class="memdesc:a4071407185cdc4fc64d22f046fc344ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a point on this curve given a value for parameter u in [0,1].  <a href="#a4071407185cdc4fc64d22f046fc344ee">More...</a><br /></td></tr>
<tr class="separator:a4071407185cdc4fc64d22f046fc344ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e7cc3d38f1e84006cc8aff65c48ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a44e7cc3d38f1e84006cc8aff65c48ec4">evalPu</a> (RealP u) const </td></tr>
<tr class="memdesc:a44e7cc3d38f1e84006cc8aff65c48ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the tangent Pu=dP/du on this curve given a value for parameter u in [0,1].  <a href="#a44e7cc3d38f1e84006cc8aff65c48ec4">More...</a><br /></td></tr>
<tr class="separator:a44e7cc3d38f1e84006cc8aff65c48ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab484dbe857482d7cffde20caaa745da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ab484dbe857482d7cffde20caaa745da1">evalPuu</a> (RealP u) const </td></tr>
<tr class="memdesc:ab484dbe857482d7cffde20caaa745da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the second derivative Puu=d2P/du2 on this curve given a value for parameter u in [0,1].  <a href="#ab484dbe857482d7cffde20caaa745da1">More...</a><br /></td></tr>
<tr class="separator:ab484dbe857482d7cffde20caaa745da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec92f7e3c7281df04744ca700378a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a98ec92f7e3c7281df04744ca700378a1">evalPuuu</a> (RealP u) const </td></tr>
<tr class="memdesc:a98ec92f7e3c7281df04744ca700378a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the third derivative Puuu=d3P/du3 on this curve.  <a href="#a98ec92f7e3c7281df04744ca700378a1">More...</a><br /></td></tr>
<tr class="separator:a98ec92f7e3c7281df04744ca700378a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cbc43383316b762d1d91ae0fa6b6dd"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a05cbc43383316b762d1d91ae0fa6b6dd">calcDsdu</a> (RealP u) const </td></tr>
<tr class="memdesc:a05cbc43383316b762d1d91ae0fa6b6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ds/du, the change in arc length per change in curve parameter.  <a href="#a05cbc43383316b762d1d91ae0fa6b6dd">More...</a><br /></td></tr>
<tr class="separator:a05cbc43383316b762d1d91ae0fa6b6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad91e8ce3787f01b099b1478b073888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a8ad91e8ce3787f01b099b1478b073888">calcUnitTangent</a> (RealP u) const </td></tr>
<tr class="memdesc:a8ad91e8ce3787f01b099b1478b073888"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit tangent vector t=dP/ds where s is the arc length.  <a href="#a8ad91e8ce3787f01b099b1478b073888">More...</a><br /></td></tr>
<tr class="separator:a8ad91e8ce3787f01b099b1478b073888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c00b824c39edc2f85f110db3962ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac7c00b824c39edc2f85f110db3962ecf">calcCurvatureVector</a> (RealP u) const </td></tr>
<tr class="memdesc:ac7c00b824c39edc2f85f110db3962ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The curvature vector c=dt/ds where t is the unit tangent vector (t=dP/ds) and s is arclength.  <a href="#ac7c00b824c39edc2f85f110db3962ecf">More...</a><br /></td></tr>
<tr class="separator:ac7c00b824c39edc2f85f110db3962ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72427ee5222d35894261592e6efb5dc"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ad72427ee5222d35894261592e6efb5dc">calcCurvatureSqr</a> (RealP u)</td></tr>
<tr class="memdesc:ad72427ee5222d35894261592e6efb5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return k^2, the square of the scalar curvature k at the point P(u) on the curve.  <a href="#ad72427ee5222d35894261592e6efb5dc">More...</a><br /></td></tr>
<tr class="separator:ad72427ee5222d35894261592e6efb5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7e9e9b9264d7ac01b009b6009b40ba"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#afe7e9e9b9264d7ac01b009b6009b40ba">calcTorsion</a> (RealP u)</td></tr>
<tr class="memdesc:afe7e9e9b9264d7ac01b009b6009b40ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return tau, the torsion or "second curvature".  <a href="#afe7e9e9b9264d7ac01b009b6009b40ba">More...</a><br /></td></tr>
<tr class="separator:afe7e9e9b9264d7ac01b009b6009b40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec146262aedfae4c9c39461921469fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#adec146262aedfae4c9c39461921469fa">calcUnitNormal</a> (RealP u) const </td></tr>
<tr class="memdesc:adec146262aedfae4c9c39461921469fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">In our definition, the unit normal vector n points in the "outward" direction, that is, it points away from the center of curvature (opposite the curvature vector).  <a href="#adec146262aedfae4c9c39461921469fa">More...</a><br /></td></tr>
<tr class="separator:adec146262aedfae4c9c39461921469fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad1467b379d414ef0a3e0ea4afd891c"><td class="memItemLeft" align="right" valign="top">RealP&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2ad1467b379d414ef0a3e0ea4afd891c">calcCurveFrame</a> (RealP u, <a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;X_FP) const </td></tr>
<tr class="memdesc:a2ad1467b379d414ef0a3e0ea4afd891c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the magnitude of the curvature (always positive), and a frame whose origin is a point along the curve, x axis is the outward unit normal n, y is the unit tangent t, and z=x X y is the binormal b, which is a normal to the osculating plane.  <a href="#a2ad1467b379d414ef0a3e0ea4afd891c">More...</a><br /></td></tr>
<tr class="separator:a2ad1467b379d414ef0a3e0ea4afd891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75511b4c0d3f64ad7a0503c10657fe94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a75511b4c0d3f64ad7a0503c10657fe94">split</a> (RealP u, <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;left, <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;right) const </td></tr>
<tr class="memdesc:a75511b4c0d3f64ad7a0503c10657fe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this curve into two at a point u=t such that 0 &lt; t &lt; 1, such that the first curve coincides with the u=0..t segment of this curve, and the second coincides with the u=t..1 segment.  <a href="#a75511b4c0d3f64ad7a0503c10657fe94">More...</a><br /></td></tr>
<tr class="separator:a75511b4c0d3f64ad7a0503c10657fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5c771ade9d296569a67a1fe9563d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a37d5c771ade9d296569a67a1fe9563d7">bisect</a> (<a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;left, <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;right) const </td></tr>
<tr class="memdesc:a37d5c771ade9d296569a67a1fe9563d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split this curve into two at the point u=1/2 (halfway in parameter space, not necessarily in arclength).  <a href="#a37d5c771ade9d296569a67a1fe9563d7">More...</a><br /></td></tr>
<tr class="separator:a37d5c771ade9d296569a67a1fe9563d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d50499c65cc62290ea2a1a8e98e60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a64d50499c65cc62290ea2a1a8e98e60f">calcBoundingSphere</a> () const </td></tr>
<tr class="memdesc:a64d50499c65cc62290ea2a1a8e98e60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sphere that surrounds the entire curve segment in the u=[0..1] range.  <a href="#a64d50499c65cc62290ea2a1a8e98e60f">More...</a><br /></td></tr>
<tr class="separator:a64d50499c65cc62290ea2a1a8e98e60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bfc1619db9ae3252964d99a6aabc56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a22bfc1619db9ae3252964d99a6aabc56">calcAxisAlignedBoundingBox</a> () const </td></tr>
<tr class="memdesc:a22bfc1619db9ae3252964d99a6aabc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an axis-aligned bounding box (AABB) that surrounds the entire curve segment in the u=[0..1] range.  <a href="#a22bfc1619db9ae3252964d99a6aabc56">More...</a><br /></td></tr>
<tr class="separator:a22bfc1619db9ae3252964d99a6aabc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af22a5f96a1b472644a627069cfd63b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt; P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a6af22a5f96a1b472644a627069cfd63b">calcOrientedBoundingBox</a> () const </td></tr>
<tr class="memdesc:a6af22a5f96a1b472644a627069cfd63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an oriented bounding box (OBB) that surrounds the entire curve segment in the u=[0..1] range.  <a href="#a6af22a5f96a1b472644a627069cfd63b">More...</a><br /></td></tr>
<tr class="separator:a6af22a5f96a1b472644a627069cfd63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These static methods provide operations useful for working with cubic Bezier curves.</p>
<p>See the <a class="el" href="classSimTK_1_1Geo_1_1CubicHermiteCurve__.html" title="A primitive useful for computations involving a single cubic Hermite curve segment in algebraic or ge...">CubicHermiteCurve_</a> class for related operations. </p>
</div></td></tr>
<tr class="memitem:a9ded8e01657d7ab207f6b0fcd80cb476"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a9ded8e01657d7ab207f6b0fcd80cb476">calcFb</a> (RealP u)</td></tr>
<tr class="memdesc:a9ded8e01657d7ab207f6b0fcd80cb476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Bernstein basis functions Fb=[B0..B3] for a given value of the parameter u.  <a href="#a9ded8e01657d7ab207f6b0fcd80cb476">More...</a><br /></td></tr>
<tr class="separator:a9ded8e01657d7ab207f6b0fcd80cb476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a0477259920ab874dd46ee073ab89a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a10a0477259920ab874dd46ee073ab89a">calcDFb</a> (RealP u)</td></tr>
<tr class="memdesc:a10a0477259920ab874dd46ee073ab89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate first derivatives dFb=[B0u..B3u] of the Bernstein basis functions for a given value of the parameter u.  <a href="#a10a0477259920ab874dd46ee073ab89a">More...</a><br /></td></tr>
<tr class="separator:a10a0477259920ab874dd46ee073ab89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2918f759160d6829ff399118b02226"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a8d2918f759160d6829ff399118b02226">calcD2Fb</a> (RealP u)</td></tr>
<tr class="memdesc:a8d2918f759160d6829ff399118b02226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate second derivatives d2Fb=[B0uu..B3uu] of the Bernstein basis functions for a given value of the parameter u.  <a href="#a8d2918f759160d6829ff399118b02226">More...</a><br /></td></tr>
<tr class="separator:a8d2918f759160d6829ff399118b02226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac379a49f6d6c4c0b509d9179f0854a62"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac379a49f6d6c4c0b509d9179f0854a62">calcD3Fb</a> (RealP u)</td></tr>
<tr class="memdesc:ac379a49f6d6c4c0b509d9179f0854a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate third derivatives d3Fb=[B0uuu..B3uuu] of the Bernstein basis functions for a given value of the parameter u.  <a href="#ac379a49f6d6c4c0b509d9179f0854a62">More...</a><br /></td></tr>
<tr class="separator:ac379a49f6d6c4c0b509d9179f0854a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5b595a06b7b973dcb411cbbb897d4f"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a2e5b595a06b7b973dcb411cbbb897d4f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2e5b595a06b7b973dcb411cbbb897d4f">calcAFromB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B)</td></tr>
<tr class="memdesc:a2e5b595a06b7b973dcb411cbbb897d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0].  <a href="#a2e5b595a06b7b973dcb411cbbb897d4f">More...</a><br /></td></tr>
<tr class="separator:a2e5b595a06b7b973dcb411cbbb897d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045449904ff74280c84ced2ba984f942"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a045449904ff74280c84ced2ba984f942"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a045449904ff74280c84ced2ba984f942">calcBFromA</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;A)</td></tr>
<tr class="memdesc:a045449904ff74280c84ced2ba984f942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the algebraic coefficients A=~[a3 a2 a1 a0], return the Bezier control points B=~[b0 b1 b2 b3].  <a href="#a045449904ff74280c84ced2ba984f942">More...</a><br /></td></tr>
<tr class="separator:a045449904ff74280c84ced2ba984f942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d1a2751bc83b0ff63edb3f257bb61a"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a45d1a2751bc83b0ff63edb3f257bb61a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a45d1a2751bc83b0ff63edb3f257bb61a">calcHFromB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B)</td></tr>
<tr class="memdesc:a45d1a2751bc83b0ff63edb3f257bb61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the Bezier control points B=~[b0 b1 b2 b3], return the Hermite coefficients H=~[h0 h1 hu0 hu1].  <a href="#a45d1a2751bc83b0ff63edb3f257bb61a">More...</a><br /></td></tr>
<tr class="separator:a45d1a2751bc83b0ff63edb3f257bb61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba251795f7f5d027db6f89fad2c66a8b"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:aba251795f7f5d027db6f89fad2c66a8b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#aba251795f7f5d027db6f89fad2c66a8b">calcBFromH</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;H)</td></tr>
<tr class="memdesc:aba251795f7f5d027db6f89fad2c66a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the Hermite coefficients H=~[h0 h1 hu0 hu1], return the Bezier control points B=~[b0 b1 b2 b3].  <a href="#aba251795f7f5d027db6f89fad2c66a8b">More...</a><br /></td></tr>
<tr class="separator:aba251795f7f5d027db6f89fad2c66a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc87ec42c2908aedf587a77e36f7e4a"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a2fc87ec42c2908aedf587a77e36f7e4a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2fc87ec42c2908aedf587a77e36f7e4a">evalPUsingB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B, RealP u)</td></tr>
<tr class="memdesc:a2fc87ec42c2908aedf587a77e36f7e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Bezier control points B and a value for the curve parameter u, return the point P(u) at that location.  <a href="#a2fc87ec42c2908aedf587a77e36f7e4a">More...</a><br /></td></tr>
<tr class="separator:a2fc87ec42c2908aedf587a77e36f7e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383b29c7421610073a56a99dac0995b7"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a383b29c7421610073a56a99dac0995b7"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a383b29c7421610073a56a99dac0995b7">evalPuUsingB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B, RealP u)</td></tr>
<tr class="memdesc:a383b29c7421610073a56a99dac0995b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Bezier control points B and a value for the curve parameter u, return the first derivative Pu(u)=dP/du at that location.  <a href="#a383b29c7421610073a56a99dac0995b7">More...</a><br /></td></tr>
<tr class="separator:a383b29c7421610073a56a99dac0995b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2820528a29afcc5d3240d271c22d21"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:aad2820528a29afcc5d3240d271c22d21"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#aad2820528a29afcc5d3240d271c22d21">evalPuuUsingB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B, RealP u)</td></tr>
<tr class="memdesc:aad2820528a29afcc5d3240d271c22d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Bezier control points B and a value for the curve parameter u, return the second derivative Puu(u)=d2P/du2 at that location.  <a href="#aad2820528a29afcc5d3240d271c22d21">More...</a><br /></td></tr>
<tr class="separator:aad2820528a29afcc5d3240d271c22d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730f7feadc4e5bfb59a4db19b9f1c8bf"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a730f7feadc4e5bfb59a4db19b9f1c8bf"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a730f7feadc4e5bfb59a4db19b9f1c8bf">evalPuuuUsingB</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;B, RealP u)</td></tr>
<tr class="memdesc:a730f7feadc4e5bfb59a4db19b9f1c8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given Bezier control points B and a value for the curve parameter u, return the third derivative Puuu(u)=d3P/du3 at that location.  <a href="#a730f7feadc4e5bfb59a4db19b9f1c8bf">More...</a><br /></td></tr>
<tr class="separator:a730f7feadc4e5bfb59a4db19b9f1c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0310ef1601b6572d69f7cae32dac615"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac0310ef1601b6572d69f7cae32dac615">getMb</a> ()</td></tr>
<tr class="memdesc:ac0310ef1601b6572d69f7cae32dac615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the Bezier basis matrix Mb explicitly.  <a href="#ac0310ef1601b6572d69f7cae32dac615">More...</a><br /></td></tr>
<tr class="separator:ac0310ef1601b6572d69f7cae32dac615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3118ba3d6fb9de63ee8b53e2678fde42"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a3118ba3d6fb9de63ee8b53e2678fde42"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a3118ba3d6fb9de63ee8b53e2678fde42">multiplyByMb</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;b)</td></tr>
<tr class="memdesc:a3118ba3d6fb9de63ee8b53e2678fde42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form the product of the Bezier basis matrix Mb and a 4-vector, exploiting the structure of Mb.  <a href="#a3118ba3d6fb9de63ee8b53e2678fde42">More...</a><br /></td></tr>
<tr class="separator:a3118ba3d6fb9de63ee8b53e2678fde42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef83520507f2f8adf5af9eadc3a94121"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#aef83520507f2f8adf5af9eadc3a94121">getMbInv</a> ()</td></tr>
<tr class="memdesc:aef83520507f2f8adf5af9eadc3a94121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the inverse inv(Mb) of the Bezier basis matrix explicitly.  <a href="#aef83520507f2f8adf5af9eadc3a94121">More...</a><br /></td></tr>
<tr class="separator:aef83520507f2f8adf5af9eadc3a94121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd34bb0e33cae22df7e68fbb879d75b"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a6dd34bb0e33cae22df7e68fbb879d75b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a6dd34bb0e33cae22df7e68fbb879d75b">multiplyByMbInv</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;b)</td></tr>
<tr class="memdesc:a6dd34bb0e33cae22df7e68fbb879d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form the product of the inverse inv(Mb) of the Bezier basis matrix Mb and a 4-vector, exploiting the structure of inv(Mb).  <a href="#a6dd34bb0e33cae22df7e68fbb879d75b">More...</a><br /></td></tr>
<tr class="separator:a6dd34bb0e33cae22df7e68fbb879d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e00928895ef8362cc96bcfbf501611f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a3e00928895ef8362cc96bcfbf501611f">getMhInvMb</a> ()</td></tr>
<tr class="memdesc:a3e00928895ef8362cc96bcfbf501611f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the product Mh^-1*Mb explicitly; this is the matrix used for conversion from Bezier to Hermite bases since H=Mh^-1 Mb B and is the inverse of the matrix Mb^-1*Mh.  <a href="#a3e00928895ef8362cc96bcfbf501611f">More...</a><br /></td></tr>
<tr class="separator:a3e00928895ef8362cc96bcfbf501611f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27846947b6f7ff002ca29eb3515a626c"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a27846947b6f7ff002ca29eb3515a626c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a27846947b6f7ff002ca29eb3515a626c">multiplyByMhInvMb</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;v)</td></tr>
<tr class="memdesc:a27846947b6f7ff002ca29eb3515a626c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector v, form the product inv(Mh)*Mb*v, exploiting the structure of the constant matrix inv(Mh)*Mb (not symmetric).  <a href="#a27846947b6f7ff002ca29eb3515a626c">More...</a><br /></td></tr>
<tr class="separator:a27846947b6f7ff002ca29eb3515a626c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ea21fc21858a28609518401dee9f9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt; 4, 4, P &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac9ea21fc21858a28609518401dee9f9a">getMbInvMh</a> ()</td></tr>
<tr class="memdesc:ac9ea21fc21858a28609518401dee9f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the product Mb^-1*Mh explicitly; this is the matrix used for conversion from Hermite to Bezier bases since B=Mb^-1 Mh H and is the inverse of the matrix Mh^-1*Mb.  <a href="#ac9ea21fc21858a28609518401dee9f9a">More...</a><br /></td></tr>
<tr class="separator:ac9ea21fc21858a28609518401dee9f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9085d56aa501a9c9c677734e42e28"><td class="memTemplParams" colspan="2">template&lt;int S&gt; </td></tr>
<tr class="memitem:a69d9085d56aa501a9c9c677734e42e28"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a69d9085d56aa501a9c9c677734e42e28">multiplyByMbInvMh</a> (const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;v)</td></tr>
<tr class="memdesc:a69d9085d56aa501a9c9c677734e42e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector v, form the product inv(Mb)*Mh*v, exploiting the structure of the constant matrix inv(Mb)*Mh (not symmetric).  <a href="#a69d9085d56aa501a9c9c677734e42e28">More...</a><br /></td></tr>
<tr class="separator:a69d9085d56aa501a9c9c677734e42e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class P&gt;<br />
class SimTK::Geo::CubicBezierCurve_&lt; P &gt;</h3>

<p>This is a primitive useful for computations involving a single cubic Bezier curve segment. </p>
<p>Objects of this class contain the Bezier control points, but these can easily be converted to algebraic or Hermite coefficients. A useful feature of the Bezier control points representation is that the curve (not necessarily planar) lies within the convex hull of the four control points. We can use that fact to create a bounding sphere or oriented bounding box around the curve. We can check whether the control points are already convex to ensure that the contained curve is well behaved, and subdivide if not.</p>
<p>Note that a cubic Bezier spline (made up of multiple segments) would not necessarily be composed of these because a spline can be contructed more compactly with shared end points. However, the primitive and inline methods here can be used for fast curve segment computations.</p>
<h3>Theory</h3>
<p>The primary reference for this implementation is the book "Geometric Modeling, 
3rd ed." by Michael E. Mortenson, Industrial Press 2006, chapter 4. We follow Mortenson's notation here (with some name changes) and equation numbers are from the text. See <a class="el" href="classSimTK_1_1Geo_1_1CubicHermiteCurve__.html" title="A primitive useful for computations involving a single cubic Hermite curve segment in algebraic or ge...">CubicHermiteCurve_</a> comments for an introduction; here we add the Bezier description to the algebraic and Hermite (geometric) forms described there.</p>
<p>The curve is parameterized by a scalar u in [0..1], such that points on the curve, and their derivatives with respect to u are given by </p><pre>
    P(u)    =    B0(u) b0 +    B1(u) b1 +    B2(u) b2 +    B3(u) b3        (4.2)
    Pu(u)   =   B0u(u) b0 +   B1u(u) b1 +   B2u(u) b2 +   B3u(u) b3
    Puu(u)  =  B0uu(u) b0 +  B1uu(u) b1 +  B2uu(u) b2 +  B3uu(u) b3
    Puuu(u) = B0uuu(u) b0 + B1uuu(u) b1 + B2uuu(u) b2 + B3uuu(u) b3
</pre><p> where the Bi's are the (scalar) Bernstein polynomials given by </p><pre>
    B0(u) =      (1-u)^3 =  -u^3 + 3u^2 - 3u + 1                           (4.5)
    B1(u) = 3 u  (1-u)^2 =  3u^3 - 6u^2 + 3u
    B2(u) = 3 u^2(1-u)   = -3u^3 + 3u^2
    B3(u) =   u^3        =   u^3</pre><pre>    B0u(u) = -3u^2 +  6u - 3  B0uu(u) =  -6u +  6  B0uuu(u) =  -6       
    B1u(u) =  9u^2 - 12u + 3  B1uu(u) =  18u - 12  B1uuu(u) =  18   
    B2u(u) = -9u^2 +  6u      B2uu(u) = -18u +  6  B2uuu(u) = -18
    B3u(u) =  3u^2            B3uu(u) =   6u       B3uuu(u) =   6
</pre><p> In matrix notation, let Fb=[B0 B1 B2 B3], and U=[u^3 u^2 u 1]. Then Fb = U Mb where Mb, the Bezier basis transformation matrix, and its inverse are: </p><pre>
         [ -1  3 -3  1 ]             [ 0  0   0  1 ]
    Mb = [  3 -6  3  0 ]   inv(Mb) = [ 0  0  1/3 1 ]
         [ -3  3  0  0 ]             [ 0 1/3 2/3 1 ] 
         [  1  0  0  0 ]             [ 1  1   1  1 ]
</pre><p> Now we can write the algebraic, Hermite, and Bezier forms in matrix notation. Let A=~[a3 a2 a1 a0], H=~[h0 h1 hu0 hu1], B=~[b0 b1 b2 b3]. We have </p><pre>
    P(u) = U A = U Mh H = U Mb B                                           (4.7)
       A = Mh H = Mb B
       H = inv(Mh) A = inv(Mh) Mb B                                        (4.8)
       B = inv(Mb) A = inv(Mb) Mh H                                        (4.9)
</pre><p> where these equations show how to convert among the algebraic, Hermite, and Bezier forms. Note that while U, Fb, Mh, and Mb are ordinary matrices, A, H, and B are hypermatrices since their elements are 3-vectors. Multiplying out the matrix products gives: </p><pre>
               [  1  0  0  0 ]                 [ 1  0   0   0  ]
    Mh^-1 Mb = [  0  0  0  1 ]      Mb^-1 Mh = [ 1  0  1/3  0  ]
               [ -3  3  0  0 ]                 [ 0  1   0 -1/3 ] 
               [  0  0 -3  3 ]                 [ 0  1   0   0  ]
</pre><p> Because of the sparsity of the matrices and the many common subexpressions above, it saves a considerable amount of computation to work out the necessary products by hand, and this implementation does that. For example, to find the Bezier control points B given the Hermite coefficients H, or vice versa, the matrix-vector multiply would take 3x28=84 flops, while the hand-worked versions are: </p><pre>
       [h0 ]     -1       [    b0   ]         [b0]     -1       [   h0     ]
   H = [h1 ] = Mh  Mb B = [    b3   ]     B = [b1] = Mb  Mh H = [h0 + hu0/3]
       [hu0]              [3 (b1-b0)]         [b2]              [h1 - hu1/3]               
       [hu1]              [3 (b3-b2)]         [b3]              [   h1     ] 
</pre><p> which instead take 3x4=12 flops, 7X faster. Conversion between Bezier and algebraic is a little more expensive: </p><pre>
              [ b3-b0 + 3 (b1-b2) ]                  [         a0          ]
   A = Mb B = [ 3 (b0+b2) - 6 b1  ]    B = Mb^-1 A = [     a1/3 + a0       ]
              [    3 (b1-b0)      ]                  [  (a2 + 2 a1)/3 + a0 ]
              [        b0         ]                  [  a3 + a2 + a1 + a0  ]
</pre><p> which take about 3x10=30 flops, still almost 3X faster than a matrix-vector multiply.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo_1_1CubicHermiteCurve__.html" title="A primitive useful for computations involving a single cubic Hermite curve segment in algebraic or ge...">CubicHermiteCurve_</a>, <a class="el" href="classSimTK_1_1Geo_1_1BicubicBezierPatch__.html" title="A primitive useful for computations involving a single bicubic Bezier patch. ">BicubicBezierPatch_</a>, <a class="el" href="classSimTK_1_1Geo_1_1BicubicHermitePatch__.html" title="A primitive useful for computations involving a single bicubic Hermite patch. ">BicubicHermitePatch_</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a36ce498f865ed44de40873147f81a28b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an uninitialized curve; control points will be garbage. </p>

</div>
</div>
<a class="anchor" id="a08404d6fa1d73a3675611dc4a234bdb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>controlPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a cubic Bezier curve using the given control points B=[b0 b1 b2 b3]. </p>

</div>
</div>
<a class="anchor" id="af7a6db7c799b247175be025cefacd742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::<a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>controlPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature accepts a <a class="el" href="classSimTK_1_1Row.html" title="This is a fixed-length row vector designed for no-overhead inline computation. ">Row</a> of control points, although they are stored internally as a <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa3b6a6db263373ce49ebe85734b9fede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt;&amp; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::getControlPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the Bezier control points B=[b0 b1 b2 b3] that are stored in this object. </p>

</div>
</div>
<a class="anchor" id="ac1d1e9154951994c03974ad9bba413c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcAlgebraicCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the algebraic coefficients A=[a3 a2 a1 a0] from the stored Bezier control points. </p>
<p>Cost is 30 flops. </p>

</div>
</div>
<a class="anchor" id="a237940a1e0a1dafac24997d5c8518b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcHermiteCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Hermite (geometric) coefficients H=[h0 h1 hu0 hu1] from the stored Bezier control points. </p>
<p>Cost is 12 flops. </p>

</div>
</div>
<a class="anchor" id="a4071407185cdc4fc64d22f046fc344ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalP </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a point on this curve given a value for parameter u in [0,1]. </p>
<p>Values outside this range are permitted but do not lie on the curve segment. Cost is 20 flops. </p>

</div>
</div>
<a class="anchor" id="a44e7cc3d38f1e84006cc8aff65c48ec4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPu </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the tangent Pu=dP/du on this curve given a value for parameter u in [0,1]. </p>
<p>Values outside this range are permitted but do not lie on the curve segment. Cost is 15 flops. </p>

</div>
</div>
<a class="anchor" id="ab484dbe857482d7cffde20caaa745da1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPuu </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the second derivative Puu=d2P/du2 on this curve given a value for parameter u in [0,1]. </p>
<p>Values outside this range are permitted but do not lie on the curve segment. Cost is 10 flops. </p>

</div>
</div>
<a class="anchor" id="a98ec92f7e3c7281df04744ca700378a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPuuu </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the third derivative Puuu=d3P/du3 on this curve. </p>
<p>Parameter u is ignored here since the 3rd derivative of a cubic curve is a constant. Cost is 3 flops. </p>

</div>
</div>
<a class="anchor" id="a05cbc43383316b762d1d91ae0fa6b6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcDsdu </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return ds/du, the change in arc length per change in curve parameter. </p>
<p>This is the magnitude of the tangent vector Pu=dP/du. Cost is about 40 flops. </p>

</div>
</div>
<a class="anchor" id="a8ad91e8ce3787f01b099b1478b073888"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcUnitTangent </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The unit tangent vector t=dP/ds where s is the arc length. </p>
<p>This is undefined at a cusp (Pu(u)==0). Cost is about 55 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo.html#adf1c55e619734a5ccb71e118d69b942c" title="Calculate the unit tangent vector t=dP/ds, given Pu=dP/du. ">Geo::calcUnitTangent()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c00b824c39edc2f85f110db3962ecf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcCurvatureVector </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The curvature vector c=dt/ds where t is the unit tangent vector (t=dP/ds) and s is arclength. </p>
<p>Cost is about 55 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo.html#a0cc3486aecf214573b6273bcbbc13135" title="Return the curvature vector c=dt/ds=d2P/ds2, given Pu=dP/du and Puu=d2P/du2. ">Geo::calcCurvatureVector()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="ad72427ee5222d35894261592e6efb5dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcCurvatureSqr </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return k^2, the square of the scalar curvature k at the point P(u) on the curve. </p>
<p>Curvature is undefined at a cusp (where Pu==0) and is zero at an inflection point (|Pu X Puu|==0). Cost is about 31 flops. </p>

</div>
</div>
<a class="anchor" id="afe7e9e9b9264d7ac01b009b6009b40ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcTorsion </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return tau, the torsion or "second curvature". </p>
<p>Torsion is a signed quantity related to the rate of change of the osculating plane binormal b, with db/ds=tau*n where n is the "outward" unit normal. Torsion is undefined at either a cusp (where Pu==0) or an inflection point (where |Pu X Puu|==0). Cost is about 30 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo.html#abebb31a8e7e26b191ce5eb347e6c4084" title="Return tau, the torsion or &quot;second curvature&quot; given Pu=dP/du, Puu=d2P/du2, Puuu=d3P/du3. ">Geo::calcTorsion()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="adec146262aedfae4c9c39461921469fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnitVec.html">UnitVec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcUnitNormal </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In our definition, the unit normal vector n points in the "outward" direction, that is, it points away from the center of curvature (opposite the curvature vector). </p>
<p>The normal is undefined at a cusp (Pu(u)==0), and arbitrary at an inflection point (|Pu X Puu|==0). If the curve is a straight line then every point has Puu==0, so the normal is arbitrary everywhere. Cost is about 105 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo.html#a91f2d03400710d64e9102acb4713dc59" title="In our definition, the unit normal vector n points in the &quot;outward&quot; direction, that is...">Geo::calcUnitNormal()</a> for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ad1467b379d414ef0a3e0ea4afd891c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealP <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcCurveFrame </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Transform__.html">TransformP</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the magnitude of the curvature (always positive), and a frame whose origin is a point along the curve, x axis is the outward unit normal n, y is the unit tangent t, and z=x X y is the binormal b, which is a normal to the osculating plane. </p>
<p>So the vectors n,t,b form a right-handed set; this convention is different from Struik's since he has n pointing the opposite direction. This frame is undefined at a cusp (Pu==0), and the normal is arbitrary at an inflection point (Puu(u)==0) or if the curve is a line (Puu==0 everywhere). Cost is about 160 flops. </p>

</div>
</div>
<a class="anchor" id="a75511b4c0d3f64ad7a0503c10657fe94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::split </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split this curve into two at a point u=t such that 0 &lt; t &lt; 1, such that the first curve coincides with the u=0..t segment of this curve, and the second coincides with the u=t..1 segment. </p>
<p>Each of the new curves is reparameterized so that its curve parameter goes from 0 to 1. This method is only allowed for tol &lt;= t &lt;= 1-tol where tol is the default tolerance for this precision. Cost is 3x15=45 flops. </p>

</div>
</div>
<a class="anchor" id="a37d5c771ade9d296569a67a1fe9563d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::bisect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split this curve into two at the point u=1/2 (halfway in parameter space, not necessarily in arclength). </p>
<p>This is a faster special case of the <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a75511b4c0d3f64ad7a0503c10657fe94" title="Split this curve into two at a point u=t such that 0 &lt; t &lt; 1, such that the first curve coincides wit...">split()</a> method. Cost is 3x10=30 flops. </p>

</div>
</div>
<a class="anchor" id="a64d50499c65cc62290ea2a1a8e98e60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1Sphere__.html">Geo::Sphere_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcBoundingSphere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a sphere that surrounds the entire curve segment in the u=[0..1] range. </p>
<p>We use the fact that the curve is enclosed within the convex hull of its control points and generate the minimum bounding sphere that includes all four control points. </p>

</div>
</div>
<a class="anchor" id="a22bfc1619db9ae3252964d99a6aabc56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1AlignedBox__.html">Geo::AlignedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcAxisAlignedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an axis-aligned bounding box (AABB) that surrounds the entire curve segment in the u=[0..1] range. </p>
<p>We use the fact that the curve is enclosed within the convex hull of its control points and generate the minimum axis-aligned box that includes all four control points. </p>

</div>
</div>
<a class="anchor" id="a6af22a5f96a1b472644a627069cfd63b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Geo_1_1OrientedBox__.html">Geo::OrientedBox_</a>&lt;P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcOrientedBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an oriented bounding box (OBB) that surrounds the entire curve segment in the u=[0..1] range. </p>
<p>We use the fact that the curve is enclosed within the convex hull of its control points and generate an oriented bounding box that includes all four control points. </p>

</div>
</div>
<a class="anchor" id="a9ded8e01657d7ab207f6b0fcd80cb476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcFb </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the Bernstein basis functions Fb=[B0..B3] for a given value of the parameter u. </p>
<p>This is an optimized calculation of U*Mb, taking 9 flops. </p>

</div>
</div>
<a class="anchor" id="a10a0477259920ab874dd46ee073ab89a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcDFb </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate first derivatives dFb=[B0u..B3u] of the Bernstein basis functions for a given value of the parameter u. </p>
<p>Cost is 10 flops. </p>

</div>
</div>
<a class="anchor" id="a8d2918f759160d6829ff399118b02226"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcD2Fb </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate second derivatives d2Fb=[B0uu..B3uu] of the Bernstein basis functions for a given value of the parameter u. </p>
<p>Cost is 5 flops. </p>

</div>
</div>
<a class="anchor" id="ac379a49f6d6c4c0b509d9179f0854a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Row.html">Row</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcD3Fb </td>
          <td>(</td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate third derivatives d3Fb=[B0uuu..B3uuu] of the Bernstein basis functions for a given value of the parameter u. </p>
<p>For a cubic curve this is just a constant. Cost is 0 flops. </p>

</div>
</div>
<a class="anchor" id="a2e5b595a06b7b973dcb411cbbb897d4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcAFromB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0]. </p>
<p>All coefficients are 3-vectors. Cost is 30 flops. </p>

</div>
</div>
<a class="anchor" id="a045449904ff74280c84ced2ba984f942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcBFromA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the algebraic coefficients A=~[a3 a2 a1 a0], return the Bezier control points B=~[b0 b1 b2 b3]. </p>
<p>All coefficients are 3-vectors. Cost is 27 flops. </p>

</div>
</div>
<a class="anchor" id="a45d1a2751bc83b0ff63edb3f257bb61a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcHFromB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the Bezier control points B=~[b0 b1 b2 b3], return the Hermite coefficients H=~[h0 h1 hu0 hu1]. </p>
<p>All coefficients are 3-vectors. Cost is 12 flops. </p>

</div>
</div>
<a class="anchor" id="aba251795f7f5d027db6f89fad2c66a8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,<a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::calcBFromH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the Hermite coefficients H=~[h0 h1 hu0 hu1], return the Bezier control points B=~[b0 b1 b2 b3]. </p>
<p>All coefficients are 3-vectors. Cost is 12 flops. </p>

</div>
</div>
<a class="anchor" id="a2fc87ec42c2908aedf587a77e36f7e4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPUsingB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Bezier control points B and a value for the curve parameter u, return the point P(u) at that location. </p>
<p>Cost is 30 flops. Note that if you need to do this for the same curve more than twice, it is cheaper to convert to algebraic form using <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2e5b595a06b7b973dcb411cbbb897d4f" title="Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0]...">calcAFromB()</a> (30 flops) and then evaluate using A (20 flops). </p>

</div>
</div>
<a class="anchor" id="a383b29c7421610073a56a99dac0995b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPuUsingB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Bezier control points B and a value for the curve parameter u, return the first derivative Pu(u)=dP/du at that location. </p>
<p>Cost is 31 flops. Note that if you need to do this for the same curve more than once, it is cheaper to convert to algebraic form using <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2e5b595a06b7b973dcb411cbbb897d4f" title="Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0]...">calcAFromB()</a> (30 flops) and then evaluate using A (15 flops). </p>

</div>
</div>
<a class="anchor" id="aad2820528a29afcc5d3240d271c22d21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPuuUsingB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Bezier control points B and a value for the curve parameter u, return the second derivative Puu(u)=d2P/du2 at that location. </p>
<p>Cost is 26 flops. Note that if you need to do this for the same curve more than once, it is cheaper to convert to algebraic form using <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2e5b595a06b7b973dcb411cbbb897d4f" title="Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0]...">calcAFromB()</a> (30 flops) and then evaluate using A (10 flops). </p>

</div>
</div>
<a class="anchor" id="a730f7feadc4e5bfb59a4db19b9f1c8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a> <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::evalPuuuUsingB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, <a class="el" href="classSimTK_1_1Vec.html">Vec3P</a>, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealP&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given Bezier control points B and a value for the curve parameter u, return the third derivative Puuu(u)=d3P/du3 at that location. </p>
<p>Cost is 21 flops. Note that if you need to do this for the same curve more than once, it is cheaper to convert to algebraic form using <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a2e5b595a06b7b973dcb411cbbb897d4f" title="Given the Bezier control points B=~[b0 b1 b2 b3], return the algebraic coefficients A=~[a3 a2 a1 a0]...">calcAFromB()</a> (30 flops) and then evaluate using A (3 flops). </p>

</div>
</div>
<a class="anchor" id="ac0310ef1601b6572d69f7cae32dac615"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::getMb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the Bezier basis matrix Mb explicitly. </p>
<p>This is mostly useful for testing since specialized routines can save a lot of CPU time over working directly in matrix form. This is a constant matrix so there is no computation cost. The matrix is symmetric although we return a full 4x4 here. </p>

</div>
</div>
<a class="anchor" id="a3118ba3d6fb9de63ee8b53e2678fde42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::multiplyByMb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Form the product of the Bezier basis matrix Mb and a 4-vector, exploiting the structure of Mb. </p>
<p>Since Mb is symmetric you can also use this for multiplication by a row from the left, i.e. ~b*Mb=~(~Mb*b)=~(Mb*b). Cost is 10 flops. </p>

</div>
</div>
<a class="anchor" id="aef83520507f2f8adf5af9eadc3a94121"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::getMbInv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the inverse inv(Mb) of the Bezier basis matrix explicitly. </p>
<p>This is mostly useful for testing since specialized routines can save a lot of CPU time over working directly in matrix form. This is a constant matrix so there is no computation cost. The matrix is symmetric although we return a full 4x4 here. </p>

</div>
</div>
<a class="anchor" id="a6dd34bb0e33cae22df7e68fbb879d75b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::multiplyByMbInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Form the product of the inverse inv(Mb) of the Bezier basis matrix Mb and a 4-vector, exploiting the structure of inv(Mb). </p>
<p>Since inv(Mb) is symmetric you can also use this for multiplication by a row from the left, i.e. ~b*Mb^-1=~(Mb^-T*b)=~(Mb^-1*b). Cost is 9 flops. </p>

</div>
</div>
<a class="anchor" id="a3e00928895ef8362cc96bcfbf501611f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::getMhInvMb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the product Mh^-1*Mb explicitly; this is the matrix used for conversion from Bezier to Hermite bases since H=Mh^-1 Mb B and is the inverse of the matrix Mb^-1*Mh. </p>
<p>This is mostly useful for testing since specialized routines can save a lot of CPU time over working directly in matrix form. There is a very efficient method for forming matrix-vector products with this matrix. This is a constant matrix so there is no computation cost. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a27846947b6f7ff002ca29eb3515a626c" title="Given a vector v, form the product inv(Mh)*Mb*v, exploiting the structure of the constant matrix inv(...">multiplyByMhInvMb()</a>, <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#ac9ea21fc21858a28609518401dee9f9a" title="Obtain the product Mb^-1*Mh explicitly; this is the matrix used for conversion from Hermite to Bezier...">getMbInvMh()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a27846947b6f7ff002ca29eb3515a626c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::multiplyByMhInvMb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector v, form the product inv(Mh)*Mb*v, exploiting the structure of the constant matrix inv(Mh)*Mb (not symmetric). </p>
<p>Cost is 4 flops. </p>

</div>
</div>
<a class="anchor" id="ac9ea21fc21858a28609518401dee9f9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Mat.html">Mat</a>&lt;4,4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::getMbInvMh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the product Mb^-1*Mh explicitly; this is the matrix used for conversion from Hermite to Bezier bases since B=Mb^-1 Mh H and is the inverse of the matrix Mh^-1*Mb. </p>
<p>This matrix is not symmetric. This method is mostly useful for testing since specialized routines can save a lot of CPU time over working directly in matrix form. There is a very efficient method for forming matrix-vector products with this matrix. This is a constant matrix so there is no computation cost here. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a27846947b6f7ff002ca29eb3515a626c" title="Given a vector v, form the product inv(Mh)*Mb*v, exploiting the structure of the constant matrix inv(...">multiplyByMhInvMb()</a>, <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html#a3e00928895ef8362cc96bcfbf501611f" title="Obtain the product Mh^-1*Mb explicitly; this is the matrix used for conversion from Bezier to Hermite...">getMhInvMb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a69d9085d56aa501a9c9c677734e42e28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P&gt; </div>
<div class="memtemplate">
template&lt;int S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt;4,P&gt; <a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">SimTK::Geo::CubicBezierCurve_</a>&lt; P &gt;::multiplyByMbInvMh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; 4, P, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a vector v, form the product inv(Mb)*Mh*v, exploiting the structure of the constant matrix inv(Mb)*Mh (not symmetric). </p>
<p>Cost is 4 flops. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Geo_8h_source.html">Geo.h</a></li>
<li><a class="el" href="Geo__CubicBezierCurve_8h_source.html">Geo_CubicBezierCurve.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Geo.html">Geo</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Geo_1_1CubicBezierCurve__.html">CubicBezierCurve_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:14 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
