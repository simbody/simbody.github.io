<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::ArrayViewConst_&lt; T, X &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1ArrayViewConst__.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classSimTK_1_1ArrayViewConst__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ArrayViewConst_&lt; T, X &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> which is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>; here we provide only the minimal read-only "const" functionality required by any <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> object, and shallow copy semantics.  
 <a href="classSimTK_1_1ArrayViewConst__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::ArrayViewConst_&lt; T, X &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1ArrayViewConst__.png" usemap="#SimTK::ArrayViewConst_5F_3C_20T_2C_20X_20_3E_map" alt=""/>
  <map id="SimTK::ArrayViewConst_5F_3C_20T_2C_20X_20_3E_map" name="SimTK::ArrayViewConst_&lt; T, X &gt;_map">
<area href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t..." alt="SimTK::ArrayView_&lt; T, X &gt;" shape="rect" coords="0,56,202,80"/>
<area href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l..." alt="SimTK::Array_&lt; T, X &gt;" shape="rect" coords="0,112,202,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types required of STL containers, plus index_type which is an extension, and packed_size_type which is an implementation detail.</p>
</div></td></tr>
<tr class="memitem:a39bda86e859db1597f4d49d8037d0660"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td></tr>
<tr class="memdesc:a39bda86e859db1597f4d49d8037d0660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored in this container.  <a href="#a39bda86e859db1597f4d49d8037d0660">More...</a><br /></td></tr>
<tr class="separator:a39bda86e859db1597f4d49d8037d0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bca96f3089b5f0d4133fce9c7cded"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td></tr>
<tr class="memdesc:af92bca96f3089b5f0d4133fce9c7cded"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (an extension).  <a href="#af92bca96f3089b5f0d4133fce9c7cded">More...</a><br /></td></tr>
<tr class="separator:af92bca96f3089b5f0d4133fce9c7cded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825bef320398cbf8d8f2e2b8631632e"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td></tr>
<tr class="memdesc:a2825bef320398cbf8d8f2e2b8631632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable pointer to a value_type.  <a href="#a2825bef320398cbf8d8f2e2b8631632e">More...</a><br /></td></tr>
<tr class="separator:a2825bef320398cbf8d8f2e2b8631632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc551f402dc69766e819733ee6f08b"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td></tr>
<tr class="memdesc:a7fdc551f402dc69766e819733ee6f08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const pointer to a value_type.  <a href="#a7fdc551f402dc69766e819733ee6f08b">More...</a><br /></td></tr>
<tr class="separator:a7fdc551f402dc69766e819733ee6f08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce6f572b1deffcefa3f3aae5263b1c"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td></tr>
<tr class="memdesc:aacce6f572b1deffcefa3f3aae5263b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable value_type reference.  <a href="#aacce6f572b1deffcefa3f3aae5263b1c">More...</a><br /></td></tr>
<tr class="separator:aacce6f572b1deffcefa3f3aae5263b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460302f601c4a2c2d63837cb1e5d875a"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td></tr>
<tr class="memdesc:a460302f601c4a2c2d63837cb1e5d875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const value_type reference.  <a href="#a460302f601c4a2c2d63837cb1e5d875a">More...</a><br /></td></tr>
<tr class="separator:a460302f601c4a2c2d63837cb1e5d875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a8bff8ad197d4dfb2d41866acbd23"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td></tr>
<tr class="memdesc:a416a8bff8ad197d4dfb2d41866acbd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable iterator for this container (same as pointer here).  <a href="#a416a8bff8ad197d4dfb2d41866acbd23">More...</a><br /></td></tr>
<tr class="separator:a416a8bff8ad197d4dfb2d41866acbd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76215b9c0677fca5706f11038f496963"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td></tr>
<tr class="memdesc:a76215b9c0677fca5706f11038f496963"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for this container (same as const_pointer here).  <a href="#a76215b9c0677fca5706f11038f496963">More...</a><br /></td></tr>
<tr class="separator:a76215b9c0677fca5706f11038f496963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b566573f0b94c804a6b6e0514c78bce"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td></tr>
<tr class="memdesc:a4b566573f0b94c804a6b6e0514c78bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable reverse iterator for this container.  <a href="#a4b566573f0b94c804a6b6e0514c78bce">More...</a><br /></td></tr>
<tr class="separator:a4b566573f0b94c804a6b6e0514c78bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d002d51080ddd32f8899e5ea3ea40"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab26d002d51080ddd32f8899e5ea3ea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reverse iterator for this container.  <a href="#ab26d002d51080ddd32f8899e5ea3ea40">More...</a><br /></td></tr>
<tr class="separator:ab26d002d51080ddd32f8899e5ea3ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaff64afd3daaed43f1acecbe2bbfe7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td></tr>
<tr class="memdesc:abaaff64afd3daaed43f1acecbe2bbfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integral type suitable for all indices and sizes for this array.  <a href="#abaaff64afd3daaed43f1acecbe2bbfe7">More...</a><br /></td></tr>
<tr class="separator:abaaff64afd3daaed43f1acecbe2bbfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f604d5e70ddbe7eb0bf9a80a236951e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td></tr>
<tr class="memdesc:a1f604d5e70ddbe7eb0bf9a80a236951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference between any two legitimate index values for this array.  <a href="#a1f604d5e70ddbe7eb0bf9a80a236951e">More...</a><br /></td></tr>
<tr class="separator:a1f604d5e70ddbe7eb0bf9a80a236951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fd47de6bffe601337c1ef0a45e88d"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td></tr>
<tr class="memdesc:af01fd47de6bffe601337c1ef0a45e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type we actually use internally to store size_type values.  <a href="#af01fd47de6bffe601337c1ef0a45e88d">More...</a><br /></td></tr>
<tr class="separator:af01fd47de6bffe601337c1ef0a45e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, conversion, and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructors here are limited to those that don't allocate new data, and can only accept const data to reference.</p>
<p>Copy assignment is suppressed. </p>
</div></td></tr>
<tr class="memitem:a6008f8ca816619f1b4a67c94027a2d59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a6008f8ca816619f1b4a67c94027a2d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="#a6008f8ca816619f1b4a67c94027a2d59">More...</a><br /></td></tr>
<tr class="separator:a6008f8ca816619f1b4a67c94027a2d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412fa0b837f5e090f343180b2dbcdc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">ArrayViewConst_</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> &amp;src)</td></tr>
<tr class="memdesc:a5412fa0b837f5e090f343180b2dbcdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; the constructed const array object will be referencing the original source data.  <a href="#a5412fa0b837f5e090f343180b2dbcdc8">More...</a><br /></td></tr>
<tr class="separator:a5412fa0b837f5e090f343180b2dbcdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba351ab4073da6f9d4c13855b039df6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">ArrayViewConst_</a> (const T *first, const T *last1)</td></tr>
<tr class="memdesc:aba351ab4073da6f9d4c13855b039df6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data.  <a href="#aba351ab4073da6f9d4c13855b039df6b">More...</a><br /></td></tr>
<tr class="separator:aba351ab4073da6f9d4c13855b039df6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">ArrayViewConst_</a> (const std::vector&lt; T, A &gt; &amp;src)</td></tr>
<tr class="memdesc:acbb823ad8bafa05dae5c1a06b426c4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion.  <a href="#acbb823ad8bafa05dae5c1a06b426c4a8">More...</a><br /></td></tr>
<tr class="separator:acbb823ad8bafa05dae5c1a06b426c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cef62772e0c408bd3e0529417b8948"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a00cef62772e0c408bd3e0529417b8948">operator const ArrayView_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a00cef62772e0c408bd3e0529417b8948"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements.  <a href="#a00cef62772e0c408bd3e0529417b8948">More...</a><br /></td></tr>
<tr class="separator:a00cef62772e0c408bd3e0529417b8948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a0b84ff4f9dd8981c5a978e2750f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a306a0b84ff4f9dd8981c5a978e2750f5">operator const Array_&lt; T, X &gt; &amp;</a> () const </td></tr>
<tr class="memdesc:a306a0b84ff4f9dd8981c5a978e2750f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data.  <a href="#a306a0b84ff4f9dd8981c5a978e2750f5">More...</a><br /></td></tr>
<tr class="separator:a306a0b84ff4f9dd8981c5a978e2750f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace600fbc0738888ceef29cc7c0846643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">disconnect</a> ()</td></tr>
<tr class="memdesc:ace600fbc0738888ceef29cc7c0846643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed.  <a href="#ace600fbc0738888ceef29cc7c0846643">More...</a><br /></td></tr>
<tr class="separator:ace600fbc0738888ceef29cc7c0846643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34fb008e433a59e3957ab27b811839"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">~ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a5f34fb008e433a59e3957ab27b811839"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information.  <a href="#a5f34fb008e433a59e3957ab27b811839">More...</a><br /></td></tr>
<tr class="separator:a5f34fb008e433a59e3957ab27b811839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Size and capacity</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods examine the number of elements (size) or the amount of allocated heap space (capacity).</p>
<p>See the derived Array_&lt;T,X&gt; class for methods that can <em>change</em> the size or capacity. </p>
</div></td></tr>
<tr class="memitem:a4571082d90592c7b0f6761140e11edb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3">size</a> () const </td></tr>
<tr class="memdesc:a4571082d90592c7b0f6761140e11edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="#a4571082d90592c7b0f6761140e11edb3">More...</a><br /></td></tr>
<tr class="separator:a4571082d90592c7b0f6761140e11edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff9e3f09bd7f0ca14dec2861a626ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea">max_size</a> () const </td></tr>
<tr class="memdesc:a4dff9e3f09bd7f0ca14dec2861a626ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="#a4dff9e3f09bd7f0ca14dec2861a626ea">More...</a><br /></td></tr>
<tr class="separator:a4dff9e3f09bd7f0ca14dec2861a626ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45ba916abcb168e7337b80890c8d68c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad45ba916abcb168e7337b80890c8d68c">empty</a> () const </td></tr>
<tr class="memdesc:ad45ba916abcb168e7337b80890c8d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="#ad45ba916abcb168e7337b80890c8d68c">More...</a><br /></td></tr>
<tr class="separator:ad45ba916abcb168e7337b80890c8d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df09ea748ac2750e730981e7563526f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f">capacity</a> () const </td></tr>
<tr class="memdesc:a3df09ea748ac2750e730981e7563526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="#a3df09ea748ac2750e730981e7563526f">More...</a><br /></td></tr>
<tr class="separator:a3df09ea748ac2750e730981e7563526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1c27ea8ca7b9f3411d438693fd8a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3c1c27ea8ca7b9f3411d438693fd8a2a">allocated</a> () const </td></tr>
<tr class="memdesc:a3c1c27ea8ca7b9f3411d438693fd8a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners.  <a href="#a3c1c27ea8ca7b9f3411d438693fd8a2a">More...</a><br /></td></tr>
<tr class="separator:a3c1c27ea8ca7b9f3411d438693fd8a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c40081730e9681d6102972f42904f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a30c40081730e9681d6102972f42904f1">isOwner</a> () const </td></tr>
<tr class="memdesc:a30c40081730e9681d6102972f42904f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="#a30c40081730e9681d6102972f42904f1">More...</a><br /></td></tr>
<tr class="separator:a30c40081730e9681d6102972f42904f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Read-only element access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide read-only (const) access to individual elements that are currently present in the array.</p>
<p>The derived ArrayView_&lt;T,X&gt; class adds the non-const versions of these methods. </p>
</div></td></tr>
<tr class="memitem:afa06a13341105ac7773a9c6bcd6a851c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#afa06a13341105ac7773a9c6bcd6a851c">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:afa06a13341105ac7773a9c6bcd6a851c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="#afa06a13341105ac7773a9c6bcd6a851c">More...</a><br /></td></tr>
<tr class="separator:afa06a13341105ac7773a9c6bcd6a851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5d31ec735550ba4b262b8e5f387020"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b5d31ec735550ba4b262b8e5f387020">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a4b5d31ec735550ba4b262b8e5f387020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="#a4b5d31ec735550ba4b262b8e5f387020">More...</a><br /></td></tr>
<tr class="separator:a4b5d31ec735550ba4b262b8e5f387020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8a30f98edabfef434169ac33831e2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2af8a30f98edabfef434169ac33831e2">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const </td></tr>
<tr class="memdesc:a2af8a30f98edabfef434169ac33831e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="#a2af8a30f98edabfef434169ac33831e2">More...</a><br /></td></tr>
<tr class="separator:a2af8a30f98edabfef434169ac33831e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5eed816397cc84bc47af96645e554"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a14d5eed816397cc84bc47af96645e554">front</a> () const </td></tr>
<tr class="memdesc:a14d5eed816397cc84bc47af96645e554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a14d5eed816397cc84bc47af96645e554">More...</a><br /></td></tr>
<tr class="separator:a14d5eed816397cc84bc47af96645e554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26683b980dcd87bafd5c6446d8f8b25b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a26683b980dcd87bafd5c6446d8f8b25b">back</a> () const </td></tr>
<tr class="memdesc:a26683b980dcd87bafd5c6446d8f8b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="#a26683b980dcd87bafd5c6446d8f8b25b">More...</a><br /></td></tr>
<tr class="separator:a26683b980dcd87bafd5c6446d8f8b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1816a17c6b643eb0967f954cdd96635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab1816a17c6b643eb0967f954cdd96635">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:ab1816a17c6b643eb0967f954cdd96635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying).  <a href="#ab1816a17c6b643eb0967f954cdd96635">More...</a><br /></td></tr>
<tr class="separator:ab1816a17c6b643eb0967f954cdd96635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288833be443e0f02d958f5cfe74312ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a288833be443e0f02d958f5cfe74312ba">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const </td></tr>
<tr class="memdesc:a288833be443e0f02d958f5cfe74312ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="#a288833be443e0f02d958f5cfe74312ba">More...</a><br /></td></tr>
<tr class="separator:a288833be443e0f02d958f5cfe74312ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Iterators (const only)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd772c6141bc079b47a9c8ce83534aa08"></a>These methods deal in iterators, which are STL generalized pointers.</p>
<p>For this class, iterators are just ordinary const pointers to T, and you may depend on that. By necessity, reverse iterators can't be just pointers; however, they contain an ordinary iterator (i.e. a pointer) that can be obtained by calling the reverse iterator's base() method. </p>
</td></tr>
<tr class="memitem:ac3e34902f0533ffbda435880fd8ce34b"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b">cbegin</a> () const </td></tr>
<tr class="memdesc:ac3e34902f0533ffbda435880fd8ce34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="#ac3e34902f0533ffbda435880fd8ce34b">More...</a><br /></td></tr>
<tr class="separator:ac3e34902f0533ffbda435880fd8ce34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664dc29fe9f3d2d3f38433774d9c3a4"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4">cend</a> () const </td></tr>
<tr class="memdesc:a0664dc29fe9f3d2d3f38433774d9c3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="#a0664dc29fe9f3d2d3f38433774d9c3a4">More...</a><br /></td></tr>
<tr class="separator:a0664dc29fe9f3d2d3f38433774d9c3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8cb9dedb2d0710570621910a016108"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108">begin</a> () const </td></tr>
<tr class="memdesc:a0f8cb9dedb2d0710570621910a016108"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>.  <a href="#a0f8cb9dedb2d0710570621910a016108">More...</a><br /></td></tr>
<tr class="separator:a0f8cb9dedb2d0710570621910a016108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6349807c889c1155e01d429e264b08e8"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8">end</a> () const </td></tr>
<tr class="memdesc:a6349807c889c1155e01d429e264b08e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="#a6349807c889c1155e01d429e264b08e8">More...</a><br /></td></tr>
<tr class="separator:a6349807c889c1155e01d429e264b08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9a931016a896c03b783f7a5bb2824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824">crbegin</a> () const </td></tr>
<tr class="memdesc:aaca9a931016a896c03b783f7a5bb2824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="#aaca9a931016a896c03b783f7a5bb2824">More...</a><br /></td></tr>
<tr class="separator:aaca9a931016a896c03b783f7a5bb2824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4736f16ae05ebee9e34077072496436b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b">crend</a> () const </td></tr>
<tr class="memdesc:a4736f16ae05ebee9e34077072496436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="#a4736f16ae05ebee9e34077072496436b">More...</a><br /></td></tr>
<tr class="separator:a4736f16ae05ebee9e34077072496436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de43406f71aed2fc534da92c4005256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256">rbegin</a> () const </td></tr>
<tr class="memdesc:a4de43406f71aed2fc534da92c4005256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256" title="The const version of rbegin() is the same as crbegin(). ">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="#a4de43406f71aed2fc534da92c4005256">More...</a><br /></td></tr>
<tr class="separator:a4de43406f71aed2fc534da92c4005256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0d66ba65094d8b6cf75922d846ff3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c">rend</a> () const </td></tr>
<tr class="memdesc:a6e0d66ba65094d8b6cf75922d846ff3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c" title="The const version of rend() is the same as crend(). ">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="#a6e0d66ba65094d8b6cf75922d846ff3c">More...</a><br /></td></tr>
<tr class="separator:a6e0d66ba65094d8b6cf75922d846ff3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2cf338eaf2590b4085bfb110470388"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388">cdata</a> () const </td></tr>
<tr class="memdesc:a4b2cf338eaf2590b4085bfb110470388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="#a4b2cf338eaf2590b4085bfb110470388">More...</a><br /></td></tr>
<tr class="separator:a4b2cf338eaf2590b4085bfb110470388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f2581b552a2df91b8f2b7f9abae43d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d">data</a> () const </td></tr>
<tr class="memdesc:aa9f2581b552a2df91b8f2b7f9abae43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="#aa9f2581b552a2df91b8f2b7f9abae43d">More...</a><br /></td></tr>
<tr class="separator:aa9f2581b552a2df91b8f2b7f9abae43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X&gt;<br />
class SimTK::ArrayViewConst_&lt; T, X &gt;</h3>

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> which is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>; here we provide only the minimal read-only "const" functionality required by any <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> object, and shallow copy semantics. </p>
<p>The ability to write is added by the <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> class, and the additional ability to reallocate, insert, erase, etc. is added by the <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> class.</p>
<p>This class is particularly useful for recasting existing const data into a const <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> without copying. For example a const std::vector can be passed to a const Array&amp; argument by an implicit, near-zero cost conversion to an <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> which can then convert to a const Array&amp;.</p>
<p>An <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> is given all the data it is going to have at the time it is constructed (except when it is being accessed from the derived <a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a> class that has more capability). The contents and size of a <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> cannot be changed after construction. In particular, the default copy assignment operator is suppressed. The destructor simply disconnects the <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> handle from the data it was referencing; no element destruction or heap deallocation occurs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored in this container. </td></tr>
    <tr><td class="paramname">X</td><td>The type to be used for indexing this container, with default unsigned (not size_t). Any integral type may be used, as well as user types that satisfy the requirements discussed with class <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html" title="The SimTK::Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template l...">Array_</a>, <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>, <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a39bda86e859db1597f4d49d8037d0660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of object stored in this container. </p>

</div>
</div>
<a class="anchor" id="af92bca96f3089b5f0d4133fce9c7cded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type (an extension). </p>

</div>
</div>
<a class="anchor" id="a2825bef320398cbf8d8f2e2b8631632e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A writable pointer to a value_type. </p>

</div>
</div>
<a class="anchor" id="a7fdc551f402dc69766e819733ee6f08b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const pointer to a value_type. </p>

</div>
</div>
<a class="anchor" id="aacce6f572b1deffcefa3f3aae5263b1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A writable value_type reference. </p>

</div>
</div>
<a class="anchor" id="a460302f601c4a2c2d63837cb1e5d875a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const value_type reference. </p>

</div>
</div>
<a class="anchor" id="a416a8bff8ad197d4dfb2d41866acbd23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A writable iterator for this container (same as pointer here). </p>

</div>
</div>
<a class="anchor" id="a76215b9c0677fca5706f11038f496963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const iterator for this container (same as const_pointer here). </p>

</div>
</div>
<a class="anchor" id="a4b566573f0b94c804a6b6e0514c78bce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A writable reverse iterator for this container. </p>

</div>
</div>
<a class="anchor" id="ab26d002d51080ddd32f8899e5ea3ea40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const reverse iterator for this container. </p>

</div>
</div>
<a class="anchor" id="abaaff64afd3daaed43f1acecbe2bbfe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integral type suitable for all indices and sizes for this array. </p>

</div>
</div>
<a class="anchor" id="a1f604d5e70ddbe7eb0bf9a80a236951e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signed integral type that can represent the difference between any two legitimate index values for this array. </p>

</div>
</div>
<a class="anchor" id="af01fd47de6bffe601337c1ef0a45e88d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ArrayIndexPackType&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integral type we actually use internally to store size_type values. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6008f8ca816619f1b4a67c94027a2d59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor allocates no heap space and is very fast. </p>

</div>
</div>
<a class="anchor" id="a5412fa0b837f5e090f343180b2dbcdc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is shallow; the constructed const array object will be referencing the original source data. </p>
<p>However, if the source is zero length, this will result in a default-constructed array view handle with a null data pointer, even if the source had some unused data allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The object whose data will be referenced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time; extremely fast. </dd></dl>

</div>
</div>
<a class="anchor" id="aba351ab4073da6f9d4c13855b039df6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data. </p>
<p>This will work as long as the size of the source data does not exceed the array's max_size. The resulting object is not resizeable but can be used to read elements of the original data. This will becomes invalid if the original data is destructed or resized, but there is no way for the <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> class to detect that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>A pointer to the first data element to be referenced. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A pointer to the position one element past the last one in the range to be referenced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source data is empty, the resulting <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> will also be empty and will look as though it had been default-constructed.</li>
<li>You can break the connection between the array handle and the data it was constructed from by calling <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a>. </li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>first &lt;= last1, last1-first &lt;= <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array. ">max_size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acbb823ad8bafa05dae5c1a06b426c4a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<div class="memtemplate">
template&lt;class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion. </p>
<p>This will work as long as the size of the vector does not exceed the array's max_size. The resulting array object is not resizeable but can be used to read elements of the original std::vector. The array becomes invalid if the original std::vector is destructed or resized, but there is no way for the array class to detect that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The std::vector&lt;T&gt; whose data will be referenced by the constructed <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>If the source std::vector is empty, the resulting array will also be empty and will look as though it had been default-constructed. It will therefore not have any connection to the source vector.</li>
<li>This is quite dangerous to use since the connection between the array and the vector is tenuous and subject to the vector remaining untouched during the lifetime of the array handle. There is no reference counting; destructing the vector leaves the array referring to garbage. Be careful!</li>
<li>You can break the connection between the array view and the vector it was constructed from by calling <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a>. </li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>src.size() &lt;= <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4dff9e3f09bd7f0ca14dec2861a626ea" title="Return the maximum allowable size for this array. ">max_size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap. There will be no construction, destruction, or heap allocation performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5f34fb008e433a59e3957ab27b811839"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::~<a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a00cef62772e0c408bd3e0529417b8948"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::operator const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements. </p>

</div>
</div>
<a class="anchor" id="a306a0b84ff4f9dd8981c5a978e2750f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::operator const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data. </p>

</div>
</div>
<a class="anchor" id="ace600fbc0738888ceef29cc7c0846643"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed. </p>
<p>The data pointer will simply be set to null; we'll assume the owner will clean things up later. In either case the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a> and <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> will be zero after this call and <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> will return null (0). </p>

</div>
</div>
<a class="anchor" id="a4571082d90592c7b0f6761140e11edb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current number of elements stored in this array. </p>

</div>
</div>
<a class="anchor" id="a4dff9e3f09bd7f0ca14dec2861a626ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum allowable size for this array. </p>

</div>
</div>
<a class="anchor" id="ad45ba916abcb168e7337b80890c8d68c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if there are no elements currently stored in this array. </p>
<p>This is equivalent to the tests <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a>==<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a>==0. </p>

</div>
</div>
<a class="anchor" id="a3df09ea748ac2750e730981e7563526f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of elements this array can currently hold without requiring reallocation. </p>
<p>The value returned by <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> is always greater than or equal to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a>, even if the data is not owned by this array in which case we have <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a>==<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a> and the array is not reallocatable. </p>

</div>
</div>
<a class="anchor" id="a3c1c27ea8ca7b9f3411d438693fd8a2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a3df09ea748ac2750e730981e7563526f" title="Return the number of elements this array can currently hold without requiring reallocation. ">capacity()</a> for owner arrays but is zero for non-owners. </p>
<dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a30c40081730e9681d6102972f42904f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::isOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors. </p>
<p>If the array does not refer to any data it is considered to be an owner since it is resizeable. </p><dl class="section note"><dt>Note</dt><dd>There is no equivalent of this method for std::vector. </dd></dl>

</div>
</div>
<a class="anchor" id="afa06a13341105ac7773a9c6bcd6a851c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a const reference. </p>
<p>Note that only a value of the array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5d31ec735550ba4b262b8e5f387020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a2af8a30f98edabfef434169ac33831e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::getElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a class="anchor" id="a14d5eed816397cc84bc47af96645e554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release). </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="a26683b980dcd87bafd5c6446d8f8b25b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release). </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1816a17c6b643eb0967f954cdd96635"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the first element to be included in the subarray; this can be one past the end of the array if <em>length</em> is zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the subarray to be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new ArrayViewConst_&lt;T,X&gt; object referencing the original data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em>length==0</em> the returned array will be in a default-constructed, all-zero and null state with no connection to the original data. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>index</em> &gt;= 0, <em>length</em> &gt;= 0 </dd>
<dd>
<em>index</em> + <em>length</em> &lt;= <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4571082d90592c7b0f6761140e11edb3" title="Return the current number of elements stored in this array. ">size()</a> </dd>
<dd>
We'll validate preconditions in Debug builds but not Release. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap; no element construction or destruction or heap allocation is required. </dd></dl>

</div>
</div>
<a class="anchor" id="a288833be443e0f02d958f5cfe74312ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::getSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a class="anchor" id="ac3e34902f0533ffbda435880fd8ce34b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="a0664dc29fe9f3d2d3f38433774d9c3a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be. </p>
<p>This method is from the proposed C++0x standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a class="anchor" id="a0f8cb9dedb2d0710570621910a016108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0f8cb9dedb2d0710570621910a016108" title="The const version of begin() is the same as cbegin(). ">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="a6349807c889c1155e01d429e264b08e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6349807c889c1155e01d429e264b08e8" title="The const version of end() is the same as cend(). ">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>. </p>

</div>
</div>
<a class="anchor" id="aaca9a931016a896c03b783f7a5bb2824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty. </p>

</div>
</div>
<a class="anchor" id="a4736f16ae05ebee9e34077072496436b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a class="anchor" id="a4de43406f71aed2fc534da92c4005256"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4de43406f71aed2fc534da92c4005256" title="The const version of rbegin() is the same as crbegin(). ">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aaca9a931016a896c03b783f7a5bb2824" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>. </p>

</div>
</div>
<a class="anchor" id="a6e0d66ba65094d8b6cf75922d846ff3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6e0d66ba65094d8b6cf75922d846ff3c" title="The const version of rend() is the same as crend(). ">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4736f16ae05ebee9e34077072496436b" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>. </p>

</div>
</div>
<a class="anchor" id="a4b2cf338eaf2590b4085bfb110470388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a> does not appear to be in the C++0x standard although it would seem obvious in view of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac3e34902f0533ffbda435880fd8ce34b" title="Return a const pointer to the first element of this array if any, otherwise cend(), which may be null (0) in that case but does not have to be. ">cbegin()</a> and <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a0664dc29fe9f3d2d3f38433774d9c3a4" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a> methods that had to be added. The C++0x overloaded const <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> method is also available. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9f2581b552a2df91b8f2b7f9abae43d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa9f2581b552a2df91b8f2b7f9abae43d" title="The const version of the data() method is identical to cdata(). ">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b2cf338eaf2590b4085bfb110470388" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:06 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
