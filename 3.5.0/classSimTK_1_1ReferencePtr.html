<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::ReferencePtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1ReferencePtr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1ReferencePtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ReferencePtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a smart pointer that implements "cross reference" semantics where a pointer data member of some object is intended to refer to some target object in a larger data structure.  
 <a href="classSimTK_1_1ReferencePtr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acfa754609f3bd0da239932c1abe6393c"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#acfa754609f3bd0da239932c1abe6393c">element_type</a></td></tr>
<tr class="separator:acfa754609f3bd0da239932c1abe6393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc96cbd0f3977bc66c6b4dc85c904e71"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#afc96cbd0f3977bc66c6b4dc85c904e71">pointer</a></td></tr>
<tr class="separator:afc96cbd0f3977bc66c6b4dc85c904e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc2cf328cb84835e3cf13edb488e3c"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aa3bc2cf328cb84835e3cf13edb488e3c">reference</a></td></tr>
<tr class="separator:aa3bc2cf328cb84835e3cf13edb488e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8a4a78b56dde0a279a04eb2c53c79055"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a8a4a78b56dde0a279a04eb2c53c79055">ReferencePtr</a> ()</td></tr>
<tr class="memdesc:a8a4a78b56dde0a279a04eb2c53c79055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates an empty object.  <a href="#a8a4a78b56dde0a279a04eb2c53c79055">More...</a><br /></td></tr>
<tr class="separator:a8a4a78b56dde0a279a04eb2c53c79055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7839f4089295fc358ec6016251add5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a8d7839f4089295fc358ec6016251add5">ReferencePtr</a> (T *tp)</td></tr>
<tr class="memdesc:a8d7839f4089295fc358ec6016251add5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a given pointer stores the pointer.  <a href="#a8d7839f4089295fc358ec6016251add5">More...</a><br /></td></tr>
<tr class="separator:a8d7839f4089295fc358ec6016251add5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2002422169b77e31cf1acaea0351eb33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a2002422169b77e31cf1acaea0351eb33">ReferencePtr</a> (T &amp;t)</td></tr>
<tr class="memdesc:a2002422169b77e31cf1acaea0351eb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a reference stores the address of the supplied object.  <a href="#a2002422169b77e31cf1acaea0351eb33">More...</a><br /></td></tr>
<tr class="separator:a2002422169b77e31cf1acaea0351eb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f11b3cd26138d33bea1560efcbcc97c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a3f11b3cd26138d33bea1560efcbcc97c">ReferencePtr</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;)</td></tr>
<tr class="memdesc:a3f11b3cd26138d33bea1560efcbcc97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor unconditionally sets the pointer to null; see class comments for why.  <a href="#a3f11b3cd26138d33bea1560efcbcc97c">More...</a><br /></td></tr>
<tr class="separator:a3f11b3cd26138d33bea1560efcbcc97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8be04337c1db46084933f9e6a0afb43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ad8be04337c1db46084933f9e6a0afb43">operator=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;r)</td></tr>
<tr class="memdesc:ad8be04337c1db46084933f9e6a0afb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment sets the pointer to null (except for a self-assign); see class comments for why.  <a href="#ad8be04337c1db46084933f9e6a0afb43">More...</a><br /></td></tr>
<tr class="separator:ad8be04337c1db46084933f9e6a0afb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d02344e9f26f109465d4a2a1bf123ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a7d02344e9f26f109465d4a2a1bf123ce">operator=</a> (T &amp;t)</td></tr>
<tr class="memdesc:a7d02344e9f26f109465d4a2a1bf123ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-referenced object by a reference to the source object; no destruction occurs.  <a href="#a7d02344e9f26f109465d4a2a1bf123ce">More...</a><br /></td></tr>
<tr class="separator:a7d02344e9f26f109465d4a2a1bf123ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b44cc1613d73ae9032400c9fdb74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a8e6b44cc1613d73ae9032400c9fdb74c">operator=</a> (T *tp)</td></tr>
<tr class="memdesc:a8e6b44cc1613d73ae9032400c9fdb74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the current pointer with the given one; no destruction occurs.  <a href="#a8e6b44cc1613d73ae9032400c9fdb74c">More...</a><br /></td></tr>
<tr class="separator:a8e6b44cc1613d73ae9032400c9fdb74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f307c505529687543b6f261ace81837"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a1f307c505529687543b6f261ace81837">~ReferencePtr</a> ()</td></tr>
<tr class="memdesc:a1f307c505529687543b6f261ace81837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor does nothing.  <a href="#a1f307c505529687543b6f261ace81837">More...</a><br /></td></tr>
<tr class="separator:a1f307c505529687543b6f261ace81837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143484933f1d883c3b814d39c9e68f92"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a143484933f1d883c3b814d39c9e68f92">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a143484933f1d883c3b814d39c9e68f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contained pointer.  <a href="#a143484933f1d883c3b814d39c9e68f92">More...</a><br /></td></tr>
<tr class="separator:a143484933f1d883c3b814d39c9e68f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d982a55a9857fcc3239e02190af68a7"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a9d982a55a9857fcc3239e02190af68a7">operator*</a> () const </td></tr>
<tr class="memdesc:a9d982a55a9857fcc3239e02190af68a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "dereference" operator returns a reference to the target object.  <a href="#a9d982a55a9857fcc3239e02190af68a7">More...</a><br /></td></tr>
<tr class="separator:a9d982a55a9857fcc3239e02190af68a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36409ee653b0506c08b38936e4226b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ad36409ee653b0506c08b38936e4226b7">operator T *</a> () const </td></tr>
<tr class="memdesc:ad36409ee653b0506c08b38936e4226b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from ReferencePtr&lt;T&gt; to T*.  <a href="#ad36409ee653b0506c08b38936e4226b7">More...</a><br /></td></tr>
<tr class="separator:ad36409ee653b0506c08b38936e4226b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b52e35d021a254e3a4931d8c1cdf1ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a4b52e35d021a254e3a4931d8c1cdf1ca">operator bool</a> () const </td></tr>
<tr class="memdesc:a4b52e35d021a254e3a4931d8c1cdf1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to type bool that returns true if the container is non-null (that is, not empty).  <a href="#a4b52e35d021a254e3a4931d8c1cdf1ca">More...</a><br /></td></tr>
<tr class="separator:a4b52e35d021a254e3a4931d8c1cdf1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b6a5c2d2726009eadb781785924088"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ac6b6a5c2d2726009eadb781785924088">get</a> () const </td></tr>
<tr class="memdesc:ac6b6a5c2d2726009eadb781785924088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contained pointer, or null if the container is empty.  <a href="#ac6b6a5c2d2726009eadb781785924088">More...</a><br /></td></tr>
<tr class="separator:ac6b6a5c2d2726009eadb781785924088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207d01f74b55814de8e2ea48b8c801f4"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a207d01f74b55814de8e2ea48b8c801f4">getRef</a> () const </td></tr>
<tr class="memdesc:a207d01f74b55814de8e2ea48b8c801f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the target object.  <a href="#a207d01f74b55814de8e2ea48b8c801f4">More...</a><br /></td></tr>
<tr class="separator:a207d01f74b55814de8e2ea48b8c801f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2bf6d41875c6af9fdfc15eb44205b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#abf2bf6d41875c6af9fdfc15eb44205b2">empty</a> () const </td></tr>
<tr class="memdesc:abf2bf6d41875c6af9fdfc15eb44205b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty.  <a href="#abf2bf6d41875c6af9fdfc15eb44205b2">More...</a><br /></td></tr>
<tr class="separator:abf2bf6d41875c6af9fdfc15eb44205b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4de9ca33ef1a7d9cd3e4040e49f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ae0e4de9ca33ef1a7d9cd3e4040e49f79">clear</a> ()</td></tr>
<tr class="memdesc:ae0e4de9ca33ef1a7d9cd3e4040e49f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this container empty; no destruction occurs.  <a href="#ae0e4de9ca33ef1a7d9cd3e4040e49f79">More...</a><br /></td></tr>
<tr class="separator:ae0e4de9ca33ef1a7d9cd3e4040e49f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ae599f4b6e367dfb7c85463acf6834"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a93ae599f4b6e367dfb7c85463acf6834">release</a> ()</td></tr>
<tr class="memdesc:a93ae599f4b6e367dfb7c85463acf6834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the pointer from this container, leaving the container empty.  <a href="#a93ae599f4b6e367dfb7c85463acf6834">More...</a><br /></td></tr>
<tr class="separator:a93ae599f4b6e367dfb7c85463acf6834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac00c607b9211b1f4f4d11f50f5b16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a6ac00c607b9211b1f4f4d11f50f5b16f">reset</a> (T *tp)</td></tr>
<tr class="memdesc:a6ac00c607b9211b1f4f4d11f50f5b16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the stored pointer with a different one; no destruction occurs.  <a href="#a6ac00c607b9211b1f4f4d11f50f5b16f">More...</a><br /></td></tr>
<tr class="separator:a6ac00c607b9211b1f4f4d11f50f5b16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c61d989b88189787be573fb002729"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a893c61d989b88189787be573fb002729">swap</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;other)</td></tr>
<tr class="memdesc:a893c61d989b88189787be573fb002729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this ReferencePtr with another one.  <a href="#a893c61d989b88189787be573fb002729">More...</a><br /></td></tr>
<tr class="separator:a893c61d989b88189787be573fb002729"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad46fd56b8a4654f2beebe971e1970a46"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad46fd56b8a4654f2beebe971e1970a46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ad46fd56b8a4654f2beebe971e1970a46">swap</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt; &amp;p1, <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="memdesc:ad46fd56b8a4654f2beebe971e1970a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ReferencePtr.html#a893c61d989b88189787be573fb002729" title="Swap the contents of this ReferencePtr with another one. ">swap()</a> member of the <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> class.  <a href="#ad46fd56b8a4654f2beebe971e1970a46">More...</a><br /></td></tr>
<tr class="separator:ad46fd56b8a4654f2beebe971e1970a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SimTK::ReferencePtr&lt; T &gt;</h3>

<p>This is a smart pointer that implements "cross reference" semantics where a pointer data member of some object is intended to refer to some target object in a larger data structure. </p>
<p>Judicious use of this container will allow you to use compiler-generated copy constructors and copy assignment operators for classes which would otherwise have to implement their own in order to properly initialize these pointer data members, which must not be copied.</p>
<p>The contained pointer is initialized to null (0) on construction, and it is reinitialized to null upon copy construction or copy assignment. That's because we are assuming this is part of copying the entire data structure and copying the old pointer would create a reference into the old data structure rather than the new copy. This pointer does not own the target to which it points, and there is no reference counting so it will become stale if the target is deleted.</p>
<p>Whether you can write through the pointer is controlled by whether type T is a const type. For example ReferencePtr&lt;int&gt; is equivalent to an int*, while ReferencePtr&lt;const int&gt; is equivalent to a const int*.</p>
<p>This class is entirely inline and has no computational or space overhead; it contains just a single pointer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html" title="Wrap a pointer to an abstract base class in a way that makes it behave like a concrete class...">ClonePtr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acfa754609f3bd0da239932c1abe6393c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#acfa754609f3bd0da239932c1abe6393c">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc96cbd0f3977bc66c6b4dc85c904e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#afc96cbd0f3977bc66c6b4dc85c904e71">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3bc2cf328cb84835e3cf13edb488e3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#aa3bc2cf328cb84835e3cf13edb488e3c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8a4a78b56dde0a279a04eb2c53c79055"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates an empty object. </p>

</div>
</div>
<a class="anchor" id="a8d7839f4089295fc358ec6016251add5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a given pointer stores the pointer. </p>

</div>
</div>
<a class="anchor" id="a2002422169b77e31cf1acaea0351eb33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a reference stores the address of the supplied object. </p>

</div>
</div>
<a class="anchor" id="a3f11b3cd26138d33bea1560efcbcc97c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor unconditionally sets the pointer to null; see class comments for why. </p>

</div>
</div>
<a class="anchor" id="a1f307c505529687543b6f261ace81837"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::~<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad8be04337c1db46084933f9e6a0afb43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment sets the pointer to null (except for a self-assign); see class comments for why. </p>

</div>
</div>
<a class="anchor" id="a7d02344e9f26f109465d4a2a1bf123ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-referenced object by a reference to the source object; no destruction occurs. </p>

</div>
</div>
<a class="anchor" id="a8e6b44cc1613d73ae9032400c9fdb74c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the current pointer with the given one; no destruction occurs. </p>

</div>
</div>
<a class="anchor" id="a143484933f1d883c3b814d39c9e68f92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contained pointer. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a class="anchor" id="a9d982a55a9857fcc3239e02190af68a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The "dereference" operator returns a reference to the target object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a class="anchor" id="ad36409ee653b0506c08b38936e4226b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator T * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion from ReferencePtr&lt;T&gt; to T*. </p>

</div>
</div>
<a class="anchor" id="a4b52e35d021a254e3a4931d8c1cdf1ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion to type bool that returns true if the container is non-null (that is, not empty). </p>

</div>
</div>
<a class="anchor" id="ac6b6a5c2d2726009eadb781785924088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contained pointer, or null if the container is empty. </p>

</div>
</div>
<a class="anchor" id="a207d01f74b55814de8e2ea48b8c801f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::getRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the target object. </p>
<p>Fails if the pointer is null. </p>

</div>
</div>
<a class="anchor" id="abf2bf6d41875c6af9fdfc15eb44205b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty. </p>

</div>
</div>
<a class="anchor" id="ae0e4de9ca33ef1a7d9cd3e4040e49f79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this container empty; no destruction occurs. </p>

</div>
</div>
<a class="anchor" id="a93ae599f4b6e367dfb7c85463acf6834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the pointer from this container, leaving the container empty. </p>
<p>The pointer is returned. </p>

</div>
</div>
<a class="anchor" id="a6ac00c607b9211b1f4f4d11f50f5b16f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the stored pointer with a different one; no destruction occurs. </p>

</div>
</div>
<a class="anchor" id="a893c61d989b88189787be573fb002729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this ReferencePtr with another one. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad46fd56b8a4654f2beebe971e1970a46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a specialization of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ReferencePtr.html#a893c61d989b88189787be573fb002729" title="Swap the contents of this ReferencePtr with another one. ">swap()</a> member of the <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ReferencePtr_8h_source.html">ReferencePtr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:23 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
