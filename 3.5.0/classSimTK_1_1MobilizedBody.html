<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Simbody: SimTK::MobilizedBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimTK_1_1MobilizedBody.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1MobilizedBody-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::MobilizedBody Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A MobilizedBody is Simbody's fundamental body-and-joint object used to parameterize a system's motion by constructing a multibody tree containing each body and its unique "mobilizer" (internal coordinate joint).  
 <a href="classSimTK_1_1MobilizedBody.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::MobilizedBody:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1MobilizedBody.png" usemap="#SimTK::MobilizedBody_map" alt=""/>
  <map id="SimTK::MobilizedBody_map" name="SimTK::MobilizedBody_map">
<area href="classSimTK_1_1PIMPLHandle.html" alt="SimTK::PIMPLHandle&lt; MobilizedBody, MobilizedBodyImpl, true &gt;" shape="rect" coords="0,0,382,24"/>
<area href="classSimTK_1_1MobilizedBody_1_1Ball.html" title="Three mobilities – unrestricted orientation modeled with a quaternion which is never singular..." alt="SimTK::MobilizedBody::Ball" shape="rect" coords="392,112,774,136"/>
<area href="classSimTK_1_1MobilizedBody_1_1BendStretch.html" title="Two mobilities: The z axis of the parent&#39;s F frame is used for rotation (and that is always aligned w..." alt="SimTK::MobilizedBody::BendStretch" shape="rect" coords="392,168,774,192"/>
<area href="classSimTK_1_1MobilizedBody_1_1Bushing.html" title="Six mobilities – arbitrary relative motion modeled as x-y-z translation followed by an x-y-z body-fi..." alt="SimTK::MobilizedBody::Bushing" shape="rect" coords="392,224,774,248"/>
<area href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl..." alt="SimTK::MobilizedBody::Custom" shape="rect" coords="392,280,774,304"/>
<area href="classSimTK_1_1MobilizedBody_1_1Cylinder.html" title="Two mobilities – rotation and translation along the common z axis of the inboard and outboard mobili..." alt="SimTK::MobilizedBody::Cylinder" shape="rect" coords="392,336,774,360"/>
<area href="classSimTK_1_1MobilizedBody_1_1Ellipsoid.html" title="Three mobilities – coordinated rotation and translation along the surface of an ellipsoid fixed to t..." alt="SimTK::MobilizedBody::Ellipsoid" shape="rect" coords="392,392,774,416"/>
<area href="classSimTK_1_1MobilizedBody_1_1Free.html" title="Unrestricted motion for a rigid body (six mobilities). " alt="SimTK::MobilizedBody::Free" shape="rect" coords="392,448,774,472"/>
<area href="classSimTK_1_1MobilizedBody_1_1FreeLine.html" title="Five mobilities, representing unrestricted motion for a body which is inertialess along its own z axi..." alt="SimTK::MobilizedBody::FreeLine" shape="rect" coords="392,504,774,528"/>
<area href="classSimTK_1_1MobilizedBody_1_1Gimbal.html" title="Three mobilities – unrestricted orientation modeled as a 1-2-3 body-fixed Euler angle sequence..." alt="SimTK::MobilizedBody::Gimbal" shape="rect" coords="392,560,774,584"/>
<area href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr..." alt="SimTK::MobilizedBody::Ground" shape="rect" coords="392,616,774,640"/>
<area href="classSimTK_1_1MobilizedBody_1_1LineOrientation.html" title="Two mobilities, representing unrestricted orientation for a body which is inertialess along its own z..." alt="SimTK::MobilizedBody::LineOrientation" shape="rect" coords="392,672,774,696"/>
<area href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer..." alt="SimTK::MobilizedBody::Pin" shape="rect" coords="392,728,774,752"/>
<area href="classSimTK_1_1MobilizedBody_1_1Planar.html" title="Three mobilities – z rotation and x,y translation. " alt="SimTK::MobilizedBody::Planar" shape="rect" coords="392,784,774,808"/>
<area href="classSimTK_1_1MobilizedBody_1_1Screw.html" title="One mobility – coordinated rotation and translation along the common z axis of the inboard and outbo..." alt="SimTK::MobilizedBody::Screw" shape="rect" coords="392,840,774,864"/>
<area href="classSimTK_1_1MobilizedBody_1_1Slider.html" title="One mobility – translation along the common x axis of the F (inboard) and M (outboard) mobilizer fra..." alt="SimTK::MobilizedBody::Slider" shape="rect" coords="392,896,774,920"/>
<area href="classSimTK_1_1MobilizedBody_1_1SphericalCoords.html" title="Three mobilities – body fixed 3-2 (z-y) rotation followed by translation along body z or body x..." alt="SimTK::MobilizedBody::SphericalCoords" shape="rect" coords="392,952,774,976"/>
<area href="classSimTK_1_1MobilizedBody_1_1Translation.html" title="Three translational mobilities describing the Cartesian motion of a point. " alt="SimTK::MobilizedBody::Translation" shape="rect" coords="392,1008,774,1032"/>
<area href="classSimTK_1_1MobilizedBody_1_1Universal.html" title="Two mobilities – rotation about the x axis, followed by a rotation about the new y axis..." alt="SimTK::MobilizedBody::Universal" shape="rect" coords="392,1064,774,1088"/>
<area href="classSimTK_1_1MobilizedBody_1_1Weld.html" title="Zero mobilities. " alt="SimTK::MobilizedBody::Weld" shape="rect" coords="392,1120,774,1144"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html">Ball</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three mobilities &ndash; unrestricted orientation modeled with a quaternion which is never singular.  <a href="classSimTK_1_1MobilizedBody_1_1Ball.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1BendStretch.html">BendStretch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two mobilities: The z axis of the parent's F frame is used for rotation (and that is always aligned with the M frame z axis).  <a href="classSimTK_1_1MobilizedBody_1_1BendStretch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Bushing.html">Bushing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Six mobilities &ndash; arbitrary relative motion modeled as x-y-z translation followed by an x-y-z body-fixed Euler angle sequence, though with a singularity when the middle angle is +/- 90 degrees.  <a href="classSimTK_1_1MobilizedBody_1_1Bushing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html">Custom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The handle class <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">MobilizedBody::Custom</a> (dataless) and its companion class <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom_1_1Implementation.html" title="This is the implementation class for Custom mobilizers. ">MobilizedBody::Custom::Implementation</a> can be used together to define new <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> types with arbitrary properties.  <a href="classSimTK_1_1MobilizedBody_1_1Custom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Cylinder.html">Cylinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two mobilities &ndash; rotation and translation along the common z axis of the inboard and outboard mobilizer frames.  <a href="classSimTK_1_1MobilizedBody_1_1Cylinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ellipsoid.html">Ellipsoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three mobilities &ndash; coordinated rotation and translation along the surface of an ellipsoid fixed to the parent (inboard) body.  <a href="classSimTK_1_1MobilizedBody_1_1Ellipsoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrestricted motion for a rigid body (six mobilities).  <a href="classSimTK_1_1MobilizedBody_1_1Free.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1FreeLine.html">FreeLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Five mobilities, representing unrestricted motion for a body which is inertialess along its own z axis.  <a href="classSimTK_1_1MobilizedBody_1_1FreeLine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1FunctionBased.html">FunctionBased</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a subclass of <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">MobilizedBody::Custom</a> which uses a set of Function objects to define the behavior of the MobilizedBody.  <a href="classSimTK_1_1MobilizedBody_1_1FunctionBased.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Gimbal.html">Gimbal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three mobilities &ndash; unrestricted orientation modeled as a 1-2-3 body-fixed Euler angle sequence, though with a singularity when the middle angle is +/- 90 degrees.  <a href="classSimTK_1_1MobilizedBody_1_1Gimbal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">Ground</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special type of "mobilized" body generated automatically by Simbody as a placeholder for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> in the 0th slot for a <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>'s mobilized bodies; don't create this yourself.  <a href="classSimTK_1_1MobilizedBody_1_1Ground.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1LineOrientation.html">LineOrientation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two mobilities, representing unrestricted orientation for a body which is inertialess along its own z axis.  <a href="classSimTK_1_1MobilizedBody_1_1LineOrientation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html">Pin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer.  <a href="classSimTK_1_1MobilizedBody_1_1Pin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Planar.html">Planar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three mobilities &ndash; z rotation and x,y translation.  <a href="classSimTK_1_1MobilizedBody_1_1Planar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Screw.html">Screw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One mobility &ndash; coordinated rotation and translation along the common z axis of the inboard and outboard mobilizer frames.  <a href="classSimTK_1_1MobilizedBody_1_1Screw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html">Slider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One mobility &ndash; translation along the common x axis of the F (inboard) and M (outboard) mobilizer frames.  <a href="classSimTK_1_1MobilizedBody_1_1Slider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1SphericalCoords.html">SphericalCoords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three mobilities &ndash; body fixed 3-2 (z-y) rotation followed by translation along body z or body x.  <a href="classSimTK_1_1MobilizedBody_1_1SphericalCoords.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html">Translation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three translational mobilities describing the Cartesian motion of a point.  <a href="classSimTK_1_1MobilizedBody_1_1Translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Universal.html">Universal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two mobilities &ndash; rotation about the x axis, followed by a rotation about the new y axis.  <a href="classSimTK_1_1MobilizedBody_1_1Universal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Weld.html">Weld</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero mobilities.  <a href="classSimTK_1_1MobilizedBody_1_1Weld.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ad75a66393b9beb5383f437057b7d07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4ad75a66393b9beb5383f437057b7d07">Direction</a> { <br />
&#160;&#160;<a class="el" href="classSimTK_1_1MobilizedBody.html#a4ad75a66393b9beb5383f437057b7d07a44607131b8c0a58bfd8162b1fb869782">Forward</a> = 0, 
<br />
&#160;&#160;<a class="el" href="classSimTK_1_1MobilizedBody.html#a4ad75a66393b9beb5383f437057b7d07add3a7423b1b31ea2078d76dc383cdaa3">Reverse</a> = 1
<br />
 }<tr class="memdesc:a4ad75a66393b9beb5383f437057b7d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructors can take an argument of this type to indicate that the mobilizer is being defined in the reverse direction, meaning from the outboard (child) body to the inboard (parent) body.  <a href="classSimTK_1_1MobilizedBody.html#a4ad75a66393b9beb5383f437057b7d07">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4ad75a66393b9beb5383f437057b7d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dceece097b7c4c4dde962f30ebaccea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html">Pin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3dceece097b7c4c4dde962f30ebaccea">Torsion</a></td></tr>
<tr class="memdesc:a3dceece097b7c4c4dde962f30ebaccea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">Pin</a> mobilizer.  <a href="#a3dceece097b7c4c4dde962f30ebaccea">More...</a><br /></td></tr>
<tr class="separator:a3dceece097b7c4c4dde962f30ebaccea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5545344d05ad3521ce2a68f52eda16d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html">Pin</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ae5545344d05ad3521ce2a68f52eda16d">Revolute</a></td></tr>
<tr class="memdesc:ae5545344d05ad3521ce2a68f52eda16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">Pin</a> mobilizer.  <a href="#ae5545344d05ad3521ce2a68f52eda16d">More...</a><br /></td></tr>
<tr class="separator:ae5545344d05ad3521ce2a68f52eda16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9ec1d7a7642b41ddf615f5be699d5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html">Slider</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0f9ec1d7a7642b41ddf615f5be699d5a">Prismatic</a></td></tr>
<tr class="memdesc:a0f9ec1d7a7642b41ddf615f5be699d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html" title="One mobility – translation along the common x axis of the F (inboard) and M (outboard) mobilizer fra...">Slider</a> mobilizer.  <a href="#a0f9ec1d7a7642b41ddf615f5be699d5a">More...</a><br /></td></tr>
<tr class="separator:a0f9ec1d7a7642b41ddf615f5be699d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f84fcd277bf27ec5783ba405cfde5a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html">Translation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a30f84fcd277bf27ec5783ba405cfde5a">Cartesian</a></td></tr>
<tr class="memdesc:a30f84fcd277bf27ec5783ba405cfde5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html" title="Three translational mobilities describing the Cartesian motion of a point. ">Translation</a> mobilizer.  <a href="#a30f84fcd277bf27ec5783ba405cfde5a">More...</a><br /></td></tr>
<tr class="separator:a30f84fcd277bf27ec5783ba405cfde5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f2645fe1494eb8687d3d355b0f664"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html">Translation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a318f2645fe1494eb8687d3d355b0f664">CartesianCoords</a></td></tr>
<tr class="memdesc:a318f2645fe1494eb8687d3d355b0f664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html" title="Three translational mobilities describing the Cartesian motion of a point. ">Translation</a> mobilizer.  <a href="#a318f2645fe1494eb8687d3d355b0f664">More...</a><br /></td></tr>
<tr class="separator:a318f2645fe1494eb8687d3d355b0f664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c70a0a5c5fdb9040c0cba94f2109cb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1BendStretch.html">BendStretch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a78c70a0a5c5fdb9040c0cba94f2109cb">PolarCoords</a></td></tr>
<tr class="memdesc:a78c70a0a5c5fdb9040c0cba94f2109cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1BendStretch.html" title="Two mobilities: The z axis of the parent&#39;s F frame is used for rotation (and that is always aligned w...">BendStretch</a> mobilizer.  <a href="#a78c70a0a5c5fdb9040c0cba94f2109cb">More...</a><br /></td></tr>
<tr class="separator:a78c70a0a5c5fdb9040c0cba94f2109cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276fecee38470399e1683a93f4530742"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html">Ball</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a276fecee38470399e1683a93f4530742">Orientation</a></td></tr>
<tr class="memdesc:a276fecee38470399e1683a93f4530742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html" title="Three mobilities – unrestricted orientation modeled with a quaternion which is never singular...">Ball</a> mobilizer.  <a href="#a276fecee38470399e1683a93f4530742">More...</a><br /></td></tr>
<tr class="separator:a276fecee38470399e1683a93f4530742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a2f89ca8450002c01f8c09d4fe1088"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html">Ball</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa9a2f89ca8450002c01f8c09d4fe1088">Spherical</a></td></tr>
<tr class="memdesc:aa9a2f89ca8450002c01f8c09d4fe1088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html" title="Three mobilities – unrestricted orientation modeled with a quaternion which is never singular...">Ball</a> mobilizer.  <a href="#aa9a2f89ca8450002c01f8c09d4fe1088">More...</a><br /></td></tr>
<tr class="separator:aa9a2f89ca8450002c01f8c09d4fe1088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; MobilizedBody, MobilizedBodyImpl, true &gt;</a></td></tr>
<tr class="memitem:a6b925b77482930c9ef55955fa1e48b45 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>, MobilizedBodyImpl, PTR &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a></td></tr>
<tr class="separator:a6b925b77482930c9ef55955fa1e48b45 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b0b3d07fe975bdbeb5c1642e8e9c8 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1PIMPLHandle.html#a6b925b77482930c9ef55955fa1e48b45">HandleBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae31b0b3d07fe975bdbeb5c1642e8e9c8">ParentHandle</a></td></tr>
<tr class="separator:ae31b0b3d07fe975bdbeb5c1642e8e9c8 inherit pub_types_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a587e4f3edc99db7da5e6ff646a8805d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a587e4f3edc99db7da5e6ff646a8805d1">MobilizedBody</a> ()</td></tr>
<tr class="memdesc:a587e4f3edc99db7da5e6ff646a8805d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor provides an empty MobilizedBody handle that can be assigned to reference any type of MobilizedBody.  <a href="#a587e4f3edc99db7da5e6ff646a8805d1">More...</a><br /></td></tr>
<tr class="separator:a587e4f3edc99db7da5e6ff646a8805d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceab99766a6c1927f05a9282b5c106e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aceab99766a6c1927f05a9282b5c106e8">MobilizedBody</a> (MobilizedBodyImpl *r)</td></tr>
<tr class="memdesc:aceab99766a6c1927f05a9282b5c106e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="#aceab99766a6c1927f05a9282b5c106e8">More...</a><br /></td></tr>
<tr class="separator:aceab99766a6c1927f05a9282b5c106e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mobilizer locking and unlocking</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Every MobilizedBody object supports locking and unlocking of the mobilizer it contains.</p>
<p>You can lock the mobilizer's position, velocity, or acceleration. In all cases the generalized accelerations udot of a locked mobilizer are prescribed. If you lock just the accelerations, then velocity and position remain free. If you lock velocity, then the generalized speeds u are prescribed to specified values, accelerations udot are prescribed to zero, and positions will remain free. If you lock position (the default locking level) then the generalized coordinates q are prescribed to specified values and the speeds u and accelerations udot are prescribed to zero. Prescribed values may be obtained from the current state, or set explicitly. The <a class="el" href="classSimTK_1_1MobilizedBody.html#a7f7324c42a57beedd7c577dbf14e2531" title="Lock this mobilizer&#39;s position or velocity at its current value, or lock the acceleration to zero...">lock()</a> and <a class="el" href="classSimTK_1_1MobilizedBody.html#a37ac591feb4c08544ab17f2f7fa0d7b0" title="Lock this mobilizer&#39;s q, u, or udot to the given scalar value, depending on level. ">lockAt()</a> methods when called at position level will modify q in the given state if necessary to satisfy the locked position, and will set u to zero. When called at velocity level they will modify u if necessary to satisfied the locked velocity, but will leave q unchanged.</p>
<p>You can also specify that a mobilizer is locked by default (at acceleration, velocity, or position level). In that case the prescribed value is recorded when the state is realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>, using values taken from the state at that time.</p>
<p>If this mobilizer is driven by a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object, locking overrides that while the lock is active; when unlocked the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object resumes control. </p>
</div></td></tr>
<tr class="memitem:a7f7324c42a57beedd7c577dbf14e2531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a7f7324c42a57beedd7c577dbf14e2531">lock</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> level=<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a>) const </td></tr>
<tr class="memdesc:a7f7324c42a57beedd7c577dbf14e2531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this mobilizer's position or velocity at its current value, or lock the acceleration to zero, depending on the <code>level</code> parameter.  <a href="#a7f7324c42a57beedd7c577dbf14e2531">More...</a><br /></td></tr>
<tr class="separator:a7f7324c42a57beedd7c577dbf14e2531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ac591feb4c08544ab17f2f7fa0d7b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a37ac591feb4c08544ab17f2f7fa0d7b0">lockAt</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> value, <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> level=<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a>) const </td></tr>
<tr class="memdesc:a37ac591feb4c08544ab17f2f7fa0d7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this mobilizer's q, u, or udot to the given scalar <code>value</code>, depending on <code>level</code>.  <a href="#a37ac591feb4c08544ab17f2f7fa0d7b0">More...</a><br /></td></tr>
<tr class="separator:a37ac591feb4c08544ab17f2f7fa0d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310411deca445ac81d55f47b61a2496d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a310411deca445ac81d55f47b61a2496d">lockAt</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;value, <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> level=<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a>) const </td></tr>
<tr class="memdesc:a310411deca445ac81d55f47b61a2496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this mobilizer's q, u, or udot to the given Vector <code>value</code>, depending on <code>level</code>.  <a href="#a310411deca445ac81d55f47b61a2496d">More...</a><br /></td></tr>
<tr class="separator:a310411deca445ac81d55f47b61a2496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24784973f1295316042dc2cd30d55760"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a24784973f1295316042dc2cd30d55760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a24784973f1295316042dc2cd30d55760">lockAt</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; N &gt; &amp;value, <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> level=<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a>) const </td></tr>
<tr class="memdesc:a24784973f1295316042dc2cd30d55760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock this mobilizer's q, u, or udot to the given <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>&lt;N&gt; <code>value</code>, depending on the <code>level</code>.  <a href="#a24784973f1295316042dc2cd30d55760">More...</a><br /></td></tr>
<tr class="separator:a24784973f1295316042dc2cd30d55760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af140876d78c207e51dfb80297dd86394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af140876d78c207e51dfb80297dd86394">unlock</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:af140876d78c207e51dfb80297dd86394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock this mobilizer, returning it to its normal behavior which may be free motion or may be controlled by a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object.  <a href="#af140876d78c207e51dfb80297dd86394">More...</a><br /></td></tr>
<tr class="separator:af140876d78c207e51dfb80297dd86394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca19bb03088e81314b9d81872b02e5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a5ca19bb03088e81314b9d81872b02e5b">isLocked</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a5ca19bb03088e81314b9d81872b02e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this mobilizer is currently locked in the given <code>state</code>.  <a href="#a5ca19bb03088e81314b9d81872b02e5b">More...</a><br /></td></tr>
<tr class="separator:a5ca19bb03088e81314b9d81872b02e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec6b9ad930bcac4fdc3d10b6f5576e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6ec6b9ad930bcac4fdc3d10b6f5576e3">getLockLevel</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a6ec6b9ad930bcac4fdc3d10b6f5576e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock level if the mobilizer is locked in the given <code>state</code>, otherwise <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a325b350a7bdf69fab347d2b9863c6e3c" title="invalid level ">Motion::NoLevel</a>.  <a href="#a6ec6b9ad930bcac4fdc3d10b6f5576e3">More...</a><br /></td></tr>
<tr class="separator:a6ec6b9ad930bcac4fdc3d10b6f5576e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff678ef3c0bf656643574492d55b01d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aff678ef3c0bf656643574492d55b01d2">getLockValueAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:aff678ef3c0bf656643574492d55b01d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the q, u, or udot value at which this mobilizer is locked, depending on the lock level, as a Vector of the appropriate length.  <a href="#aff678ef3c0bf656643574492d55b01d2">More...</a><br /></td></tr>
<tr class="separator:aff678ef3c0bf656643574492d55b01d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b71338ce06176e41f11d9d113f4339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ac5b71338ce06176e41f11d9d113f4339">lockByDefault</a> (<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> level=<a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a>)</td></tr>
<tr class="memdesc:ac5b71338ce06176e41f11d9d113f4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change whether this mobilizer is initially locked.  <a href="#ac5b71338ce06176e41f11d9d113f4339">More...</a><br /></td></tr>
<tr class="separator:ac5b71338ce06176e41f11d9d113f4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca64cbc146e75b7450991b5b6f5ac6bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aca64cbc146e75b7450991b5b6f5ac6bd">isLockedByDefault</a> () const </td></tr>
<tr class="memdesc:aca64cbc146e75b7450991b5b6f5ac6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this mobilizer is to be locked in the default state.  <a href="#aca64cbc146e75b7450991b5b6f5ac6bd">More...</a><br /></td></tr>
<tr class="separator:aca64cbc146e75b7450991b5b6f5ac6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a9a8a76cfdd4d3a85ce75ca5bd1d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a44a9a8a76cfdd4d3a85ce75ca5bd1d47">getLockByDefaultLevel</a> () const </td></tr>
<tr class="memdesc:a44a9a8a76cfdd4d3a85ce75ca5bd1d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the level at which the mobilizer is locked by default, if it is locked by default, otherwise <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a325b350a7bdf69fab347d2b9863c6e3c" title="invalid level ">Motion::NoLevel</a>.  <a href="#a44a9a8a76cfdd4d3a85ce75ca5bd1d47">More...</a><br /></td></tr>
<tr class="separator:a44a9a8a76cfdd4d3a85ce75ca5bd1d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Access - Bodies</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods extract already-computed information from the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> or <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, or set values in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.</p>
</div></td></tr>
<tr class="memitem:a877368286148b4efbdb2d5e7f6904ac4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a877368286148b4efbdb2d5e7f6904ac4">getBodyTransform</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a877368286148b4efbdb2d5e7f6904ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated spatial configuration X_GB of body B's body frame, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#a877368286148b4efbdb2d5e7f6904ac4">More...</a><br /></td></tr>
<tr class="separator:a877368286148b4efbdb2d5e7f6904ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0404ecdf9a8172bf22d2def7d79e0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a5a0404ecdf9a8172bf22d2def7d79e0b">getBodyRotation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a5a0404ecdf9a8172bf22d2def7d79e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated spatial orientation R_GB of body B's body frame x, y, and z axes expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, as the Rotation matrix R_GB.  <a href="#a5a0404ecdf9a8172bf22d2def7d79e0b">More...</a><br /></td></tr>
<tr class="separator:a5a0404ecdf9a8172bf22d2def7d79e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2d6882a3f7c42239bd6449cadf66bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2e2d6882a3f7c42239bd6449cadf66bd">getBodyOriginLocation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a2e2d6882a3f7c42239bd6449cadf66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated spatial location of body B's body frame origin Bo, measured from the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> origin Go and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, as the position vector p_GB (== p_GoBo).  <a href="#a2e2d6882a3f7c42239bd6449cadf66bd">More...</a><br /></td></tr>
<tr class="separator:a2e2d6882a3f7c42239bd6449cadf66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be00463060a74c56863a179b0061f3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6be00463060a74c56863a179b0061f3a">getMobilizerTransform</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a6be00463060a74c56863a179b0061f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">At stage Position or higher, return the cross-mobilizer transform X_FM, the body's inboard mobilizer frame M measured and expressed in the parent body's corresponding outboard frame F.  <a href="#a6be00463060a74c56863a179b0061f3a">More...</a><br /></td></tr>
<tr class="separator:a6be00463060a74c56863a179b0061f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136b1b973ae2d60e2bd09a19529c15a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a136b1b973ae2d60e2bd09a19529c15a8">getBodyVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a136b1b973ae2d60e2bd09a19529c15a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated spatial velocity V_GB of this body's reference frame B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#a136b1b973ae2d60e2bd09a19529c15a8">More...</a><br /></td></tr>
<tr class="separator:a136b1b973ae2d60e2bd09a19529c15a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e64cc62fa2f76bd37894007abd378"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad07e64cc62fa2f76bd37894007abd378">getBodyAngularVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:ad07e64cc62fa2f76bd37894007abd378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated inertial angular velocity vector w_GB of this body B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#ad07e64cc62fa2f76bd37894007abd378">More...</a><br /></td></tr>
<tr class="separator:ad07e64cc62fa2f76bd37894007abd378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9911f4352e9224184e8dab962c7d8f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af9911f4352e9224184e8dab962c7d8f0">getBodyOriginVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:af9911f4352e9224184e8dab962c7d8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explicitly, v_GBo) of this body B's origin point Bo, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#af9911f4352e9224184e8dab962c7d8f0">More...</a><br /></td></tr>
<tr class="separator:af9911f4352e9224184e8dab962c7d8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f87b4238c3efe0418275163bc258bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a16f87b4238c3efe0418275163bc258bc">getMobilizerVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a16f87b4238c3efe0418275163bc258bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">At stage Velocity or higher, return the cross-mobilizer velocity V_FM, the relative velocity of this body's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F.  <a href="#a16f87b4238c3efe0418275163bc258bc">More...</a><br /></td></tr>
<tr class="separator:a16f87b4238c3efe0418275163bc258bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab728f49034ee32dea4620f23a632a3f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab728f49034ee32dea4620f23a632a3f0">getBodyAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:ab728f49034ee32dea4620f23a632a3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated spatial acceleration A_GB of this body's reference frame B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#ab728f49034ee32dea4620f23a632a3f0">More...</a><br /></td></tr>
<tr class="separator:ab728f49034ee32dea4620f23a632a3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056be794b2e8d9c9d77124162d7b35f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a056be794b2e8d9c9d77124162d7b35f1">getBodyAngularAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a056be794b2e8d9c9d77124162d7b35f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated inertial angular acceleration vector b_GB of this body B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#a056be794b2e8d9c9d77124162d7b35f1">More...</a><br /></td></tr>
<tr class="separator:a056be794b2e8d9c9d77124162d7b35f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bea21eaba5cb4db3751fbf3d0d8bc6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0bea21eaba5cb4db3751fbf3d0d8bc6e">getBodyOriginAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a0bea21eaba5cb4db3751fbf3d0d8bc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more explicitly, a_GBo) of this body B's origin point Bo, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#a0bea21eaba5cb4db3751fbf3d0d8bc6e">More...</a><br /></td></tr>
<tr class="separator:a0bea21eaba5cb4db3751fbf3d0d8bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c7069df29ad92032816b5403aa6997"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a79c7069df29ad92032816b5403aa6997">getMobilizerAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a79c7069df29ad92032816b5403aa6997"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Not implemented yet &ndash; any volunteers? At stage Acceleration, return the cross-mobilizer acceleration A_FM, the relative acceleration of body B's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F.  <a href="#a79c7069df29ad92032816b5403aa6997">More...</a><br /></td></tr>
<tr class="separator:a79c7069df29ad92032816b5403aa6997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecd25fe2c8f44a48db42ab92f80a690"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2ecd25fe2c8f44a48db42ab92f80a690">getBodyMassProperties</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a2ecd25fe2c8f44a48db42ab92f80a690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this body's mass properties in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#a2ecd25fe2c8f44a48db42ab92f80a690">More...</a><br /></td></tr>
<tr class="separator:a2ecd25fe2c8f44a48db42ab92f80a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919bf69fc4449d163d04b867450b901f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a919bf69fc4449d163d04b867450b901f">getBodySpatialInertiaInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a919bf69fc4449d163d04b867450b901f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the already-calculated SpatialInertia of this body, taken about the body's origin (<em>not</em> its mass center), and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#a919bf69fc4449d163d04b867450b901f">More...</a><br /></td></tr>
<tr class="separator:a919bf69fc4449d163d04b867450b901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63398ad3cebfd110b2815a25201fd17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a63398ad3cebfd110b2815a25201fd17d">getBodyMass</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a63398ad3cebfd110b2815a25201fd17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mass of this body.  <a href="#a63398ad3cebfd110b2815a25201fd17d">More...</a><br /></td></tr>
<tr class="separator:a63398ad3cebfd110b2815a25201fd17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cefb252884569addb85d934cd9ca620"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a8cefb252884569addb85d934cd9ca620">getBodyMassCenterStation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a8cefb252884569addb85d934cd9ca620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this body's center of mass station (i.e., the vector fixed in the body, going from body origin to body mass center, expressed in the body frame.) The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher.  <a href="#a8cefb252884569addb85d934cd9ca620">More...</a><br /></td></tr>
<tr class="separator:a8cefb252884569addb85d934cd9ca620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e492d01b892751aa6d82d73cd76cc22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#af4586b331c8fbbb1f3c18d2a1a03ce92">UnitInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6e492d01b892751aa6d82d73cd76cc22">getBodyUnitInertiaAboutBodyOrigin</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a6e492d01b892751aa6d82d73cd76cc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this body's unit inertia matrix in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, taken about the body origin and expressed in the body frame.  <a href="#a6e492d01b892751aa6d82d73cd76cc22">More...</a><br /></td></tr>
<tr class="separator:a6e492d01b892751aa6d82d73cd76cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6765463d0ad8f2e0bc84ddf3fb54746d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6765463d0ad8f2e0bc84ddf3fb54746d">getInboardFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a6765463d0ad8f2e0bc84ddf3fb54746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this mobilizer's frame F fixed on the parent body P, as the fixed Transform from P's body frame to the frame F fixed to P.  <a href="#a6765463d0ad8f2e0bc84ddf3fb54746d">More...</a><br /></td></tr>
<tr class="separator:a6765463d0ad8f2e0bc84ddf3fb54746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69952d293c85ea3642d972018cfc00dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a69952d293c85ea3642d972018cfc00dc">getOutboardFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a69952d293c85ea3642d972018cfc00dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>'s mobilizer frame M, as the fixed Transform from this body B's frame to the frame M fixed on B.  <a href="#a69952d293c85ea3642d972018cfc00dc">More...</a><br /></td></tr>
<tr class="separator:a69952d293c85ea3642d972018cfc00dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c851f977baae82c1c2355247685b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aea0c851f977baae82c1c2355247685b7">setInboardFrame</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_PF) const </td></tr>
<tr class="memdesc:aea0c851f977baae82c1c2355247685b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet.  <a href="#aea0c851f977baae82c1c2355247685b7">More...</a><br /></td></tr>
<tr class="separator:aea0c851f977baae82c1c2355247685b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d09e7b28e1f08fd30128c549fe83d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a525d09e7b28e1f08fd30128c549fe83d">setOutboardFrame</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_BM) const </td></tr>
<tr class="memdesc:a525d09e7b28e1f08fd30128c549fe83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet.  <a href="#a525d09e7b28e1f08fd30128c549fe83d">More...</a><br /></td></tr>
<tr class="separator:a525d09e7b28e1f08fd30128c549fe83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State Access - Mobilizer generalized coordinates q and speeds u</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods extract q- or u-related information from the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> or <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, or set q or u values in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.</p>
</div></td></tr>
<tr class="memitem:a4dd37c7e26fc0d3af29bd39cbcc53977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977">getNumQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a4dd37c7e26fc0d3af29bd39cbcc53977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of generalized coordinates q currently in use by this mobilizer.  <a href="#a4dd37c7e26fc0d3af29bd39cbcc53977">More...</a><br /></td></tr>
<tr class="separator:a4dd37c7e26fc0d3af29bd39cbcc53977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0670418dc17ea36ae69d8a1ec42504c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c">getNumU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:aa0670418dc17ea36ae69d8a1ec42504c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of generalized speeds u currently in use by this mobilizer.  <a href="#aa0670418dc17ea36ae69d8a1ec42504c">More...</a><br /></td></tr>
<tr class="separator:aa0670418dc17ea36ae69d8a1ec42504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccd00b0e744058c564242f912214270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1QIndex.html">QIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0ccd00b0e744058c564242f912214270">getFirstQIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a0ccd00b0e744058c564242f912214270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global <a class="el" href="classSimTK_1_1QIndex.html" title="Unique integer type for Subsystem-local q indexing. ">QIndex</a> of the first q for this mobilizer; all the q's range from <a class="el" href="classSimTK_1_1MobilizedBody.html#a0ccd00b0e744058c564242f912214270" title="Return the global QIndex of the first q for this mobilizer; all the q&#39;s range from getFirstQIndex() t...">getFirstQIndex()</a> to <a class="el" href="classSimTK_1_1QIndex.html" title="Unique integer type for Subsystem-local q indexing. ">QIndex</a>(<a class="el" href="classSimTK_1_1MobilizedBody.html#a0ccd00b0e744058c564242f912214270" title="Return the global QIndex of the first q for this mobilizer; all the q&#39;s range from getFirstQIndex() t...">getFirstQIndex()</a>+getNumQ()-1).  <a href="#a0ccd00b0e744058c564242f912214270">More...</a><br /></td></tr>
<tr class="separator:a0ccd00b0e744058c564242f912214270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ecf9620996412218499fa99f8a126f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab4ecf9620996412218499fa99f8a126f">getFirstUIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:ab4ecf9620996412218499fa99f8a126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global <a class="el" href="classSimTK_1_1UIndex.html" title="Unique integer type for Subsystem-local u indexing. ">UIndex</a> of the first u for this mobilizer; all the u's range from <a class="el" href="classSimTK_1_1MobilizedBody.html#ab4ecf9620996412218499fa99f8a126f" title="Return the global UIndex of the first u for this mobilizer; all the u&#39;s range from getFirstUIndex() t...">getFirstUIndex()</a> to <a class="el" href="classSimTK_1_1UIndex.html" title="Unique integer type for Subsystem-local u indexing. ">UIndex</a>(<a class="el" href="classSimTK_1_1MobilizedBody.html#ab4ecf9620996412218499fa99f8a126f" title="Return the global UIndex of the first u for this mobilizer; all the u&#39;s range from getFirstUIndex() t...">getFirstUIndex()</a>+getNumU()-1).  <a href="#ab4ecf9620996412218499fa99f8a126f">More...</a><br /></td></tr>
<tr class="separator:ab4ecf9620996412218499fa99f8a126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1b775de0ddef150089ac78fde3ba85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#acb1b775de0ddef150089ac78fde3ba85">getQMotionMethod</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:acb1b775de0ddef150089ac78fde3ba85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how generalized coordinate q values are being determined.  <a href="#acb1b775de0ddef150089ac78fde3ba85">More...</a><br /></td></tr>
<tr class="separator:acb1b775de0ddef150089ac78fde3ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7364818e28d23abaf997e4357efb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a8b7364818e28d23abaf997e4357efb7c">getUMotionMethod</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a8b7364818e28d23abaf997e4357efb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how generalized speed u values are being determined.  <a href="#a8b7364818e28d23abaf997e4357efb7c">More...</a><br /></td></tr>
<tr class="separator:a8b7364818e28d23abaf997e4357efb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9863cce1313097e6d446b9dc661e2fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa9863cce1313097e6d446b9dc661e2fc">getUDotMotionMethod</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:aa9863cce1313097e6d446b9dc661e2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how generalized acceleration udot values are being determined.  <a href="#aa9863cce1313097e6d446b9dc661e2fc">More...</a><br /></td></tr>
<tr class="separator:aa9863cce1313097e6d446b9dc661e2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a6e0e3edd73d690e01e109afd25bb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a95a6e0e3edd73d690e01e109afd25bb1">getOneQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which) const </td></tr>
<tr class="memdesc:a95a6e0e3edd73d690e01e109afd25bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the generalized coordinates q from this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a95a6e0e3edd73d690e01e109afd25bb1">More...</a><br /></td></tr>
<tr class="separator:a95a6e0e3edd73d690e01e109afd25bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848c5bb901ca0a72a9d0f1eeb89783ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a848c5bb901ca0a72a9d0f1eeb89783ca">getOneU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which) const </td></tr>
<tr class="memdesc:a848c5bb901ca0a72a9d0f1eeb89783ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the generalized speeds u from this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a848c5bb901ca0a72a9d0f1eeb89783ca">More...</a><br /></td></tr>
<tr class="separator:a848c5bb901ca0a72a9d0f1eeb89783ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258623c5e835d49718c9b3dae063a7cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a258623c5e835d49718c9b3dae063a7cf">getQAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a258623c5e835d49718c9b3dae063a7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinates q currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a258623c5e835d49718c9b3dae063a7cf">More...</a><br /></td></tr>
<tr class="separator:a258623c5e835d49718c9b3dae063a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e8007f8925c60b99a84a2f2f973ac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a74e8007f8925c60b99a84a2f2f973ac3">getUAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a74e8007f8925c60b99a84a2f2f973ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> all the generalized speeds u currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a74e8007f8925c60b99a84a2f2f973ac3">More...</a><br /></td></tr>
<tr class="separator:a74e8007f8925c60b99a84a2f2f973ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79c133af999645df8522032f7f8e911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa79c133af999645df8522032f7f8e911">getOneQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which) const </td></tr>
<tr class="memdesc:aa79c133af999645df8522032f7f8e911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the generalized coordinate derivatives qdot from this mobilizer's partition of the matter subsystem's full qdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#aa79c133af999645df8522032f7f8e911">More...</a><br /></td></tr>
<tr class="separator:aa79c133af999645df8522032f7f8e911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86018b5ade92c57d641beb65b8ca8fc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a86018b5ade92c57d641beb65b8ca8fc9">getQDotAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a86018b5ade92c57d641beb65b8ca8fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinate derivatives qdot currently in use by this mobilizer, from this mobilizer's partition in the matter subsystem's full qdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#a86018b5ade92c57d641beb65b8ca8fc9">More...</a><br /></td></tr>
<tr class="separator:a86018b5ade92c57d641beb65b8ca8fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addedad56051003dc25ff4c8fc661a188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#addedad56051003dc25ff4c8fc661a188">getOneUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which) const </td></tr>
<tr class="memdesc:addedad56051003dc25ff4c8fc661a188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the generalized accelerations udot from this mobilizer's partition of the matter subsystem's full udot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#addedad56051003dc25ff4c8fc661a188">More...</a><br /></td></tr>
<tr class="separator:addedad56051003dc25ff4c8fc661a188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c653abfcccb09d9176a38a088f0250d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3c653abfcccb09d9176a38a088f0250d">getOneQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which) const </td></tr>
<tr class="memdesc:a3c653abfcccb09d9176a38a088f0250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the generalized coordinate second derivatives qdotdot from this mobilizer's partition of the matter subsystem's full qdotdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#a3c653abfcccb09d9176a38a088f0250d">More...</a><br /></td></tr>
<tr class="separator:a3c653abfcccb09d9176a38a088f0250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14203212503b70930c104cf35aa45b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af14203212503b70930c104cf35aa45b1">getUDotAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:af14203212503b70930c104cf35aa45b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> all the generalized accelerations udot currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full udot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#af14203212503b70930c104cf35aa45b1">More...</a><br /></td></tr>
<tr class="separator:af14203212503b70930c104cf35aa45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9b3bf9124c207b254f4b45bf8c228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a63e9b3bf9124c207b254f4b45bf8c228">getQDotDotAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a63e9b3bf9124c207b254f4b45bf8c228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinate second derivatives qdotdot currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full qdotdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache.  <a href="#a63e9b3bf9124c207b254f4b45bf8c228">More...</a><br /></td></tr>
<tr class="separator:a63e9b3bf9124c207b254f4b45bf8c228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c098a7882568be9f1171d38d4206f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0c098a7882568be9f1171d38d4206f10">getTauAsVector</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a0c098a7882568be9f1171d38d4206f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the generalized forces tau resulting from prescribed (known) acceleration, corresponding to each of this mobilizer's mobilities, as a Vector of length nu=<a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>.  <a href="#a0c098a7882568be9f1171d38d4206f10">More...</a><br /></td></tr>
<tr class="separator:a0c098a7882568be9f1171d38d4206f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48fce7013f9a3e63e320ca5d47cec01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab48fce7013f9a3e63e320ca5d47cec01">getOneTau</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> which) const </td></tr>
<tr class="memdesc:ab48fce7013f9a3e63e320ca5d47cec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the tau forces resulting from prescribed (known) acceleration, corresponding to one of this mobilizer's mobilities as selected here using the <code>which</code> parameter, numbered from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>-1.  <a href="#ab48fce7013f9a3e63e320ca5d47cec01">More...</a><br /></td></tr>
<tr class="separator:ab48fce7013f9a3e63e320ca5d47cec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8e7bc0a62e38ccb9e867f635dbe993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#adf8e7bc0a62e38ccb9e867f635dbe993">setOneQ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> v) const </td></tr>
<tr class="memdesc:adf8e7bc0a62e38ccb9e867f635dbe993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one of the generalized coordinates q to value <code>v</code>, in this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#adf8e7bc0a62e38ccb9e867f635dbe993">More...</a><br /></td></tr>
<tr class="separator:adf8e7bc0a62e38ccb9e867f635dbe993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fd4564e60a150dbc3ebbe979912796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a87fd4564e60a150dbc3ebbe979912796">setOneU</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> v) const </td></tr>
<tr class="memdesc:a87fd4564e60a150dbc3ebbe979912796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one of the generalized speeds u to value <code>v</code>, in this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a87fd4564e60a150dbc3ebbe979912796">More...</a><br /></td></tr>
<tr class="separator:a87fd4564e60a150dbc3ebbe979912796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b080dcb6c8bdb05e373fd7386b3de93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a5b080dcb6c8bdb05e373fd7386b3de93">setQFromVector</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;v) const </td></tr>
<tr class="memdesc:a5b080dcb6c8bdb05e373fd7386b3de93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all of the generalized coordinates q to value <code>v</code> (a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>), in this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a5b080dcb6c8bdb05e373fd7386b3de93">More...</a><br /></td></tr>
<tr class="separator:a5b080dcb6c8bdb05e373fd7386b3de93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127f82d17a6440392e604a103bfff5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a127f82d17a6440392e604a103bfff5ef">setUFromVector</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;v) const </td></tr>
<tr class="memdesc:a127f82d17a6440392e604a103bfff5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all of the generalized speeds u to value <code>v</code> (a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>), in this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a127f82d17a6440392e604a103bfff5ef">More...</a><br /></td></tr>
<tr class="separator:a127f82d17a6440392e604a103bfff5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f926e05e89b9d8a157272b1512b32c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9">setQToFitTransform</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FM) const </td></tr>
<tr class="memdesc:a5f926e05e89b9d8a157272b1512b32c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this mobilizer's q's to best approximate the supplied Transform which requests a particular relative orientation and translation between the F "fixed" frame and M "moving" frame connected by this mobilizer.  <a href="#a5f926e05e89b9d8a157272b1512b32c9">More...</a><br /></td></tr>
<tr class="separator:a5f926e05e89b9d8a157272b1512b32c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e2368d92372f485263d54eaee3ab1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a47e2368d92372f485263d54eaee3ab1d">setQToFitRotation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_FM) const </td></tr>
<tr class="memdesc:a47e2368d92372f485263d54eaee3ab1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this mobilizer's q's to best approximate the supplied Rotation matrix which requests a particular relative orientation between the "fixed" frame F and "moving" frame M connected by this mobilizer.  <a href="#a47e2368d92372f485263d54eaee3ab1d">More...</a><br /></td></tr>
<tr class="separator:a47e2368d92372f485263d54eaee3ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831b84be9c28e51d85dc46aaa98e7531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a831b84be9c28e51d85dc46aaa98e7531">setQToFitTranslation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;p_FM) const </td></tr>
<tr class="memdesc:a831b84be9c28e51d85dc46aaa98e7531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this mobilizer's q's to best approximate the supplied position vector which requests a particular offset between the origins of the F "fixed" frame and M "moving" frame connected by this mobilizer, with <em>any</em> q's (rotational or translational) being modified if doing so helps satisfy the request.  <a href="#a831b84be9c28e51d85dc46aaa98e7531">More...</a><br /></td></tr>
<tr class="separator:a831b84be9c28e51d85dc46aaa98e7531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08ae9b8fe0f468d7d874d76022d19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a7c08ae9b8fe0f468d7d874d76022d19d">setUToFitVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;V_FM) const </td></tr>
<tr class="memdesc:a7c08ae9b8fe0f468d7d874d76022d19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this mobilizer's u's (generalized speeds) to best approximate the supplied spatial velocity <code>V_FM</code> which requests the relative angular and linear velocity between the "fixed" and "moving" frames connected by this mobilizer.  <a href="#a7c08ae9b8fe0f468d7d874d76022d19d">More...</a><br /></td></tr>
<tr class="separator:a7c08ae9b8fe0f468d7d874d76022d19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456eff373a5cf775cd683de27544411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6456eff373a5cf775cd683de27544411">setUToFitAngularVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;w_FM) const </td></tr>
<tr class="memdesc:a6456eff373a5cf775cd683de27544411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust this mobilizer's u's (generalized speeds) to best approximate the supplied angular velocity <code>w_FM</code> which requests a particular relative angular between the "fixed" and "moving" frames connected by this mobilizer.  <a href="#a6456eff373a5cf775cd683de27544411">More...</a><br /></td></tr>
<tr class="separator:a6456eff373a5cf775cd683de27544411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e470bca119537446a02f79680dc328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab9e470bca119537446a02f79680dc328">setUToFitLinearVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;v_FM) const </td></tr>
<tr class="memdesc:ab9e470bca119537446a02f79680dc328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust <em>any</em> of this mobilizer's u's (generalized speeds) to best approximate the supplied linear velocity <code>v_FM</code> which requests a particular velocity for the "moving" frame M origin in the "fixed" frame F on the parent where these are the frames connected by this mobilizer.  <a href="#ab9e470bca119537446a02f79680dc328">More...</a><br /></td></tr>
<tr class="separator:ab9e470bca119537446a02f79680dc328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69c8e858f8d99f6677ed94e60c332e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa69c8e858f8d99f6677ed94e60c332e2">getHCol</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> ux) const </td></tr>
<tr class="memdesc:aa69c8e858f8d99f6677ed94e60c332e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert use only: obtain a column of the hinge matrix H corresponding to one of this mobilizer's mobilities (actually a column of H_PB_G; what Jain calls H* and Schwieters calls H^T).  <a href="#aa69c8e858f8d99f6677ed94e60c332e2">More...</a><br /></td></tr>
<tr class="separator:aa69c8e858f8d99f6677ed94e60c332e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c3388fb03ba24f5ae543dd173770bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a29c3388fb03ba24f5ae543dd173770bf">getH_FMCol</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> ux) const </td></tr>
<tr class="memdesc:a29c3388fb03ba24f5ae543dd173770bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert use only: obtain a column of the mobilizer-local hinge matrix H_FM which maps generalized speeds u to cross-mobilizer spatial velocity V_FM via V_FM=H_FM*u.  <a href="#a29c3388fb03ba24f5ae543dd173770bf">More...</a><br /></td></tr>
<tr class="separator:a29c3388fb03ba24f5ae543dd173770bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods use state variables and Response methods to compute basic quantities which cannot be precomputed, but which can be implemented with an inline combination of basic floating point operations which can be reliably determined at compile time.</p>
<p>The method names and descriptions use the following terms:</p><ul>
<li>Body or ThisBody: the Body B associated with the current MobilizedBody. ThisBody is implied when no other <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> is mentioned.</li>
<li>Ground: the "MobilizedBody" G representing the Ground reference frame which never moves.</li>
<li>AnotherBody: the Body A being referenced, which in general is neither ThisBody nor Ground.</li>
<li>Station: a point S fixed on ThisBody B, located by a position vector p_BS (or more explicitly, p_BoS) from the B-frame origin Bo to the point S, expressed in the B-frame coordinate system.</li>
<li>Vector: a vector v fixed on ThisBody B, given by a vector v_B expressed in the B-frame coordinate system.</li>
<li>Direction: a unit vector u fixed on ThisBody B, given by a unit vector u_B expressed in the B-frame coordinate system.</li>
<li>Frame: an origin and coordinate axes F fixed on ThisBody B, given by a transform X_BF that locates F's origin (a Station) in B and expresses each of F's axes (Directions) in B.</li>
<li>Origin: the Station located at (0,0,0) in ThisBody frame B, that is, body B's origin point.</li>
<li>MassCenter: the Station on ThisBody B which is the center of mass for B.</li>
<li>GroundPoint, GroundVector: a Point P or Vector v on the Ground "Body" G. These are measured and expressed in the Ground frame, as p_GP or v_G.</li>
<li>AnotherBodyStation, AnotherBodyVector, etc.: a Station S or Vector v on AnotherBody A. These are measured and expressed in the A frame, as p_AS or v_A.</li>
<li>Mobilizer frame M: the mobilizer's outboard "moving" frame, fixed to ThisBody B.</li>
<li>Mobilizer frame F: the mobilizer's inboard "fixed" frame, fixed to the parent body P. </li>
</ul>
</div></td></tr>
<tr class="memitem:a38e9d5ec372c7502412e39ec6043302a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a38e9d5ec372c7502412e39ec6043302a">findBodyTransformInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a38e9d5ec372c7502412e39ec6043302a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return X_AB, the spatial transform giving this body B's frame in body A's frame.  <a href="#a38e9d5ec372c7502412e39ec6043302a">More...</a><br /></td></tr>
<tr class="separator:a38e9d5ec372c7502412e39ec6043302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bb12d2d6844023df97cff24d71549b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a44bb12d2d6844023df97cff24d71549b">findBodyRotationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a44bb12d2d6844023df97cff24d71549b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return R_AB, the rotation matrix giving this body B's axes in body A's frame.  <a href="#a44bb12d2d6844023df97cff24d71549b">More...</a><br /></td></tr>
<tr class="separator:a44bb12d2d6844023df97cff24d71549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1b290369cf503f4729b4bcd0f8aa4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4f1b290369cf503f4729b4bcd0f8aa4f">findBodyOriginLocationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;toBodyA) const </td></tr>
<tr class="memdesc:a4f1b290369cf503f4729b4bcd0f8aa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the station on another body A (that is, a point measured and expressed in A) that is currently coincident in space with the origin Bo of this body B.  <a href="#a4f1b290369cf503f4729b4bcd0f8aa4f">More...</a><br /></td></tr>
<tr class="separator:a4f1b290369cf503f4729b4bcd0f8aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d82188ee012eda593dbe5bd4d7d6689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4d82188ee012eda593dbe5bd4d7d6689">findBodyVelocityInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a4d82188ee012eda593dbe5bd4d7d6689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular and linear velocity of body B's frame in body A's frame, expressed in body A, and arranged as a SpatialVec.  <a href="#a4d82188ee012eda593dbe5bd4d7d6689">More...</a><br /></td></tr>
<tr class="separator:a4d82188ee012eda593dbe5bd4d7d6689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3149c2ccfcf53d3c6d2f1da6e02ade0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3149c2ccfcf53d3c6d2f1da6e02ade0a">findBodyAngularVelocityInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a3149c2ccfcf53d3c6d2f1da6e02ade0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular velocity w_AB of body B's frame in body A's frame, expressed in body A.  <a href="#a3149c2ccfcf53d3c6d2f1da6e02ade0a">More...</a><br /></td></tr>
<tr class="separator:a3149c2ccfcf53d3c6d2f1da6e02ade0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9266f52fbc2390c278c4496a454594ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a9266f52fbc2390c278c4496a454594ef">findBodyOriginVelocityInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a9266f52fbc2390c278c4496a454594ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the velocity of body B's origin point in body A's frame, expressed in body A.  <a href="#a9266f52fbc2390c278c4496a454594ef">More...</a><br /></td></tr>
<tr class="separator:a9266f52fbc2390c278c4496a454594ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdf069f368b01b2c40a6dde309eca42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a7bdf069f368b01b2c40a6dde309eca42">findBodyAccelerationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a7bdf069f368b01b2c40a6dde309eca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular and linear acceleration of body B's frame in body A's frame, expressed in body A, and arranged as a SpatialVec.  <a href="#a7bdf069f368b01b2c40a6dde309eca42">More...</a><br /></td></tr>
<tr class="separator:a7bdf069f368b01b2c40a6dde309eca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980e38c7e2e4f0da9aa47078cf8b33a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a980e38c7e2e4f0da9aa47078cf8b33a4">findBodyAngularAccelerationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a980e38c7e2e4f0da9aa47078cf8b33a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angular acceleration of body B's frame in body A's frame, expressed in body A.  <a href="#a980e38c7e2e4f0da9aa47078cf8b33a4">More...</a><br /></td></tr>
<tr class="separator:a980e38c7e2e4f0da9aa47078cf8b33a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03734a07495ebcf090b9a27a68461c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa03734a07495ebcf090b9a27a68461c7">findBodyOriginAccelerationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:aa03734a07495ebcf090b9a27a68461c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the acceleration of body B's origin point in body A's frame, expressed in body A.  <a href="#aa03734a07495ebcf090b9a27a68461c7">More...</a><br /></td></tr>
<tr class="separator:aa03734a07495ebcf090b9a27a68461c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc19dffd701936d44999571df13ba62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4bc19dffd701936d44999571df13ba62">findMobilizerReactionOnBodyAtMInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a4bc19dffd701936d44999571df13ba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the location of the mobilizer frame M (fixed to body B, but not necessarily at the body frame origin), expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#a4bc19dffd701936d44999571df13ba62">More...</a><br /></td></tr>
<tr class="separator:a4bc19dffd701936d44999571df13ba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f297ca83ef03523984f5dc57ed1786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a51f297ca83ef03523984f5dc57ed1786">findMobilizerReactionOnBodyAtOriginInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a51f297ca83ef03523984f5dc57ed1786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the spatial reaction force (moment and force) applied by the mobilizer to body B but shifted to the B frame origin, and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#a51f297ca83ef03523984f5dc57ed1786">More...</a><br /></td></tr>
<tr class="separator:a51f297ca83ef03523984f5dc57ed1786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad512a9ba70777226e20cd478f3b92372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad512a9ba70777226e20cd478f3b92372">findMobilizerReactionOnParentAtFInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:ad512a9ba70777226e20cd478f3b92372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard) body P at the location of the inboard "fixed" mobilizer frame F (fixed to body P, but not necessarily at the P frame origin), expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#ad512a9ba70777226e20cd478f3b92372">More...</a><br /></td></tr>
<tr class="separator:ad512a9ba70777226e20cd478f3b92372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9108cf72177a2a8488ac652f0289bf5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a9108cf72177a2a8488ac652f0289bf5f">findMobilizerReactionOnParentAtOriginInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a9108cf72177a2a8488ac652f0289bf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard) body P at the location of the P frame origin, and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#a9108cf72177a2a8488ac652f0289bf5f">More...</a><br /></td></tr>
<tr class="separator:a9108cf72177a2a8488ac652f0289bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba41aaca4c7ffde96012433cbad8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4cba41aaca4c7ffde96012433cbad8db">findStationLocationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB) const </td></tr>
<tr class="memdesc:a4cba41aaca4c7ffde96012433cbad8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cartesian (ground) location that is currently coincident with a station (point) S fixed on body B.  <a href="#a4cba41aaca4c7ffde96012433cbad8db">More...</a><br /></td></tr>
<tr class="separator:a4cba41aaca4c7ffde96012433cbad8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154c001e683ff81cd207db7677c002d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a154c001e683ff81cd207db7677c002d4">findStationLocationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;toBodyA) const </td></tr>
<tr class="memdesc:a154c001e683ff81cd207db7677c002d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a station S on this body B, return the location on another body A which is at the same location in space.  <a href="#a154c001e683ff81cd207db7677c002d4">More...</a><br /></td></tr>
<tr class="separator:a154c001e683ff81cd207db7677c002d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea3a099f83c1721e9778b4ecc48df8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aaea3a099f83c1721e9778b4ecc48df8e">findStationVelocityInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB) const </td></tr>
<tr class="memdesc:aaea3a099f83c1721e9778b4ecc48df8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a station fixed on body B, return its inertial (Cartesian) velocity, that is, its velocity relative to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame.  <a href="#aaea3a099f83c1721e9778b4ecc48df8e">More...</a><br /></td></tr>
<tr class="separator:aaea3a099f83c1721e9778b4ecc48df8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe15ba865f8200758f6403d69898a627"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#abe15ba865f8200758f6403d69898a627">findStationVelocityInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:abe15ba865f8200758f6403d69898a627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the velocity of a station S fixed on body B, in body A's frame, expressed in body A.  <a href="#abe15ba865f8200758f6403d69898a627">More...</a><br /></td></tr>
<tr class="separator:abe15ba865f8200758f6403d69898a627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63fa56fba245dea20dd1c558f938243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad63fa56fba245dea20dd1c558f938243">findStationAccelerationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB) const </td></tr>
<tr class="memdesc:ad63fa56fba245dea20dd1c558f938243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a station fixed on body B, return its inertial (Cartesian) acceleration, that is, its acceleration relative to the ground frame, expressed in the ground frame.  <a href="#ad63fa56fba245dea20dd1c558f938243">More...</a><br /></td></tr>
<tr class="separator:ad63fa56fba245dea20dd1c558f938243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4b1e77bf8540e4f02be6ab1c2d30a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0c4b1e77bf8540e4f02be6ab1c2d30a7">findStationAccelerationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a0c4b1e77bf8540e4f02be6ab1c2d30a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the acceleration of a station S fixed on body B, in another body A's frame, expressed in body A.  <a href="#a0c4b1e77bf8540e4f02be6ab1c2d30a7">More...</a><br /></td></tr>
<tr class="separator:a0c4b1e77bf8540e4f02be6ab1c2d30a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0204ec2a61c7539a85f0c79d2b4800c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa0204ec2a61c7539a85f0c79d2b4800c">findStationLocationAndVelocityInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnB, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnGround, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityInGround) const </td></tr>
<tr class="memdesc:aa0204ec2a61c7539a85f0c79d2b4800c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is cheaper to calculate a station's ground location and velocity together than to do them separately.  <a href="#aa0204ec2a61c7539a85f0c79d2b4800c">More...</a><br /></td></tr>
<tr class="separator:aa0204ec2a61c7539a85f0c79d2b4800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ead96bfda2f3e7879d46e0e2b1c8575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2ead96bfda2f3e7879d46e0e2b1c8575">findStationLocationVelocityAndAccelerationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnB, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnGround, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityInGround, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;accelerationInGround) const </td></tr>
<tr class="memdesc:a2ead96bfda2f3e7879d46e0e2b1c8575"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is cheaper to calculate a station's ground location, velocity, and acceleration together than to do them separately.  <a href="#a2ead96bfda2f3e7879d46e0e2b1c8575">More...</a><br /></td></tr>
<tr class="separator:a2ead96bfda2f3e7879d46e0e2b1c8575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a54cb9ae23c2776f281bb2c66b4218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a24a54cb9ae23c2776f281bb2c66b4218">findMassCenterLocationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a24a54cb9ae23c2776f281bb2c66b4218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cartesian (ground) location of this body B's mass center.  <a href="#a24a54cb9ae23c2776f281bb2c66b4218">More...</a><br /></td></tr>
<tr class="separator:a24a54cb9ae23c2776f281bb2c66b4218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b751d3d1e97d6a4953adead25f482f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa3b751d3d1e97d6a4953adead25f482f">findMassCenterLocationInAnotherBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;toBodyA) const </td></tr>
<tr class="memdesc:aa3b751d3d1e97d6a4953adead25f482f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the point of another body A that is currently coincident in space with the mass center CB of this body B.  <a href="#aa3b751d3d1e97d6a4953adead25f482f">More...</a><br /></td></tr>
<tr class="separator:aa3b751d3d1e97d6a4953adead25f482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd25ff7099afe8eef241bb1e796f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a9abd25ff7099afe8eef241bb1e796f9b">findStationAtGroundPoint</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationInG) const </td></tr>
<tr class="memdesc:a9abd25ff7099afe8eef241bb1e796f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the station (point) S of this body B that is coincident with the given <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> location.  <a href="#a9abd25ff7099afe8eef241bb1e796f9b">More...</a><br /></td></tr>
<tr class="separator:a9abd25ff7099afe8eef241bb1e796f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d8bbf4d1bf416cb0fb41c5952754d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ac5d8bbf4d1bf416cb0fb41c5952754d5">findStationAtAnotherBodyStation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;fromBodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnA) const </td></tr>
<tr class="memdesc:ac5d8bbf4d1bf416cb0fb41c5952754d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the station (point) on this body B that is coincident with the given station on another body A.  <a href="#ac5d8bbf4d1bf416cb0fb41c5952754d5">More...</a><br /></td></tr>
<tr class="separator:ac5d8bbf4d1bf416cb0fb41c5952754d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0f6b7bd56ef94cbd6e1e54cf57568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a63f0f6b7bd56ef94cbd6e1e54cf57568">findStationAtAnotherBodyOrigin</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;fromBodyA) const </td></tr>
<tr class="memdesc:a63f0f6b7bd56ef94cbd6e1e54cf57568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the station S of this body that is currently coincident in space with the origin Ao of another body A.  <a href="#a63f0f6b7bd56ef94cbd6e1e54cf57568">More...</a><br /></td></tr>
<tr class="separator:a63f0f6b7bd56ef94cbd6e1e54cf57568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24fa5ed7cd6e2f835b6bc5bee23a026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad24fa5ed7cd6e2f835b6bc5bee23a026">findStationAtAnotherBodyMassCenter</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;fromBodyA) const </td></tr>
<tr class="memdesc:ad24fa5ed7cd6e2f835b6bc5bee23a026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the station S of this body that is currently coincident in space with the mass center Ac of another body A.  <a href="#ad24fa5ed7cd6e2f835b6bc5bee23a026">More...</a><br /></td></tr>
<tr class="separator:ad24fa5ed7cd6e2f835b6bc5bee23a026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174c4b66e4b65aac1a0a4d08544ed1ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a174c4b66e4b65aac1a0a4d08544ed1ea">findFrameTransformInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;frameOnB) const </td></tr>
<tr class="memdesc:a174c4b66e4b65aac1a0a4d08544ed1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current Ground-frame pose (position and orientation) of a frame F that is fixed to body B.  <a href="#a174c4b66e4b65aac1a0a4d08544ed1ea">More...</a><br /></td></tr>
<tr class="separator:a174c4b66e4b65aac1a0a4d08544ed1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad875a1f313cb6bdb0fc2f6c11f858cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad875a1f313cb6bdb0fc2f6c11f858cd8">findFrameVelocityInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;frameOnB) const </td></tr>
<tr class="memdesc:ad875a1f313cb6bdb0fc2f6c11f858cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current Ground-frame spatial velocity V_GF (that is, angular and linear velocity) of a frame F that is fixed to body B.  <a href="#ad875a1f313cb6bdb0fc2f6c11f858cd8">More...</a><br /></td></tr>
<tr class="separator:ad875a1f313cb6bdb0fc2f6c11f858cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df50ff36dffd8aa82a7379edeb6cb8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6df50ff36dffd8aa82a7379edeb6cb8b">findFrameAccelerationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;frameOnB) const </td></tr>
<tr class="memdesc:a6df50ff36dffd8aa82a7379edeb6cb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current Ground-frame spatial acceleration A_GF (that is, angular and linear acceleration) of a frame F that is fixed to body B.  <a href="#a6df50ff36dffd8aa82a7379edeb6cb8b">More...</a><br /></td></tr>
<tr class="separator:a6df50ff36dffd8aa82a7379edeb6cb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5bca3a4ca67bfa7e3ae660f353b072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a4a5bca3a4ca67bfa7e3ae660f353b072">expressVectorInGroundFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;vectorInB) const </td></tr>
<tr class="memdesc:a4a5bca3a4ca67bfa7e3ae660f353b072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express a vector expressed in this body B's frame into the same vector in G, by applying only a rotation.  <a href="#a4a5bca3a4ca67bfa7e3ae660f353b072">More...</a><br /></td></tr>
<tr class="separator:a4a5bca3a4ca67bfa7e3ae660f353b072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa32d7c974459ecb5acf90ab4dc1eaa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aaa32d7c974459ecb5acf90ab4dc1eaa0">expressGroundVectorInBodyFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;vectorInG) const </td></tr>
<tr class="memdesc:aaa32d7c974459ecb5acf90ab4dc1eaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express a vector expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> into the same vector expressed in this body B, by applying only rotation.  <a href="#aaa32d7c974459ecb5acf90ab4dc1eaa0">More...</a><br /></td></tr>
<tr class="separator:aaa32d7c974459ecb5acf90ab4dc1eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f57973c18df491b727df80a4aa8e0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3f57973c18df491b727df80a4aa8e0a4">expressVectorInAnotherBodyFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;vectorInB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a3f57973c18df491b727df80a4aa8e0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express a vector expressed in this body B into the same vector expressed in body A, by applying only a rotation.  <a href="#a3f57973c18df491b727df80a4aa8e0a4">More...</a><br /></td></tr>
<tr class="separator:a3f57973c18df491b727df80a4aa8e0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44026b68e505b7193b6211e1bb3292b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a44026b68e505b7193b6211e1bb3292b9">expressMassPropertiesInGroundFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a44026b68e505b7193b6211e1bb3292b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this body B's mass properties in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> by applying only a rotation, not a shift of reference point.  <a href="#a44026b68e505b7193b6211e1bb3292b9">More...</a><br /></td></tr>
<tr class="separator:a44026b68e505b7193b6211e1bb3292b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af552e3a4fda07b3e80448c02a82f2c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af552e3a4fda07b3e80448c02a82f2c48">expressMassPropertiesInAnotherBodyFrame</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:af552e3a4fda07b3e80448c02a82f2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-express this body B's mass properties in another body A's frame by applying only a rotation, not a shift of reference point.  <a href="#af552e3a4fda07b3e80448c02a82f2c48">More...</a><br /></td></tr>
<tr class="separator:af552e3a4fda07b3e80448c02a82f2c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">High-Level Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>High level operators combine <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> Access and Basic Operators with run-time tests to calculate more complex MobilizedBody-specific quantities, with more complicated implementations that can exploit special cases at run time.</p>
</div></td></tr>
<tr class="memitem:a502978034abfca4e767d7b30c9f8e356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga62d661c98a4b9595b84102e835800511">SpatialMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a502978034abfca4e767d7b30c9f8e356">calcBodySpatialInertiaMatrixInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:a502978034abfca4e767d7b30c9f8e356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mass properties of body B, measured from and about the B origin Bo, but expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> and then returned as a Spatial Inertia Matrix.  <a href="#a502978034abfca4e767d7b30c9f8e356">More...</a><br /></td></tr>
<tr class="separator:a502978034abfca4e767d7b30c9f8e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27daeddf797146742c9f67b53d99c291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a27daeddf797146742c9f67b53d99c291">calcBodyCentralInertia</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> objectBodyB) const </td></tr>
<tr class="memdesc:a27daeddf797146742c9f67b53d99c291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the central inertia for body B, that is, the inertia taken about body B's mass center Bc, and expressed in B.  <a href="#a27daeddf797146742c9f67b53d99c291">More...</a><br /></td></tr>
<tr class="separator:a27daeddf797146742c9f67b53d99c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c0e656d5315370004b3052bd3e5ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a36c0e656d5315370004b3052bd3e5ce0">calcBodyInertiaAboutAnotherBodyStation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;aboutLocationOnBodyA) const </td></tr>
<tr class="memdesc:a36c0e656d5315370004b3052bd3e5ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inertia of this body B, taken about an arbitrary point PA of body A, and expressed in body A.  <a href="#a36c0e656d5315370004b3052bd3e5ce0">More...</a><br /></td></tr>
<tr class="separator:a36c0e656d5315370004b3052bd3e5ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4029646b0e89372c37eb12a7f63c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#afc4029646b0e89372c37eb12a7f63c4c">calcBodyMomentumAboutBodyOriginInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state)</td></tr>
<tr class="memdesc:afc4029646b0e89372c37eb12a7f63c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate body B's momentum (angular, linear) measured and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, but taken about the body origin Bo.  <a href="#afc4029646b0e89372c37eb12a7f63c4c">More...</a><br /></td></tr>
<tr class="separator:afc4029646b0e89372c37eb12a7f63c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4057ec7dbf36556c8633529f521457b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa4057ec7dbf36556c8633529f521457b">calcBodyMomentumAboutBodyMassCenterInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const </td></tr>
<tr class="memdesc:aa4057ec7dbf36556c8633529f521457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate body B's momentum (angular, linear) measured and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, but taken about the body mass center Bc.  <a href="#aa4057ec7dbf36556c8633529f521457b">More...</a><br /></td></tr>
<tr class="separator:aa4057ec7dbf36556c8633529f521457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670bf0636c3fee6ab7c642fc2bdb13bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a670bf0636c3fee6ab7c642fc2bdb13bf">calcStationToStationDistance</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;bodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyA) const </td></tr>
<tr class="memdesc:a670bf0636c3fee6ab7c642fc2bdb13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance from a station PB on body B to a station PA on body A.  <a href="#a670bf0636c3fee6ab7c642fc2bdb13bf">More...</a><br /></td></tr>
<tr class="separator:a670bf0636c3fee6ab7c642fc2bdb13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc856e321ebcd2a73abe8dae404bc721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#adc856e321ebcd2a73abe8dae404bc721">calcStationToStationDistanceTimeDerivative</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;bodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyA) const </td></tr>
<tr class="memdesc:adc856e321ebcd2a73abe8dae404bc721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the time rate of change of distance from a fixed point PB on body B to a fixed point PA on body A.  <a href="#adc856e321ebcd2a73abe8dae404bc721">More...</a><br /></td></tr>
<tr class="separator:adc856e321ebcd2a73abe8dae404bc721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b7270f1b4ee67d7ce39f5b7a7a1038"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af6b7270f1b4ee67d7ce39f5b7a7a1038">calcStationToStationDistance2ndTimeDerivative</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;bodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyA) const </td></tr>
<tr class="memdesc:af6b7270f1b4ee67d7ce39f5b7a7a1038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the second time derivative of distance from a fixed point PB on body B to a fixed point PA on body A.  <a href="#af6b7270f1b4ee67d7ce39f5b7a7a1038">More...</a><br /></td></tr>
<tr class="separator:af6b7270f1b4ee67d7ce39f5b7a7a1038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2310ebac8eef484807289765f02ca90d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2310ebac8eef484807289765f02ca90d">calcBodyMovingPointVelocityInBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a2310ebac8eef484807289765f02ca90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet &ndash; any volunteers? Return the velocity of a point P moving on body B, in body A's frame, expressed in body A.  <a href="#a2310ebac8eef484807289765f02ca90d">More...</a><br /></td></tr>
<tr class="separator:a2310ebac8eef484807289765f02ca90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4ac1adfc161012b68803cf42bac406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a5e4ac1adfc161012b68803cf42bac406">calcBodyMovingPointAccelerationInBody</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;accelerationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;inBodyA) const </td></tr>
<tr class="memdesc:a5e4ac1adfc161012b68803cf42bac406"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet &ndash; any volunteers? Return the velocity of a point P moving (and possibly accelerating) on body B, in body A's frame, expressed in body A.  <a href="#a5e4ac1adfc161012b68803cf42bac406">More...</a><br /></td></tr>
<tr class="separator:a5e4ac1adfc161012b68803cf42bac406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ce43a4954a9b0d1b1f8c4120118a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aea0ce43a4954a9b0d1b1f8c4120118a3">calcMovingPointToPointDistanceTimeDerivative</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;bodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyA) const </td></tr>
<tr class="memdesc:aea0ce43a4954a9b0d1b1f8c4120118a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet &ndash; any volunteers? Calculate the time rate of change of distance from a moving point PB on body B to a moving point PA on body A.  <a href="#aea0ce43a4954a9b0d1b1f8c4120118a3">More...</a><br /></td></tr>
<tr class="separator:aea0ce43a4954a9b0d1b1f8c4120118a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667a7e9ff38a440c40a6edfe6e5be508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a667a7e9ff38a440c40a6edfe6e5be508">calcMovingPointToPointDistance2ndTimeDerivative</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;accelerationOnBodyB, const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;bodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;locationOnBodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;velocityOnBodyA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;accelerationOnBodyA) const </td></tr>
<tr class="memdesc:a667a7e9ff38a440c40a6edfe6e5be508"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: not implemented yet &ndash; any volunteers? Calculate the second time derivative of distance from a moving point PB on body B to a moving point PA on body A.  <a href="#a667a7e9ff38a440c40a6edfe6e5be508">More...</a><br /></td></tr>
<tr class="separator:a667a7e9ff38a440c40a6edfe6e5be508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and Misc Methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are the base class services which are used while building a concrete MobilizedBody, or to query a MobilizedBody to find out how it was built.</p>
<p>These are unlikely to be used by end users of MobilizedBodies. </p>
</div></td></tr>
<tr class="memitem:a50504ba0523506307e866bf5a3c9a6b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Body.html">Body</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a50504ba0523506307e866bf5a3c9a6b3">getBody</a> () const </td></tr>
<tr class="memdesc:a50504ba0523506307e866bf5a3c9a6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody.  <a href="#a50504ba0523506307e866bf5a3c9a6b3">More...</a><br /></td></tr>
<tr class="separator:a50504ba0523506307e866bf5a3c9a6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d923cd8142f9f22fd8c066bc123f5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Body.html">Body</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a9d923cd8142f9f22fd8c066bc123f5fc">updBody</a> ()</td></tr>
<tr class="memdesc:a9d923cd8142f9f22fd8c066bc123f5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody.  <a href="#a9d923cd8142f9f22fd8c066bc123f5fc">More...</a><br /></td></tr>
<tr class="separator:a9d923cd8142f9f22fd8c066bc123f5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed529dd784c1b31d0758dc108d99733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6ed529dd784c1b31d0758dc108d99733">setBody</a> (const <a class="el" href="classSimTK_1_1Body.html">Body</a> &amp;)</td></tr>
<tr class="memdesc:a6ed529dd784c1b31d0758dc108d99733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody with a new one.  <a href="#a6ed529dd784c1b31d0758dc108d99733">More...</a><br /></td></tr>
<tr class="separator:a6ed529dd784c1b31d0758dc108d99733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0397e80362252a12c1e1b82fad4119d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0397e80362252a12c1e1b82fad4119d1">addBodyDecoration</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_BD, const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;geometry)</td></tr>
<tr class="memdesc:a0397e80362252a12c1e1b82fad4119d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add decorative geometry specified relative to the new (outboard) body's reference frame B.  <a href="#a0397e80362252a12c1e1b82fad4119d1">More...</a><br /></td></tr>
<tr class="separator:a0397e80362252a12c1e1b82fad4119d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fdbd930e0d1b457b34f74bbea48f05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a23fdbd930e0d1b457b34f74bbea48f05">addBodyDecoration</a> (const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;geometry)</td></tr>
<tr class="memdesc:a23fdbd930e0d1b457b34f74bbea48f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for use when the <code>geometry</code> is supplied in the body frame.  <a href="#a23fdbd930e0d1b457b34f74bbea48f05">More...</a><br /></td></tr>
<tr class="separator:a23fdbd930e0d1b457b34f74bbea48f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318d42af0404b963baaf79aefe5ac2aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a318d42af0404b963baaf79aefe5ac2aa">addOutboardDecoration</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_MD, const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;geometry)</td></tr>
<tr class="memdesc:a318d42af0404b963baaf79aefe5ac2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add decorative geometry specified relative to the outboard mobilizer frame M attached to body B.  <a href="#a318d42af0404b963baaf79aefe5ac2aa">More...</a><br /></td></tr>
<tr class="separator:a318d42af0404b963baaf79aefe5ac2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691b7b83f03bab864809c57f09aa5bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a1691b7b83f03bab864809c57f09aa5bd">getNumOutboardDecorations</a> () const </td></tr>
<tr class="memdesc:a1691b7b83f03bab864809c57f09aa5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of decorations added with <a class="el" href="classSimTK_1_1MobilizedBody.html#a318d42af0404b963baaf79aefe5ac2aa" title="Add decorative geometry specified relative to the outboard mobilizer frame M attached to body B...">addOutboardDecoration()</a>.  <a href="#a1691b7b83f03bab864809c57f09aa5bd">More...</a><br /></td></tr>
<tr class="separator:a1691b7b83f03bab864809c57f09aa5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953490945c2f038d5863a2a69562d1bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a953490945c2f038d5863a2a69562d1bd">getOutboardDecoration</a> (int i) const </td></tr>
<tr class="memdesc:a953490945c2f038d5863a2a69562d1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the i'th outboard decoration.  <a href="#a953490945c2f038d5863a2a69562d1bd">More...</a><br /></td></tr>
<tr class="separator:a953490945c2f038d5863a2a69562d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c9eeb5134c3f0592ff8ad9596c60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab72c9eeb5134c3f0592ff8ad9596c60a">updOutboardDecoration</a> (int i)</td></tr>
<tr class="memdesc:ab72c9eeb5134c3f0592ff8ad9596c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the i'th outboard decoration.  <a href="#ab72c9eeb5134c3f0592ff8ad9596c60a">More...</a><br /></td></tr>
<tr class="separator:ab72c9eeb5134c3f0592ff8ad9596c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4d45c5d01f527fe78d1cd87ae0ed12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aac4d45c5d01f527fe78d1cd87ae0ed12">addInboardDecoration</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_FD, const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;geometry)</td></tr>
<tr class="memdesc:aac4d45c5d01f527fe78d1cd87ae0ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add decorative geometry specified relative to the inboard mobilizer frame F attached to the parent body P.  <a href="#aac4d45c5d01f527fe78d1cd87ae0ed12">More...</a><br /></td></tr>
<tr class="separator:aac4d45c5d01f527fe78d1cd87ae0ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6332e7affc3bc5d08e03404217e1e10f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a6332e7affc3bc5d08e03404217e1e10f">getNumInboardDecorations</a> () const </td></tr>
<tr class="memdesc:a6332e7affc3bc5d08e03404217e1e10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of decorations added with <a class="el" href="classSimTK_1_1MobilizedBody.html#aac4d45c5d01f527fe78d1cd87ae0ed12" title="Add decorative geometry specified relative to the inboard mobilizer frame F attached to the parent bo...">addInboardDecoration()</a>.  <a href="#a6332e7affc3bc5d08e03404217e1e10f">More...</a><br /></td></tr>
<tr class="separator:a6332e7affc3bc5d08e03404217e1e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9023214074ff6f08a66482a47ca18dac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a9023214074ff6f08a66482a47ca18dac">getInboardDecoration</a> (int i) const </td></tr>
<tr class="memdesc:a9023214074ff6f08a66482a47ca18dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the i'th inboard decoration.  <a href="#a9023214074ff6f08a66482a47ca18dac">More...</a><br /></td></tr>
<tr class="separator:a9023214074ff6f08a66482a47ca18dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aafb9d7c6308942522cdbde6ccf1d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2aafb9d7c6308942522cdbde6ccf1d06">updInboardDecoration</a> (int i)</td></tr>
<tr class="memdesc:a2aafb9d7c6308942522cdbde6ccf1d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the i'th inboard decoration.  <a href="#a2aafb9d7c6308942522cdbde6ccf1d06">More...</a><br /></td></tr>
<tr class="separator:a2aafb9d7c6308942522cdbde6ccf1d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ad8ad7a2ab01d1f972ac63b75177c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a96ad8ad7a2ab01d1f972ac63b75177c4">setDefaultMassProperties</a> (const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> &amp;m)</td></tr>
<tr class="memdesc:a96ad8ad7a2ab01d1f972ac63b75177c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the contained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> can have its mass properties set to the supplied value <code>m</code> its mass properties are changed, otherwise the method fails.  <a href="#a96ad8ad7a2ab01d1f972ac63b75177c4">More...</a><br /></td></tr>
<tr class="separator:a96ad8ad7a2ab01d1f972ac63b75177c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cf261b33dd74faca04cf0df404387d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ac7cf261b33dd74faca04cf0df404387d">getDefaultMassProperties</a> () const </td></tr>
<tr class="memdesc:ac7cf261b33dd74faca04cf0df404387d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mass properties of the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> stored within this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>.  <a href="#ac7cf261b33dd74faca04cf0df404387d">More...</a><br /></td></tr>
<tr class="separator:ac7cf261b33dd74faca04cf0df404387d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8093a13f5455a64f3992ac46e60baff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a8093a13f5455a64f3992ac46e60baff3">adoptMotion</a> (<a class="el" href="classSimTK_1_1Motion.html">Motion</a> &amp;ownerHandle)</td></tr>
<tr class="memdesc:a8093a13f5455a64f3992ac46e60baff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a unique <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object for this MobilizedBody.  <a href="#a8093a13f5455a64f3992ac46e60baff3">More...</a><br /></td></tr>
<tr class="separator:a8093a13f5455a64f3992ac46e60baff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad387e92c292c91370ae34e64d4fb1a25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ad387e92c292c91370ae34e64d4fb1a25">clearMotion</a> ()</td></tr>
<tr class="memdesc:ad387e92c292c91370ae34e64d4fb1a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object associated with this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> it is removed; otherwise, nothing happens.  <a href="#ad387e92c292c91370ae34e64d4fb1a25">More...</a><br /></td></tr>
<tr class="separator:ad387e92c292c91370ae34e64d4fb1a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdc23563e2ce3e79a6eff6028713f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aad0cdc23563e2ce3e79a6eff6028713f">hasMotion</a> () const </td></tr>
<tr class="memdesc:aad0cdc23563e2ce3e79a6eff6028713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this MobilizedBody has an associated <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object.  <a href="#aad0cdc23563e2ce3e79a6eff6028713f">More...</a><br /></td></tr>
<tr class="separator:aad0cdc23563e2ce3e79a6eff6028713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45691e3b33e7c78f5118078565df5f6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Motion.html">Motion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a45691e3b33e7c78f5118078565df5f6d">getMotion</a> () const </td></tr>
<tr class="memdesc:a45691e3b33e7c78f5118078565df5f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object associated with this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, this returns a const reference to it.  <a href="#a45691e3b33e7c78f5118078565df5f6d">More...</a><br /></td></tr>
<tr class="separator:a45691e3b33e7c78f5118078565df5f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa316ee0d30e68802bbb5c5e5f923b629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa316ee0d30e68802bbb5c5e5f923b629">setDefaultInboardFrame</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_PF)</td></tr>
<tr class="memdesc:aa316ee0d30e68802bbb5c5e5f923b629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this mobilizer's frame F on the parent body P.  <a href="#aa316ee0d30e68802bbb5c5e5f923b629">More...</a><br /></td></tr>
<tr class="separator:aa316ee0d30e68802bbb5c5e5f923b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ab782162cb3812c0d8210288290624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa9ab782162cb3812c0d8210288290624">setDefaultOutboardFrame</a> (const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_BM)</td></tr>
<tr class="memdesc:aa9ab782162cb3812c0d8210288290624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this mobilizer's frame M fixed on this (the outboard) body B.  <a href="#aa9ab782162cb3812c0d8210288290624">More...</a><br /></td></tr>
<tr class="separator:aa9ab782162cb3812c0d8210288290624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb13a977d8b395603bbb2bdc9b17b97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#acdb13a977d8b395603bbb2bdc9b17b97">getDefaultInboardFrame</a> () const </td></tr>
<tr class="memdesc:acdb13a977d8b395603bbb2bdc9b17b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this mobilizer's default for the frame F fixed on the parent (inboard) body P, as the fixed Transform from P's body frame to the frame F fixed to P.  <a href="#acdb13a977d8b395603bbb2bdc9b17b97">More...</a><br /></td></tr>
<tr class="separator:acdb13a977d8b395603bbb2bdc9b17b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3685fb7d4a869b5f155b1a8ff93d14f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3685fb7d4a869b5f155b1a8ff93d14f8">getDefaultOutboardFrame</a> () const </td></tr>
<tr class="memdesc:a3685fb7d4a869b5f155b1a8ff93d14f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this MobilizedBody's default for mobilizer frame M, as the fixed Transform from this body B's frame to the frame M fixed on B.  <a href="#a3685fb7d4a869b5f155b1a8ff93d14f8">More...</a><br /></td></tr>
<tr class="separator:a3685fb7d4a869b5f155b1a8ff93d14f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b7797495da5ec793e3990ca55709e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a01b7797495da5ec793e3990ca55709e4">operator MobilizedBodyIndex</a> () const </td></tr>
<tr class="memdesc:a01b7797495da5ec793e3990ca55709e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion from MobilizedBody to <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> when needed.  <a href="#a01b7797495da5ec793e3990ca55709e4">More...</a><br /></td></tr>
<tr class="separator:a01b7797495da5ec793e3990ca55709e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57d3e2056111f2f266a5cac92a118cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#af57d3e2056111f2f266a5cac92a118cf">getMobilizedBodyIndex</a> () const </td></tr>
<tr class="memdesc:af57d3e2056111f2f266a5cac92a118cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within the owning <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>.  <a href="#af57d3e2056111f2f266a5cac92a118cf">More...</a><br /></td></tr>
<tr class="separator:af57d3e2056111f2f266a5cac92a118cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994d1afbed8dbddda0032b05e17bb21e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a994d1afbed8dbddda0032b05e17bb21e">getParentMobilizedBody</a> () const </td></tr>
<tr class="memdesc:a994d1afbed8dbddda0032b05e17bb21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> serving as the parent body of the current <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>.  <a href="#a994d1afbed8dbddda0032b05e17bb21e">More...</a><br /></td></tr>
<tr class="separator:a994d1afbed8dbddda0032b05e17bb21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36d77f2bba99bcc6960e85ff20aebe5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ab36d77f2bba99bcc6960e85ff20aebe5">getBaseMobilizedBody</a> () const </td></tr>
<tr class="memdesc:ab36d77f2bba99bcc6960e85ff20aebe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to this MobilizedBody's oldest ancestor other than <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, or return <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> if this MobilizedBody is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#ab36d77f2bba99bcc6960e85ff20aebe5">More...</a><br /></td></tr>
<tr class="separator:ab36d77f2bba99bcc6960e85ff20aebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac775ea17a6b45616c8f4614d7f05039a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ac775ea17a6b45616c8f4614d7f05039a">getMatterSubsystem</a> () const </td></tr>
<tr class="memdesc:ac775ea17a6b45616c8f4614d7f05039a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a reference to the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> which contains this MobilizedBody.  <a href="#ac775ea17a6b45616c8f4614d7f05039a">More...</a><br /></td></tr>
<tr class="separator:ac775ea17a6b45616c8f4614d7f05039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b3864498124e5f5a9874efe68ffd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa31b3864498124e5f5a9874efe68ffd2">updMatterSubsystem</a> ()</td></tr>
<tr class="memdesc:aa31b3864498124e5f5a9874efe68ffd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a writable reference to the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> which contains this MobilizedBody.  <a href="#aa31b3864498124e5f5a9874efe68ffd2">More...</a><br /></td></tr>
<tr class="separator:aa31b3864498124e5f5a9874efe68ffd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3811f11ba5bc6c71d69089f8e44cae09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a3811f11ba5bc6c71d69089f8e44cae09">isInSubsystem</a> () const </td></tr>
<tr class="memdesc:a3811f11ba5bc6c71d69089f8e44cae09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> object is owned by a matter subsystem.  <a href="#a3811f11ba5bc6c71d69089f8e44cae09">More...</a><br /></td></tr>
<tr class="separator:a3811f11ba5bc6c71d69089f8e44cae09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d669565cc8b3280a9dcda76d436f74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a48d669565cc8b3280a9dcda76d436f74">isInSameSubsystem</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;mobod) const </td></tr>
<tr class="memdesc:a48d669565cc8b3280a9dcda76d436f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> <code>mobod</code> is in the same matter subsystem as the current body.  <a href="#a48d669565cc8b3280a9dcda76d436f74">More...</a><br /></td></tr>
<tr class="separator:a48d669565cc8b3280a9dcda76d436f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc702c31a60e1aa2c30bde5928df1ee3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#adc702c31a60e1aa2c30bde5928df1ee3">isSameMobilizedBody</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;mobod) const </td></tr>
<tr class="memdesc:adc702c31a60e1aa2c30bde5928df1ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a given MobilizedBody <code>mobod</code> is the same MobilizedBody as this one.  <a href="#adc702c31a60e1aa2c30bde5928df1ee3">More...</a><br /></td></tr>
<tr class="separator:adc702c31a60e1aa2c30bde5928df1ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d2b1ce31d2517f54fe6ca017e12e77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a91d2b1ce31d2517f54fe6ca017e12e77">isGround</a> () const </td></tr>
<tr class="memdesc:a91d2b1ce31d2517f54fe6ca017e12e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this body is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, meaning that it is actually body 0 of some matter subsytem, not just that its body type is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>.  <a href="#a91d2b1ce31d2517f54fe6ca017e12e77">More...</a><br /></td></tr>
<tr class="separator:a91d2b1ce31d2517f54fe6ca017e12e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9c7060d2eba76350683a5877b8e9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a88a9c7060d2eba76350683a5877b8e9c">getLevelInMultibodyTree</a> () const </td></tr>
<tr class="memdesc:a88a9c7060d2eba76350683a5877b8e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this body's level in the tree of bodies, starting with ground at 0, bodies directly connected to ground at 1, bodies directly connected to those at 2, etc.  <a href="#a88a9c7060d2eba76350683a5877b8e9c">More...</a><br /></td></tr>
<tr class="separator:a88a9c7060d2eba76350683a5877b8e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dd85c33023cff8000542223937cc47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a38dd85c33023cff8000542223937cc47">cloneForNewParent</a> (<a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;parent) const </td></tr>
<tr class="memdesc:a38dd85c33023cff8000542223937cc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> which is identical to this one, except that it has a different parent (and consequently might belong to a different <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>).  <a href="#a38dd85c33023cff8000542223937cc47">More...</a><br /></td></tr>
<tr class="separator:a38dd85c33023cff8000542223937cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abdb29a5b69ee005c69f03492012cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a8abdb29a5b69ee005c69f03492012cf6">getOneFromQPartition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike) const </td></tr>
<tr class="memdesc:a8abdb29a5b69ee005c69f03492012cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility selects one of the q's (generalized coordinates) associated with this mobilizer from a supplied "q-like" Vector, meaning a Vector which is the same length as the Vector of q's for the containing matter subsystem.  <a href="#a8abdb29a5b69ee005c69f03492012cf6">More...</a><br /></td></tr>
<tr class="separator:a8abdb29a5b69ee005c69f03492012cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4c37c9469de167f38bceaf61e61ac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#acb4c37c9469de167f38bceaf61e61ac7">updOneFromQPartition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike) const </td></tr>
<tr class="memdesc:acb4c37c9469de167f38bceaf61e61ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility returns a writable reference to one of the q's (generalized coordinates) associated with this mobilizer from a supplied "q-like" Vector, meaning a Vector which is the same length as the Vector of q's for the containing matter subsystem.  <a href="#acb4c37c9469de167f38bceaf61e61ac7">More...</a><br /></td></tr>
<tr class="separator:acb4c37c9469de167f38bceaf61e61ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70b5c8c35ed2c4f98ea9ec497248d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#acf70b5c8c35ed2c4f98ea9ec497248d5">getOneFromUPartition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike) const </td></tr>
<tr class="memdesc:acf70b5c8c35ed2c4f98ea9ec497248d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility selects one of the u's (generalized speeds) associated with this mobilizer from a supplied "u-like" Vector, meaning a Vector which is the same length as the Vector of u's for the containing matter subsystem.  <a href="#acf70b5c8c35ed2c4f98ea9ec497248d5">More...</a><br /></td></tr>
<tr class="separator:acf70b5c8c35ed2c4f98ea9ec497248d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9467b6c619d89e1aa7e98894734840f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#ae9467b6c619d89e1aa7e98894734840f">updOneFromUPartition</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike) const </td></tr>
<tr class="memdesc:ae9467b6c619d89e1aa7e98894734840f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility returns a writable reference to one of the u's (generalized speeds) associated with this mobilizer from a supplied "u-like" Vector, meaning a Vector which is the same length as the Vector of u's for the containing matter subsystem.  <a href="#ae9467b6c619d89e1aa7e98894734840f">More...</a><br /></td></tr>
<tr class="separator:ae9467b6c619d89e1aa7e98894734840f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa98b6d48e4c17602da737be176d547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0aa98b6d48e4c17602da737be176d547">applyOneMobilityForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, int which, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> f, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const </td></tr>
<tr class="memdesc:a0aa98b6d48e4c17602da737be176d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility adds in the supplied generalized force <code>f</code> (a scalar) to the appropriate slot of the supplied <code>mobilityForces</code> Vector, which is a "u-like" Vector.  <a href="#a0aa98b6d48e4c17602da737be176d547">More...</a><br /></td></tr>
<tr class="separator:a0aa98b6d48e4c17602da737be176d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5f187e7ecd3ab750fd60f66a75010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a0ac5f187e7ecd3ab750fd60f66a75010">convertQForceToUForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> &gt; &amp;fq, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> &gt; &amp;fu) const </td></tr>
<tr class="memdesc:a0ac5f187e7ecd3ab750fd60f66a75010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a generalized force in the q-space of this mobilizer, convert it to the equivalent generalized mobility force (u-space force).  <a href="#a0ac5f187e7ecd3ab750fd60f66a75010">More...</a><br /></td></tr>
<tr class="separator:a0ac5f187e7ecd3ab750fd60f66a75010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d73a0b77545b7929b5299399a1c543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a77d73a0b77545b7929b5299399a1c543">applyBodyForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;spatialForceInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const </td></tr>
<tr class="memdesc:a77d73a0b77545b7929b5299399a1c543"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility adds in the supplied spatial force <code>spatialForceInG</code> (consisting of a torque vector, and a force vector to be applied at the current body's origin) to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector.  <a href="#a77d73a0b77545b7929b5299399a1c543">More...</a><br /></td></tr>
<tr class="separator:a77d73a0b77545b7929b5299399a1c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6aeee0ce7fed8f55293a34f1c4d435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a2b6aeee0ce7fed8f55293a34f1c4d435">applyBodyTorque</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;torqueInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const </td></tr>
<tr class="memdesc:a2b6aeee0ce7fed8f55293a34f1c4d435"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility adds in the supplied pure torque <code>torqueInG</code> to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector.  <a href="#a2b6aeee0ce7fed8f55293a34f1c4d435">More...</a><br /></td></tr>
<tr class="separator:a2b6aeee0ce7fed8f55293a34f1c4d435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d41383618cfbc4d254bdcce82d0a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#a86d41383618cfbc4d254bdcce82d0a73">applyForceToBodyPoint</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointInB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;forceInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const </td></tr>
<tr class="memdesc:a86d41383618cfbc4d254bdcce82d0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility adds in the supplied force <code>forceInG</code> applied at a point <code>pointInB</code> to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector.  <a href="#a86d41383618cfbc4d254bdcce82d0a73">More...</a><br /></td></tr>
<tr class="separator:a86d41383618cfbc4d254bdcce82d0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; MobilizedBody, MobilizedBodyImpl, true &gt;</a></td></tr>
<tr class="memitem:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ab7d17772c38115b341ee2e12aeeac36f">isEmptyHandle</a> () const</td></tr>
<tr class="memdesc:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is empty, that is, does not refer to any implementation object.  <a href="#ab7d17772c38115b341ee2e12aeeac36f">More...</a><br /></td></tr>
<tr class="separator:ab7d17772c38115b341ee2e12aeeac36f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3a6d9f8e49a5b828a9143b44a42e94f5">isOwnerHandle</a> () const</td></tr>
<tr class="memdesc:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this handle is the owner of the implementation object to which it refers.  <a href="#a3a6d9f8e49a5b828a9143b44a42e94f5">More...</a><br /></td></tr>
<tr class="separator:a3a6d9f8e49a5b828a9143b44a42e94f5 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a1cb05874b5a826344472105dbd649249">isSameHandle</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;other) const</td></tr>
<tr class="memdesc:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is the same object as "this" PIMPLHandle.  <a href="#a1cb05874b5a826344472105dbd649249">More...</a><br /></td></tr>
<tr class="separator:a1cb05874b5a826344472105dbd649249 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a53fc78d673f2db6a98f3bb4cdf14fd2f">disown</a> (<a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;newOwner)</td></tr>
<tr class="memdesc:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give up ownership of the implementation to an empty handle.  <a href="#a53fc78d673f2db6a98f3bb4cdf14fd2f">More...</a><br /></td></tr>
<tr class="separator:a53fc78d673f2db6a98f3bb4cdf14fd2f inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a878ec0d1cdd705d051a485a89c32f6e9">referenceAssign</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;source)</td></tr>
<tr class="memdesc:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Copy" assignment but with shallow (pointer) semantics.  <a href="#a878ec0d1cdd705d051a485a89c32f6e9">More...</a><br /></td></tr>
<tr class="separator:a878ec0d1cdd705d051a485a89c32f6e9 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a2de72469fd5f56985b944f696e9e79ae">copyAssign</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;source)</td></tr>
<tr class="memdesc:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is real copy assignment, with ordinary C++ object ("value") semantics.  <a href="#a2de72469fd5f56985b944f696e9e79ae">More...</a><br /></td></tr>
<tr class="separator:a2de72469fd5f56985b944f696e9e79ae inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a46a485a9ef857781b8029ffd829fa636">clearHandle</a> ()</td></tr>
<tr class="memdesc:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this an empty handle, deleting the implementation object if this handle is the owner of it.  <a href="#a46a485a9ef857781b8029ffd829fa636">More...</a><br /></td></tr>
<tr class="separator:a46a485a9ef857781b8029ffd829fa636 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">const MobilizedBodyImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a66906a41755f8dae64f3bd945b949c74">getImpl</a> () const</td></tr>
<tr class="memdesc:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the implementation associated with this Handle.  <a href="#a66906a41755f8dae64f3bd945b949c74">More...</a><br /></td></tr>
<tr class="separator:a66906a41755f8dae64f3bd945b949c74 inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">MobilizedBodyImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3cea00ca400bace6ccb795e5ba54d4ef">updImpl</a> ()</td></tr>
<tr class="memdesc:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to the implementation associated with this Handle.  <a href="#a3cea00ca400bace6ccb795e5ba54d4ef">More...</a><br /></td></tr>
<tr class="separator:a3cea00ca400bace6ccb795e5ba54d4ef inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a0e940afd133cc244c156b54a177529bd">getImplHandleCount</a> () const</td></tr>
<tr class="memdesc:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of handles the implementation believes are referencing it.  <a href="#a0e940afd133cc244c156b54a177529bd">More...</a><br /></td></tr>
<tr class="separator:a0e940afd133cc244c156b54a177529bd inherit pub_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa3ca9a5e09ca1368d7724daa9d7ff3fd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1MobilizedBody.html#aa3ca9a5e09ca1368d7724daa9d7ff3fd">Mobod</a></td></tr>
<tr class="memdesc:aa3ca9a5e09ca1368d7724daa9d7ff3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mobod is the approved abbreviation for <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. Feel free to use it if you get tired of typing or seeing the full name.  <a href="#aa3ca9a5e09ca1368d7724daa9d7ff3fd">More...</a><br /></td></tr>
<tr class="separator:aa3ca9a5e09ca1368d7724daa9d7ff3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classSimTK_1_1PIMPLHandle"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSimTK_1_1PIMPLHandle')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSimTK_1_1PIMPLHandle.html">SimTK::PIMPLHandle&lt; MobilizedBody, MobilizedBodyImpl, true &gt;</a></td></tr>
<tr class="memitem:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#ae66aa14c4a664f31d22289e2bb604441">PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor makes this an empty handle.  <a href="#ae66aa14c4a664f31d22289e2bb604441">More...</a><br /></td></tr>
<tr class="separator:ae66aa14c4a664f31d22289e2bb604441 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#aa9451ca6b7502c54447d10449662a483">PIMPLHandle</a> (MobilizedBodyImpl *p)</td></tr>
<tr class="memdesc:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides consruction of a handle referencing an existing implementation object.  <a href="#aa9451ca6b7502c54447d10449662a483">More...</a><br /></td></tr>
<tr class="separator:aa9451ca6b7502c54447d10449662a483 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a6f661f13ccfd6ca41d8a9fc3435e32e7">PIMPLHandle</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor makes either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer
semantics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a6f661f13ccfd6ca41d8a9fc3435e32e7">More...</a><br /></td></tr>
<tr class="separator:a6f661f13ccfd6ca41d8a9fc3435e32e7 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a5cabb439c294d4b696f9ec0a9534b6e3">~PIMPLHandle</a> ()</td></tr>
<tr class="memdesc:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note that the destructor is non-virtual.  <a href="#a5cabb439c294d4b696f9ec0a9534b6e3">More...</a><br /></td></tr>
<tr class="separator:a5cabb439c294d4b696f9ec0a9534b6e3 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a39c83a6a5f2b7fb96834981442d30f8d">operator=</a> (const <a class="el" href="classSimTK_1_1PIMPLHandle.html">PIMPLHandle</a> &amp;source)</td></tr>
<tr class="memdesc:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment makes the current handle either a deep (value) or shallow (reference) copy of the supplied source PIMPL object, based on whether this is a "pointer sematics" (PTR=true) or "object (value) semantics" (PTR=false, default) class.  <a href="#a39c83a6a5f2b7fb96834981442d30f8d">More...</a><br /></td></tr>
<tr class="separator:a39c83a6a5f2b7fb96834981442d30f8d inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a59892732781a567f4ad30b982acb2c27">setImpl</a> (MobilizedBodyImpl *p)</td></tr>
<tr class="memdesc:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the implementation for this empty handle.  <a href="#a59892732781a567f4ad30b982acb2c27">More...</a><br /></td></tr>
<tr class="separator:a59892732781a567f4ad30b982acb2c27 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1PIMPLHandle.html#a3666ec4c8e626e771aa5d058605fa840">hasSameImplementation</a> (const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;other) const</td></tr>
<tr class="memdesc:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the supplied handle is a reference to the same implementation object as is referenced by "this" PIMPLHandle.  <a href="#a3666ec4c8e626e771aa5d058605fa840">More...</a><br /></td></tr>
<tr class="separator:a3666ec4c8e626e771aa5d058605fa840 inherit pro_methods_classSimTK_1_1PIMPLHandle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A MobilizedBody is Simbody's fundamental body-and-joint object used to parameterize a system's motion by constructing a multibody tree containing each body and its unique "mobilizer" (internal coordinate joint). </p>
<p>A MobilizedBody connects a new body (the "child", "outboard", or "successor" body) with a mobilizer and a reference frame to an existing MobilizedBody (the "parent", "inboard", or "predecessor" body) that is already part of a <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. In the topology of the multibody tree, the parent mobilized body is always closer to <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> ("inboard") than is the child.</p>
<p>This is the base class for all MobilizedBody classes, which include a body and a particular kind of mobilizer. Each built-in MobilizedBody type is a local subclass within MobilizedBody, so the built-ins have names like <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">MobilizedBody::Pin</a>. All concrete MobilizedBody classes, including the built-ins, are derived from <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. There is a <a class="el" href="classSimTK_1_1MobilizedBody_1_1Custom.html" title="The handle class MobilizedBody::Custom (dataless) and its companion class MobilizedBody::Custom::Impl...">MobilizedBody::Custom</a> class available for defining your own mobilizer types.</p>
<p>Normally, a MobilizedBody's motion is unknown and Simbody calculates it using forward dynamics where the motion results from external or internal forces. However, a MobilizedBody may be locked or controlled by an associated <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object which defines how it is to move; those are inverse dynamics conditions in which the motion is known but the generalized forces required to produce that motion are to be determined. In general a system may contain a mix of forward- and inverse-dynamics mobilizers, and mobilizers may be switched between forward and inverse dynamics during simulations.</p>
<p>The MobilizedBody class supports a large number of methods useful for obtaining and modifying body-specific and mobilizer-specific information and for performing useful computations. These are organized in three sets:</p><ul>
<li>State Access</li>
<li>Basic Operators</li>
<li>High Level Operators</li>
</ul>
<p><em>State Access</em> methods simply extract already-calculated data from the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> or State Cache, or set state values. They involve no additional computation, have names beginning with "get" and "upd" (update) and return references to the requested quantities rather than calculated values. We divide these into routines which deal with bodies and routines which deal with mobilizers and mobilities.</p>
<p><em>Basic Operators</em> use <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> Access methods to compute basic quantities which cannot be precomputed, such as the velocity of an arbitrary point, using an inline combination of basic floating point operations which can be reliably determined at compile time. These have names beginning with "find" or a more specific verb, as a reminder that they do not require a great deal of computation.</p>
<p><em>High Level Operators</em> combine responses and basic operators with run-time tests to calculate more complex quantities, with more complicated implementations that can exploit special cases at run time. These begin with "calc" (calculate) as a reminder that they may involve substantial run time computation.</p>
<p>There is also a set of methods used for construction, and miscellaneous utilities.</p>
<h3>Mobilizer Terminology and Notation</h3>
<p>Refer to the figure below for the terminology we use when discussing mobilizers and mobilized bodies.</p>
<div class="image">
<img src="MobilizerTerminology.png" alt="MobilizerTerminology.png"/>
<div class="caption">
Terminology and notation for mobilized bodies</div></div>
<p> The figure shows the coordinate frames used in describing the mobility of MobilizedBody B with respect to its inboard parent body P. Everything blue in the figure is associated with B. The origin point O of each frame is labeled. A new MobilizedBody with body frame B is added to the multibody tree by choosing a parent body P that is already present in the tree. There are two frames associated with the mobilizer: the "fixed" frame F that is attached to the parent, and the "moving" frame M that is attached to the new body B. Frame F is specified by giving its transform X_PF relative to the P frame. Frame M is specified by giving its transform X_BM relative to the B frame. At run time the transform X_FM between the two mobilizer frames represents translation and rotation of the mobilizer. That motion is parameterized via generalized coordinates q and generalized speeds u, the specific meaning of which is a unique property of each type of mobilizer.</p>
<p>In the API below, we'll refer to the current ("this") <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> as "body B". It is the "object" or "main" body with which we are concerned. Often there will be another body mentioned in the argument list as a target for some conversion. That "another" body will be called "body A". The <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> body is abbreviated "G".</p>
<p>We use Fo to mean "the origin of frame F", Bc is "the mass center of body B". R_AF is the rotation matrix giving frame F's orientation in frame A, such that a vector v expressed in F is reexpressed in A by v_A = R_AF*v_F. X_AF is the spatial transform giving frame F's origin location and orientation in frame A, such that a point P whose location is measured from F's origin Fo and expressed in F by position vector p_FP (or more explicitly p_FoP) is remeasured from frame A's origin Ao and reexpressed in A via p_AP = X_AF*p_FP, where p_AP==p_AoP.</p>
<h3>Theory</h3>
<p>For the mathematical and computational theory behind Simbody's mobilizers, see</p><ul>
<li>the <a href="https://simtk.org/docman/view.php/47/1536/Seth-2010-ShermanEastmanDelp-MinimalJointFormulationForBiomechanisms-NonlinearDyn-v62-p291.pdf">paper</a> Seth, A.; Sherman, M.A.; Eastman, P.; Delp, S.L. "Minimal formulation 
    of joint motion for biomechanisms" Nonlinear Dynamics 62:291-303 (2010), or</li>
<li>the Simbody Theory Manual. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a3dceece097b7c4c4dde962f30ebaccea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html">Pin</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a3dceece097b7c4c4dde962f30ebaccea">SimTK::MobilizedBody::Torsion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">Pin</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="ae5545344d05ad3521ce2a68f52eda16d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html">Pin</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#ae5545344d05ad3521ce2a68f52eda16d">SimTK::MobilizedBody::Revolute</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">Pin</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a0f9ec1d7a7642b41ddf615f5be699d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html">Slider</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a0f9ec1d7a7642b41ddf615f5be699d5a">SimTK::MobilizedBody::Prismatic</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html" title="One mobility – translation along the common x axis of the F (inboard) and M (outboard) mobilizer fra...">Slider</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a30f84fcd277bf27ec5783ba405cfde5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html">Translation</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a30f84fcd277bf27ec5783ba405cfde5a">SimTK::MobilizedBody::Cartesian</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html" title="Three translational mobilities describing the Cartesian motion of a point. ">Translation</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a318f2645fe1494eb8687d3d355b0f664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html">Translation</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a318f2645fe1494eb8687d3d355b0f664">SimTK::MobilizedBody::CartesianCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Translation.html" title="Three translational mobilities describing the Cartesian motion of a point. ">Translation</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a78c70a0a5c5fdb9040c0cba94f2109cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1BendStretch.html">BendStretch</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a78c70a0a5c5fdb9040c0cba94f2109cb">SimTK::MobilizedBody::PolarCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1BendStretch.html" title="Two mobilities: The z axis of the parent&#39;s F frame is used for rotation (and that is always aligned w...">BendStretch</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a276fecee38470399e1683a93f4530742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html">Ball</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#a276fecee38470399e1683a93f4530742">SimTK::MobilizedBody::Orientation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html" title="Three mobilities – unrestricted orientation modeled with a quaternion which is never singular...">Ball</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="aa9a2f89ca8450002c01f8c09d4fe1088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html">Ball</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#aa9a2f89ca8450002c01f8c09d4fe1088">SimTK::MobilizedBody::Spherical</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synonym for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ball.html" title="Three mobilities – unrestricted orientation modeled with a quaternion which is never singular...">Ball</a> mobilizer. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4ad75a66393b9beb5383f437057b7d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSimTK_1_1MobilizedBody.html#a4ad75a66393b9beb5383f437057b7d07">SimTK::MobilizedBody::Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructors can take an argument of this type to indicate that the mobilizer is being defined in the reverse direction, meaning from the outboard (child) body to the inboard (parent) body. </p>
<p>That means that the mobilizer coordinates and speeds will be defined as though the tree had been built in the opposite direction. It does not actually affect which body is the inboard one and which is the outboard; it just affects the definitions of the generalized coordinates q and speeds u that parameterize the motion of the outboard body with respect to the inboard one. This is a topological setting and can't be changed dynamically. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4ad75a66393b9beb5383f437057b7d07a44607131b8c0a58bfd8162b1fb869782"></a>Forward&#160;</td><td class="fielddoc">
<p>Use default definitions for q and u (inboard to outboard). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4ad75a66393b9beb5383f437057b7d07add3a7423b1b31ea2078d76dc383cdaa3"></a>Reverse&#160;</td><td class="fielddoc">
<p>Define q and u in the reverse order (outboard to inboard). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a587e4f3edc99db7da5e6ff646a8805d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::MobilizedBody::MobilizedBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor provides an empty MobilizedBody handle that can be assigned to reference any type of MobilizedBody. </p>

</div>
</div>
<a class="anchor" id="aceab99766a6c1927f05a9282b5c106e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::MobilizedBody::MobilizedBody </td>
          <td>(</td>
          <td class="paramtype">MobilizedBodyImpl *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f7324c42a57beedd7c577dbf14e2531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock this mobilizer's position or velocity at its current value, or lock the acceleration to zero, depending on the <code>level</code> parameter. </p>
<p>The prescribed position or velocity is taken from <code>state</code> and recorded. If the lock is at the position (q) level then the generalized speeds u for this mobilizer are set to zero in the <code>state</code>. If the mobilizer was already locked, the new lock specification overrides it. The <code>state</code> must already have been realized to at least <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a> and will be lowered to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a> on return since a lock is an Instance-stage change. </p>

</div>
</div>
<a class="anchor" id="a37ac591feb4c08544ab17f2f7fa0d7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::lockAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock this mobilizer's q, u, or udot to the given scalar <code>value</code>, depending on <code>level</code>. </p>
<p>When locking at the position level (the default), this mobilizer's q in <code>state</code> is set to <code>value</code>, and u in <code>state</code> is set to zero. When locking at velocity level, this mobilizer's u in <code>state</code> is set to <code>value</code> but the q is left unchanged. This signature of <a class="el" href="classSimTK_1_1MobilizedBody.html#a37ac591feb4c08544ab17f2f7fa0d7b0" title="Lock this mobilizer&#39;s q, u, or udot to the given scalar value, depending on level. ">lockAt()</a>, taking <code>value</code> as a scalar, is only permitted for mobilizers that have just a single q and u, such as a <a class="el" href="classSimTK_1_1MobilizedBody_1_1Pin.html" title="Provides one rotational mobility about the common z axis of the F and M frames of the mobilizer...">Pin</a> or <a class="el" href="classSimTK_1_1MobilizedBody_1_1Slider.html" title="One mobility – translation along the common x axis of the F (inboard) and M (outboard) mobilizer fra...">Slider</a> mobilizer. See the other signatures of <a class="el" href="classSimTK_1_1MobilizedBody.html#a37ac591feb4c08544ab17f2f7fa0d7b0" title="Lock this mobilizer&#39;s q, u, or udot to the given scalar value, depending on level. ">lockAt()</a> for multi-coordinate mobilizers. </p>

</div>
</div>
<a class="anchor" id="a310411deca445ac81d55f47b61a2496d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::lockAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock this mobilizer's q, u, or udot to the given Vector <code>value</code>, depending on <code>level</code>. </p>
<p>When locking at the position level (the default), this mobilizer's q's in <code>state</code> is set to <code>value</code>, and its u's in <code>state</code> are set to zero. When locking at velocity level, this mobilizer's u's in <code>state</code> are set to <code>value</code> but its q's are left unchanged. The Vector must be the expected length, either nq=<a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> for the default <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce" title="we know q, u, and udot ">Motion::Position</a> level, or nu=<a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> for <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a8239c44e81d2a5c234e24fb98286db84" title="we know u and udot; integrate to get q ">Motion::Velocity</a> or <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a943ac4d40bfc990c7cd493ea7a3f2b31" title="we know udot; integrate to get u, q ">Motion::Acceleration</a> levels. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>, <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a24784973f1295316042dc2cd30d55760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::lockAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vec.html">Vec</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock this mobilizer's q, u, or udot to the given <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a>&lt;N&gt; <code>value</code>, depending on the <code>level</code>. </p>
<p>When locking at the position level (the default), this mobilizer's q's in <code>state</code> is set to <code>value</code>, and its u's in <code>state</code> are set to zero. When locking at velocity level, this mobilizer's u's in <code>state</code> are set to <code>value</code> but its q's are left unchanged. The size N of the given <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">Vec</a> must match the expected length, either nq=<a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> for the default <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce" title="we know q, u, and udot ">Motion::Position</a> level, or nu=<a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> for <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a8239c44e81d2a5c234e24fb98286db84" title="we know u and udot; integrate to get q ">Motion::Velocity</a> or <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a943ac4d40bfc990c7cd493ea7a3f2b31" title="we know udot; integrate to get u, q ">Motion::Acceleration</a> levels. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>, <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af140876d78c207e51dfb80297dd86394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock this mobilizer, returning it to its normal behavior which may be free motion or may be controlled by a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object. </p>
<p>If the mobilizer is already unlocked nothing happens. </p>

</div>
</div>
<a class="anchor" id="a5ca19bb03088e81314b9d81872b02e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isLocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this mobilizer is currently locked in the given <code>state</code>. </p>

</div>
</div>
<a class="anchor" id="a6ec6b9ad930bcac4fdc3d10b6f5576e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> SimTK::MobilizedBody::getLockLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lock level if the mobilizer is locked in the given <code>state</code>, otherwise <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a325b350a7bdf69fab347d2b9863c6e3c" title="invalid level ">Motion::NoLevel</a>. </p>

</div>
</div>
<a class="anchor" id="aff678ef3c0bf656643574492d55b01d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getLockValueAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the q, u, or udot value at which this mobilizer is locked, depending on the lock level, as a Vector of the appropriate length. </p>
<p>If the mobilizer is not currently locked, a zero-length Vector is returned. </p>

</div>
</div>
<a class="anchor" id="ac5b71338ce06176e41f11d9d113f4339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::lockByDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1ab6205466dbcc889f3eb5cee0a51b38ce">Motion::Position</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change whether this mobilizer is initially locked. </p>
<p>On construction the mobilizer is unlocked by default; you can change that here. To respecify that the motion is unlocked, use <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a325b350a7bdf69fab347d2b9863c6e3c" title="invalid level ">Motion::NoLevel</a> as the <code>level</code>. This is a topological change; you'll have to call realizeTopology() again and get a new <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> if you call this method. If the default lock is at the position or velocity level, the required q or u value is recorded at the time a <code>state</code> is realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>. A default <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a943ac4d40bfc990c7cd493ea7a3f2b31" title="we know udot; integrate to get u, q ">Motion::Acceleration</a> lock always prescribes the accelerations udot to zero. </p>

</div>
</div>
<a class="anchor" id="aca64cbc146e75b7450991b5b6f5ac6bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isLockedByDefault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this mobilizer is to be locked in the default state. </p>

</div>
</div>
<a class="anchor" id="a44a9a8a76cfdd4d3a85ce75ca5bd1d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1">Motion::Level</a> SimTK::MobilizedBody::getLockByDefaultLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the level at which the mobilizer is locked by default, if it is locked by default, otherwise <a class="el" href="classSimTK_1_1Motion.html#a621d231ddcfa2ced9edae83c05b7b7a1a325b350a7bdf69fab347d2b9863c6e3c" title="invalid level ">Motion::NoLevel</a>. </p>

</div>
</div>
<a class="anchor" id="a877368286148b4efbdb2d5e7f6904ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getBodyTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated spatial configuration X_GB of body B's body frame, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>That is, we return the location of the body frame's origin, and the orientation of its x, y, and z axes, as the Transform X_GB. This notation is intended to convey unambiguously the sense of this transform, which is as follows: if you have a station (body fixed point) S on body B, represented by position vector p_BS (a.k.a. p_BoS) from the origin Bo of B to the point S and expressed in the B frame, then p_GS=X_GB*p_BS where p_GS (== p_GoS) is the position vector from the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> origin Go to the point in space currently coincident with S and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. The inverse transformation is obtained using the "~" operator where ~X_GB=X_BG, so that p_BS = ~X_GB*p_GS. This response is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a5a0404ecdf9a8172bf22d2def7d79e0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; SimTK::MobilizedBody::getBodyRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated spatial orientation R_GB of body B's body frame x, y, and z axes expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, as the Rotation matrix R_GB. </p>
<p>The sense of this rotation matrix is such that if you have a vector v fixed on body B, represented by the vector v_B expressed in the B frame, then v_G=R_GB*v_B where v_G is the same vector but re-expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. The inverse transformation is obtained using the "~" operator where ~R_GB=R_BG, so that v_B = ~R_GB*v_G. This response is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a2e2d6882a3f7c42239bd6449cadf66bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyOriginLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated spatial location of body B's body frame origin Bo, measured from the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> origin Go and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, as the position vector p_GB (== p_GoBo). </p>
<p>This response is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a6be00463060a74c56863a179b0061f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getMobilizerTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>At stage Position or higher, return the cross-mobilizer transform X_FM, the body's inboard mobilizer frame M measured and expressed in the parent body's corresponding outboard frame F. </p>

</div>
</div>
<a class="anchor" id="a136b1b973ae2d60e2bd09a19529c15a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::MobilizedBody::getBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated spatial velocity V_GB of this body's reference frame B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>That is, we return the linear velocity v_GB of the body frame's origin in G, and the body's angular velocity w_GB as the spatial velocity vector V_GB = {w_GB, v_GB}. This response is available at Velocity stage. </p>

</div>
</div>
<a class="anchor" id="ad07e64cc62fa2f76bd37894007abd378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated inertial angular velocity vector w_GB of this body B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>This response is available at Velocity stage. </p>

</div>
</div>
<a class="anchor" id="af9911f4352e9224184e8dab962c7d8f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyOriginVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explicitly, v_GBo) of this body B's origin point Bo, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>This response is available at Velocity stage. </p>

</div>
</div>
<a class="anchor" id="a16f87b4238c3efe0418275163bc258bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::MobilizedBody::getMobilizerVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>At stage Velocity or higher, return the cross-mobilizer velocity V_FM, the relative velocity of this body's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F. </p>
<p>Note that this isn't the usual spatial velocity since it isn't expressed in G. </p>

</div>
</div>
<a class="anchor" id="ab728f49034ee32dea4620f23a632a3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::MobilizedBody::getBodyAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated spatial acceleration A_GB of this body's reference frame B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>That is, we return the linear acceleration a_GB of the body frame's origin in G, and the body's angular acceleration b_GB as the spatial acceleration vector A_GB = {b_GB, a_GB}. This response is available at Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="a056be794b2e8d9c9d77124162d7b35f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyAngularAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated inertial angular acceleration vector b_GB of this body B, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>This response is available at Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="a0bea21eaba5cb4db3751fbf3d0d8bc6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyOriginAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more explicitly, a_GBo) of this body B's origin point Bo, measured with respect to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>This response is available at Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="a79c7069df29ad92032816b5403aa6997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::MobilizedBody::getMobilizerAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: Not implemented yet &ndash; any volunteers? At stage Acceleration, return the cross-mobilizer acceleration A_FM, the relative acceleration of body B's "moving" mobilizer frame M in the parent body's corresponding "fixed" frame F, measured and expressed in F. </p>
<p>Note that this isn't the usual spatial acceleration since it isn't expressed in G. </p>

</div>
</div>
<a class="anchor" id="a2ecd25fe2c8f44a48db42ab92f80a690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&amp; SimTK::MobilizedBody::getBodyMassProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this body's mass properties in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>
<p>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. </p>

</div>
</div>
<a class="anchor" id="a919bf69fc4449d163d04b867450b901f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>&amp; SimTK::MobilizedBody::getBodySpatialInertiaInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the already-calculated SpatialInertia of this body, taken about the body's origin (<em>not</em> its mass center), and expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a> or higher. </p>

</div>
</div>
<a class="anchor" id="a63398ad3cebfd110b2815a25201fd17d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getBodyMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the mass of this body. </p>
<p>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a>. </p>

</div>
</div>
<a class="anchor" id="a8cefb252884569addb85d934cd9ca620"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::MobilizedBody::getBodyMassCenterStation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this body's center of mass station (i.e., the vector fixed in the body, going from body origin to body mass center, expressed in the body frame.) The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. </p>

</div>
</div>
<a class="anchor" id="a6e492d01b892751aa6d82d73cd76cc22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#af4586b331c8fbbb1f3c18d2a1a03ce92">UnitInertia</a>&amp; SimTK::MobilizedBody::getBodyUnitInertiaAboutBodyOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to this body's unit inertia matrix in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, taken about the body origin and expressed in the body frame. </p>
<p>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. </p>

</div>
</div>
<a class="anchor" id="a6765463d0ad8f2e0bc84ddf3fb54746d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getInboardFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this mobilizer's frame F fixed on the parent body P, as the fixed Transform from P's body frame to the frame F fixed to P. </p>
<p>If this frame is changeable, the result comes from the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, otherwise it is from the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> object itself. The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. </p>

</div>
</div>
<a class="anchor" id="a69952d293c85ea3642d972018cfc00dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getOutboardFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>'s mobilizer frame M, as the fixed Transform from this body B's frame to the frame M fixed on B. </p>
<p>If this frame is changeable, the result comes from the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache, otherwise it is from the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> object itself. The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> or higher. </p>

</div>
</div>
<a class="anchor" id="aea0c851f977baae82c1c2355247685b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setInboardFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_PF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: not implemented yet. </p>
<p>Set the location and orientation of the inboard (parent) mobilizer frame F, fixed to this mobilizer's parent body P. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#aa316ee0d30e68802bbb5c5e5f923b629" title="Change this mobilizer&#39;s frame F on the parent body P. ">setDefaultInboardFrame()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a525d09e7b28e1f08fd30128c549fe83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setOutboardFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_BM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: not implemented yet. </p>
<p>Set the location and orientation of the outboard mobilizer frame M, fixed to this body B. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#aa9ab782162cb3812c0d8210288290624" title="Change this mobilizer&#39;s frame M fixed on this (the outboard) body B. ">setDefaultOutboardFrame()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4dd37c7e26fc0d3af29bd39cbcc53977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::getNumQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of generalized coordinates q currently in use by this mobilizer. </p>
<p><a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>. </p>

</div>
</div>
<a class="anchor" id="aa0670418dc17ea36ae69d8a1ec42504c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::getNumU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of generalized speeds u currently in use by this mobilizer. </p>
<p><a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must have been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>. </p>

</div>
</div>
<a class="anchor" id="a0ccd00b0e744058c564242f912214270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1QIndex.html">QIndex</a> SimTK::MobilizedBody::getFirstQIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global <a class="el" href="classSimTK_1_1QIndex.html" title="Unique integer type for Subsystem-local q indexing. ">QIndex</a> of the first q for this mobilizer; all the q's range from <a class="el" href="classSimTK_1_1MobilizedBody.html#a0ccd00b0e744058c564242f912214270" title="Return the global QIndex of the first q for this mobilizer; all the q&#39;s range from getFirstQIndex() t...">getFirstQIndex()</a> to <a class="el" href="classSimTK_1_1QIndex.html" title="Unique integer type for Subsystem-local q indexing. ">QIndex</a>(<a class="el" href="classSimTK_1_1MobilizedBody.html#a0ccd00b0e744058c564242f912214270" title="Return the global QIndex of the first q for this mobilizer; all the q&#39;s range from getFirstQIndex() t...">getFirstQIndex()</a>+getNumQ()-1). </p>

</div>
</div>
<a class="anchor" id="ab4ecf9620996412218499fa99f8a126f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> SimTK::MobilizedBody::getFirstUIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global <a class="el" href="classSimTK_1_1UIndex.html" title="Unique integer type for Subsystem-local u indexing. ">UIndex</a> of the first u for this mobilizer; all the u's range from <a class="el" href="classSimTK_1_1MobilizedBody.html#ab4ecf9620996412218499fa99f8a126f" title="Return the global UIndex of the first u for this mobilizer; all the u&#39;s range from getFirstUIndex() t...">getFirstUIndex()</a> to <a class="el" href="classSimTK_1_1UIndex.html" title="Unique integer type for Subsystem-local u indexing. ">UIndex</a>(<a class="el" href="classSimTK_1_1MobilizedBody.html#ab4ecf9620996412218499fa99f8a126f" title="Return the global UIndex of the first u for this mobilizer; all the u&#39;s range from getFirstUIndex() t...">getFirstUIndex()</a>+getNumU()-1). </p>

</div>
</div>
<a class="anchor" id="acb1b775de0ddef150089ac78fde3ba85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a> SimTK::MobilizedBody::getQMotionMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how generalized coordinate q values are being determined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Must be realized to Instance stage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b7364818e28d23abaf997e4357efb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a> SimTK::MobilizedBody::getUMotionMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how generalized speed u values are being determined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Must be realized to Instance stage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9863cce1313097e6d446b9dc661e2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Motion.html#a35e4b496a9364ac7dbca3420815b86b7">Motion::Method</a> SimTK::MobilizedBody::getUDotMotionMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how generalized acceleration udot values are being determined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Must be realized to Instance stage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95a6e0e3edd73d690e01e109afd25bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the generalized coordinates q from this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a848c5bb901ca0a72a9d0f1eeb89783ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the generalized speeds u from this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a258623c5e835d49718c9b3dae063a7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getQAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinates q currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="a74e8007f8925c60b99a84a2f2f973ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getUAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> all the generalized speeds u currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="aa79c133af999645df8522032f7f8e911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the generalized coordinate derivatives qdot from this mobilizer's partition of the matter subsystem's full qdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a86018b5ade92c57d641beb65b8ca8fc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getQDotAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinate derivatives qdot currently in use by this mobilizer, from this mobilizer's partition in the matter subsystem's full qdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>

</div>
</div>
<a class="anchor" id="addedad56051003dc25ff4c8fc661a188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneUDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the generalized accelerations udot from this mobilizer's partition of the matter subsystem's full udot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a3c653abfcccb09d9176a38a088f0250d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneQDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the generalized coordinate second derivatives qdotdot from this mobilizer's partition of the matter subsystem's full qdotdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>-1. </p>

</div>
</div>
<a class="anchor" id="af14203212503b70930c104cf35aa45b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getUDotAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a> all the generalized accelerations udot currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full udot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>

</div>
</div>
<a class="anchor" id="a63e9b3bf9124c207b254f4b45bf8c228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getQDotDotAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return as a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a> all the generalized coordinate second derivatives qdotdot currently in use by this mobilizer, from this mobilizer's partion in the matter subsystem's full qdotdot vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> cache. </p>

</div>
</div>
<a class="anchor" id="a0c098a7882568be9f1171d38d4206f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::MobilizedBody::getTauAsVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the generalized forces tau resulting from prescribed (known) acceleration, corresponding to each of this mobilizer's mobilities, as a Vector of length nu=<a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>. </p>
<p>If this mobilizer has prescribed accelerations udot due to an active lock or <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object, the set of generalized forces tau that must be added in order to produce those accelerations is calculated at Acceleration stage. There is one scalar tau per mobility and they can be returned individually or as a Vector. The return value is zero if this mobilizer is currently free. </p>

</div>
</div>
<a class="anchor" id="ab48fce7013f9a3e63e320ca5d47cec01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneTau </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return one of the tau forces resulting from prescribed (known) acceleration, corresponding to one of this mobilizer's mobilities as selected here using the <code>which</code> parameter, numbered from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>-1. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a0c098a7882568be9f1171d38d4206f10" title="Return the generalized forces tau resulting from prescribed (known) acceleration, corresponding to ea...">getTauAsVector()</a> for more information </dd></dl>

</div>
</div>
<a class="anchor" id="adf8e7bc0a62e38ccb9e867f635dbe993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setOneQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one of the generalized coordinates q to value <code>v</code>, in this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a87fd4564e60a150dbc3ebbe979912796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setOneU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one of the generalized speeds u to value <code>v</code>, in this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>The particular coordinate is selected using the <code>which</code> parameter, numbering from zero to <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>-1. </p>

</div>
</div>
<a class="anchor" id="a5b080dcb6c8bdb05e373fd7386b3de93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setQFromVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all of the generalized coordinates q to value <code>v</code> (a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#a4dd37c7e26fc0d3af29bd39cbcc53977" title="Return the number of generalized coordinates q currently in use by this mobilizer. ">getNumQ()</a>), in this mobilizer's partition of the matter subsystem's full q vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="a127f82d17a6440392e604a103bfff5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setUFromVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set all of the generalized speeds u to value <code>v</code> (a Vector of length <a class="el" href="classSimTK_1_1MobilizedBody.html#aa0670418dc17ea36ae69d8a1ec42504c" title="Return the number of generalized speeds u currently in use by this mobilizer. ">getNumU()</a>), in this mobilizer's partition of the matter subsystem's full u vector in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="a5f926e05e89b9d8a157272b1512b32c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setQToFitTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust this mobilizer's q's to best approximate the supplied Transform which requests a particular relative orientation and translation between the F "fixed" frame and M "moving" frame connected by this mobilizer. </p>
<p>This set of methods sets the generalized coordinates, or speeds (state variables) for just the mobilizer associated with this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> (ignoring all other mobilizers and constraints), without requiring knowledge of the meanings of the individual state variables. The idea here is to provide a physically-meaningful quantity relating the mobilizer's inboard and outboard frames, and then ask the mobilizer to set its state variables to reproduce that quantity to the extent it can.</p>
<p>These methods can be called in <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aedd9c6ba269432679e666eda36ee069b" title="Modeling choices made. ">Stage::Model</a>, however the routines may consult the current values of the state variables in some cases, so you must make sure they have been set to reasonable, or at least innocuous values (zero will work). In no circumstance will any of these methods look at any state variables that belong to another mobilizer; they are limited to working locally with just the current mobilizer.</p>
<p>Routines which specify only translation (linear velocity) may use rotational coordinates to help satisfy the translation requirement. An alternate "Only" method is available to forbid modification of purely rotational coordinates in that case. When a mobilizer uses state variables which have combined rotational and translational character (e.g. a screw joint) consult the documentation for the derived <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> class to find out how that mobilizer responds to these routines.</p>
<p>There is no guarantee that the desired physical quantity will be achieved by these routines; you can check on return if you're worried. Individual mobilizers make specific promises about what they will do; consult the documentation. These routines do not throw exceptions even for absurd requests like specifying a rotation for a sliding mobilizer. Nothing happens if there are no mobilities here, i.e. <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> or a <a class="el" href="classSimTK_1_1MobilizedBody_1_1Weld.html" title="Zero mobilities. ">Weld</a> mobilizer. </p>

</div>
</div>
<a class="anchor" id="a47e2368d92372f485263d54eaee3ab1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setQToFitRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>R_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust this mobilizer's q's to best approximate the supplied Rotation matrix which requests a particular relative orientation between the "fixed" frame F and "moving" frame M connected by this mobilizer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9" title="Adjust this mobilizer&#39;s q&#39;s to best approximate the supplied Transform which requests a particular re...">setQToFitTransform()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a831b84be9c28e51d85dc46aaa98e7531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setQToFitTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>p_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust this mobilizer's q's to best approximate the supplied position vector which requests a particular offset between the origins of the F "fixed" frame and M "moving" frame connected by this mobilizer, with <em>any</em> q's (rotational or translational) being modified if doing so helps satisfy the request. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9" title="Adjust this mobilizer&#39;s q&#39;s to best approximate the supplied Transform which requests a particular re...">setQToFitTransform()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c08ae9b8fe0f468d7d874d76022d19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setUToFitVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>V_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust this mobilizer's u's (generalized speeds) to best approximate the supplied spatial velocity <code>V_FM</code> which requests the relative angular and linear velocity between the "fixed" and "moving" frames connected by this mobilizer. </p>
<p>Routines which affect generalized speeds u depend on the generalized coordinates q already having been set; they never change these coordinates. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9" title="Adjust this mobilizer&#39;s q&#39;s to best approximate the supplied Transform which requests a particular re...">setQToFitTransform()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6456eff373a5cf775cd683de27544411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setUToFitAngularVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>w_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust this mobilizer's u's (generalized speeds) to best approximate the supplied angular velocity <code>w_FM</code> which requests a particular relative angular between the "fixed" and "moving" frames connected by this mobilizer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9" title="Adjust this mobilizer&#39;s q&#39;s to best approximate the supplied Transform which requests a particular re...">setQToFitTransform()</a>, <a class="el" href="classSimTK_1_1MobilizedBody.html#a7c08ae9b8fe0f468d7d874d76022d19d" title="Adjust this mobilizer&#39;s u&#39;s (generalized speeds) to best approximate the supplied spatial velocity V_...">setUToFitVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab9e470bca119537446a02f79680dc328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::setUToFitLinearVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>v_FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust <em>any</em> of this mobilizer's u's (generalized speeds) to best approximate the supplied linear velocity <code>v_FM</code> which requests a particular velocity for the "moving" frame M origin in the "fixed" frame F on the parent where these are the frames connected by this mobilizer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5f926e05e89b9d8a157272b1512b32c9" title="Adjust this mobilizer&#39;s q&#39;s to best approximate the supplied Transform which requests a particular re...">setQToFitTransform()</a>, <a class="el" href="classSimTK_1_1MobilizedBody.html#a7c08ae9b8fe0f468d7d874d76022d19d" title="Adjust this mobilizer&#39;s u&#39;s (generalized speeds) to best approximate the supplied spatial velocity V_...">setUToFitVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa69c8e858f8d99f6677ed94e60c332e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::getHCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>ux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert use only: obtain a column of the hinge matrix H corresponding to one of this mobilizer's mobilities (actually a column of H_PB_G; what Jain calls H* and Schwieters calls H^T). </p>
<p>This is the matrix that maps generalized speeds u to the cross-body relative spatial velocity V_PB_G via V_PB_G=H*u. Note that although H relates child body B to parent body B, it is expressed in the ground frame G so the resulting cross-body velocity of B in P is also expressed in G. The supplied state must have been realized through Position stage because H varies with this mobilizer's generalized coordinates q. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a29c3388fb03ba24f5ae543dd173770bf" title="Expert use only: obtain a column of the mobilizer-local hinge matrix H_FM which maps generalized spee...">getH_FMCol()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29c3388fb03ba24f5ae543dd173770bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::getH_FMCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>ux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert use only: obtain a column of the mobilizer-local hinge matrix H_FM which maps generalized speeds u to cross-mobilizer spatial velocity V_FM via V_FM=H_FM*u. </p>
<p>Note that H and V here are expressed in the parent body's (inboard) frame F. The supplied state must have been realized through Position stage because H varies with this mobilizer's generalized coordinates q. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#aa69c8e858f8d99f6677ed94e60c332e2" title="Expert use only: obtain a column of the hinge matrix H corresponding to one of this mobilizer&#39;s mobil...">getHCol()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38e9d5ec372c7502412e39ec6043302a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> SimTK::MobilizedBody::findBodyTransformInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return X_AB, the spatial transform giving this body B's frame in body A's frame. </p>
<p>Cost is 63 flops. If you know that one of the bodies is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, use the 0-cost response <a class="el" href="classSimTK_1_1MobilizedBody.html#a877368286148b4efbdb2d5e7f6904ac4" title="Extract from the state cache the already-calculated spatial configuration X_GB of body B&#39;s body frame...">getBodyTransform()</a> instead of this operators. This operator is available in Position stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a877368286148b4efbdb2d5e7f6904ac4" title="Extract from the state cache the already-calculated spatial configuration X_GB of body B&#39;s body frame...">getBodyTransform()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44bb12d2d6844023df97cff24d71549b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> SimTK::MobilizedBody::findBodyRotationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return R_AB, the rotation matrix giving this body B's axes in body A's frame. </p>
<p>Cost is 45 flops. If you know that one of the bodies is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, use the 0-cost response <a class="el" href="classSimTK_1_1MobilizedBody.html#a5a0404ecdf9a8172bf22d2def7d79e0b" title="Extract from the state cache the already-calculated spatial orientation R_GB of body B&#39;s body frame x...">getBodyRotation()</a> instead of this operators. This operator is available in Position stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a5a0404ecdf9a8172bf22d2def7d79e0b" title="Extract from the state cache the already-calculated spatial orientation R_GB of body B&#39;s body frame x...">getBodyRotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f1b290369cf503f4729b4bcd0f8aa4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findBodyOriginLocationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>toBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the station on another body A (that is, a point measured and expressed in A) that is currently coincident in space with the origin Bo of this body B. </p>
<p>Cost is 18 flops. This operator is available at Position stage. Note: "findBodyOriginLocationInGround" doesn't exist because it would be the same as the no-cost response method <a class="el" href="classSimTK_1_1MobilizedBody.html#a2e2d6882a3f7c42239bd6449cadf66bd" title="Extract from the state cache the already-calculated spatial location of body B&#39;s body frame origin Bo...">getBodyOriginLocation()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a2e2d6882a3f7c42239bd6449cadf66bd" title="Extract from the state cache the already-calculated spatial location of body B&#39;s body frame origin Bo...">getBodyOriginLocation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d82188ee012eda593dbe5bd4d7d6689"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findBodyVelocityInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular and linear velocity of body B's frame in body A's frame, expressed in body A, and arranged as a SpatialVec. </p>
<p>Cost is 51 flops. If you know inBodyA is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this routine; use the response method <a class="el" href="classSimTK_1_1MobilizedBody.html#a136b1b973ae2d60e2bd09a19529c15a8" title="Extract from the state cache the already-calculated spatial velocity V_GB of this body&#39;s reference fr...">getBodyVelocity()</a> which is free. This operator is available in Velocity stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a136b1b973ae2d60e2bd09a19529c15a8" title="Extract from the state cache the already-calculated spatial velocity V_GB of this body&#39;s reference fr...">getBodyVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3149c2ccfcf53d3c6d2f1da6e02ade0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findBodyAngularVelocityInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular velocity w_AB of body B's frame in body A's frame, expressed in body A. </p>
<p>Cost is 18 flops. If you know inBodyA is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this routine; use the response method <a class="el" href="classSimTK_1_1MobilizedBody.html#ad07e64cc62fa2f76bd37894007abd378" title="Extract from the state cache the already-calculated inertial angular velocity vector w_GB of this bod...">getBodyAngularVelocity()</a> which is free. This operator is available in Velocity stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#ad07e64cc62fa2f76bd37894007abd378" title="Extract from the state cache the already-calculated inertial angular velocity vector w_GB of this bod...">getBodyAngularVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9266f52fbc2390c278c4496a454594ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findBodyOriginVelocityInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the velocity of body B's origin point in body A's frame, expressed in body A. </p>
<p>Cost is 51 flops. If you know inBodyA is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this routine; use the response method <a class="el" href="classSimTK_1_1MobilizedBody.html#af9911f4352e9224184e8dab962c7d8f0" title="Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explic...">getBodyOriginVelocity()</a> which is free. This operator is available in Velocity stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#af9911f4352e9224184e8dab962c7d8f0" title="Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explic...">getBodyOriginVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7bdf069f368b01b2c40a6dde309eca42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findBodyAccelerationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular and linear acceleration of body B's frame in body A's frame, expressed in body A, and arranged as a SpatialVec. </p>
<p>Cost is 105 flops. If you know that inBodyA is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this operator; instead, use the response method <a class="el" href="classSimTK_1_1MobilizedBody.html#ab728f49034ee32dea4620f23a632a3f0" title="Extract from the state cache the already-calculated spatial acceleration A_GB of this body&#39;s referenc...">getBodyAcceleration()</a> which is free. This operator is available in Acceleration stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#ab728f49034ee32dea4620f23a632a3f0" title="Extract from the state cache the already-calculated spatial acceleration A_GB of this body&#39;s referenc...">getBodyAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a980e38c7e2e4f0da9aa47078cf8b33a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findBodyAngularAccelerationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angular acceleration of body B's frame in body A's frame, expressed in body A. </p>
<p>Cost is 33 flops. If you know <code>inBodyA</code> is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this operator; instead use the response method getBodyAngularAccleration() which is free. This operator is available at AccelerationStage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a056be794b2e8d9c9d77124162d7b35f1" title="Extract from the state cache the already-calculated inertial angular acceleration vector b_GB of this...">getBodyAngularAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa03734a07495ebcf090b9a27a68461c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findBodyOriginAccelerationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the acceleration of body B's origin point in body A's frame, expressed in body A. </p>
<p>Cost is 105 flops. If you know that inBodyA is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this operator; instead, use the response method <a class="el" href="classSimTK_1_1MobilizedBody.html#a0bea21eaba5cb4db3751fbf3d0d8bc6e" title="Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more ex...">getBodyOriginAcceleration()</a> which is free. This operator is available at Acceleration stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a0bea21eaba5cb4db3751fbf3d0d8bc6e" title="Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more ex...">getBodyOriginAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4bc19dffd701936d44999571df13ba62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findMobilizerReactionOnBodyAtMInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the location of the mobilizer frame M (fixed to body B, but not necessarily at the body frame origin), expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>
<p>This operator is available at Acceleration stage. Cost is about 120 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#ad512a9ba70777226e20cd478f3b92372" title="Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard)...">findMobilizerReactionOnParentAtFInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1MobilizedBody.html#a51f297ca83ef03523984f5dc57ed1786" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B but shifted t...">findMobilizerReactionOnBodyAtOriginInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51f297ca83ef03523984f5dc57ed1786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findMobilizerReactionOnBodyAtOriginInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the spatial reaction force (moment and force) applied by the mobilizer to body B but shifted to the B frame origin, and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>
<p>This operator is available at Acceleration stage. Cost is about 90 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a9108cf72177a2a8488ac652f0289bf5f" title="Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard)...">findMobilizerReactionOnParentAtOriginInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1MobilizedBody.html#a4bc19dffd701936d44999571df13ba62" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the locati...">findMobilizerReactionOnBodyAtMInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad512a9ba70777226e20cd478f3b92372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findMobilizerReactionOnParentAtFInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard) body P at the location of the inboard "fixed" mobilizer frame F (fixed to body P, but not necessarily at the P frame origin), expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>
<p>This operator is available at Acceleration stage. Cost is about 140 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a4bc19dffd701936d44999571df13ba62" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the locati...">findMobilizerReactionOnBodyAtMInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1MobilizedBody.html#a9108cf72177a2a8488ac652f0289bf5f" title="Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard)...">findMobilizerReactionOnParentAtOriginInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9108cf72177a2a8488ac652f0289bf5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findMobilizerReactionOnParentAtOriginInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard) body P at the location of the P frame origin, and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>
<p>This operator is available at Acceleration stage. Cost is about 110 flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a51f297ca83ef03523984f5dc57ed1786" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B but shifted t...">findMobilizerReactionOnBodyAtOriginInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1MobilizedBody.html#ad512a9ba70777226e20cd478f3b92372" title="Return the spatial reaction force (moment and force) applied by the mobilizer to the parent (inboard)...">findMobilizerReactionOnParentAtFInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adc629077769b8c767bd1bc160787d4af" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4cba41aaca4c7ffde96012433cbad8db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationLocationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Cartesian (ground) location that is currently coincident with a station (point) S fixed on body B. </p>
<p>That is, we return locationInG=X_GB*stationOnB which means the result is measured from the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> origin and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. In more precise notation, we're calculating p_GS = X_GB * p_BS for position vectors p_GS and p_BS. Cost is 18 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a154c001e683ff81cd207db7677c002d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationLocationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>toBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a station S on this body B, return the location on another body A which is at the same location in space. </p>
<p>That is, we return locationOnA=X_AB*locationOnB, which means the result is measured from the body A origin and expressed in body A. In more precise notation, we're calculating p_AS = X_AB * p_BS, which we actually calculate as p_AS = X_AG*(X_GB*p_BS). Cost is 36 flops. Note: if you know that one of the bodies is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, use one of the routines above which is specialized for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> to avoid half the work. This operator is available at Position stage or higher. </p>

</div>
</div>
<a class="anchor" id="aaea3a099f83c1721e9778b4ecc48df8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationVelocityInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a station fixed on body B, return its inertial (Cartesian) velocity, that is, its velocity relative to the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame, expressed in the <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> frame. </p>
<p>Cost is 27 flops. If you know the station is the body origin (0,0,0) don't use this routine; use the response <a class="el" href="classSimTK_1_1MobilizedBody.html#af9911f4352e9224184e8dab962c7d8f0" title="Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explic...">getBodyOriginVelocity()</a> which is free. This operator is available at Velocity stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#af9911f4352e9224184e8dab962c7d8f0" title="Extract from the state cache the already-calculated inertial linear velocity vector v_GB (more explic...">getBodyOriginVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe15ba865f8200758f6403d69898a627"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationVelocityInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the velocity of a station S fixed on body B, in body A's frame, expressed in body A. </p>
<p>Cost is 93 flops. If you know <code>inBodyA</code> is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this operator; instead use the operator <a class="el" href="classSimTK_1_1MobilizedBody.html#aaea3a099f83c1721e9778b4ecc48df8e" title="Given a station fixed on body B, return its inertial (Cartesian) velocity, that is, its velocity relative to the Ground frame, expressed in the Ground frame. ">findStationVelocityInGround()</a> which is much cheaper. This operator is available in Velocity stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#aaea3a099f83c1721e9778b4ecc48df8e" title="Given a station fixed on body B, return its inertial (Cartesian) velocity, that is, its velocity relative to the Ground frame, expressed in the Ground frame. ">findStationVelocityInGround()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad63fa56fba245dea20dd1c558f938243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAccelerationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a station fixed on body B, return its inertial (Cartesian) acceleration, that is, its acceleration relative to the ground frame, expressed in the ground frame. </p>
<p>Cost is 48 flops. If you know the station is the body origin (0,0,0) don't use this routine; use the response <a class="el" href="classSimTK_1_1MobilizedBody.html#a0bea21eaba5cb4db3751fbf3d0d8bc6e" title="Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more ex...">getBodyOriginAcceleration()</a> which is free. This operator is available at Acceleration stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a0bea21eaba5cb4db3751fbf3d0d8bc6e" title="Extract from the state cache the already-calculated inertial linear acceleration vector a_GB (more ex...">getBodyOriginAcceleration()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c4b1e77bf8540e4f02be6ab1c2d30a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAccelerationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the acceleration of a station S fixed on body B, in another body A's frame, expressed in body A. </p>
<p>Cost is 186 flops. If you know that <code>inBodyA</code> is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, don't use this operator; instead, use the operator <a class="el" href="classSimTK_1_1MobilizedBody.html#ad63fa56fba245dea20dd1c558f938243" title="Given a station fixed on body B, return its inertial (Cartesian) acceleration, that is...">findStationAccelerationInGround()</a> which is much cheaper. This operator is available in Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="aa0204ec2a61c7539a85f0c79d2b4800c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::findStationLocationAndVelocityInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnGround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityInGround</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is cheaper to calculate a station's ground location and velocity together than to do them separately. </p>
<p>Here we can return them both in 30 flops, vs. 45 to do them in two calls. This operator is available at Velocity stage. </p>

</div>
</div>
<a class="anchor" id="a2ead96bfda2f3e7879d46e0e2b1c8575"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::findStationLocationVelocityAndAccelerationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnGround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityInGround</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>accelerationInGround</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It is cheaper to calculate a station's ground location, velocity, and acceleration together than to do them separately. </p>
<p>Here we can return them all in 54 flops, vs. 93 to do them in three calls. This operator is available at Acceleration stage. </p>

</div>
</div>
<a class="anchor" id="a24a54cb9ae23c2776f281bb2c66b4218"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findMassCenterLocationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Cartesian (ground) location of this body B's mass center. </p>
<p>Cost is 18 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="aa3b751d3d1e97d6a4953adead25f482f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findMassCenterLocationInAnotherBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>toBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the point of another body A that is currently coincident in space with the mass center CB of this body B. </p>
<p>Cost is 36 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a9abd25ff7099afe8eef241bb1e796f9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAtGroundPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the station (point) S of this body B that is coincident with the given <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> location. </p>
<p>That is we return locationOnB = X_BG*locationInG, which means the result is measured from the body origin Bo and expressed in the body frame. In more precise notation, we're calculating p_BS = X_BG*p_GS. Cost is 18 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="ac5d8bbf4d1bf416cb0fb41c5952754d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAtAnotherBodyStation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>fromBodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the station (point) on this body B that is coincident with the given station on another body A. </p>
<p>That is we return stationOnB = X_BA * stationOnA, which means the result is measured from the body origin Bo and expressed in the body frame. Cost is 36 flops. This operator is available at Position stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a154c001e683ff81cd207db7677c002d4" title="Given a station S on this body B, return the location on another body A which is at the same location...">findStationLocationInAnotherBody()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a63f0f6b7bd56ef94cbd6e1e54cf57568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAtAnotherBodyOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>fromBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the station S of this body that is currently coincident in space with the origin Ao of another body A. </p>
<p>Cost is 18 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="ad24fa5ed7cd6e2f835b6bc5bee23a026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::findStationAtAnotherBodyMassCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>fromBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the station S of this body that is currently coincident in space with the mass center Ac of another body A. </p>
<p>Cost is 36 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a174c4b66e4b65aac1a0a4d08544ed1ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> SimTK::MobilizedBody::findFrameTransformInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>frameOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current Ground-frame pose (position and orientation) of a frame F that is fixed to body B. </p>
<p>That is, we return X_GF=X_GB*X_BF. Cost is 63 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="ad875a1f313cb6bdb0fc2f6c11f858cd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findFrameVelocityInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>frameOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current Ground-frame spatial velocity V_GF (that is, angular and linear velocity) of a frame F that is fixed to body B. </p>
<p>The angular velocity of F is the same as that of B, but the linear velocity is the velocity of F's origin Fo rather than B's origin Bo. This operator is available at Velocity stage. Cost is 27 flops. </p>

</div>
</div>
<a class="anchor" id="a6df50ff36dffd8aa82a7379edeb6cb8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::findFrameAccelerationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>frameOnB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current Ground-frame spatial acceleration A_GF (that is, angular and linear acceleration) of a frame F that is fixed to body B. </p>
<p>The angular acceleration of F is the same as that of B, but the linear acceleration is the acceleration of F's origin Fo rather than B's origin Bo. This operator is available at Acceleration stage. Cost is 48 flops. </p>

</div>
</div>
<a class="anchor" id="a4a5bca3a4ca67bfa7e3ae660f353b072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::expressVectorInGroundFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorInB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express a vector expressed in this body B's frame into the same vector in G, by applying only a rotation. </p>
<p>That is, we return vectorInG = R_GB * vectorInB. Cost is 15 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="aaa32d7c974459ecb5acf90ab4dc1eaa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::expressGroundVectorInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express a vector expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> into the same vector expressed in this body B, by applying only rotation. </p>
<p>That is, we return vectorInB = R_BG * vectorInG. Cost is 15 flops. This operator is available at Position stage. </p>

</div>
</div>
<a class="anchor" id="a3f57973c18df491b727df80a4aa8e0a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::expressVectorInAnotherBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express a vector expressed in this body B into the same vector expressed in body A, by applying only a rotation. </p>
<p>That is, we return vectorInA = R_AB * vectorInB. Cost is 30 flops. This operator is available at Position stage. Note: if you know one of the bodies is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, call one of the specialized methods above to save 15 flops. </p>

</div>
</div>
<a class="anchor" id="a44026b68e505b7193b6211e1bb3292b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> SimTK::MobilizedBody::expressMassPropertiesInGroundFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this body B's mass properties in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> by applying only a rotation, not a shift of reference point. </p>
<p>The mass properties remain measured in the body B frame, taken about the body B origin Bo, but are reexpressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>

</div>
</div>
<a class="anchor" id="af552e3a4fda07b3e80448c02a82f2c48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> SimTK::MobilizedBody::expressMassPropertiesInAnotherBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-express this body B's mass properties in another body A's frame by applying only a rotation, not a shift of reference point. </p>
<p>The mass properties remain measured in the body B frame, taken about the body B origin Bo, but are reexpressed in A. </p>

</div>
</div>
<a class="anchor" id="a502978034abfca4e767d7b30c9f8e356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga62d661c98a4b9595b84102e835800511">SpatialMat</a> SimTK::MobilizedBody::calcBodySpatialInertiaMatrixInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the mass properties of body B, measured from and about the B origin Bo, but expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> and then returned as a Spatial Inertia Matrix. </p>
<p>The mass properties are arranged in the SpatialMat like this: </p><pre>
        M=[      I_Bo      crossMat(m*Bc) ]
        [ ~crossMat(m*Bc)   diag(m)     ]
</pre><p> where I_Bo is the inertia taken about the B frame origin Bo, and Bc is the vector p_BoBc from B's origin to its mass center.</p>
<p>The Spatial Inertia Matrix for <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> has infinite mass and inertia, with the cross terms set to zero. That is, it looks like a 6x6 diagonal matrix with Infinity on the diagonals.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, unless <code>objectBodyB</code> == <code>GroundIndex</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a27daeddf797146742c9f67b53d99c291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a> SimTK::MobilizedBody::calcBodyCentralInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>objectBodyB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the central inertia for body B, that is, the inertia taken about body B's mass center Bc, and expressed in B. </p>
<p>/ </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a36c0e656d5315370004b3052bd3e5ce0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a> SimTK::MobilizedBody::calcBodyInertiaAboutAnotherBodyStation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>aboutLocationOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the inertia of this body B, taken about an arbitrary point PA of body A, and expressed in body A. </p>
<p>TODO: this needs testing! </p>

</div>
</div>
<a class="anchor" id="afc4029646b0e89372c37eb12a7f63c4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::calcBodyMomentumAboutBodyOriginInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate body B's momentum (angular, linear) measured and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, but taken about the body origin Bo. </p>

</div>
</div>
<a class="anchor" id="aa4057ec7dbf36556c8633529f521457b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::MobilizedBody::calcBodyMomentumAboutBodyMassCenterInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate body B's momentum (angular, linear) measured and expressed in <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, but taken about the body mass center Bc. </p>

</div>
</div>
<a class="anchor" id="a670bf0636c3fee6ab7c642fc2bdb13bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::calcStationToStationDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the distance from a station PB on body B to a station PA on body A. </p>
<p>We are given the location vectors (stations) p_Bo_PB and p_Ao_PA, expressed in their respective frames. We return |p_PB_PA|. </p>

</div>
</div>
<a class="anchor" id="adc856e321ebcd2a73abe8dae404bc721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::calcStationToStationDistanceTimeDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the time rate of change of distance from a fixed point PB on body B to a fixed point PA on body A. </p>
<p>We are given the location vectors p_Bo_PB and p_Ao_PA, expressed in their respective frames. We return d/dt |p_BoAo|, under the assumption that the time derivatives of the two given vectors in their own frames is zero. </p>

</div>
</div>
<a class="anchor" id="af6b7270f1b4ee67d7ce39f5b7a7a1038"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::calcStationToStationDistance2ndTimeDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the second time derivative of distance from a fixed point PB on body B to a fixed point PA on body A. </p>
<p>We are given the position vectors (stations) p_Bo_PB and p_Ao_PA, expressed in their respective frames. We return d^2/dt^2 |p_PB_PA|, under the assumption that the time derivatives of the two given vectors in their own frames is zero. </p>

</div>
</div>
<a class="anchor" id="a2310ebac8eef484807289765f02ca90d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::calcBodyMovingPointVelocityInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: not implemented yet &ndash; any volunteers? Return the velocity of a point P moving on body B, in body A's frame, expressed in body A. </p>

</div>
</div>
<a class="anchor" id="a5e4ac1adfc161012b68803cf42bac406"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::MobilizedBody::calcBodyMovingPointAccelerationInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>accelerationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>inBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: not implemented yet &ndash; any volunteers? Return the velocity of a point P moving (and possibly accelerating) on body B, in body A's frame, expressed in body A. </p>

</div>
</div>
<a class="anchor" id="aea0ce43a4954a9b0d1b1f8c4120118a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::calcMovingPointToPointDistanceTimeDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: not implemented yet &ndash; any volunteers? Calculate the time rate of change of distance from a moving point PB on body B to a moving point PA on body A. </p>
<p>We are given the location vectors p_Bo_PB and p_Ao_PA, and the velocities of PB in B and PA in A, all expressed in their respective frames. We return d/dt |p_BoAo|, taking into account the (given) time derivatives of the locations in their local frames, as well as the relative velocities of the bodies. </p>

</div>
</div>
<a class="anchor" id="a667a7e9ff38a440c40a6edfe6e5be508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::calcMovingPointToPointDistance2ndTimeDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>accelerationOnBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>locationOnBodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>velocityOnBodyA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>accelerationOnBodyA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: not implemented yet &ndash; any volunteers? Calculate the second time derivative of distance from a moving point PB on body B to a moving point PA on body A. </p>
<p>We are given the location vectors p_Bo_PB and p_Ao_PA, and the velocities and accelerations of PB in B and PA in A, all expressed in their respective frames. We return d^2/dt^2 |p_AoBo|, taking into account the time derivatives of the locations in their local frames, as well as the relative velocities and accelerations of the bodies. </p>

</div>
</div>
<a class="anchor" id="a50504ba0523506307e866bf5a3c9a6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Body.html">Body</a>&amp; SimTK::MobilizedBody::getBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody. </p>
<p>This refers to an internal copy of the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> that is owned by the MobilizedBody. </p>

</div>
</div>
<a class="anchor" id="a9d923cd8142f9f22fd8c066bc123f5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Body.html">Body</a>&amp; SimTK::MobilizedBody::updBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody. </p>
<p>This refers to an internal copy of the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> that is owned by the MobilizedBody. Calling this method invalidates the MobilizedBody's topology, so the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s realizeTopology() method must be called again. </p>

</div>
</div>
<a class="anchor" id="a6ed529dd784c1b31d0758dc108d99733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::setBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Body.html">Body</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> contained within this MobilizedBody with a new one. </p>
<p>Calling this method invalidates the MobilizedBody's topology, so the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s realizeTopology() method must be called again. A reference to this MobilizedBody is returned so that this can be chained like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0397e80362252a12c1e1b82fad4119d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::addBodyDecoration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_BD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add decorative geometry specified relative to the new (outboard) body's reference frame B. </p>
<p>Note that the body itself may already have had some decorative geometry on it when it was first put into this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>; this just adds more and the returned index is larger. Use the underlying <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> object's accessors to find this decorative geometry again. The given <code>geometry</code> object is <em>copied</em> here; we do not keep a reference to the supplied object. </p>

</div>
</div>
<a class="anchor" id="a23fdbd930e0d1b457b34f74bbea48f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::addBodyDecoration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for use when the <code>geometry</code> is supplied in the body frame. </p>
<p>This is the same as addBodyDecoration(Transform(),geometry). </p>

</div>
</div>
<a class="anchor" id="a318d42af0404b963baaf79aefe5ac2aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::addOutboardDecoration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_MD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add decorative geometry specified relative to the outboard mobilizer frame M attached to body B. </p>
<p>If body B already has decorative geometry on it, this just adds some more, but kept in a separate list from the body decorations and inboard decorations. Returns a unique index that can be used to identify this outboard decoration later (numbered starting from zero for outboard decorations only). </p>

</div>
</div>
<a class="anchor" id="a1691b7b83f03bab864809c57f09aa5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::getNumOutboardDecorations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the count of decorations added with <a class="el" href="classSimTK_1_1MobilizedBody.html#a318d42af0404b963baaf79aefe5ac2aa" title="Add decorative geometry specified relative to the outboard mobilizer frame M attached to body B...">addOutboardDecoration()</a>. </p>

</div>
</div>
<a class="anchor" id="a953490945c2f038d5863a2a69562d1bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&amp; SimTK::MobilizedBody::getOutboardDecoration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the i'th outboard decoration. </p>

</div>
</div>
<a class="anchor" id="ab72c9eeb5134c3f0592ff8ad9596c60a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&amp; SimTK::MobilizedBody::updOutboardDecoration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the i'th outboard decoration. </p>

</div>
</div>
<a class="anchor" id="aac4d45c5d01f527fe78d1cd87ae0ed12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::addInboardDecoration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_FD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add decorative geometry specified relative to the inboard mobilizer frame F attached to the parent body P. </p>
<p>If body P already has decorative geometry on it, this just adds some more, but kept in a separate list from the body decorations and outboard decorations. Returns a unique index that can be used to identify this inboard decoration later (numbered starting from zero for inboard decorations only). </p>

</div>
</div>
<a class="anchor" id="a6332e7affc3bc5d08e03404217e1e10f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::getNumInboardDecorations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the count of decorations added with <a class="el" href="classSimTK_1_1MobilizedBody.html#aac4d45c5d01f527fe78d1cd87ae0ed12" title="Add decorative geometry specified relative to the inboard mobilizer frame F attached to the parent bo...">addInboardDecoration()</a>. </p>

</div>
</div>
<a class="anchor" id="a9023214074ff6f08a66482a47ca18dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&amp; SimTK::MobilizedBody::getInboardDecoration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the i'th inboard decoration. </p>

</div>
</div>
<a class="anchor" id="a2aafb9d7c6308942522cdbde6ccf1d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&amp; SimTK::MobilizedBody::updInboardDecoration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the i'th inboard decoration. </p>

</div>
</div>
<a class="anchor" id="a96ad8ad7a2ab01d1f972ac63b75177c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::setDefaultMassProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the contained <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> can have its mass properties set to the supplied value <code>m</code> its mass properties are changed, otherwise the method fails. </p>
<p>Calling this method invalidates the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>'s topology, so the containing matter subsystem's realizeTopology() method must be called again. A reference to this MobilizedBody is returned so that this can be chained like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="ac7cf261b33dd74faca04cf0df404387d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&amp; SimTK::MobilizedBody::getDefaultMassProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the mass properties of the <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> stored within this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. </p>

</div>
</div>
<a class="anchor" id="a8093a13f5455a64f3992ac46e60baff3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::adoptMotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Motion.html">Motion</a> &amp;&#160;</td>
          <td class="paramname"><em>ownerHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a unique <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object for this MobilizedBody. </p>
<p>The MobilizedBody takes over ownership of the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object and is responsible for cleaning up its heap space when the time comes. This is a Topology-changing operation and consequently requires write access to the MobilizedBody which will propagate to invalidate the containing <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> and <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s topology. There can only be one <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object per mobilizer; this method will throw an exception if there is already one here. </p>

</div>
</div>
<a class="anchor" id="ad387e92c292c91370ae34e64d4fb1a25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::clearMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object associated with this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> it is removed; otherwise, nothing happens. </p>
<p>If a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> is deleted, the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>'s topology is invalidated. </p>

</div>
</div>
<a class="anchor" id="aad0cdc23563e2ce3e79a6eff6028713f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::hasMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether this MobilizedBody has an associated <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object. </p>
<p>This does not tell you whether the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object is currently enabled or in use; just whether it is available. </p>

</div>
</div>
<a class="anchor" id="a45691e3b33e7c78f5118078565df5f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Motion.html">Motion</a>&amp; SimTK::MobilizedBody::getMotion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object associated with this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, this returns a const reference to it. </p>
<p>Otherwise it will throw an exception. You can check first using <a class="el" href="classSimTK_1_1MobilizedBody.html#aad0cdc23563e2ce3e79a6eff6028713f" title="Check whether this MobilizedBody has an associated Motion object. ">hasMotion()</a>. Note that there is no provision to obtain a writable reference to the contained <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object; if you want to change it clear the existing object instead and replace it with a new one. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#aad0cdc23563e2ce3e79a6eff6028713f" title="Check whether this MobilizedBody has an associated Motion object. ">hasMotion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa316ee0d30e68802bbb5c5e5f923b629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::setDefaultInboardFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_PF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change this mobilizer's frame F on the parent body P. </p>
<p>Calling this method invalidates the MobilizedBody's topology, so the containing matter subsystem's realizeTopology() method must be called again. A reference to this MobilizedBody is returned so that this can be chained like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="aa9ab782162cb3812c0d8210288290624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::setDefaultOutboardFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_BM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change this mobilizer's frame M fixed on this (the outboard) body B. </p>
<p>Calling this method invalidates the MobilizedBody's topology, so the containing matter subsystem's realizeTopology() method must be called again. A reference to this MobilizedBody is returned so that this can be chained like an assignment operator. </p>

</div>
</div>
<a class="anchor" id="acdb13a977d8b395603bbb2bdc9b17b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getDefaultInboardFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this mobilizer's default for the frame F fixed on the parent (inboard) body P, as the fixed Transform from P's body frame to the frame F fixed to P. </p>
<p>This default Transform is stored with the MobilizedBody object, not the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="a3685fb7d4a869b5f155b1a8ff93d14f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a>&amp; SimTK::MobilizedBody::getDefaultOutboardFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this MobilizedBody's default for mobilizer frame M, as the fixed Transform from this body B's frame to the frame M fixed on B. </p>
<p>This default Transform is stored with the MobilizedBody object, not the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>

</div>
</div>
<a class="anchor" id="a01b7797495da5ec793e3990ca55709e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::MobilizedBody::operator <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an implicit conversion from MobilizedBody to <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> when needed. </p>
<p>This will fail unless this MobilizedBody is owned by some <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. We guarantee that the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of a mobilized body is numerically larger than the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of its parent. </p>

</div>
</div>
<a class="anchor" id="af57d3e2056111f2f266a5cac92a118cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> SimTK::MobilizedBody::getMobilizedBodyIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within the owning <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. </p>
<p>This will fail unless this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> is owned by some <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. We guarantee that the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of a mobilized body is numerically larger than the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of its parent. </p>

</div>
</div>
<a class="anchor" id="a994d1afbed8dbddda0032b05e17bb21e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::getParentMobilizedBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> serving as the parent body of the current <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. </p>
<p>This call will fail if the current <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, since <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> has no parent. </p>

</div>
</div>
<a class="anchor" id="ab36d77f2bba99bcc6960e85ff20aebe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::getBaseMobilizedBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to this MobilizedBody's oldest ancestor other than <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, or return <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a> if this MobilizedBody is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>
<p>That is, we return the "base" MobilizedBody for this MobilizedBody, meaning the one which connects this branch of the multibody tree directly to <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>

</div>
</div>
<a class="anchor" id="ac775ea17a6b45616c8f4614d7f05039a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>&amp; SimTK::MobilizedBody::getMatterSubsystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a reference to the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> which contains this MobilizedBody. </p>
<p>This will fail unless this <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> is owned by some <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. </p>

</div>
</div>
<a class="anchor" id="aa31b3864498124e5f5a9874efe68ffd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>&amp; SimTK::MobilizedBody::updMatterSubsystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a writable reference to the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> which contains this MobilizedBody. </p>
<p>This will fail unless this MobilizedBody is owned by some <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a>. </p>

</div>
</div>
<a class="anchor" id="a3811f11ba5bc6c71d69089f8e44cae09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isInSubsystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the current <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> object is owned by a matter subsystem. </p>

</div>
</div>
<a class="anchor" id="a48d669565cc8b3280a9dcda76d436f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isInSameSubsystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>mobod</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> <code>mobod</code> is in the same matter subsystem as the current body. </p>
<p>If the bodies are not in a subsystem, this routine will return <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="adc702c31a60e1aa2c30bde5928df1ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isSameMobilizedBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>mobod</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a given MobilizedBody <code>mobod</code> is the same MobilizedBody as this one. </p>
<p>For this to be true the handles must not be empty, and the implementation objects must be <em>the same object</em> not separate objects with identical contents. </p>

</div>
</div>
<a class="anchor" id="a91d2b1ce31d2517f54fe6ca017e12e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::MobilizedBody::isGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this body is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>, meaning that it is actually body 0 of some matter subsytem, not just that its body type is <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>

</div>
</div>
<a class="anchor" id="a88a9c7060d2eba76350683a5877b8e9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::MobilizedBody::getLevelInMultibodyTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return this body's level in the tree of bodies, starting with ground at 0, bodies directly connected to ground at 1, bodies directly connected to those at 2, etc. </p>
<p>This is callable after realizeTopology(). This is the graph distance of the body from <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html" title="This is a special type of &quot;mobilized&quot; body generated automatically by Simbody as a placeholder for Gr...">Ground</a>. </p>

</div>
</div>
<a class="anchor" id="a38dd85c33023cff8000542223937cc47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::MobilizedBody::cloneForNewParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> which is identical to this one, except that it has a different parent (and consequently might belong to a different <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>). </p>

</div>
</div>
<a class="anchor" id="a8abdb29a5b69ee005c69f03492012cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneFromQPartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility selects one of the q's (generalized coordinates) associated with this mobilizer from a supplied "q-like" Vector, meaning a Vector which is the same length as the Vector of q's for the containing matter subsystem. </p>

</div>
</div>
<a class="anchor" id="acb4c37c9469de167f38bceaf61e61ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&amp; SimTK::MobilizedBody::updOneFromQPartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility returns a writable reference to one of the q's (generalized coordinates) associated with this mobilizer from a supplied "q-like" Vector, meaning a Vector which is the same length as the Vector of q's for the containing matter subsystem. </p>

</div>
</div>
<a class="anchor" id="acf70b5c8c35ed2c4f98ea9ec497248d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::MobilizedBody::getOneFromUPartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility selects one of the u's (generalized speeds) associated with this mobilizer from a supplied "u-like" Vector, meaning a Vector which is the same length as the Vector of u's for the containing matter subsystem. </p>

</div>
</div>
<a class="anchor" id="ae9467b6c619d89e1aa7e98894734840f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&amp; SimTK::MobilizedBody::updOneFromUPartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility returns a writable reference to one of the u's (generalized speeds) associated with this mobilizer from a supplied "u-like" Vector, meaning a Vector which is the same length as the Vector of u's for the containing matter subsystem. </p>

</div>
</div>
<a class="anchor" id="a0aa98b6d48e4c17602da737be176d547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::applyOneMobilityForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility adds in the supplied generalized force <code>f</code> (a scalar) to the appropriate slot of the supplied <code>mobilityForces</code> Vector, which is a "u-like" Vector. </p>
<p>Note that we are <em>adding</em> this not <em>setting</em> it so it important that <code>mobilityForces</code> be initialized to zero before making a set of calls to <a class="el" href="classSimTK_1_1MobilizedBody.html#a0aa98b6d48e4c17602da737be176d547" title="This utility adds in the supplied generalized force f (a scalar) to the appropriate slot of the suppl...">applyOneMobilityForce()</a>. </p>

</div>
</div>
<a class="anchor" id="a0ac5f187e7ecd3ab750fd60f66a75010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::convertQForceToUForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>, <a class="el" href="classSimTK_1_1MobilizerQIndex.html">MobilizerQIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a generalized force in the q-space of this mobilizer, convert it to the equivalent generalized mobility force (u-space force). </p>
<p>This uses the kinematic coupling matrix N that appears in equation (1) qdot=N*u. Here we compute (2) fu = ~N*fq (that's N transpose, not inverse).</p>
<p>Simbody deals with generalized forces in mobility (u) space, but sometimes these are more convenient to generate in generalized coordinate (q) space. In that case this utility method is useful to perform the conversion from q space to u space that is necessary for communicating the force to Simbody.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> already realized through Position stage, from which this mobilizer's kinematic coupling matrix N(q) is obtained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fq</td><td>This is a generalized force in the space of the generalized coordinates q rather than the generalized speeds u. The length of <code>fq</code> must be nq, the number of q's currently being used by this mobilizer in the given <code>state</code>. (This can depend on a Model-stage state variable.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fu</td><td>This is the generalized force in mobility space (the space of the generalized speeds u) that is equivalent to <code>fq</code>. <code>fu</code> will be resized if necessary to length nu, the number of u's being used by this mobilizer.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The physical quantity power (force times velocity) must not change as a result of a change of coordinates. Hence we must have ~fq*qdot==~fu*u which follows from equations (1) and (2): multiply (1) by ~fq to get </p><pre>
    ~fq*qdot= ~fq*N*u
            = ~(~N*fq)*u
            = ~fu*u           from equation (2).
</pre><p> For any mobilizer where qdot==u this simply copies the input to the output. Otherwise a multiplication by ~N is done, but that is very fast since N has already been computed. Cost depends on type of mobilizer but is unlikely to exceed 25 flops. </p>

</div>
</div>
<a class="anchor" id="a77d73a0b77545b7929b5299399a1c543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::applyBodyForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>spatialForceInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility adds in the supplied spatial force <code>spatialForceInG</code> (consisting of a torque vector, and a force vector to be applied at the current body's origin) to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector. </p>
<p>Note that we are <em>adding</em> this not <em>setting</em> it so it is important that <code>bodyForcesInG</code> be initialized to zero before making a set of calls to <a class="el" href="classSimTK_1_1MobilizedBody.html#a77d73a0b77545b7929b5299399a1c543" title="This utility adds in the supplied spatial force spatialForceInG (consisting of a torque vector...">applyBodyForce()</a>. </p>

</div>
</div>
<a class="anchor" id="a2b6aeee0ce7fed8f55293a34f1c4d435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::applyBodyTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torqueInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility adds in the supplied pure torque <code>torqueInG</code> to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector. </p>
<p>Note that we are <em>adding</em> this not <em>setting</em> it so it is important that <code>bodyForcesInG</code> be initialized to zero before making a set of calls to <a class="el" href="classSimTK_1_1MobilizedBody.html#a2b6aeee0ce7fed8f55293a34f1c4d435" title="This utility adds in the supplied pure torque torqueInG to the appropriate slot of the supplied bodyF...">applyBodyTorque()</a>. </p>

</div>
</div>
<a class="anchor" id="a86d41383618cfbc4d254bdcce82d0a73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::MobilizedBody::applyForceToBodyPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pointInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>forceInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility adds in the supplied force <code>forceInG</code> applied at a point <code>pointInB</code> to the appropriate slot of the supplied <code>bodyForcesInG</code> Vector. </p>
<p>Notes:</p><ul>
<li>we are <em>adding</em> this not <em>setting</em> it so it is important that <code>bodyForcesInG</code> be initialized to zero before making a set of calls to <a class="el" href="classSimTK_1_1MobilizedBody.html#a86d41383618cfbc4d254bdcce82d0a73" title="This utility adds in the supplied force forceInG applied at a point pointInB to the appropriate slot ...">applyForceToBodyPoint()</a>.</li>
<li><code>pointInB</code> represents a fixed station of B and is provided by giving the vector from body B's origin to the point, expressed in the B frame, while the applied force (and resulting body forces and torques) are expressed in the ground frame. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa3ca9a5e09ca1368d7724daa9d7ff3fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> <a class="el" href="classSimTK_1_1MobilizedBody.html#aa3ca9a5e09ca1368d7724daa9d7ff3fd">Mobod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mobod is the approved abbreviation for <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. Feel free to use it if you get tired of typing or seeing the full name. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MobilizedBody_8h_source.html">MobilizedBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a></li>
    <li class="footer">Generated on Tue Apr 26 2016 22:01:18 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
