<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::NiceTypeName&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structSimTK_1_1NiceTypeName.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structSimTK_1_1NiceTypeName-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::NiceTypeName&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Obtain human-readable and XML-usable names for arbitrarily-complicated C++ types.  
 <a href="structSimTK_1_1NiceTypeName.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a10092fe83a00f0a1e306ac390c64a8ba"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a10092fe83a00f0a1e306ac390c64a8ba">name</a> ()</td></tr>
<tr class="memdesc:a10092fe83a00f0a1e306ac390c64a8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#a10092fe83a00f0a1e306ac390c64a8ba" title="The default implementation of name() here returns the raw result from `typeid(T). ...">name()</a> here returns the raw result from `typeid(T).  <a href="#a10092fe83a00f0a1e306ac390c64a8ba">More...</a><br /></td></tr>
<tr class="separator:a10092fe83a00f0a1e306ac390c64a8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b1203e8b059d72f41042214f732872"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872">namestr</a> ()</td></tr>
<tr class="memdesc:a03b1203e8b059d72f41042214f732872"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a> attempts to return a nicely demangled and canonicalized type name on all platforms, using the SimTK::demangle() and SimTK::canonicalizeTypeName() methods.  <a href="#a03b1203e8b059d72f41042214f732872">More...</a><br /></td></tr>
<tr class="separator:a03b1203e8b059d72f41042214f732872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4996a90dbec9e9dceef395f3d166c3e"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#ab4996a90dbec9e9dceef395f3d166c3e">xmlstr</a> ()</td></tr>
<tr class="memdesc:ab4996a90dbec9e9dceef395f3d166c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#ab4996a90dbec9e9dceef395f3d166c3e" title="The default implementation of xmlstr() takes the output of namestr() and invokes SimTK::encodeTypeNam...">xmlstr()</a> takes the output of <a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a> and invokes SimTK::encodeTypeNameForXML() on it.  <a href="#ab4996a90dbec9e9dceef395f3d166c3e">More...</a><br /></td></tr>
<tr class="separator:ab4996a90dbec9e9dceef395f3d166c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a979982102c0dbd9e9c970d56c96481e3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a979982102c0dbd9e9c970d56c96481e3">demangle</a> (const char *<a class="el" href="structSimTK_1_1NiceTypeName.html#a10092fe83a00f0a1e306ac390c64a8ba">name</a>)</td></tr>
<tr class="memdesc:a979982102c0dbd9e9c970d56c96481e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to demangle a type name as returned by typeid.name(), with the result hopefully suitable for meaningful display to a human.  <a href="#a979982102c0dbd9e9c970d56c96481e3">More...</a><br /></td></tr>
<tr class="separator:a979982102c0dbd9e9c970d56c96481e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e3c5fd1a1f3fafe347c2ad1b1ed7e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a90e3c5fd1a1f3fafe347c2ad1b1ed7e0">canonicalizeTypeName</a> (std::string &amp;&amp;demangledTypeName)</td></tr>
<tr class="memdesc:a90e3c5fd1a1f3fafe347c2ad1b1ed7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a compiler-dependent demangled type name string as returned by SimTK::demangle(), attempt to form a canonicalized representation that will be the same for any compiler.  <a href="#a90e3c5fd1a1f3fafe347c2ad1b1ed7e0">More...</a><br /></td></tr>
<tr class="separator:a90e3c5fd1a1f3fafe347c2ad1b1ed7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e753eb6270e387a7d93231219c4d09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a26e753eb6270e387a7d93231219c4d09">canonicalizeTypeName</a> (const std::string &amp;demangledTypeName)</td></tr>
<tr class="memdesc:a26e753eb6270e387a7d93231219c4d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, but takes an lvalue reference so has to copy the input.  <a href="#a26e753eb6270e387a7d93231219c4d09">More...</a><br /></td></tr>
<tr class="separator:a26e753eb6270e387a7d93231219c4d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d93b0c0ed6ed28a38cafc05e0fca54"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a32d93b0c0ed6ed28a38cafc05e0fca54">encodeTypeNameForXML</a> (std::string &amp;&amp;canonicalizedTypeName)</td></tr>
<tr class="memdesc:a32d93b0c0ed6ed28a38cafc05e0fca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a canonicalized type name, produce a modified version that is better-suited to use as an XML attribute.  <a href="#a32d93b0c0ed6ed28a38cafc05e0fca54">More...</a><br /></td></tr>
<tr class="separator:a32d93b0c0ed6ed28a38cafc05e0fca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3af754c62e20c3f15e93eec0a85faa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#aaa3af754c62e20c3f15e93eec0a85faa">encodeTypeNameForXML</a> (const std::string &amp;niceTypeName)</td></tr>
<tr class="memdesc:aaa3af754c62e20c3f15e93eec0a85faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, but takes an lvalue reference so has to copy the input.  <a href="#aaa3af754c62e20c3f15e93eec0a85faa">More...</a><br /></td></tr>
<tr class="separator:aaa3af754c62e20c3f15e93eec0a85faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced0536b8baac1a5ad6c879b84ca219c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#aced0536b8baac1a5ad6c879b84ca219c">decodeXMLTypeName</a> (std::string &amp;&amp;xmlTypeName)</td></tr>
<tr class="memdesc:aced0536b8baac1a5ad6c879b84ca219c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a type name that was encoded for XML by SimTK::encodeTypeNameForXML(), restore it to its canonicalized form.  <a href="#aced0536b8baac1a5ad6c879b84ca219c">More...</a><br /></td></tr>
<tr class="separator:aced0536b8baac1a5ad6c879b84ca219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b99d7e2379c7a5d10018f2f1f991ed4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1NiceTypeName.html#a7b99d7e2379c7a5d10018f2f1f991ed4">decodeXMLTypeName</a> (const std::string &amp;xmlTypeName)</td></tr>
<tr class="memdesc:a7b99d7e2379c7a5d10018f2f1f991ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, but takes an lvalue reference so has to copy the input.  <a href="#a7b99d7e2379c7a5d10018f2f1f991ed4">More...</a><br /></td></tr>
<tr class="separator:a7b99d7e2379c7a5d10018f2f1f991ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
struct SimTK::NiceTypeName&lt; T &gt;</h3>

<p>Obtain human-readable and XML-usable names for arbitrarily-complicated C++ types. </p>
<p>Three methods <code><a class="el" href="structSimTK_1_1NiceTypeName.html#a10092fe83a00f0a1e306ac390c64a8ba" title="The default implementation of name() here returns the raw result from `typeid(T). ...">name()</a></code>, <code><a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a></code>, and <code><a class="el" href="structSimTK_1_1NiceTypeName.html#ab4996a90dbec9e9dceef395f3d166c3e" title="The default implementation of xmlstr() takes the output of namestr() and invokes SimTK::encodeTypeNam...">xmlstr()</a></code> are provided giving respectively the compiler-dependent output from <code>typeid(T).name()</code>, a canonicalized human-readable string, and the canonicalized string with XML-forbidden angle brackets replaced by curly braces. The default implementation is usable for most types, but if you don't like the result you can specialize to provide nicer names. For example, you may prefer <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da" title="This is the most common 3D vector type: a column of 3 Real values stored consecutively in memory (pac...">SimTK::Vec3</a> to <a class="el" href="classSimTK_1_1Vec.html" title="This is a fixed-length column vector designed for no-overhead inline computation. ...">SimTK::Vec</a>&lt;3,double,1&gt;.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't expect usable names for types that are defined in an anonymous namespace or for function-local types. Names will still be produced but they won't be unique and won't necessarily be compiler-independent.</dd></dl>
<p>The output of <code><a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a></code> is typically used for error messages and testing; <code><a class="el" href="structSimTK_1_1NiceTypeName.html#ab4996a90dbec9e9dceef395f3d166c3e" title="The default implementation of xmlstr() takes the output of namestr() and invokes SimTK::encodeTypeNam...">xmlstr()</a></code> is used for type tags in XML for use in deserializing. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a10092fe83a00f0a1e306ac390c64a8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10092fe83a00f0a1e306ac390c64a8ba">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* <a class="el" href="structSimTK_1_1NiceTypeName.html">SimTK::NiceTypeName</a>&lt; T &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#a10092fe83a00f0a1e306ac390c64a8ba" title="The default implementation of name() here returns the raw result from `typeid(T). ...">name()</a> here returns the raw result from `typeid(T). </p>
<p>name()` which will be fast but may be a mangled name in some compilers (gcc and clang included). </p>

</div>
</div>
<a id="a03b1203e8b059d72f41042214f732872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b1203e8b059d72f41042214f732872">&#9670;&nbsp;</a></span>namestr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; <a class="el" href="structSimTK_1_1NiceTypeName.html">SimTK::NiceTypeName</a>&lt; T &gt;::namestr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a> attempts to return a nicely demangled and canonicalized type name on all platforms, using the SimTK::demangle() and SimTK::canonicalizeTypeName() methods. </p>
<p>This is an expensive operation but is only done once. </p>

</div>
</div>
<a id="ab4996a90dbec9e9dceef395f3d166c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4996a90dbec9e9dceef395f3d166c3e">&#9670;&nbsp;</a></span>xmlstr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; <a class="el" href="structSimTK_1_1NiceTypeName.html">SimTK::NiceTypeName</a>&lt; T &gt;::xmlstr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation of <a class="el" href="structSimTK_1_1NiceTypeName.html#ab4996a90dbec9e9dceef395f3d166c3e" title="The default implementation of xmlstr() takes the output of namestr() and invokes SimTK::encodeTypeNam...">xmlstr()</a> takes the output of <a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a> and invokes SimTK::encodeTypeNameForXML() on it. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a979982102c0dbd9e9c970d56c96481e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979982102c0dbd9e9c970d56c96481e3">&#9670;&nbsp;</a></span>demangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string demangle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to demangle a type name as returned by typeid.name(), with the result hopefully suitable for meaningful display to a human. </p>
<p>Behavior is compiler-dependent. </p>

</div>
</div>
<a id="a90e3c5fd1a1f3fafe347c2ad1b1ed7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e3c5fd1a1f3fafe347c2ad1b1ed7e0">&#9670;&nbsp;</a></span>canonicalizeTypeName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string canonicalizeTypeName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>demangledTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a compiler-dependent demangled type name string as returned by SimTK::demangle(), attempt to form a canonicalized representation that will be the same for any compiler. </p>
<p>Unnecessary spaces and superfluous keywords like "class" and "struct" are removed. The <code><a class="el" href="structSimTK_1_1NiceTypeName.html#a03b1203e8b059d72f41042214f732872" title="The default implementation of namestr() attempts to return a nicely demangled and canonicalized type ...">namestr()</a></code> method of <a class="el" href="structSimTK_1_1NiceTypeName.html" title="Obtain human-readable and XML-usable names for arbitrarily-complicated C++ types. ...">NiceTypeName</a>&lt;T&gt; uses this function to produce a human-friendly type name that is the same on any platform. The input argument is left empty. </p>

</div>
</div>
<a id="a26e753eb6270e387a7d93231219c4d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e753eb6270e387a7d93231219c4d09">&#9670;&nbsp;</a></span>canonicalizeTypeName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string canonicalizeTypeName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>demangledTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same, but takes an lvalue reference so has to copy the input. </p>

</div>
</div>
<a id="a32d93b0c0ed6ed28a38cafc05e0fca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d93b0c0ed6ed28a38cafc05e0fca54">&#9670;&nbsp;</a></span>encodeTypeNameForXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string encodeTypeNameForXML </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>canonicalizedTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a canonicalized type name, produce a modified version that is better-suited to use as an XML attribute. </p>
<p>This means replacing the angle brackets with curly braces to avoid trouble. The input argument is left empty. </p>

</div>
</div>
<a id="aaa3af754c62e20c3f15e93eec0a85faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3af754c62e20c3f15e93eec0a85faa">&#9670;&nbsp;</a></span>encodeTypeNameForXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string encodeTypeNameForXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>niceTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same, but takes an lvalue reference so has to copy the input. </p>

</div>
</div>
<a id="aced0536b8baac1a5ad6c879b84ca219c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced0536b8baac1a5ad6c879b84ca219c">&#9670;&nbsp;</a></span>decodeXMLTypeName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string decodeXMLTypeName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>xmlTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a type name that was encoded for XML by SimTK::encodeTypeNameForXML(), restore it to its canonicalized form. </p>
<p>This means replacing curly braces by angle brackets. The input argument is left empty. </p>

</div>
</div>
<a id="a7b99d7e2379c7a5d10018f2f1f991ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b99d7e2379c7a5d10018f2f1f991ed4">&#9670;&nbsp;</a></span>decodeXMLTypeName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string decodeXMLTypeName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>xmlTypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same, but takes an lvalue reference so has to copy the input. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="SimTKcommon_2include_2SimTKcommon_2internal_2common_8h_source.html">SimTKcommon/include/SimTKcommon/internal/common.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="structSimTK_1_1NiceTypeName.html">NiceTypeName</a></li>
    <li class="footer">Generated on Fri Dec 6 2019 17:28:07 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
