<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::Xml::Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1Xml_1_1Element.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1Xml_1_1Element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::Xml::Element Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes.  
 <a href="classSimTK_1_1Xml_1_1Element.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::Xml::Element:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1Xml_1_1Element.png" usemap="#SimTK::Xml::Element_map" alt=""/>
  <map id="SimTK::Xml::Element_map" name="SimTK::Xml::Element_map">
<area href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. " alt="SimTK::Xml::Node" shape="rect" coords="0,0,124,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As discussed elsewhere, elements come in two varieties: value elements and compound elements.</p>
<p>New value elements can be created easily since they are essentially just a name,value pair. Compound elements require a series of method calls to create the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> node and then add child nodes to it. In either case you may want to add attributes also. </p>
</div></td></tr>
<tr class="memitem:ace92fc2051430e6dc12eec23135bc409"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ace92fc2051430e6dc12eec23135bc409">Element</a> ()</td></tr>
<tr class="memdesc:ace92fc2051430e6dc12eec23135bc409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements.  <a href="#ace92fc2051430e6dc12eec23135bc409">More...</a><br /></td></tr>
<tr class="separator:ace92fc2051430e6dc12eec23135bc409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab436c4a5dd786608a8083cae30a93388"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab436c4a5dd786608a8083cae30a93388">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value=&quot;&quot;)</td></tr>
<tr class="memdesc:ab436c4a5dd786608a8083cae30a93388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value.  <a href="#ab436c4a5dd786608a8083cae30a93388">More...</a><br /></td></tr>
<tr class="separator:ab436c4a5dd786608a8083cae30a93388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aeeea0c8fd0fe18efb95f2907ac055451">Element</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tagWord, const T &amp;value)</td></tr>
<tr class="memdesc:aeeea0c8fd0fe18efb95f2907ac055451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#aeeea0c8fd0fe18efb95f2907ac055451">More...</a><br /></td></tr>
<tr class="separator:aeeea0c8fd0fe18efb95f2907ac055451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841cd0f539fbb2b6eaa1487745320c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a841cd0f539fbb2b6eaa1487745320c61">clone</a> () const</td></tr>
<tr class="memdesc:a841cd0f539fbb2b6eaa1487745320c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a841cd0f539fbb2b6eaa1487745320c61" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow.  <a href="#a841cd0f539fbb2b6eaa1487745320c61">More...</a><br /></td></tr>
<tr class="separator:a841cd0f539fbb2b6eaa1487745320c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bbdc9ab6c9e66939abe218fedcc096"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ab1bbdc9ab6c9e66939abe218fedcc096">getElementTag</a> () const</td></tr>
<tr class="memdesc:ab1bbdc9ab6c9e66939abe218fedcc096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element tag word.  <a href="#ab1bbdc9ab6c9e66939abe218fedcc096">More...</a><br /></td></tr>
<tr class="separator:ab1bbdc9ab6c9e66939abe218fedcc096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6b5bf3c6e351f7dd9afa52fcff07af52">setElementTag</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the tag word that is used to bracket this element.  <a href="#a6b5bf3c6e351f7dd9afa52fcff07af52">More...</a><br /></td></tr>
<tr class="separator:a6b5bf3c6e351f7dd9afa52fcff07af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79c09e3f397a48c65f40f86d113664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a4e79c09e3f397a48c65f40f86d113664">insertNodeBefore</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr class="memdesc:a4e79c09e3f397a48c65f40f86d113664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a4e79c09e3f397a48c65f40f86d113664">More...</a><br /></td></tr>
<tr class="separator:a4e79c09e3f397a48c65f40f86d113664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9bdc6b7182e6308f1bd9e08c830566b9">insertNodeAfter</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;pos, <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr class="memdesc:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>).  <a href="#a9bdc6b7182e6308f1bd9e08c830566b9">More...</a><br /></td></tr>
<tr class="separator:a9bdc6b7182e6308f1bd9e08c830566b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f65d60e9910d0e0106756d27d1a2c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1f65d60e9910d0e0106756d27d1a2c11">appendNode</a> (<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> node)</td></tr>
<tr class="memdesc:a1f65d60e9910d0e0106756d27d1a2c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abbreviation for <code>insertNodeAfter(node_end(), node);</code>.  <a href="#a1f65d60e9910d0e0106756d27d1a2c11">More...</a><br /></td></tr>
<tr class="separator:a1f65d60e9910d0e0106756d27d1a2c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3822acf6439f7b502ef0d6778ede972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ac3822acf6439f7b502ef0d6778ede972">eraseNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;deleteThis)</td></tr>
<tr class="memdesc:ac3822acf6439f7b502ef0d6778ede972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>.  <a href="#ac3822acf6439f7b502ef0d6778ede972">More...</a><br /></td></tr>
<tr class="separator:ac3822acf6439f7b502ef0d6778ede972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5b6dd8506bfb5221631df7dad4de4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#afd5b6dd8506bfb5221631df7dad4de4d">removeNode</a> (const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;removeThis)</td></tr>
<tr class="memdesc:afd5b6dd8506bfb5221631df7dad4de4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>.  <a href="#afd5b6dd8506bfb5221631df7dad4de4d">More...</a><br /></td></tr>
<tr class="separator:afd5b6dd8506bfb5221631df7dad4de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Value elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>As described elsewhere, value elements are those that have no child elements and only a single <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, whose contents can be considered as the element's value.</p>
<p>Methods in this section allow you to work conveniently with value elements, getting direct access to the value string or interpreting it as some other type. You can easily modify the value by obtaining a writable refence to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> object that holds it. We provide methods for working with this element's value (if it is a value element) and with an element's children's values (if this element is compound). </p>
</div></td></tr>
<tr class="memitem:a3a5c760941e395827738881fcda726df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3a5c760941e395827738881fcda726df">isValueElement</a> () const</td></tr>
<tr class="memdesc:a3a5c760941e395827738881fcda726df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes and no child elements.  <a href="#a3a5c760941e395827738881fcda726df">More...</a><br /></td></tr>
<tr class="separator:a3a5c760941e395827738881fcda726df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc4e5c49b8b4e45f09592e4c3adcda6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aabc4e5c49b8b4e45f09592e4c3adcda6">getValue</a> () const</td></tr>
<tr class="memdesc:aabc4e5c49b8b4e45f09592e4c3adcda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of this value element.  <a href="#aabc4e5c49b8b4e45f09592e4c3adcda6">More...</a><br /></td></tr>
<tr class="separator:aabc4e5c49b8b4e45f09592e4c3adcda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe1243e8e2e83ceb3925659181065d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d">updValue</a> ()</td></tr>
<tr class="memdesc:a6fbe1243e8e2e83ceb3925659181065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element.  <a href="#a6fbe1243e8e2e83ceb3925659181065d">More...</a><br /></td></tr>
<tr class="separator:a6fbe1243e8e2e83ceb3925659181065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d99f6f31da37e122ee14dcb7281238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238">setValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr class="memdesc:a87d99f6f31da37e122ee14dcb7281238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the text value of this value element.  <a href="#a87d99f6f31da37e122ee14dcb7281238">More...</a><br /></td></tr>
<tr class="separator:a87d99f6f31da37e122ee14dcb7281238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fd52a31abb8f1626d7902c747b02d4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a03fd52a31abb8f1626d7902c747b02d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4">setValueAs</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a03fd52a31abb8f1626d7902c747b02d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists).  <a href="#a03fd52a31abb8f1626d7902c747b02d4">More...</a><br /></td></tr>
<tr class="separator:a03fd52a31abb8f1626d7902c747b02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa601a3b3b7392708f4728fe396fea6f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa601a3b3b7392708f4728fe396fea6f7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa601a3b3b7392708f4728fe396fea6f7">getValueAs</a> () const</td></tr>
<tr class="memdesc:aa601a3b3b7392708f4728fe396fea6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming this is a "value element", convert its text value to the type of the template argument T.  <a href="#aa601a3b3b7392708f4728fe396fea6f7">More...</a><br /></td></tr>
<tr class="separator:aa601a3b3b7392708f4728fe396fea6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd5c3247ff45af5f8ad0083d3122bac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2cd5c3247ff45af5f8ad0083d3122bac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2cd5c3247ff45af5f8ad0083d3122bac">getValueAs</a> (T &amp;out) const</td></tr>
<tr class="memdesc:a2cd5c3247ff45af5f8ad0083d3122bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa601a3b3b7392708f4728fe396fea6f7" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects.  <a href="#a2cd5c3247ff45af5f8ad0083d3122bac">More...</a><br /></td></tr>
<tr class="separator:a2cd5c3247ff45af5f8ad0083d3122bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae270392614f6ec8d7d6d58c5572fca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6ae270392614f6ec8d7d6d58c5572fca">getRequiredElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const</td></tr>
<tr class="memdesc:a6ae270392614f6ec8d7d6d58c5572fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>must</em> be present in this element.  <a href="#a6ae270392614f6ec8d7d6d58c5572fca">More...</a><br /></td></tr>
<tr class="separator:a6ae270392614f6ec8d7d6d58c5572fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298fef4266524b814feaf9002719d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af298fef4266524b814feaf9002719d0e">getOptionalElementValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const</td></tr>
<tr class="memdesc:af298fef4266524b814feaf9002719d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string.  <a href="#af298fef4266524b814feaf9002719d0e">More...</a><br /></td></tr>
<tr class="separator:af298fef4266524b814feaf9002719d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147fe5ad38e20d3fb21d5442dd7d559f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a147fe5ad38e20d3fb21d5442dd7d559f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a147fe5ad38e20d3fb21d5442dd7d559f">getRequiredElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const</td></tr>
<tr class="memdesc:a147fe5ad38e20d3fb21d5442dd7d559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required child value element to the type of the template argument T.  <a href="#a147fe5ad38e20d3fb21d5442dd7d559f">More...</a><br /></td></tr>
<tr class="separator:a147fe5ad38e20d3fb21d5442dd7d559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12946c49aa16236c16083fff539f4347"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12946c49aa16236c16083fff539f4347"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a12946c49aa16236c16083fff539f4347">getOptionalElementValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag, const T &amp;def) const</td></tr>
<tr class="memdesc:a12946c49aa16236c16083fff539f4347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of an optional child value element, if present, to the type of the template argument T.  <a href="#a12946c49aa16236c16083fff539f4347">More...</a><br /></td></tr>
<tr class="separator:a12946c49aa16236c16083fff539f4347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>You can add, modify, and remove element attributes with the methods in this section.</p>
<p>You can work directly with individual attributes by name, or you can iterate through the list of attributes. </p>
</div></td></tr>
<tr class="memitem:abdcdc6686359597350b9c45cf7a58df1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#abdcdc6686359597350b9c45cf7a58df1">hasAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const</td></tr>
<tr class="memdesc:abdcdc6686359597350b9c45cf7a58df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has an attribute of this name.  <a href="#abdcdc6686359597350b9c45cf7a58df1">More...</a><br /></td></tr>
<tr class="separator:abdcdc6686359597350b9c45cf7a58df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c04ffb38dc3e908fd559c7c542ad559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8c04ffb38dc3e908fd559c7c542ad559">setAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;value)</td></tr>
<tr class="memdesc:a8c04ffb38dc3e908fd559c7c542ad559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one.  <a href="#a8c04ffb38dc3e908fd559c7c542ad559">More...</a><br /></td></tr>
<tr class="separator:a8c04ffb38dc3e908fd559c7c542ad559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03e4d7a877ad3a514412e78e3efc6ce7">eraseAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an attribute of this element if it exists, otherwise do nothing.  <a href="#a03e4d7a877ad3a514412e78e3efc6ce7">More...</a><br /></td></tr>
<tr class="separator:a03e4d7a877ad3a514412e78e3efc6ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a3d47972f939413d56e2a2302bf53a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a63a3d47972f939413d56e2a2302bf53a">getRequiredAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a63a3d47972f939413d56e2a2302bf53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string and throw an error if that attribute is not present.  <a href="#a63a3d47972f939413d56e2a2302bf53a">More...</a><br /></td></tr>
<tr class="separator:a63a3d47972f939413d56e2a2302bf53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac522c5cb6ede0937ea65f50d2192dce4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac522c5cb6ede0937ea65f50d2192dce4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ac522c5cb6ede0937ea65f50d2192dce4">getRequiredAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name) const</td></tr>
<tr class="memdesc:ac522c5cb6ede0937ea65f50d2192dce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the text value of a required attribute to the type of the template argument T.  <a href="#ac522c5cb6ede0937ea65f50d2192dce4">More...</a><br /></td></tr>
<tr class="separator:ac522c5cb6ede0937ea65f50d2192dce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2bbdb5a09cec23f14f7ec800e2ded7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1c2bbdb5a09cec23f14f7ec800e2ded7">getOptionalAttributeValue</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;def=&quot;&quot;) const</td></tr>
<tr class="memdesc:a1c2bbdb5a09cec23f14f7ec800e2ded7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value.  <a href="#a1c2bbdb5a09cec23f14f7ec800e2ded7">More...</a><br /></td></tr>
<tr class="separator:a1c2bbdb5a09cec23f14f7ec800e2ded7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9056e773edb5dcf7bb87a545053189d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9056e773edb5dcf7bb87a545053189d9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9056e773edb5dcf7bb87a545053189d9">getOptionalAttributeValueAs</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name, const T &amp;def) const</td></tr>
<tr class="memdesc:a9056e773edb5dcf7bb87a545053189d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the value of an optional attribute, if present, from a string to the type of the template argument T.  <a href="#a9056e773edb5dcf7bb87a545053189d9">More...</a><br /></td></tr>
<tr class="separator:a9056e773edb5dcf7bb87a545053189d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad904c330f4cec26a4e5793bed0441445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad904c330f4cec26a4e5793bed0441445">getRequiredAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:ad904c330f4cec26a4e5793bed0441445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present.  <a href="#ad904c330f4cec26a4e5793bed0441445">More...</a><br /></td></tr>
<tr class="separator:ad904c330f4cec26a4e5793bed0441445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd827d22b75b6202b7461b2ab90ddeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aacd827d22b75b6202b7461b2ab90ddeb">getOptionalAttribute</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;name)</td></tr>
<tr class="memdesc:aacd827d22b75b6202b7461b2ab90ddeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present.  <a href="#aacd827d22b75b6202b7461b2ab90ddeb">More...</a><br /></td></tr>
<tr class="separator:aacd827d22b75b6202b7461b2ab90ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d797fd21a8b3d851616dc8d00241a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a34d797fd21a8b3d851616dc8d00241a6">getAllAttributes</a> ()</td></tr>
<tr class="memdesc:a34d797fd21a8b3d851616dc8d00241a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element.  <a href="#a34d797fd21a8b3d851616dc8d00241a6">More...</a><br /></td></tr>
<tr class="separator:a34d797fd21a8b3d851616dc8d00241a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">attribute_begin</a> ()</td></tr>
<tr class="memdesc:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through all the attributes of this element.  <a href="#a2e80bd8d9c3421ba9d1113579f9acf47">More...</a><br /></td></tr>
<tr class="separator:a2e80bd8d9c3421ba9d1113579f9acf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65769495cad8024a3181347457516fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65769495cad8024a3181347457516fea">attribute_end</a> () const</td></tr>
<tr class="memdesc:a65769495cad8024a3181347457516fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65769495cad8024a3181347457516fea" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a> iterator indicates the end of a sequence of attributes.  <a href="#a65769495cad8024a3181347457516fea">More...</a><br /></td></tr>
<tr class="separator:a65769495cad8024a3181347457516fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Compound elements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Many elements contain child nodes, including other elements.</p>
<p>When there is just a single child <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node and no child elements, we call the element a "value element" and it is easiest to work with using the methods in the "Value elements" section. When there are child elements and/or multiple <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes, the element is called a "compound element" and you need a way to iterate and recurse through its contents. The methods in this section support looking through all contained nodes, nodes of specified types, element nodes, or element nodes with a specified tags. You can obtain handles to child Nodes or Elements and then iterate through those recursively. </p>
</div></td></tr>
<tr class="memitem:a82e8659d3e35d4becfd96a1f32f97019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a82e8659d3e35d4becfd96a1f32f97019">hasElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag) const</td></tr>
<tr class="memdesc:a82e8659d3e35d4becfd96a1f32f97019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this element has a child element with this tag.  <a href="#a82e8659d3e35d4becfd96a1f32f97019">More...</a><br /></td></tr>
<tr class="separator:a82e8659d3e35d4becfd96a1f32f97019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dfe2421ff727f96769a61459013798"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af6dfe2421ff727f96769a61459013798">hasNode</a> (<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>) const</td></tr>
<tr class="memdesc:af6dfe2421ff727f96769a61459013798"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#af6dfe2421ff727f96769a61459013798">More...</a><br /></td></tr>
<tr class="separator:af6dfe2421ff727f96769a61459013798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a1ee99cd86e3e413234c7b4bf9e2d5bf6">getRequiredElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>must</em> be present in this element.  <a href="#a1ee99cd86e3e413234c7b4bf9e2d5bf6">More...</a><br /></td></tr>
<tr class="separator:a1ee99cd86e3e413234c7b4bf9e2d5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3772785ece91bcccba9da75e89eecbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3772785ece91bcccba9da75e89eecbdd">getOptionalElement</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag)</td></tr>
<tr class="memdesc:a3772785ece91bcccba9da75e89eecbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle.  <a href="#a3772785ece91bcccba9da75e89eecbdd">More...</a><br /></td></tr>
<tr class="separator:a3772785ece91bcccba9da75e89eecbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c43f8749c9def7a0b65136e8fc1329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329">getAllElements</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr class="memdesc:af9c43f8749c9def7a0b65136e8fc1329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word).  <a href="#af9c43f8749c9def7a0b65136e8fc1329">More...</a><br /></td></tr>
<tr class="separator:af9c43f8749c9def7a0b65136e8fc1329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f0a78da097f84bf67bef22bb5b5372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a60f0a78da097f84bf67bef22bb5b5372">getAllNodes</a> (<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr class="memdesc:a60f0a78da097f84bf67bef22bb5b5372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types.  <a href="#a60f0a78da097f84bf67bef22bb5b5372">More...</a><br /></td></tr>
<tr class="separator:a60f0a78da097f84bf67bef22bb5b5372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">element_begin</a> (const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;tag=&quot;&quot;)</td></tr>
<tr class="memdesc:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied.  <a href="#a8f9e8c86fb08bd3c0ffd397e0186acb0">More...</a><br /></td></tr>
<tr class="separator:a8f9e8c86fb08bd3c0ffd397e0186acb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc2dde6804fa7658f8598251ee4dd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7fc2dde6804fa7658f8598251ee4dd8c">element_end</a> () const</td></tr>
<tr class="memdesc:a7fc2dde6804fa7658f8598251ee4dd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7fc2dde6804fa7658f8598251ee4dd8c" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used.  <a href="#a7fc2dde6804fa7658f8598251ee4dd8c">More...</a><br /></td></tr>
<tr class="separator:a7fc2dde6804fa7658f8598251ee4dd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3c5ff58a4653ffac14b19447f8c718"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">node_begin</a> (<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a> allowed=<a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a>)</td></tr>
<tr class="memdesc:a9d3c5ff58a4653ffac14b19447f8c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied.  <a href="#a9d3c5ff58a4653ffac14b19447f8c718">More...</a><br /></td></tr>
<tr class="separator:a9d3c5ff58a4653ffac14b19447f8c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600ed771a8cdfb0670556046c95a781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781">node_end</a> () const</td></tr>
<tr class="memdesc:a7600ed771a8cdfb0670556046c95a781"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used.  <a href="#a7600ed771a8cdfb0670556046c95a781">More...</a><br /></td></tr>
<tr class="separator:a7600ed771a8cdfb0670556046c95a781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Xml_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Xml_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Xml_1_1Node.html">SimTK::Xml::Node</a></td></tr>
<tr class="memitem:adb7e501cc8eec830524567e9a24569da inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#adb7e501cc8eec830524567e9a24569da">operator==</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const</td></tr>
<tr class="memdesc:adb7e501cc8eec830524567e9a24569da inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparing Nodes for equality means asking if the two <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles are referring to exactly the same object; two different nodes that happen to have the same properties will not test equal by this criteria.  <a href="classSimTK_1_1Xml_1_1Node.html#adb7e501cc8eec830524567e9a24569da">More...</a><br /></td></tr>
<tr class="separator:adb7e501cc8eec830524567e9a24569da inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd30f9be9ec59c1b10fcf0b0463a07a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#addd30f9be9ec59c1b10fcf0b0463a07a">operator!=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;other) const</td></tr>
<tr class="memdesc:addd30f9be9ec59c1b10fcf0b0463a07a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test using same criteria as <a class="el" href="classSimTK_1_1Xml_1_1Node.html#adb7e501cc8eec830524567e9a24569da" title="Comparing Nodes for equality means asking if the two Node handles are referring to exactly the same o...">operator==()</a>.  <a href="classSimTK_1_1Xml_1_1Node.html#addd30f9be9ec59c1b10fcf0b0463a07a">More...</a><br /></td></tr>
<tr class="separator:addd30f9be9ec59c1b10fcf0b0463a07a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f">Node</a> ()</td></tr>
<tr class="memdesc:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle that can be used to hold a reference to any kind of <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>.  <a href="classSimTK_1_1Xml_1_1Node.html#a6086556201f425213e56d7d35d5a770f">More...</a><br /></td></tr>
<tr class="separator:a6086556201f425213e56d7d35d5a770f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504">Node</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; that is, this handle will refer to the same node as the source.  <a href="classSimTK_1_1Xml_1_1Node.html#a37a4a32f7bcd56d7e045def2c0721504">More...</a><br /></td></tr>
<tr class="separator:a37a4a32f7bcd56d7e045def2c0721504 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ac73ad2654deb98cc0d755cedef628102">operator=</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;src)</td></tr>
<tr class="memdesc:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is shallow; the handle is first cleared and then will refer to the same node as the source.  <a href="classSimTK_1_1Xml_1_1Node.html#ac73ad2654deb98cc0d755cedef628102">More...</a><br /></td></tr>
<tr class="separator:ac73ad2654deb98cc0d755cedef628102 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77429c159c08d95e3325a30575c2dfd9 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a77429c159c08d95e3325a30575c2dfd9">clone</a> () const</td></tr>
<tr class="memdesc:a77429c159c08d95e3325a30575c2dfd9 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a77429c159c08d95e3325a30575c2dfd9" title="The clone() method makes a deep copy of this Node and its children and returns a new orphan Node with...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> with the same contents; ordinary assignment and copy construction is shallow.  <a href="classSimTK_1_1Xml_1_1Node.html#a77429c159c08d95e3325a30575c2dfd9">More...</a><br /></td></tr>
<tr class="separator:a77429c159c08d95e3325a30575c2dfd9 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741">~Node</a> ()</td></tr>
<tr class="memdesc:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle destructor does not recover heap space so if you create orphan nodes and then don't put them in a document there will be a memory leak unless you explicitly destruct them first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explicitly frees the heap space for an orphan node that was created but never inserted in...">clearOrphan()</a>.  <a href="classSimTK_1_1Xml_1_1Node.html#ae54089650958823d1a7d070cf27c1741">More...</a><br /></td></tr>
<tr class="separator:ae54089650958823d1a7d070cf27c1741 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#acc212921b30a4a7b95f339224b115b47">clear</a> ()</td></tr>
<tr class="memdesc:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method restores the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle to its default-constructed state but does not recover any heap space; use <a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8" title="This method explicitly frees the heap space for an orphan node that was created but never inserted in...">clearOrphan()</a> if you know this node was never put into a document.  <a href="classSimTK_1_1Xml_1_1Node.html#acc212921b30a4a7b95f339224b115b47">More...</a><br /></td></tr>
<tr class="separator:acc212921b30a4a7b95f339224b115b47 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8">clearOrphan</a> ()</td></tr>
<tr class="memdesc:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method explicitly frees the heap space for an orphan node that was created but never inserted into a document.  <a href="classSimTK_1_1Xml_1_1Node.html#af526ba1e54d03561336ec39eba5a3fe8">More...</a><br /></td></tr>
<tr class="separator:af526ba1e54d03561336ec39eba5a3fe8 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aac697dbcfb591fdc1789e29cd4716f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a4aac697dbcfb591fdc1789e29cd4716f">getNodeType</a> () const</td></tr>
<tr class="memdesc:a4aac697dbcfb591fdc1789e29cd4716f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc" title="The Xml::NodeType enum serves as the actual type of a node and as a filter for allowable node types d...">Xml::NodeType</a> of this node.  <a href="classSimTK_1_1Xml_1_1Node.html#a4aac697dbcfb591fdc1789e29cd4716f">More...</a><br /></td></tr>
<tr class="separator:a4aac697dbcfb591fdc1789e29cd4716f inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55604619eacbc9479665023bb6b2a91a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a55604619eacbc9479665023bb6b2a91a">getNodeTypeAsString</a> () const</td></tr>
<tr class="memdesc:a55604619eacbc9479665023bb6b2a91a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> type as a string; an empty handle returns "NoNode".  <a href="classSimTK_1_1Xml_1_1Node.html#a55604619eacbc9479665023bb6b2a91a">More...</a><br /></td></tr>
<tr class="separator:a55604619eacbc9479665023bb6b2a91a inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e1e47b8b6858e8bc1898f962db0011 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a21e1e47b8b6858e8bc1898f962db0011">isValid</a> () const</td></tr>
<tr class="memdesc:a21e1e47b8b6858e8bc1898f962db0011 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is referencing some node, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="classSimTK_1_1Xml_1_1Node.html#a21e1e47b8b6858e8bc1898f962db0011">More...</a><br /></td></tr>
<tr class="separator:a21e1e47b8b6858e8bc1898f962db0011 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4009a4dfe26312aaa5e163cf1dcd35 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a1a4009a4dfe26312aaa5e163cf1dcd35">isTopLevelNode</a> () const</td></tr>
<tr class="memdesc:a1a4009a4dfe26312aaa5e163cf1dcd35 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by the top-level <a class="el" href="namespaceSimTK_1_1Xml.html" title="This namespace contains Xml::Document and all the related XML classes. ">Xml</a> document, false if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is owned by an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> or is an orphan, or if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handle is empty.  <a href="classSimTK_1_1Xml_1_1Node.html#a1a4009a4dfe26312aaa5e163cf1dcd35">More...</a><br /></td></tr>
<tr class="separator:a1a4009a4dfe26312aaa5e163cf1dcd35 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81be72473c8d82613367af16f94dea inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aac81be72473c8d82613367af16f94dea">isOrphan</a> () const</td></tr>
<tr class="memdesc:aac81be72473c8d82613367af16f94dea inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an orphan, meaning that it is not empty, but is not owned by any element or top-level document.  <a href="classSimTK_1_1Xml_1_1Node.html#aac81be72473c8d82613367af16f94dea">More...</a><br /></td></tr>
<tr class="separator:aac81be72473c8d82613367af16f94dea inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9f1c168547cc625567f485706f99d7 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#afc9f1c168547cc625567f485706f99d7">hasParentElement</a> () const</td></tr>
<tr class="memdesc:afc9f1c168547cc625567f485706f99d7 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this node has a parent, i.e.  <a href="classSimTK_1_1Xml_1_1Node.html#afc9f1c168547cc625567f485706f99d7">More...</a><br /></td></tr>
<tr class="separator:afc9f1c168547cc625567f485706f99d7 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#aad45b2ef59c93d755edb25334f501a17">getParentElement</a> ()</td></tr>
<tr class="memdesc:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle referencing this node's parent if it has one, otherwise throws an error; check first with <a class="el" href="classSimTK_1_1Xml_1_1Node.html#afc9f1c168547cc625567f485706f99d7" title="Return true if this node has a parent, i.e. ">hasParentElement()</a> if you aren't sure.  <a href="classSimTK_1_1Xml_1_1Node.html#aad45b2ef59c93d755edb25334f501a17">More...</a><br /></td></tr>
<tr class="separator:aad45b2ef59c93d755edb25334f501a17 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97268d9b9e2ed007fc7664bbe8c726c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ab97268d9b9e2ed007fc7664bbe8c726c">getNodeText</a> () const</td></tr>
<tr class="memdesc:ab97268d9b9e2ed007fc7664bbe8c726c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a text value associated with this <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> (<em>not</em> including its child nodes if any); the behavior depends on the NodeType.  <a href="classSimTK_1_1Xml_1_1Node.html#ab97268d9b9e2ed007fc7664bbe8c726c">More...</a><br /></td></tr>
<tr class="separator:ab97268d9b9e2ed007fc7664bbe8c726c inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1540e41fcdb16788990f9d13d02ccc2 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#ac1540e41fcdb16788990f9d13d02ccc2">writeToString</a> (<a class="el" href="classSimTK_1_1String.html">String</a> &amp;out, bool compact=false) const</td></tr>
<tr class="memdesc:ac1540e41fcdb16788990f9d13d02ccc2 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this node (and everything it contains) to the given <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a>.  <a href="classSimTK_1_1Xml_1_1Node.html#ac1540e41fcdb16788990f9d13d02ccc2">More...</a><br /></td></tr>
<tr class="separator:ac1540e41fcdb16788990f9d13d02ccc2 inherit pub_methods_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion to Element from Node</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If you have a handle to a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>, such as would be returned by a <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a>, you can check whether that <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and if so cast it to one.</p>
</div></td></tr>
<tr class="memitem:a569474bd297296231c6078cc050a8521"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521">isA</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;)</td></tr>
<tr class="memdesc:a569474bd297296231c6078cc050a8521"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an element node.  <a href="#a569474bd297296231c6078cc050a8521">More...</a><br /></td></tr>
<tr class="separator:a569474bd297296231c6078cc050a8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869b394c523a22dc160a5990850457e3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a869b394c523a22dc160a5990850457e3">getAs</a> (const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a869b394c523a22dc160a5990850457e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node.  <a href="#a869b394c523a22dc160a5990850457e3">More...</a><br /></td></tr>
<tr class="separator:a869b394c523a22dc160a5990850457e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15f74e7946e1abb0026eff29803cbd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ad15f74e7946e1abb0026eff29803cbd2">getAs</a> (<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:ad15f74e7946e1abb0026eff29803cbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node.  <a href="#ad15f74e7946e1abb0026eff29803cbd2">More...</a><br /></td></tr>
<tr class="separator:ad15f74e7946e1abb0026eff29803cbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6db9d28bd448a131448276ee03de1e6d">Node</a></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e0f8cd9eaf440c228d99647a4a4f84"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#af0e0f8cd9eaf440c228d99647a4a4f84">element_iterator</a></td></tr>
<tr class="separator:af0e0f8cd9eaf440c228d99647a4a4f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa08f8230c284dd818e7808d85a4c5dad"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa08f8230c284dd818e7808d85a4c5dad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad">toXmlElement</a> (const T &amp;thing, const std::string &amp;name)</td></tr>
<tr class="memdesc:aa08f8230c284dd818e7808d85a4c5dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of serialization to an XML element for objects whose class does not define a member function <code>toXmlElement(name)</code>.  <a href="#aa08f8230c284dd818e7808d85a4c5dad">More...</a><br /></td></tr>
<tr class="separator:aa08f8230c284dd818e7808d85a4c5dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175e3a77228b244bcaa8509cb3a0570d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a175e3a77228b244bcaa8509cb3a0570d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a175e3a77228b244bcaa8509cb3a0570d">toXmlElementHelper</a> (const T &amp;thing, const std::string &amp;name, bool) -&gt; decltype(std::declval&lt; T &gt;().<a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad">toXmlElement</a>(name))</td></tr>
<tr class="memdesc:a175e3a77228b244bcaa8509cb3a0570d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> that selects the member function if it exists.  <a href="#a175e3a77228b244bcaa8509cb3a0570d">More...</a><br /></td></tr>
<tr class="separator:a175e3a77228b244bcaa8509cb3a0570d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c119082fe24b8fb7d9de80e3b37f218"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c119082fe24b8fb7d9de80e3b37f218"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a9c119082fe24b8fb7d9de80e3b37f218">toXmlElementHelper</a> (const T &amp;thing, const std::string &amp;name, int) -&gt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a></td></tr>
<tr class="memdesc:a9c119082fe24b8fb7d9de80e3b37f218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> that selects the free function if no member function exists.  <a href="#a9c119082fe24b8fb7d9de80e3b37f218">More...</a><br /></td></tr>
<tr class="separator:a9c119082fe24b8fb7d9de80e3b37f218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dcf998ba773963012d9fd24b77e629"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0dcf998ba773963012d9fd24b77e629"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629">fromXmlElement</a> (T &amp;thing, <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;elt, const std::string &amp;requiredName=&quot;&quot;)</td></tr>
<tr class="memdesc:ae0dcf998ba773963012d9fd24b77e629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of deserialization from an XML element for objects whose class does not define a member function <code>fromXmlElement(elt,name)</code>.  <a href="#ae0dcf998ba773963012d9fd24b77e629">More...</a><br /></td></tr>
<tr class="separator:ae0dcf998ba773963012d9fd24b77e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b556aa0d77009a73d6465d19119a74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a06b556aa0d77009a73d6465d19119a74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a06b556aa0d77009a73d6465d19119a74">fromXmlElementHelper</a> (T &amp;thing, <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;elt, const std::string &amp;requiredTag, bool) -&gt; decltype(std::declval&lt; T &gt;().<a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629">fromXmlElement</a>(elt, requiredTag))</td></tr>
<tr class="memdesc:a06b556aa0d77009a73d6465d19119a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> that selects the member function if it exists.  <a href="#a06b556aa0d77009a73d6465d19119a74">More...</a><br /></td></tr>
<tr class="separator:a06b556aa0d77009a73d6465d19119a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad295b614ce9358261f2a2dccad05ddc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aad295b614ce9358261f2a2dccad05ddc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aad295b614ce9358261f2a2dccad05ddc">fromXmlElementHelper</a> (T &amp;thing, <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;elt, const std::string &amp;requiredTag, int) -&gt; void</td></tr>
<tr class="memdesc:aad295b614ce9358261f2a2dccad05ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> that selects the free function if no member function exists.  <a href="#aad295b614ce9358261f2a2dccad05ddc">More...</a><br /></td></tr>
<tr class="separator:aad295b614ce9358261f2a2dccad05ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1Xml_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1Xml_1_1Node')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1Xml_1_1Node.html">SimTK::Xml::Node</a></td></tr>
<tr class="memitem:a86d7925f6bf44d44d54bab5444a068ad inherit related_classSimTK_1_1Xml_1_1Node"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;xmlNode)</td></tr>
<tr class="memdesc:a86d7925f6bf44d44d54bab5444a068ad inherit related_classSimTK_1_1Xml_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a "pretty printed" textual representation of the given XML node (and all its contents) to an std::ostream.  <a href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad">More...</a><br /></td></tr>
<tr class="separator:a86d7925f6bf44d44d54bab5444a068ad inherit related_classSimTK_1_1Xml_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of child nodes. </p>
<p>The tag word, which begins with an underscore or a letter, can serve as either the type or the name of the element depending on context. The nodes can be comments, unknowns, text, and child elements (recursively). It is common for "leaf" elements (elements with no child elements) to be supplied simply for their values, for example mass might be provided via an element "&lt;mass&gt; 29.3 &lt;/mass&gt;". We call such elements "value
elements" since they have a uniquely identifiable value similar to that of attributes. Value elements have no more than one text node. They may have attributes, and may also have comment and unknown nodes but they cannot have any child elements. This class provides a special set of methods for dealing with value nodes very conveniently; they will fail if you attempt to use them on an element that is not a value element. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace92fc2051430e6dc12eec23135bc409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace92fc2051430e6dc12eec23135bc409">&#9670;&nbsp;</a></span>Element() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle; this is suitable only for holding references to other Elements. </p>

</div>
</div>
<a id="ab436c4a5dd786608a8083cae30a93388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab436c4a5dd786608a8083cae30a93388">&#9670;&nbsp;</a></span>Element() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a value element that uses the given tag word but is not yet part of any XML document, and optionally give it an inital value. </p>
<p>Note that although you provide the initial value as a string, you can access it as any type T to which that string can be converted, using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa601a3b3b7392708f4728fe396fea6f7" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a> templatized method.</p>
<p>If no initial value is provided, then the element will be empty so would print as "&lt;tagWord /&gt;". If you provide a value (say "contents") here or add one later, it will print as "&lt;tagWord&gt;contents&lt;/tagWord&gt;". In general you can add child elements and other node types with subsequent method calls; that would change this element from a value element to a compound element. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aabc4e5c49b8b4e45f09592e4c3adcda6" title="Get the text value of this value element. ">getValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element. ">updValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element. ">setValue()</a> </dd></dl>

</div>
</div>
<a id="aeeea0c8fd0fe18efb95f2907ac055451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeea0c8fd0fe18efb95f2907ac055451">&#9670;&nbsp;</a></span>Element() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Xml::Element::Element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tagWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new value element and set its initial value to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa601a3b3b7392708f4728fe396fea6f7" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs&lt;T&gt;()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a841cd0f539fbb2b6eaa1487745320c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841cd0f539fbb2b6eaa1487745320c61">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a841cd0f539fbb2b6eaa1487745320c61" title="The clone() method makes a deep copy of this Element and its children and returns a new orphan Elemen...">clone()</a> method makes a deep copy of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> and its children and returns a new orphan <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> with the same contents; ordinary assignment and copy construction are shallow. </p>

</div>
</div>
<a id="ab1bbdc9ab6c9e66939abe218fedcc096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bbdc9ab6c9e66939abe218fedcc096">&#9670;&nbsp;</a></span>getElementTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getElementTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element tag word. </p>
<p>This may represent the name or type of the element depending on context. </p>

</div>
</div>
<a id="a6b5bf3c6e351f7dd9afa52fcff07af52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5bf3c6e351f7dd9afa52fcff07af52">&#9670;&nbsp;</a></span>setElementTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setElementTag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the tag word that is used to bracket this element. </p>

</div>
</div>
<a id="a4e79c09e3f397a48c65f40f86d113664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e79c09e3f397a48c65f40f86d113664">&#9670;&nbsp;</a></span>insertNodeBefore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::insertNodeBefore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just before the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a id="a9bdc6b7182e6308f1bd9e08c830566b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdc6b7182e6308f1bd9e08c830566b9">&#9670;&nbsp;</a></span>insertNodeAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::insertNodeAfter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node into the list of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s children, just after the node pointed to by the supplied iterator (or at the end if the iterator is <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>). </p>
<p>The iterator must refer to a node that is a child of this <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>. This <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> takes over ownership of the node which must not already have a parent. </p>

</div>
</div>
<a id="a1f65d60e9910d0e0106756d27d1a2c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f65d60e9910d0e0106756d27d1a2c11">&#9670;&nbsp;</a></span>appendNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::appendNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an abbreviation for <code>insertNodeAfter(node_end(), node);</code>. </p>

</div>
</div>
<a id="ac3822acf6439f7b502ef0d6778ede972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3822acf6439f7b502ef0d6778ede972">&#9670;&nbsp;</a></span>eraseNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::eraseNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>deleteThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the indicated node, which must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>
<p>The node will be removed from this element and deleted. The iterator is invalid after this call; be sure not to use it again. Also, there must not be any handles referencing the now-deleted node. </p>

</div>
</div>
<a id="afd5b6dd8506bfb5221631df7dad4de4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5b6dd8506bfb5221631df7dad4de4d">&#9670;&nbsp;</a></span>removeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> SimTK::Xml::Element::removeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>removeThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the indicated node from this element without erasing it, returning it as an orphan <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a>. </p>
<p>The node must be a child of this element, and must not be <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. The node will be removed from this element and returned as an orphan. The iterator is invalid after this call; be sure not to use it again. </p>

</div>
</div>
<a id="a3a5c760941e395827738881fcda726df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5c760941e395827738881fcda726df">&#9670;&nbsp;</a></span>isValueElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::isValueElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this element qualifies as a "value element", defined as an element containing zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes and no child elements. </p>
<p>You can treat a value element as you would an attribute &ndash; it can be viewed as having a single value, which is just the value of its lone <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node (or a null string if it doesn't have any text). </p>

</div>
</div>
<a id="aabc4e5c49b8b4e45f09592e4c3adcda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc4e5c49b8b4e45f09592e4c3adcda6">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the text value of this value element. </p>
<p>An error will be thrown if this is not a "value element". See the comments for this class for the definition of a "value element". </p><dl class="section note"><dt>Note</dt><dd>This does not return the same text as the base class method <a class="el" href="classSimTK_1_1Xml_1_1Node.html#ab97268d9b9e2ed007fc7664bbe8c726c" title="Return a text value associated with this Node (not including its child nodes if any); the behavior de...">Node::getNodeText()</a> does in the case of an element node; that returns the element tag word not its contents. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3a5c760941e395827738881fcda726df" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a87d99f6f31da37e122ee14dcb7281238" title="Set the text value of this value element. ">setValue()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a6fbe1243e8e2e83ceb3925659181065d" title="Obtain a writable reference to the String containing the value of this value element. ">updValue()</a> </dd></dl>

</div>
</div>
<a id="a6fbe1243e8e2e83ceb3925659181065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbe1243e8e2e83ceb3925659181065d">&#9670;&nbsp;</a></span>updValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::updValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a writable reference to the <a class="el" href="classSimTK_1_1String.html" title="SimTK::String is a plug-compatible std::string replacement (plus some additional functionality) inten...">String</a> containing the value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, one will be added to it here with a null-string value so that we can return a reference to it. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3a5c760941e395827738881fcda726df" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aabc4e5c49b8b4e45f09592e4c3adcda6" title="Get the text value of this value element. ">getValue()</a> </dd></dl>

</div>
</div>
<a id="a87d99f6f31da37e122ee14dcb7281238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d99f6f31da37e122ee14dcb7281238">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the text value of this value element. </p>
<p>An error will be thrown if this is not a value element. If the element was initially empty and didn't contain a <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node, one will be added to it here so that we have a place to hold the <em>value</em>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a3a5c760941e395827738881fcda726df" title="Determine whether this element qualifies as a &quot;value element&quot;, defined as an element containing zero ...">isValueElement()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a03fd52a31abb8f1626d7902c747b02d4" title="Set the value of this value element to the text equivalent of any type T for which a conversion const...">setValueAs&lt;T&gt;()</a> </dd></dl>

</div>
</div>
<a id="a03fd52a31abb8f1626d7902c747b02d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fd52a31abb8f1626d7902c747b02d4">&#9670;&nbsp;</a></span>setValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setValueAs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of this value element to the text equivalent of any type T for which a conversion construction String(T) is allowed (generally any type for which a stream insertion <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a86d7925f6bf44d44d54bab5444a068ad" title="Output a &quot;pretty printed&quot; textual representation of the given XML node (and all its contents) to an s...">operator&lt;&lt;()</a> exists). </p>

</div>
</div>
<a id="aa601a3b3b7392708f4728fe396fea6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa601a3b3b7392708f4728fe396fea6f7">&#9670;&nbsp;</a></span>getValueAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getValueAs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming this is a "value element", convert its text value to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cd5c3247ff45af5f8ad0083d3122bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd5c3247ff45af5f8ad0083d3122bac">&#9670;&nbsp;</a></span>getValueAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::getValueAs </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate form of <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa601a3b3b7392708f4728fe396fea6f7" title="Assuming this is a &quot;value element&quot;, convert its text value to the type of the template argument T...">getValueAs()</a> that avoids unnecessary copying and heap allocation for reading in large container objects. </p>

</div>
</div>
<a id="a6ae270392614f6ec8d7d6d58c5572fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae270392614f6ec8d7d6d58c5572fca">&#9670;&nbsp;</a></span>getRequiredElementValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getRequiredElementValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text value of a child value element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one this refers to the first one. Then the element is expected to contain either zero or one <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> nodes; if none we'll return a null string, otherwise the value of the <a class="el" href="classSimTK_1_1Xml_1_1Text.html" title="This is the &quot;leaf&quot; content of an element. ">Text</a> node. Thus an element like "&lt;tag&gt;stuff&lt;/tag&gt;" will have the value "stuff". An error will be thrown if either the element is not found or it is not a "value element". </p>

</div>
</div>
<a id="af298fef4266524b814feaf9002719d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af298fef4266524b814feaf9002719d0e">&#9670;&nbsp;</a></span>getOptionalElementValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::Element::getOptionalElementValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the text value of a child value element that <em>may</em> be present in this element, otherwise return a default string. </p>
<p>If the child element is found, it must be a "value element" as defined above. </p>

</div>
</div>
<a id="a147fe5ad38e20d3fb21d5442dd7d559f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147fe5ad38e20d3fb21d5442dd7d559f">&#9670;&nbsp;</a></span>getRequiredElementValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getRequiredElementValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of a required child value element to the type of the template argument T. </p>
<p>It is an error if the element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the required child text element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the text element, converted to an object of type T. </dd></dl>

</div>
</div>
<a id="a12946c49aa16236c16083fff539f4347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12946c49aa16236c16083fff539f4347">&#9670;&nbsp;</a></span>getOptionalElementValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getOptionalElementValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of an optional child value element, if present, to the type of the template argument T. </p>
<p>It is an error if the child element is present but is not a value element, or if the text cannot be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vector or Array.) If the child element is not present, then return a supplied default value of type T. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag of the optional child element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if child element is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of element <em>tag</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a id="abdcdc6686359597350b9c45cf7a58df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcdc6686359597350b9c45cf7a58df1">&#9670;&nbsp;</a></span>hasAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this element has an attribute of this name. </p>

</div>
</div>
<a id="a8c04ffb38dc3e908fd559c7c542ad559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c04ffb38dc3e908fd559c7c542ad559">&#9670;&nbsp;</a></span>setAttributeValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::setAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an attribute of this element, creating a new one if this is a new attribute name otherwise modifying an existing one. </p>

</div>
</div>
<a id="a03e4d7a877ad3a514412e78e3efc6ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e4d7a877ad3a514412e78e3efc6ce7">&#9670;&nbsp;</a></span>eraseAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::Xml::Element::eraseAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase an attribute of this element if it exists, otherwise do nothing. </p>
<p>If you need to know if the attribute exists, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#abdcdc6686359597350b9c45cf7a58df1" title="Return true if this element has an attribute of this name. ">hasAttribute()</a>. There is no removeAttribute() that orphans an existing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a>, but you can easily recreate one with the same name and value. </p>

</div>
</div>
<a id="a63a3d47972f939413d56e2a2302bf53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a3d47972f939413d56e2a2302bf53a">&#9670;&nbsp;</a></span>getRequiredAttributeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1String.html">String</a>&amp; SimTK::Xml::Element::getRequiredAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an attribute as a string and throw an error if that attribute is not present. </p>

</div>
</div>
<a id="ac522c5cb6ede0937ea65f50d2192dce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac522c5cb6ede0937ea65f50d2192dce4">&#9670;&nbsp;</a></span>getRequiredAttributeValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getRequiredAttributeValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the text value of a required attribute to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream using the "&gt;&gt;" operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2bbdb5a09cec23f14f7ec800e2ded7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2bbdb5a09cec23f14f7ec800e2ded7">&#9670;&nbsp;</a></span>getOptionalAttributeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1String.html">String</a> SimTK::Xml::Element::getOptionalAttributeValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of an attribute as a string if the attribute is present in this element, otherwise return a supplied default value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The string to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default string <em>def</em>. </dd></dl>

</div>
</div>
<a id="a9056e773edb5dcf7bb87a545053189d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9056e773edb5dcf7bb87a545053189d9">&#9670;&nbsp;</a></span>getOptionalAttributeValueAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SimTK::Xml::Element::getOptionalAttributeValueAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the value of an optional attribute, if present, from a string to the type of the template argument T. </p>
<p>It is an error if the text can not be converted, in its entirety, to a single object of type T. (But note that type T may be a container of some sort, like a Vec3.) If the attribute is not present, then return a supplied default value of type T. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that can be read from a stream with operator "&gt;&gt;". </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the optional attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">def</td><td>The value of type T to return if the attribute is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of attribute <em>name</em> if it is present, otherwise a copy of the supplied default value <em>def</em>. </dd></dl>

</div>
</div>
<a id="ad904c330f4cec26a4e5793bed0441445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad904c330f4cec26a4e5793bed0441445">&#9670;&nbsp;</a></span>getRequiredAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> SimTK::Xml::Element::getRequiredAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element; an error will be thrown if no such attribute is present. </p>

</div>
</div>
<a id="aacd827d22b75b6202b7461b2ab90ddeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd827d22b75b6202b7461b2ab90ddeb">&#9670;&nbsp;</a></span>getOptionalAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a> SimTK::Xml::Element::getOptionalAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handle referencing a particular attribute of this element specified by name, or an empty handle if no such attribute is present. </p>

</div>
</div>
<a id="a34d797fd21a8b3d851616dc8d00241a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d797fd21a8b3d851616dc8d00241a6">&#9670;&nbsp;</a></span>getAllAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Attribute.html">Attribute</a>&gt; SimTK::Xml::Element::getAllAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> handles referencing all the attributes of this element. </p>
<p>Attributes are returned in the order that they appear in the element tag. <a class="el" href="classSimTK_1_1Xml_1_1Attribute.html" title="Elements can have attributes, which are name=&quot;value&quot; pairs that appear within the element start tag i...">Attribute</a> names within a tag are unique; if the source document had repeated attribute names only the last one to appear is retained and that's the only one we'll find here. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Attribute&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a2e80bd8d9c3421ba9d1113579f9acf47">attribute_begin</a>(), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a65769495cad8024a3181347457516fea">attribute_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a2e80bd8d9c3421ba9d1113579f9acf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e80bd8d9c3421ba9d1113579f9acf47">&#9670;&nbsp;</a></span>attribute_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> SimTK::Xml::Element::attribute_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through all the attributes of this element. </p>
<p>If there are no attributes then the returned <a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Attributes ...">attribute_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65769495cad8024a3181347457516fea" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a>. </p>

</div>
</div>
<a id="a65769495cad8024a3181347457516fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65769495cad8024a3181347457516fea">&#9670;&nbsp;</a></span>attribute_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1attribute__iterator.html">attribute_iterator</a> SimTK::Xml::Element::attribute_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a65769495cad8024a3181347457516fea" title="This attribute_end() iterator indicates the end of a sequence of attributes. ">attribute_end()</a> iterator indicates the end of a sequence of attributes. </p>

</div>
</div>
<a id="a82e8659d3e35d4becfd96a1f32f97019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e8659d3e35d4becfd96a1f32f97019">&#9670;&nbsp;</a></span>hasElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this element has a child element with this tag. </p>

</div>
</div>
<a id="af6dfe2421ff727f96769a61459013798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dfe2421ff727f96769a61459013798">&#9670;&nbsp;</a></span>hasNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::Xml::Element::hasNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if this element has any child nodes, or any child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>

</div>
</div>
<a id="a1ee99cd86e3e413234c7b4bf9e2d5bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee99cd86e3e413234c7b4bf9e2d5bf6">&#9670;&nbsp;</a></span>getRequiredElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::getRequiredElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to a child element that <em>must</em> be present in this element. </p>
<p>The child is identified by its tag; if there is more than one only the first one is returned. If you want to see all children with this tag, use <a class="el" href="classSimTK_1_1Xml_1_1Element.html#af9c43f8749c9def7a0b65136e8fc1329" title="Return an array containing Element handles referencing all the immediate child elements contained in ...">getAllElements()</a> or use an <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a>. </p>

</div>
</div>
<a id="a3772785ece91bcccba9da75e89eecbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3772785ece91bcccba9da75e89eecbdd">&#9670;&nbsp;</a></span>getOptionalElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a> SimTK::Xml::Element::getOptionalElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to a child element that <em>may</em> be present in this element; otherwise return an invalid <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handle. </p>
<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> using the <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>'s <a class="el" href="classSimTK_1_1Xml_1_1Node.html#a21e1e47b8b6858e8bc1898f962db0011" title="Return true if this Node handle is referencing some node, false if the Node handle is empty...">isValid()</a> method. </p>

</div>
</div>
<a id="af9c43f8749c9def7a0b65136e8fc1329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c43f8749c9def7a0b65136e8fc1329">&#9670;&nbsp;</a></span>getAllElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&gt; SimTK::Xml::Element::getAllElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a> handles referencing all the immediate child elements contained in this element, or all the child elements of a particular type (that is, with a given tag word). </p>
<p>Elements are returned in the order they are seen in the document. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Element&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a8f9e8c86fb08bd3c0ffd397e0186acb0">element_begin</a>(tag), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a7fc2dde6804fa7658f8598251ee4dd8c">element_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a60f0a78da097f84bf67bef22bb5b5372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f0a78da097f84bf67bef22bb5b5372">&#9670;&nbsp;</a></span>getAllNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a>&gt; SimTK::Xml::Element::getAllNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array containing <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> handles referencing all the immediate child nodes contained in this element, or all the child nodes of a particular type or types. </p>
<p>Nodes are returned in the order they are seen in the document. This is just a shortcut for</p><div class="fragment"><div class="line">Array_&lt;Node&gt;(<a class="code" href="classSimTK_1_1Xml_1_1Element.html#a9d3c5ff58a4653ffac14b19447f8c718">node_begin</a>(allowed), <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781">node_end</a>());</div></div><!-- fragment --> 
</div>
</div>
<a id="a8f9e8c86fb08bd3c0ffd397e0186acb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9e8c86fb08bd3c0ffd397e0186acb0">&#9670;&nbsp;</a></span>element_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> SimTK::Xml::Element::element_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through the immediate child elements of this element, or the child elements that have the indicated tag if one is supplied. </p>
<p>If there are no children with the <em>allowed</em> tag then the returned <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Element nod...">element_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7fc2dde6804fa7658f8598251ee4dd8c" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a>. </p>

</div>
</div>
<a id="a7fc2dde6804fa7658f8598251ee4dd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc2dde6804fa7658f8598251ee4dd8c">&#9670;&nbsp;</a></span>element_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a> SimTK::Xml::Element::element_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7fc2dde6804fa7658f8598251ee4dd8c" title="This element_end() iterator indicates the end of any sequence of elements regardless of the tag restr...">element_end()</a> iterator indicates the end of any sequence of elements regardless of the tag restriction on the iterator being used. </p>

</div>
</div>
<a id="a9d3c5ff58a4653ffac14b19447f8c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3c5ff58a4653ffac14b19447f8c718">&#9670;&nbsp;</a></span>node_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::Element::node_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bc">NodeType</a>&#160;</td>
          <td class="paramname"><em>allowed</em> = <code><a class="el" href="namespaceSimTK_1_1Xml.html#a7a166f7c2fb7f77beb467f74b3f766bca3c0570f6f18060a4551d3c183e91bbc0">AnyNodes</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For iterating through the immediate child nodes of this element, or the child nodes of the type(s) allowed by the NodeType filter if one is supplied. </p>
<p>If there are no children of the <em>allowed</em> types then the returned <a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html" title="This is a bidirectional iterator suitable for moving forward or backward within a list of Nodes...">node_iterator</a> tests equal to <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a>. </p>

</div>
</div>
<a id="a7600ed771a8cdfb0670556046c95a781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600ed771a8cdfb0670556046c95a781">&#9670;&nbsp;</a></span>node_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1node__iterator.html">node_iterator</a> SimTK::Xml::Element::node_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classSimTK_1_1Xml_1_1Element.html#a7600ed771a8cdfb0670556046c95a781" title="This node_end() iterator indicates the end of any sequence of nodes regardless of the NodeType restri...">node_end()</a> iterator indicates the end of any sequence of nodes regardless of the NodeType restriction on the iterator being used. </p>

</div>
</div>
<a id="a569474bd297296231c6078cc050a8521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569474bd297296231c6078cc050a8521">&#9670;&nbsp;</a></span>isA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SimTK::Xml::Element::isA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classSimTK_1_1Test.html" title="This is the main class to support testing. ">Test</a> whether a given <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is an element node. </p>

</div>
</div>
<a id="a869b394c523a22dc160a5990850457e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869b394c523a22dc160a5990850457e3">&#9670;&nbsp;</a></span>getAs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; SimTK::Xml::Element::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast a <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a const <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node. ">isA()</a> </dd></dl>

</div>
</div>
<a id="ad15f74e7946e1abb0026eff29803cbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15f74e7946e1abb0026eff29803cbd2">&#9670;&nbsp;</a></span>getAs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a>&amp; SimTK::Xml::Element::getAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recast a writable <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> to a writable <a class="el" href="classSimTK_1_1Xml_1_1Element.html" title="An element has (1) a tagword, (2) a map of (name,value) pairs called attributes, and (3) a list of ch...">Element</a>, throwing an error if the <a class="el" href="classSimTK_1_1Xml_1_1Node.html" title="Abstract handle for holding any kind of node in an XML tree. ">Node</a> is not actually an element node. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a569474bd297296231c6078cc050a8521" title="Test whether a given Node is an element node. ">isA()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6db9d28bd448a131448276ee03de1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9d28bd448a131448276ee03de1e6d">&#9670;&nbsp;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1Node.html">Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0e0f8cd9eaf440c228d99647a4a4f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e0f8cd9eaf440c228d99647a4a4f84">&#9670;&nbsp;</a></span>element_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1Xml_1_1element__iterator.html">element_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa08f8230c284dd818e7808d85a4c5dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f8230c284dd818e7808d85a4c5dad">&#9670;&nbsp;</a></span>toXmlElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> toXmlElement </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of serialization to an XML element for objects whose class does not define a member function <code>toXmlElement(name)</code>. </p>
<p>A name can be provided for this value; by default that will be used as the element's tag word so make sure it is a legal XML tag. If <code>name</code> is empty we'll use <code>&lt;value&gt;</code> as the tag. This default implementation uses Simbody's stream serialization method <code><a class="el" href="group__writeUnformatted.html#gaae02786573d73eb2fcdb5e552a6fa891" title="The default implementation of writeUnformatted&lt;T&gt; converts the object to a String using the templatiz...">SimTK::writeUnformatted</a>&lt;T&gt;()</code>. Specialize this free function or provide a member function if that doesn't provide the behavior you want.</p>
<p>If type <code>T</code> provides a member function or specialization of this method, it may choose any tag word, in which case the given name if any should be added as an attribute <code>name="name"</code> ("value" is not used in that case if <code>name</code> is empty).</p>
<p>A helper function <code>toXmlElementHelper&lt;T&gt;</code> is available for invoking the member function <code>T::toXmlElement()</code> if it exists, otherwise the appropriate specialization of this free function. Invoke the helper like this: </p><div class="fragment"><div class="line">Xml::Element e = <a class="code" href="classSimTK_1_1Xml_1_1Element.html#a175e3a77228b244bcaa8509cb3a0570d">toXmlElementHelper</a>(T, <span class="stringliteral">&quot;name&quot;</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p> The third parameter <code>true</code> is a dummy that allows prioritization of the member function over the free function if both exist, using SFINAE. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a175e3a77228b244bcaa8509cb3a0570d" title="Helper function for toXmlElement() that selects the member function if it exists. ...">toXmlElementHelper()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> </dd></dl>

</div>
</div>
<a id="a175e3a77228b244bcaa8509cb3a0570d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175e3a77228b244bcaa8509cb3a0570d">&#9670;&nbsp;</a></span>toXmlElementHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto toXmlElementHelper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;T&gt;().<a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad">toXmlElement</a>(name)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> that selects the member function if it exists. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> </dd></dl>

</div>
</div>
<a id="a9c119082fe24b8fb7d9de80e3b37f218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c119082fe24b8fb7d9de80e3b37f218">&#9670;&nbsp;</a></span>toXmlElementHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto toXmlElementHelper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> that selects the free function if no member function exists. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> </dd></dl>

</div>
</div>
<a id="ae0dcf998ba773963012d9fd24b77e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dcf998ba773963012d9fd24b77e629">&#9670;&nbsp;</a></span>fromXmlElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fromXmlElement </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>requiredName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of deserialization from an XML element for objects whose class does not define a member function <code>fromXmlElement(elt,name)</code>. </p>
<p>The name is optional but if provided then we require that the given element has that name. For this default implementation, we'll expect the element's tag word to be the given name; specializations or member functions are free to use a different tag with the name as an attribute.</p>
<p>This default implementation uses Simbody's stream deserialization method <code><a class="el" href="group__readFromStream.html#ga64e0c2535ba54f956b015cd371914e69" title="The default implementation of readUnformatted&lt;T&gt; reads in the next whitespace-separated token and the...">SimTK::readUnformatted</a>&lt;T&gt;()</code>. Specialize this free function or provide a member function if that doesn't provide the behavior you want.</p>
<p>A helper function <code>fromXmlElementHelper&lt;T&gt;</code> is available for invoking the member function <code>T::fromXmlElement()</code> if it exists, otherwise the appropriate specialization of this free function. Invoke the helper like this: </p><div class="fragment"><div class="line"><a class="code" href="classSimTK_1_1Xml_1_1Element.html#a06b556aa0d77009a73d6465d19119a74">fromXmlElementHelper</a>(T, element, <span class="stringliteral">&quot;requiredName&quot;</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><p> The last parameter <code>true</code> is a dummy that allows prioritization of the member function over the free function if both exist, using SFINAE. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#a06b556aa0d77009a73d6465d19119a74" title="Helper function for fromXmlElement() that selects the member function if it exists. ">fromXmlElementHelper()</a>, <a class="el" href="classSimTK_1_1Xml_1_1Element.html#aa08f8230c284dd818e7808d85a4c5dad" title="Default implementation of serialization to an XML element for objects whose class does not define a m...">toXmlElement()</a> </dd></dl>

</div>
</div>
<a id="a06b556aa0d77009a73d6465d19119a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b556aa0d77009a73d6465d19119a74">&#9670;&nbsp;</a></span>fromXmlElementHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto fromXmlElementHelper </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>requiredTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::declval&lt;T&gt;().<a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629">fromXmlElement</a>(elt,requiredTag)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> that selects the member function if it exists. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> </dd></dl>

</div>
</div>
<a id="aad295b614ce9358261f2a2dccad05ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad295b614ce9358261f2a2dccad05ddc">&#9670;&nbsp;</a></span>fromXmlElementHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto fromXmlElementHelper </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> &amp;&#160;</td>
          <td class="paramname"><em>elt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>requiredTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> that selects the free function if no member function exists. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Xml_1_1Element.html#ae0dcf998ba773963012d9fd24b77e629" title="Default implementation of deserialization from an XML element for objects whose class does not define...">fromXmlElement()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="namespaceSimTK_1_1Xml.html">Xml</a></li><li class="navelem"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Element</a></li>
    <li class="footer">Generated on Fri Dec 6 2019 17:28:09 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
