<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::ClonePtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1ClonePtr.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1ClonePtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ClonePtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Smart pointer with deep copy semantics.  
 <a href="classSimTK_1_1ClonePtr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a16a8c3a419862297520e74155fd4c0e5"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a16a8c3a419862297520e74155fd4c0e5">element_type</a></td></tr>
<tr class="memdesc:a16a8c3a419862297520e74155fd4c0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the contained object.  <a href="#a16a8c3a419862297520e74155fd4c0e5">More...</a><br /></td></tr>
<tr class="separator:a16a8c3a419862297520e74155fd4c0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e6d3d76470b070d45a3a4beef31d02"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#af3e6d3d76470b070d45a3a4beef31d02">pointer</a></td></tr>
<tr class="memdesc:af3e6d3d76470b070d45a3a4beef31d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the contained object.  <a href="#af3e6d3d76470b070d45a3a4beef31d02">More...</a><br /></td></tr>
<tr class="separator:af3e6d3d76470b070d45a3a4beef31d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c11fa076622a78c3fb373127fab6be9"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a2c11fa076622a78c3fb373127fab6be9">reference</a></td></tr>
<tr class="memdesc:a2c11fa076622a78c3fb373127fab6be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a reference to the contained object.  <a href="#a2c11fa076622a78c3fb373127fab6be9">More...</a><br /></td></tr>
<tr class="separator:a2c11fa076622a78c3fb373127fab6be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a3aae1c0efd169ce7d28dc7a9d30c1847"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a3aae1c0efd169ce7d28dc7a9d30c1847">ClonePtr</a> () noexcept</td></tr>
<tr class="memdesc:a3aae1c0efd169ce7d28dc7a9d30c1847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor stores a <code>nullptr</code>.  <a href="#a3aae1c0efd169ce7d28dc7a9d30c1847">More...</a><br /></td></tr>
<tr class="separator:a3aae1c0efd169ce7d28dc7a9d30c1847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93eedabe424e5faee23d6e5ce265fc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ac93eedabe424e5faee23d6e5ce265fc8">ClonePtr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:ac93eedabe424e5faee23d6e5ce265fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from <code>nullptr</code> is the same as the default constructor.  <a href="#ac93eedabe424e5faee23d6e5ce265fc8">More...</a><br /></td></tr>
<tr class="separator:ac93eedabe424e5faee23d6e5ce265fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eeda0396038a4422380ccf60753c20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a32eeda0396038a4422380ccf60753c20">ClonePtr</a> (T *x) noexcept</td></tr>
<tr class="memdesc:a32eeda0396038a4422380ccf60753c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a writable heap-allocated object, take over ownership of that object.  <a href="#a32eeda0396038a4422380ccf60753c20">More...</a><br /></td></tr>
<tr class="separator:a32eeda0396038a4422380ccf60753c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70247203e537823ee66f812966b360e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a70247203e537823ee66f812966b360e2">ClonePtr</a> (const T *x)</td></tr>
<tr class="memdesc:a70247203e537823ee66f812966b360e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pointer to a read-only object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this ClonePtr the owner of the copy.  <a href="#a70247203e537823ee66f812966b360e2">More...</a><br /></td></tr>
<tr class="separator:a70247203e537823ee66f812966b360e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f63bd5f21bcf7eb49132bc4368f2c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ae3f63bd5f21bcf7eb49132bc4368f2c0">ClonePtr</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae3f63bd5f21bcf7eb49132bc4368f2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a read-only reference to an object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this ClonePtr object the owner of the copy.  <a href="#ae3f63bd5f21bcf7eb49132bc4368f2c0">More...</a><br /></td></tr>
<tr class="separator:ae3f63bd5f21bcf7eb49132bc4368f2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b633793d04bd8e3701c0cb888b263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a4e3b633793d04bd8e3701c0cb888b263">ClonePtr</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;src)</td></tr>
<tr class="memdesc:a4e3b633793d04bd8e3701c0cb888b263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deep; the new ClonePtr object contains a new copy of the object in the source, created via the source object's <code>clone()</code> method.  <a href="#a4e3b633793d04bd8e3701c0cb888b263">More...</a><br /></td></tr>
<tr class="separator:a4e3b633793d04bd8e3701c0cb888b263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd6086ffaedae659098492e923c8b5"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a31fd6086ffaedae659098492e923c8b5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a31fd6086ffaedae659098492e923c8b5">ClonePtr</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;src)</td></tr>
<tr class="memdesc:a31fd6086ffaedae659098492e923c8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy construction from a compatible ClonePtr.  <a href="#a31fd6086ffaedae659098492e923c8b5">More...</a><br /></td></tr>
<tr class="separator:a31fd6086ffaedae659098492e923c8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dc6e4fe805d378df3edaa2da6a75e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a57dc6e4fe805d378df3edaa2da6a75e0">ClonePtr</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a57dc6e4fe805d378df3edaa2da6a75e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor is very fast and leaves the source empty.  <a href="#a57dc6e4fe805d378df3edaa2da6a75e0">More...</a><br /></td></tr>
<tr class="separator:a57dc6e4fe805d378df3edaa2da6a75e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837fac238af5655472435a724a7c1954"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a837fac238af5655472435a724a7c1954"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a837fac238af5655472435a724a7c1954">ClonePtr</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a837fac238af5655472435a724a7c1954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction from a compatible ClonePtr.  <a href="#a837fac238af5655472435a724a7c1954">More...</a><br /></td></tr>
<tr class="separator:a837fac238af5655472435a724a7c1954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:a22bbaeb1d5cb2a7358d0be7f66bf5a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a22bbaeb1d5cb2a7358d0be7f66bf5a85">operator=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;src)</td></tr>
<tr class="memdesc:a22bbaeb1d5cb2a7358d0be7f66bf5a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment replaces the currently-held object by a copy of the object held in the source container, created using the source object's <code>clone()</code> method.  <a href="#a22bbaeb1d5cb2a7358d0be7f66bf5a85">More...</a><br /></td></tr>
<tr class="separator:a22bbaeb1d5cb2a7358d0be7f66bf5a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a18eb9a33bac15ba85ffa437a09189"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:ad5a18eb9a33bac15ba85ffa437a09189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ad5a18eb9a33bac15ba85ffa437a09189">operator=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;src)</td></tr>
<tr class="memdesc:ad5a18eb9a33bac15ba85ffa437a09189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment from a compatible ClonePtr.  <a href="#ad5a18eb9a33bac15ba85ffa437a09189">More...</a><br /></td></tr>
<tr class="separator:ad5a18eb9a33bac15ba85ffa437a09189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc28ba826ef6377dfaab55ab096a5cbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#adc28ba826ef6377dfaab55ab096a5cbb">operator=</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:adc28ba826ef6377dfaab55ab096a5cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment replaces the currently-held object by the source object, leaving the source empty.  <a href="#adc28ba826ef6377dfaab55ab096a5cbb">More...</a><br /></td></tr>
<tr class="separator:adc28ba826ef6377dfaab55ab096a5cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69dbeab4a237f73fd1c58223c2b49e33"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a69dbeab4a237f73fd1c58223c2b49e33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a69dbeab4a237f73fd1c58223c2b49e33">operator=</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a69dbeab4a237f73fd1c58223c2b49e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment from a compatible ClonePtr replaces the currently-held object by the source object, leaving the source empty.  <a href="#a69dbeab4a237f73fd1c58223c2b49e33">More...</a><br /></td></tr>
<tr class="separator:a69dbeab4a237f73fd1c58223c2b49e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c90ffac1ab535129b0b80716266766d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a3c90ffac1ab535129b0b80716266766d">operator=</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a3c90ffac1ab535129b0b80716266766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its <code>clone()</code> method.  <a href="#a3c90ffac1ab535129b0b80716266766d">More...</a><br /></td></tr>
<tr class="separator:a3c90ffac1ab535129b0b80716266766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf873e65e4b2287b01b7469a5932e7ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#abf873e65e4b2287b01b7469a5932e7ad">operator=</a> (T *x) noexcept</td></tr>
<tr class="memdesc:abf873e65e4b2287b01b7469a5932e7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object.  <a href="#abf873e65e4b2287b01b7469a5932e7ad">More...</a><br /></td></tr>
<tr class="separator:abf873e65e4b2287b01b7469a5932e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a6d23dacf600ff5deb5bc9863a221cf3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a6d23dacf600ff5deb5bc9863a221cf3d">~ClonePtr</a> () noexcept</td></tr>
<tr class="memdesc:a6d23dacf600ff5deb5bc9863a221cf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor deletes the contained object.  <a href="#a6d23dacf600ff5deb5bc9863a221cf3d">More...</a><br /></td></tr>
<tr class="separator:a6d23dacf600ff5deb5bc9863a221cf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr class="memitem:a24a317bf44ba0d02d8e32b587fa9c5a7"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7">get</a> () const noexcept</td></tr>
<tr class="memdesc:a24a317bf44ba0d02d8e32b587fa9c5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the contained object if any, or <code>nullptr</code>.  <a href="#a24a317bf44ba0d02d8e32b587fa9c5a7">More...</a><br /></td></tr>
<tr class="separator:a24a317bf44ba0d02d8e32b587fa9c5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9aa41fb20bdfad61ef6ec2f3c50022"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022">upd</a> () noexcept</td></tr>
<tr class="memdesc:adf9aa41fb20bdfad61ef6ec2f3c50022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the contained object if any, or <code>nullptr</code>.  <a href="#adf9aa41fb20bdfad61ef6ec2f3c50022">More...</a><br /></td></tr>
<tr class="separator:adf9aa41fb20bdfad61ef6ec2f3c50022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3309ea0c04bcaf42b42253b6a60c946d"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a3309ea0c04bcaf42b42253b6a60c946d">getRef</a> () const</td></tr>
<tr class="memdesc:a3309ea0c04bcaf42b42253b6a60c946d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the contained object.  <a href="#a3309ea0c04bcaf42b42253b6a60c946d">More...</a><br /></td></tr>
<tr class="separator:a3309ea0c04bcaf42b42253b6a60c946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d49dd7e39d9f503da3e73dd34f5d809"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a5d49dd7e39d9f503da3e73dd34f5d809">updRef</a> ()</td></tr>
<tr class="memdesc:a5d49dd7e39d9f503da3e73dd34f5d809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the contained object.  <a href="#a5d49dd7e39d9f503da3e73dd34f5d809">More...</a><br /></td></tr>
<tr class="separator:a5d49dd7e39d9f503da3e73dd34f5d809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a0613fd71240a07b0e2e8e5ac2b2f"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ac78a0613fd71240a07b0e2e8e5ac2b2f">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:ac78a0613fd71240a07b0e2e8e5ac2b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a const pointer to the contained object.  <a href="#ac78a0613fd71240a07b0e2e8e5ac2b2f">More...</a><br /></td></tr>
<tr class="separator:ac78a0613fd71240a07b0e2e8e5ac2b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb43d4dc23ac327ec89c038192c8c6a6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#abb43d4dc23ac327ec89c038192c8c6a6">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:abb43d4dc23ac327ec89c038192c8c6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a writable pointer to the contained object.  <a href="#abb43d4dc23ac327ec89c038192c8c6a6">More...</a><br /></td></tr>
<tr class="separator:abb43d4dc23ac327ec89c038192c8c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619d08afc55e34c347506b4c1307b01b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a619d08afc55e34c347506b4c1307b01b">operator*</a> () const</td></tr>
<tr class="memdesc:a619d08afc55e34c347506b4c1307b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This "dereference" operator returns a const reference to the contained object.  <a href="#a619d08afc55e34c347506b4c1307b01b">More...</a><br /></td></tr>
<tr class="separator:a619d08afc55e34c347506b4c1307b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a4b7dd6f8f65a7055f9a19e919e8b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ac19a4b7dd6f8f65a7055f9a19e919e8b">operator*</a> ()</td></tr>
<tr class="memdesc:ac19a4b7dd6f8f65a7055f9a19e919e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the contained object.  <a href="#ac19a4b7dd6f8f65a7055f9a19e919e8b">More...</a><br /></td></tr>
<tr class="separator:ac19a4b7dd6f8f65a7055f9a19e919e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Methods</div></td></tr>
<tr class="memitem:aa074503ce254b1511b46de610048943b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#aa074503ce254b1511b46de610048943b">reset</a> () noexcept</td></tr>
<tr class="memdesc:aa074503ce254b1511b46de610048943b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this container empty if it isn't already, destructing the contained object if there is one.  <a href="#aa074503ce254b1511b46de610048943b">More...</a><br /></td></tr>
<tr class="separator:aa074503ce254b1511b46de610048943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f0d5c9d4e0ca380802a72cb931684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ab54f0d5c9d4e0ca380802a72cb931684">reset</a> (T *x) noexcept</td></tr>
<tr class="memdesc:ab54f0d5c9d4e0ca380802a72cb931684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the contents of this container with the supplied heap-allocated object, taking over ownership of that object and deleting the current one first if necessary.  <a href="#ab54f0d5c9d4e0ca380802a72cb931684">More...</a><br /></td></tr>
<tr class="separator:ab54f0d5c9d4e0ca380802a72cb931684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2e0549265c9eaefa3e661d284bf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a6de2e0549265c9eaefa3e661d284bf72">swap</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a6de2e0549265c9eaefa3e661d284bf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this ClonePtr with another one, with ownership changing hands but no copying performed.  <a href="#a6de2e0549265c9eaefa3e661d284bf72">More...</a><br /></td></tr>
<tr class="separator:a6de2e0549265c9eaefa3e661d284bf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835a4da50cb9a05983a70207063807b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a835a4da50cb9a05983a70207063807b8">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a835a4da50cb9a05983a70207063807b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations.  <a href="#a835a4da50cb9a05983a70207063807b8">More...</a><br /></td></tr>
<tr class="separator:a835a4da50cb9a05983a70207063807b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a958e36ecdc25629402336b2f9a3311"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a5a958e36ecdc25629402336b2f9a3311">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a5a958e36ecdc25629402336b2f9a3311"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a conversion to type bool that returns true if the container is non-null (that is, not empty).  <a href="#a5a958e36ecdc25629402336b2f9a3311">More...</a><br /></td></tr>
<tr class="separator:a5a958e36ecdc25629402336b2f9a3311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99328b36a77ef7d50391cbc0432cdeef"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a99328b36a77ef7d50391cbc0432cdeef">release</a> () noexcept</td></tr>
<tr class="memdesc:a99328b36a77ef7d50391cbc0432cdeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the contained object from management by this container and transfer ownership to the caller.  <a href="#a99328b36a77ef7d50391cbc0432cdeef">More...</a><br /></td></tr>
<tr class="separator:a99328b36a77ef7d50391cbc0432cdeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490297697bb49686c5ee98c44b1660d1"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a490297697bb49686c5ee98c44b1660d1">getPtr</a> () const noexcept</td></tr>
<tr class="memdesc:a490297697bb49686c5ee98c44b1660d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Same as <code><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a></code>.  <a href="#a490297697bb49686c5ee98c44b1660d1">More...</a><br /></td></tr>
<tr class="separator:a490297697bb49686c5ee98c44b1660d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa5c148ade2beaa167cc5acd205fe8"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a02aa5c148ade2beaa167cc5acd205fe8">updPtr</a> () noexcept</td></tr>
<tr class="memdesc:a02aa5c148ade2beaa167cc5acd205fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Same as <code><a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a></code>.  <a href="#a02aa5c148ade2beaa167cc5acd205fe8">More...</a><br /></td></tr>
<tr class="separator:a02aa5c148ade2beaa167cc5acd205fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572650d3ccd620ac55c0e4d9757a37bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a572650d3ccd620ac55c0e4d9757a37bb">clear</a> () noexcept</td></tr>
<tr class="memdesc:a572650d3ccd620ac55c0e4d9757a37bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ClonePtr.html#aa074503ce254b1511b46de610048943b" title="Make this container empty if it isn&#39;t already, destructing the contained object if there is one...">reset()</a> instead.  <a href="#a572650d3ccd620ac55c0e4d9757a37bb">More...</a><br /></td></tr>
<tr class="separator:a572650d3ccd620ac55c0e4d9757a37bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a614e5d746a1a997cac03e1dc5c36a00f"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a614e5d746a1a997cac03e1dc5c36a00f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a614e5d746a1a997cac03e1dc5c36a00f">ClonePtr</a></td></tr>
<tr class="separator:a614e5d746a1a997cac03e1dc5c36a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a45be263cd7780f61a10ee03506146eda"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a45be263cd7780f61a10ee03506146eda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a45be263cd7780f61a10ee03506146eda">swap</a> (<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;p1, <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;p2) noexcept</td></tr>
<tr class="memdesc:a45be263cd7780f61a10ee03506146eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ClonePtr.html#a6de2e0549265c9eaefa3e661d284bf72" title="Swap the contents of this ClonePtr with another one, with ownership changing hands but no copying per...">swap()</a> member of the <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> class.  <a href="#a45be263cd7780f61a10ee03506146eda">More...</a><br /></td></tr>
<tr class="separator:a45be263cd7780f61a10ee03506146eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96029ad7026c473e92a5d157ed26b20"><td class="memTemplParams" colspan="2">template&lt;class charT , class traits , class T &gt; </td></tr>
<tr class="memitem:aa96029ad7026c473e92a5d157ed26b20"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#aa96029ad7026c473e92a5d157ed26b20">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aa96029ad7026c473e92a5d157ed26b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> object.  <a href="#aa96029ad7026c473e92a5d157ed26b20">More...</a><br /></td></tr>
<tr class="separator:aa96029ad7026c473e92a5d157ed26b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4187e30a49939dc757c025432d9a263e"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a4187e30a49939dc757c025432d9a263e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a4187e30a49939dc757c025432d9a263e">operator==</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a4187e30a49939dc757c025432d9a263e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> containers.  <a href="#a4187e30a49939dc757c025432d9a263e">More...</a><br /></td></tr>
<tr class="separator:a4187e30a49939dc757c025432d9a263e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18cf0f6c991801ecfa18f0a76f9548e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab18cf0f6c991801ecfa18f0a76f9548e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ab18cf0f6c991801ecfa18f0a76f9548e">operator==</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:ab18cf0f6c991801ecfa18f0a76f9548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>.  <a href="#ab18cf0f6c991801ecfa18f0a76f9548e">More...</a><br /></td></tr>
<tr class="separator:ab18cf0f6c991801ecfa18f0a76f9548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd9001e5c956f83923f97d71c2d79d6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5fd9001e5c956f83923f97d71c2d79d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a5fd9001e5c956f83923f97d71c2d79d6">operator==</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a5fd9001e5c956f83923f97d71c2d79d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>.  <a href="#a5fd9001e5c956f83923f97d71c2d79d6">More...</a><br /></td></tr>
<tr class="separator:a5fd9001e5c956f83923f97d71c2d79d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954492f749b7361447bd637145defde8"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a954492f749b7361447bd637145defde8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a954492f749b7361447bd637145defde8">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a954492f749b7361447bd637145defde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for two compatible <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to.  <a href="#a954492f749b7361447bd637145defde8">More...</a><br /></td></tr>
<tr class="separator:a954492f749b7361447bd637145defde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae185870e3cc4532a833d6fb89a755167"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae185870e3cc4532a833d6fb89a755167"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ae185870e3cc4532a833d6fb89a755167">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:ae185870e3cc4532a833d6fb89a755167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison against a <code>nullptr</code>.  <a href="#ae185870e3cc4532a833d6fb89a755167">More...</a><br /></td></tr>
<tr class="separator:ae185870e3cc4532a833d6fb89a755167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb98aef4697b9facb4e8417225eba4f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3fb98aef4697b9facb4e8417225eba4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a3fb98aef4697b9facb4e8417225eba4f">operator&lt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a3fb98aef4697b9facb4e8417225eba4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison of a <code>nullptr</code> against this container.  <a href="#a3fb98aef4697b9facb4e8417225eba4f">More...</a><br /></td></tr>
<tr class="separator:a3fb98aef4697b9facb4e8417225eba4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5498dd80dae1048e59eb4504bcd9611"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ab5498dd80dae1048e59eb4504bcd9611"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ab5498dd80dae1048e59eb4504bcd9611">operator!=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ab5498dd80dae1048e59eb4504bcd9611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer inequality test defined as <code>!(lhs==rhs)</code>.  <a href="#ab5498dd80dae1048e59eb4504bcd9611">More...</a><br /></td></tr>
<tr class="separator:ab5498dd80dae1048e59eb4504bcd9611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575bc518dd9a82c6d46fb37c6cf685f5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a575bc518dd9a82c6d46fb37c6cf685f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a575bc518dd9a82c6d46fb37c6cf685f5">operator!=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a575bc518dd9a82c6d46fb37c6cf685f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>.  <a href="#a575bc518dd9a82c6d46fb37c6cf685f5">More...</a><br /></td></tr>
<tr class="separator:a575bc518dd9a82c6d46fb37c6cf685f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f51ea5c12e65d5eea7f74f18e53f50"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac0f51ea5c12e65d5eea7f74f18e53f50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ac0f51ea5c12e65d5eea7f74f18e53f50">operator!=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac0f51ea5c12e65d5eea7f74f18e53f50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>.  <a href="#ac0f51ea5c12e65d5eea7f74f18e53f50">More...</a><br /></td></tr>
<tr class="separator:ac0f51ea5c12e65d5eea7f74f18e53f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac3351e266062bae512f0244144c268"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a0ac3351e266062bae512f0244144c268"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a0ac3351e266062bae512f0244144c268">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ac3351e266062bae512f0244144c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-than test defined as <code>rhs &lt; lhs</code>.  <a href="#a0ac3351e266062bae512f0244144c268">More...</a><br /></td></tr>
<tr class="separator:a0ac3351e266062bae512f0244144c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade71dc0d897518f0aff17a664f58bbc0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade71dc0d897518f0aff17a664f58bbc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ade71dc0d897518f0aff17a664f58bbc0">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:ade71dc0d897518f0aff17a664f58bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>.  <a href="#ade71dc0d897518f0aff17a664f58bbc0">More...</a><br /></td></tr>
<tr class="separator:ade71dc0d897518f0aff17a664f58bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad6355143164c2069c8530408f9175"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7aad6355143164c2069c8530408f9175"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a7aad6355143164c2069c8530408f9175">operator&gt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7aad6355143164c2069c8530408f9175"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>.  <a href="#a7aad6355143164c2069c8530408f9175">More...</a><br /></td></tr>
<tr class="separator:a7aad6355143164c2069c8530408f9175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420ec177989d4fe5aa6ca9a417d45649"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a420ec177989d4fe5aa6ca9a417d45649"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a420ec177989d4fe5aa6ca9a417d45649">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a420ec177989d4fe5aa6ca9a417d45649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>.  <a href="#a420ec177989d4fe5aa6ca9a417d45649">More...</a><br /></td></tr>
<tr class="separator:a420ec177989d4fe5aa6ca9a417d45649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a60f8f3cfb21bb862b678dde97cf279"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7a60f8f3cfb21bb862b678dde97cf279"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a7a60f8f3cfb21bb862b678dde97cf279">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a7a60f8f3cfb21bb862b678dde97cf279"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>.  <a href="#a7a60f8f3cfb21bb862b678dde97cf279">More...</a><br /></td></tr>
<tr class="separator:a7a60f8f3cfb21bb862b678dde97cf279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9460147c759c1f51aa7be02ce10f482"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad9460147c759c1f51aa7be02ce10f482"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ad9460147c759c1f51aa7be02ce10f482">operator&gt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ad9460147c759c1f51aa7be02ce10f482"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>.  <a href="#ad9460147c759c1f51aa7be02ce10f482">More...</a><br /></td></tr>
<tr class="separator:ad9460147c759c1f51aa7be02ce10f482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041746e0be1a40c1ba4d6d31a1465d9d"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a041746e0be1a40c1ba4d6d31a1465d9d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a041746e0be1a40c1ba4d6d31a1465d9d">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a041746e0be1a40c1ba4d6d31a1465d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments).  <a href="#a041746e0be1a40c1ba4d6d31a1465d9d">More...</a><br /></td></tr>
<tr class="separator:a041746e0be1a40c1ba4d6d31a1465d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0e6d482d9b6ae316e875a7d8ddf96e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d0e6d482d9b6ae316e875a7d8ddf96e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#a3d0e6d482d9b6ae316e875a7d8ddf96e">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a3d0e6d482d9b6ae316e875a7d8ddf96e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments).  <a href="#a3d0e6d482d9b6ae316e875a7d8ddf96e">More...</a><br /></td></tr>
<tr class="separator:a3d0e6d482d9b6ae316e875a7d8ddf96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae015d7a8497508039f4a5c236502822d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae015d7a8497508039f4a5c236502822d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ClonePtr.html#ae015d7a8497508039f4a5c236502822d">operator&lt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ae015d7a8497508039f4a5c236502822d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments).  <a href="#ae015d7a8497508039f4a5c236502822d">More...</a><br /></td></tr>
<tr class="separator:ae015d7a8497508039f4a5c236502822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SimTK::ClonePtr&lt; T &gt;</h3>

<p>Smart pointer with deep copy semantics. </p>
<p>This is similar to <code>std::unique_ptr</code> in that it does not permit shared ownership of the contained object. However, unlike <code>std::unique_ptr</code>, ClonePtr supports copy and assignment operations, by insisting that the contained object have a clone() method that returns a pointer to a heap-allocated deep copy of the <em>concrete</em> object. The API is modeled as closely as possible on the C++11 <code>std::unique_ptr</code> API. However, it always uses a default deleter. Also, in keeping with Simbody's careful distinction between writable and const access, and for compatibility with <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a>, the <a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> method is modified to return only a const pointer, with <a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a> (update) added to return a writable pointer.</p>
<p>This class is entirely inline and has no computational or space overhead except when cloning is required; it contains just a single pointer and does no reference counting.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the contained object, which <em>must</em> have a <code>clone()</code> method. May be an abstract or concrete type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a>, <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a16a8c3a419862297520e74155fd4c0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8c3a419862297520e74155fd4c0e5">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html#a16a8c3a419862297520e74155fd4c0e5">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the contained object. </p>

</div>
</div>
<a id="af3e6d3d76470b070d45a3a4beef31d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e6d3d76470b070d45a3a4beef31d02">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html#af3e6d3d76470b070d45a3a4beef31d02">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a pointer to the contained object. </p>

</div>
</div>
<a id="a2c11fa076622a78c3fb373127fab6be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c11fa076622a78c3fb373127fab6be9">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html#a2c11fa076622a78c3fb373127fab6be9">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a reference to the contained object. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3aae1c0efd169ce7d28dc7a9d30c1847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aae1c0efd169ce7d28dc7a9d30c1847">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor stores a <code>nullptr</code>. </p>
<p>No heap allocation is performed. The <a class="el" href="classSimTK_1_1ClonePtr.html#a835a4da50cb9a05983a70207063807b8" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> method will return true when called on a default-constructed ClonePtr. </p>

</div>
</div>
<a id="ac93eedabe424e5faee23d6e5ce265fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93eedabe424e5faee23d6e5ce265fc8">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from <code>nullptr</code> is the same as the default constructor. </p>
<p>This is an implicit conversion that allows <code>nullptr</code> to be used to initialize a ClonePtr. </p>

</div>
</div>
<a id="a32eeda0396038a4422380ccf60753c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eeda0396038a4422380ccf60753c20">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a writable heap-allocated object, take over ownership of that object. </p>
<p>The <code>clone()</code> method is <em>not</em> invoked. </p>

</div>
</div>
<a id="a70247203e537823ee66f812966b360e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70247203e537823ee66f812966b360e2">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a pointer to a read-only object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this ClonePtr the owner of the copy. </p>
<p>Ownership of the original object is not affected. If the supplied pointer is null, the resulting ClonePtr will be empty. </p>

</div>
</div>
<a id="ae3f63bd5f21bcf7eb49132bc4368f2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f63bd5f21bcf7eb49132bc4368f2c0">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a read-only reference to an object, create a new heap-allocated copy of that object via its <code>clone()</code> method and make this ClonePtr object the owner of the copy. </p>
<p>Ownership of the original object is not affected. </p>

</div>
</div>
<a id="a4e3b633793d04bd8e3701c0cb888b263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3b633793d04bd8e3701c0cb888b263">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is deep; the new ClonePtr object contains a new copy of the object in the source, created via the source object's <code>clone()</code> method. </p>
<p>If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="a31fd6086ffaedae659098492e923c8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fd6086ffaedae659098492e923c8b5">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy construction from a compatible ClonePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. The new ClonePtr object contains a new copy of the object in the source, created via the source object's <code>clone()</code> method. If the source container is empty this one will be empty also. </p>

</div>
</div>
<a id="a57dc6e4fe805d378df3edaa2da6a75e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dc6e4fe805d378df3edaa2da6a75e0">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor is very fast and leaves the source empty. </p>
<p>Ownership is transferred from the source to the new ClonePtr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="a837fac238af5655472435a724a7c1954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837fac238af5655472435a724a7c1954">&#9670;&nbsp;</a></span>ClonePtr() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construction from a compatible ClonePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. Ownership is transferred from the source to the new ClonePtr. If the source was empty this one will be empty also. No heap activity occurs. </p>

</div>
</div>
<a id="a6d23dacf600ff5deb5bc9863a221cf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d23dacf600ff5deb5bc9863a221cf3d">&#9670;&nbsp;</a></span>~ClonePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::~<a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor deletes the contained object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#aa074503ce254b1511b46de610048943b" title="Make this container empty if it isn&#39;t already, destructing the contained object if there is one...">reset()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22bbaeb1d5cb2a7358d0be7f66bf5a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bbaeb1d5cb2a7358d0be7f66bf5a85">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment replaces the currently-held object by a copy of the object held in the source container, created using the source object's <code>clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. Nothing happens if the source and destination are the same container. </p>

</div>
</div>
<a id="ad5a18eb9a33bac15ba85ffa437a09189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a18eb9a33bac15ba85ffa437a09189">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment from a compatible ClonePtr. </p>
<p>Type <code>U*</code> must be implicitly convertible to type <code>T*</code>. The currently-held object is replaced by a copy of the object held in the source container, created using the source object's <code>clone()</code> method. The currently-held object (if any) is deleted. If the source container is empty this one will be empty also after the assignment. </p>

</div>
</div>
<a id="adc28ba826ef6377dfaab55ab096a5cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc28ba826ef6377dfaab55ab096a5cbb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment replaces the currently-held object by the source object, leaving the source empty. </p>
<p>The currently-held object (if any) is deleted. The <code>clone()</code> method is <em>not</em> invoked. Nothing happens if the source and destination are the same containers. </p>

</div>
</div>
<a id="a69dbeab4a237f73fd1c58223c2b49e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dbeab4a237f73fd1c58223c2b49e33">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment from a compatible ClonePtr replaces the currently-held object by the source object, leaving the source empty. </p>
<p>Type U* must be implicitly convertible to type T*. The currently-held object (if any) is deleted. The <code>clone()</code> method is <em>not</em> invoked. </p>

</div>
</div>
<a id="a3c90ffac1ab535129b0b80716266766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c90ffac1ab535129b0b80716266766d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by a heap-allocated copy of the source object, created using its <code>clone()</code> method. </p>
<p>The currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="abf873e65e4b2287b01b7469a5932e7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf873e65e4b2287b01b7469a5932e7ad">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-held object by the given source object and takes over ownership of the source object. </p>
<p>The <br />
currently-held object (if any) is deleted. </p>

</div>
</div>
<a id="a24a317bf44ba0d02d8e32b587fa9c5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a317bf44ba0d02d8e32b587fa9c5a7">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that this is different than <code>get()</code> for the standard smart pointers like <code>std::unique_ptr</code> which return a writable pointer. Use <a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a> here for that purpose. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a>, <a class="el" href="classSimTK_1_1ClonePtr.html#a3309ea0c04bcaf42b42253b6a60c946d" title="Return a const reference to the contained object. ">getRef()</a> </dd></dl>

</div>
</div>
<a id="adf9aa41fb20bdfad61ef6ec2f3c50022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9aa41fb20bdfad61ef6ec2f3c50022">&#9670;&nbsp;</a></span>upd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::upd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the contained object if any, or <code>nullptr</code>. </p>
<p>Note that you need write access to this container in order to get write access to the object it contains. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a>, <a class="el" href="classSimTK_1_1ClonePtr.html#a5d49dd7e39d9f503da3e73dd34f5d809" title="Return a writable reference to the contained object. ">updRef()</a> </dd></dl>

</div>
</div>
<a id="a3309ea0c04bcaf42b42253b6a60c946d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3309ea0c04bcaf42b42253b6a60c946d">&#9670;&nbsp;</a></span>getRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::getRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the contained object. </p>
<p>Don't call this if this container is empty. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> </dd></dl>

</div>
</div>
<a id="a5d49dd7e39d9f503da3e73dd34f5d809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d49dd7e39d9f503da3e73dd34f5d809">&#9670;&nbsp;</a></span>updRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::updRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the contained object. </p>
<p>Don't call this if this container is empty. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a> </dd></dl>

</div>
</div>
<a id="ac78a0613fd71240a07b0e2e8e5ac2b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78a0613fd71240a07b0e2e8e5ac2b2f">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference a const pointer to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="abb43d4dc23ac327ec89c038192c8c6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb43d4dc23ac327ec89c038192c8c6a6">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference a writable pointer to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="a619d08afc55e34c347506b4c1307b01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619d08afc55e34c347506b4c1307b01b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This "dereference" operator returns a const reference to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="ac19a4b7dd6f8f65a7055f9a19e919e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19a4b7dd6f8f65a7055f9a19e919e8b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the contained object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="aa074503ce254b1511b46de610048943b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa074503ce254b1511b46de610048943b">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this container empty if it isn't already, destructing the contained object if there is one. </p>
<p>The container is restored to its default-constructed state. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html#a835a4da50cb9a05983a70207063807b8" title="Return true if this container is empty, which is the state the container is in immediately after defa...">empty()</a> </dd></dl>

</div>
</div>
<a id="ab54f0d5c9d4e0ca380802a72cb931684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54f0d5c9d4e0ca380802a72cb931684">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the contents of this container with the supplied heap-allocated object, taking over ownership of that object and deleting the current one first if necessary. </p>
<p>Nothing happens if the supplied pointer is the same as the one already being managed. </p>

</div>
</div>
<a id="a6de2e0549265c9eaefa3e661d284bf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de2e0549265c9eaefa3e661d284bf72">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this ClonePtr with another one, with ownership changing hands but no copying performed. </p>
<p>This is very fast; no heap activity occurs. Both containers must have been instantiated with the identical type. </p>

</div>
</div>
<a id="a835a4da50cb9a05983a70207063807b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835a4da50cb9a05983a70207063807b8">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty, which is the state the container is in immediately after default construction and various other operations. </p>

</div>
</div>
<a id="a5a958e36ecdc25629402336b2f9a3311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a958e36ecdc25629402336b2f9a3311">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a conversion to type bool that returns true if the container is non-null (that is, not empty). </p>

</div>
</div>
<a id="a99328b36a77ef7d50391cbc0432cdeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99328b36a77ef7d50391cbc0432cdeef">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the contained object from management by this container and transfer ownership to the caller. </p>
<p>A writable pointer to the object is returned. No object destruction occurs. This ClonePtr is left empty. </p>

</div>
</div>
<a id="a490297697bb49686c5ee98c44b1660d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490297697bb49686c5ee98c44b1660d1">&#9670;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::getPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Same as <code><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a></code>. </p>
<p>Use <a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a> instead; it is more like the API for <code>std::unique_ptr</code>. </p>

</div>
</div>
<a id="a02aa5c148ade2beaa167cc5acd205fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa5c148ade2beaa167cc5acd205fe8">&#9670;&nbsp;</a></span>updPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::updPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Same as <code><a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a></code>. </p>
<p>Use <a class="el" href="classSimTK_1_1ClonePtr.html#adf9aa41fb20bdfad61ef6ec2f3c50022" title="Return a writable pointer to the contained object if any, or nullptr. ">upd()</a> instead; it is a better match for <code><a class="el" href="classSimTK_1_1ClonePtr.html#a24a317bf44ba0d02d8e32b587fa9c5a7" title="Return a const pointer to the contained object if any, or nullptr. ">get()</a></code> modeled after the API for <code>std::unique_ptr</code>. </p>

</div>
</div>
<a id="a572650d3ccd620ac55c0e4d9757a37bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572650d3ccd620ac55c0e4d9757a37bb">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ClonePtr.html">SimTK::ClonePtr</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ClonePtr.html#aa074503ce254b1511b46de610048943b" title="Make this container empty if it isn&#39;t already, destructing the contained object if there is one...">reset()</a> instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a614e5d746a1a997cac03e1dc5c36a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614e5d746a1a997cac03e1dc5c36a00f">&#9670;&nbsp;</a></span>ClonePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45be263cd7780f61a10ee03506146eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45be263cd7780f61a10ee03506146eda">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ClonePtr.html#a6de2e0549265c9eaefa3e661d284bf72" title="Swap the contents of this ClonePtr with another one, with ownership changing hands but no copying per...">swap()</a> member of the <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> class. </p>
<p>(This function is defined in the <code><a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a></code> namespace.) </p>

</div>
</div>
<a id="aa96029ad7026c473e92a5d157ed26b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96029ad7026c473e92a5d157ed26b20">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class charT , class traits , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT, traits &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> object. </p>
<p>This is equivalent to <code>os &lt;&lt; p.get();</code>. </p>

</div>
</div>
<a id="a4187e30a49939dc757c025432d9a263e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4187e30a49939dc757c025432d9a263e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> containers. </p>
<p>Returns <code>true</code> if the pointers refer to the same object or if both are null. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a id="ab18cf0f6c991801ecfa18f0a76f9548e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18cf0f6c991801ecfa18f0a76f9548e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>. </p>

</div>
</div>
<a id="a5fd9001e5c956f83923f97d71c2d79d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd9001e5c956f83923f97d71c2d79d6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>. </p>

</div>
</div>
<a id="a954492f749b7361447bd637145defde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954492f749b7361447bd637145defde8">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for two compatible <a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics. ">ClonePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to. </p>
<p>Returns <code>true</code> if the lhs pointer tests less than the rhs pointer. A null pointer tests less than any non-null pointer. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a id="ae185870e3cc4532a833d6fb89a755167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae185870e3cc4532a833d6fb89a755167">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison against a <code>nullptr</code>. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method always returns <code>false</code>. </p>

</div>
</div>
<a id="a3fb98aef4697b9facb4e8417225eba4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb98aef4697b9facb4e8417225eba4f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison of a <code>nullptr</code> against this container. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method returns <code>true</code> unless the container is empty. </p>

</div>
</div>
<a id="ab5498dd80dae1048e59eb4504bcd9611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5498dd80dae1048e59eb4504bcd9611">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer inequality test defined as <code>!(lhs==rhs)</code>. </p>

</div>
</div>
<a id="a575bc518dd9a82c6d46fb37c6cf685f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575bc518dd9a82c6d46fb37c6cf685f5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>. </p>

</div>
</div>
<a id="ac0f51ea5c12e65d5eea7f74f18e53f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f51ea5c12e65d5eea7f74f18e53f50">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>. </p>

</div>
</div>
<a id="a0ac3351e266062bae512f0244144c268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac3351e266062bae512f0244144c268">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-than test defined as <code>rhs &lt; lhs</code>. </p>

</div>
</div>
<a id="ade71dc0d897518f0aff17a664f58bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade71dc0d897518f0aff17a664f58bbc0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>. </p>

</div>
</div>
<a id="a7aad6355143164c2069c8530408f9175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aad6355143164c2069c8530408f9175">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>. </p>

</div>
</div>
<a id="a420ec177989d4fe5aa6ca9a417d45649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420ec177989d4fe5aa6ca9a417d45649">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>. </p>

</div>
</div>
<a id="a7a60f8f3cfb21bb862b678dde97cf279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a60f8f3cfb21bb862b678dde97cf279">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>. </p>

</div>
</div>
<a id="ad9460147c759c1f51aa7be02ce10f482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9460147c759c1f51aa7be02ce10f482">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>. </p>

</div>
</div>
<a id="a041746e0be1a40c1ba4d6d31a1465d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041746e0be1a40c1ba4d6d31a1465d9d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a id="a3d0e6d482d9b6ae316e875a7d8ddf96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0e6d482d9b6ae316e875a7d8ddf96e">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a id="ae015d7a8497508039f4a5c236502822d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae015d7a8497508039f4a5c236502822d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ClonePtr_8h_source.html">ClonePtr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ClonePtr.html">ClonePtr</a></li>
    <li class="footer">Generated on Fri Dec 6 2019 17:28:04 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
