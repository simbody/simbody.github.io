<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::SimbodyMatterSubsystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1SimbodyMatterSubsystem.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1SimbodyMatterSubsystem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::SimbodyMatterSubsystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This subsystem contains the bodies ("matter") in the multibody system, the mobilizers (joints) that define the generalized coordinates used to represent the motion of those bodies, and constraints that must be satisfied by the values of those coordinates.  
 <a href="classSimTK_1_1SimbodyMatterSubsystem.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::SimbodyMatterSubsystem:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1SimbodyMatterSubsystem.png" usemap="#SimTK::SimbodyMatterSubsystem_map" alt=""/>
  <map id="SimTK::SimbodyMatterSubsystem_map" name="SimTK::SimbodyMatterSubsystem_map">
<area href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys..." alt="SimTK::Subsystem" shape="rect" coords="0,0,197,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, Destruction, Topological information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section are used in the extended construction phase for a SimbodyMatterSubsystem which we call defining the "topology" of the multibody system.</p>
<p>This includes adding mobilized bodies and constraints. Topological information is always state-independent since it is kept in the SimbodyMatterSubsystem object directly. The construction phase ends when realizeTopology() is called on the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>. </p>
</div></td></tr>
<tr class="memitem:a1b1f2127fdc50c1c92b5a20db22cd43f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1b1f2127fdc50c1c92b5a20db22cd43f">SimbodyMatterSubsystem</a> (<a class="el" href="classSimTK_1_1MultibodySystem.html">MultibodySystem</a> &amp;)</td></tr>
<tr class="memdesc:a1b1f2127fdc50c1c92b5a20db22cd43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a1b1f2127fdc50c1c92b5a20db22cd43f">More...</a><br /></td></tr>
<tr class="separator:a1b1f2127fdc50c1c92b5a20db22cd43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5ec5c33a93af6d9e3a8ebc6bf37b51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b5ec5c33a93af6d9e3a8ebc6bf37b51">SimbodyMatterSubsystem</a> ()</td></tr>
<tr class="memdesc:a4b5ec5c33a93af6d9e3a8ebc6bf37b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an orphan matter subsystem containing only the Ground body (mobilized body 0); normally use the other constructor to place the subsystem in a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a4b5ec5c33a93af6d9e3a8ebc6bf37b51">More...</a><br /></td></tr>
<tr class="separator:a4b5ec5c33a93af6d9e3a8ebc6bf37b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f39cefdaee87456ea572c72e1f1a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac49f39cefdaee87456ea572c72e1f1a1">~SimbodyMatterSubsystem</a> ()</td></tr>
<tr class="memdesc:ac49f39cefdaee87456ea572c72e1f1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor destroys the subsystem implementation object only if this handle is the last reference.  <a href="#ac49f39cefdaee87456ea572c72e1f1a1">More...</a><br /></td></tr>
<tr class="separator:ac49f39cefdaee87456ea572c72e1f1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b8a5a13e1dc86d8ba8044b351c6bdc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad5b8a5a13e1dc86d8ba8044b351c6bdc">getMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>) const</td></tr>
<tr class="memdesc:ad5b8a5a13e1dc86d8ba8044b351c6bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#ad5b8a5a13e1dc86d8ba8044b351c6bdc">More...</a><br /></td></tr>
<tr class="separator:ad5b8a5a13e1dc86d8ba8044b351c6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5142442d0d59524a47f604584040fdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5142442d0d59524a47f604584040fdc1">updMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>)</td></tr>
<tr class="memdesc:a5142442d0d59524a47f604584040fdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#a5142442d0d59524a47f604584040fdc1">More...</a><br /></td></tr>
<tr class="separator:a5142442d0d59524a47f604584040fdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903434aff60bd8c1cce43cdfad8906d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a903434aff60bd8c1cce43cdfad8906d2">getGround</a> () const</td></tr>
<tr class="memdesc:a903434aff60bd8c1cce43cdfad8906d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a read-only (const) reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem.  <a href="#a903434aff60bd8c1cce43cdfad8906d2">More...</a><br /></td></tr>
<tr class="separator:a903434aff60bd8c1cce43cdfad8906d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0851b330170f8e5a0700382ddf58bd22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22">updGround</a> ()</td></tr>
<tr class="memdesc:a0851b330170f8e5a0700382ddf58bd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem; you need a writable reference if you're adding a mobilized body that is directly connected to Ground.  <a href="#a0851b330170f8e5a0700382ddf58bd22">More...</a><br /></td></tr>
<tr class="separator:a0851b330170f8e5a0700382ddf58bd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7776baa71fc6d342f3140284b56553fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7776baa71fc6d342f3140284b56553fb">Ground</a> ()</td></tr>
<tr class="memdesc:a7776baa71fc6d342f3140284b56553fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a synonym for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> that makes for nicer-looking examples.  <a href="#a7776baa71fc6d342f3140284b56553fb">More...</a><br /></td></tr>
<tr class="separator:a7776baa71fc6d342f3140284b56553fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c1a9d82a9736a481ed6b354ba00e6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a24c1a9d82a9736a481ed6b354ba00e6a">getConstraint</a> (<a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>) const</td></tr>
<tr class="memdesc:a24c1a9d82a9736a481ed6b354ba00e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem.  <a href="#a24c1a9d82a9736a481ed6b354ba00e6a">More...</a><br /></td></tr>
<tr class="separator:a24c1a9d82a9736a481ed6b354ba00e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca8b7eb162893128a6abc69d522e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a85ca8b7eb162893128a6abc69d522e62">updConstraint</a> (<a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>)</td></tr>
<tr class="memdesc:a85ca8b7eb162893128a6abc69d522e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem.  <a href="#a85ca8b7eb162893128a6abc69d522e62">More...</a><br /></td></tr>
<tr class="separator:a85ca8b7eb162893128a6abc69d522e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19657abf3c40de3bc74bede59f8b1f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a19657abf3c40de3bc74bede59f8b1f7d">setShowDefaultGeometry</a> (bool show)</td></tr>
<tr class="memdesc:a19657abf3c40de3bc74bede59f8b1f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally the matter subsystem will attempt to generate some decorative geometry as a sketch of the defined multibody system; you can disable that with this method.  <a href="#a19657abf3c40de3bc74bede59f8b1f7d">More...</a><br /></td></tr>
<tr class="separator:a19657abf3c40de3bc74bede59f8b1f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f8327dfdc9c8cd1b382cf27e7cd37a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a86f8327dfdc9c8cd1b382cf27e7cd37a">getShowDefaultGeometry</a> () const</td></tr>
<tr class="memdesc:a86f8327dfdc9c8cd1b382cf27e7cd37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether this matter subsystem is set to generate default decorative geometry that can be used to visualize this multibody system.  <a href="#a86f8327dfdc9c8cd1b382cf27e7cd37a">More...</a><br /></td></tr>
<tr class="separator:a86f8327dfdc9c8cd1b382cf27e7cd37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f40d04cfab14431af5abbaf60e1cce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a45f40d04cfab14431af5abbaf60e1cce">getNumBodies</a> () const</td></tr>
<tr class="memdesc:a45f40d04cfab14431af5abbaf60e1cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bodies includes all mobilized bodies <em>including</em> Ground, which is the first mobilized body, at <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> 0.  <a href="#a45f40d04cfab14431af5abbaf60e1cce">More...</a><br /></td></tr>
<tr class="separator:a45f40d04cfab14431af5abbaf60e1cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcd1876e2525cc9fb102cd299cce203"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acfcd1876e2525cc9fb102cd299cce203">getNumConstraints</a> () const</td></tr>
<tr class="memdesc:acfcd1876e2525cc9fb102cd299cce203"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total number of defined constraints, each of which may generate more than one constraint equation.  <a href="#acfcd1876e2525cc9fb102cd299cce203">More...</a><br /></td></tr>
<tr class="separator:acfcd1876e2525cc9fb102cd299cce203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd2acffb10679e18813eeddb734fc2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcd2acffb10679e18813eeddb734fc2d">getNumMobilities</a> () const</td></tr>
<tr class="memdesc:abcd2acffb10679e18813eeddb734fc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all the mobilizer degrees of freedom.  <a href="#abcd2acffb10679e18813eeddb734fc2d">More...</a><br /></td></tr>
<tr class="separator:abcd2acffb10679e18813eeddb734fc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f35fc427997efab70e1825caaf472"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaa2f35fc427997efab70e1825caaf472">getTotalQAlloc</a> () const</td></tr>
<tr class="memdesc:aaa2f35fc427997efab70e1825caaf472"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all the q vector allocations for each joint.  <a href="#aaa2f35fc427997efab70e1825caaf472">More...</a><br /></td></tr>
<tr class="separator:aaa2f35fc427997efab70e1825caaf472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3e416b8263877d3e599774554f78d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a59d3e416b8263877d3e599774554f78d">adoptMobilizedBody</a> (<a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> parent, <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;child)</td></tr>
<tr class="memdesc:a59d3e416b8263877d3e599774554f78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach new matter by attaching it to the indicated parent body (not normally called by users &ndash; see <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>).  <a href="#a59d3e416b8263877d3e599774554f78d">More...</a><br /></td></tr>
<tr class="separator:a59d3e416b8263877d3e599774554f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf98f3426a2778ba1db81c5d76bccce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf98f3426a2778ba1db81c5d76bccce2">adoptConstraint</a> (<a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;)</td></tr>
<tr class="memdesc:adf98f3426a2778ba1db81c5d76bccce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> object to the matter subsystem (not normally called by users &ndash; see <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>).  <a href="#adf98f3426a2778ba1db81c5d76bccce2">More...</a><br /></td></tr>
<tr class="separator:adf98f3426a2778ba1db81c5d76bccce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6b02ae234cc0784aa40f4a6d94cf27"><td class="memItemLeft" align="right" valign="top">UnilateralContactIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1f6b02ae234cc0784aa40f4a6d94cf27">adoptUnilateralContact</a> (<a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a> *)</td></tr>
<tr class="memdesc:a1f6b02ae234cc0784aa40f4a6d94cf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Experimental)  <a href="#a1f6b02ae234cc0784aa40f4a6d94cf27">More...</a><br /></td></tr>
<tr class="separator:a1f6b02ae234cc0784aa40f4a6d94cf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be69c620957a93b9b797b3c4d2ed124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9be69c620957a93b9b797b3c4d2ed124">getNumUnilateralContacts</a> () const</td></tr>
<tr class="memdesc:a9be69c620957a93b9b797b3c4d2ed124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a9be69c620957a93b9b797b3c4d2ed124">More...</a><br /></td></tr>
<tr class="separator:a9be69c620957a93b9b797b3c4d2ed124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4f3a61791e7ac3870a899e8216952b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5a4f3a61791e7ac3870a899e8216952b">getUnilateralContact</a> (UnilateralContactIndex) const</td></tr>
<tr class="memdesc:a5a4f3a61791e7ac3870a899e8216952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a5a4f3a61791e7ac3870a899e8216952b">More...</a><br /></td></tr>
<tr class="separator:a5a4f3a61791e7ac3870a899e8216952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d443f6085527aaa5a0e754d6ea42a57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7d443f6085527aaa5a0e754d6ea42a57">updUnilateralContact</a> (UnilateralContactIndex)</td></tr>
<tr class="memdesc:a7d443f6085527aaa5a0e754d6ea42a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a7d443f6085527aaa5a0e754d6ea42a57">More...</a><br /></td></tr>
<tr class="separator:a7d443f6085527aaa5a0e754d6ea42a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade345270c030aaf4e4521b49c6dd4231"><td class="memItemLeft" align="right" valign="top">StateLimitedFrictionIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ade345270c030aaf4e4521b49c6dd4231">adoptStateLimitedFriction</a> (<a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a> *)</td></tr>
<tr class="memdesc:ade345270c030aaf4e4521b49c6dd4231"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Experimental)  <a href="#ade345270c030aaf4e4521b49c6dd4231">More...</a><br /></td></tr>
<tr class="separator:ade345270c030aaf4e4521b49c6dd4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00faa4c404c31ded89c06f0ad7c1d509"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a00faa4c404c31ded89c06f0ad7c1d509">getNumStateLimitedFrictions</a> () const</td></tr>
<tr class="memdesc:a00faa4c404c31ded89c06f0ad7c1d509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a00faa4c404c31ded89c06f0ad7c1d509">More...</a><br /></td></tr>
<tr class="separator:a00faa4c404c31ded89c06f0ad7c1d509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b654dad770f79263dafaa2aafeb06"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a357b654dad770f79263dafaa2aafeb06">getStateLimitedFriction</a> (StateLimitedFrictionIndex) const</td></tr>
<tr class="memdesc:a357b654dad770f79263dafaa2aafeb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a357b654dad770f79263dafaa2aafeb06">More...</a><br /></td></tr>
<tr class="separator:a357b654dad770f79263dafaa2aafeb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae7adcc1ce992f808f2402649e81e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9ae7adcc1ce992f808f2402649e81e95">updStateLimitedFriction</a> (StateLimitedFrictionIndex)</td></tr>
<tr class="memdesc:a9ae7adcc1ce992f808f2402649e81e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>.  <a href="#a9ae7adcc1ce992f808f2402649e81e95">More...</a><br /></td></tr>
<tr class="separator:a9ae7adcc1ce992f808f2402649e81e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af874cd8e7ca24c492042a0eef52ec9e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af874cd8e7ca24c492042a0eef52ec9e8">SimbodyMatterSubsystem</a> (const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;ss)</td></tr>
<tr class="memdesc:af874cd8e7ca24c492042a0eef52ec9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is not very useful.  <a href="#af874cd8e7ca24c492042a0eef52ec9e8">More...</a><br /></td></tr>
<tr class="separator:af874cd8e7ca24c492042a0eef52ec9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e07d273b578e2d1ae9935de12da608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a29e07d273b578e2d1ae9935de12da608">operator=</a> (const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;ss)</td></tr>
<tr class="memdesc:a29e07d273b578e2d1ae9935de12da608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is not very useful.  <a href="#a29e07d273b578e2d1ae9935de12da608">More...</a><br /></td></tr>
<tr class="separator:a29e07d273b578e2d1ae9935de12da608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set/get modeling options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section involve setting and getting various modeling options that may be selected.</p>
<p>This includes whether to use quaternions or Euler angles to represent rotations, and enabling/disabling constraints. </p>
</div></td></tr>
<tr class="memitem:a0164088f7e48b71db08706c65b6467ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0164088f7e48b71db08706c65b6467ea">setUseEulerAngles</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, bool useEulerAngles) const</td></tr>
<tr class="memdesc:a0164088f7e48b71db08706c65b6467ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all mobilizers offering unrestricted orientation, decide what method we should use to model their orientations.  <a href="#a0164088f7e48b71db08706c65b6467ea">More...</a><br /></td></tr>
<tr class="separator:a0164088f7e48b71db08706c65b6467ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf982ad4fe5e4a869346593fb454db89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#adf982ad4fe5e4a869346593fb454db89">getUseEulerAngles</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:adf982ad4fe5e4a869346593fb454db89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current setting of the "use Euler angles" model variable as set in the supplied <em>state</em>.  <a href="#adf982ad4fe5e4a869346593fb454db89">More...</a><br /></td></tr>
<tr class="separator:adf982ad4fe5e4a869346593fb454db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a8b52991614ad6b600cafa82cf917b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88a8b52991614ad6b600cafa82cf917b">getNumQuaternionsInUse</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a88a8b52991614ad6b600cafa82cf917b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of quaternions in use by the mobilizers of this system, given the current setting of the "use Euler angles" flag in the supplied <em>state</em>, and the types of mobilizers in the multibody tree.  <a href="#a88a8b52991614ad6b600cafa82cf917b">More...</a><br /></td></tr>
<tr class="separator:a88a8b52991614ad6b600cafa82cf917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d662f1db0c80568e51c88da5d1fef4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d662f1db0c80568e51c88da5d1fef4a">isUsingQuaternion</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx) const</td></tr>
<tr class="memdesc:a3d662f1db0c80568e51c88da5d1fef4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and the setting of the "use Euler angles" flag in the supplied <em>state</em>.  <a href="#a3d662f1db0c80568e51c88da5d1fef4a">More...</a><br /></td></tr>
<tr class="separator:a3d662f1db0c80568e51c88da5d1fef4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1463bd323e19002ff3b05c7cb3d7c5"><td class="memItemLeft" align="right" valign="top">QuaternionPoolIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea1463bd323e19002ff3b05c7cb3d7c5">getQuaternionPoolIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx) const</td></tr>
<tr class="memdesc:aea1463bd323e19002ff3b05c7cb3d7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given mobilizer is currently using a quaternion to represent orientation, return the QuaternionPoolIndex (a small integer) assigned to that quaternion.  <a href="#aea1463bd323e19002ff3b05c7cb3d7c5">More...</a><br /></td></tr>
<tr class="separator:aea1463bd323e19002ff3b05c7cb3d7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a54e463f72432d1b1c97fb3f324439f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4a54e463f72432d1b1c97fb3f324439f">setConstraintIsDisabled</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> constraintIx, bool shouldDisableConstraint) const</td></tr>
<tr class="memdesc:a4a54e463f72432d1b1c97fb3f324439f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or enable the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> whose <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is supplied within the supplied <em>state</em>.  <a href="#a4a54e463f72432d1b1c97fb3f324439f">More...</a><br /></td></tr>
<tr class="separator:a4a54e463f72432d1b1c97fb3f324439f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4fa4b6ac99dfd2505f6d95189864d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe4fa4b6ac99dfd2505f6d95189864d4">isConstraintDisabled</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> constraint) const</td></tr>
<tr class="memdesc:afe4fa4b6ac99dfd2505f6d95189864d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a particular <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is currently disabled in the given <em>state</em>.  <a href="#afe4fa4b6ac99dfd2505f6d95189864d4">More...</a><br /></td></tr>
<tr class="separator:afe4fa4b6ac99dfd2505f6d95189864d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e92e3504739bb2791cca77035df980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad6e92e3504739bb2791cca77035df980">convertToEulerAngles</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;inputState, <a class="el" href="classSimTK_1_1State.html">State</a> &amp;outputState) const</td></tr>
<tr class="memdesc:ad6e92e3504739bb2791cca77035df980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which may be modeled using quaternions, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which represents the same configuration using Euler angles instead.  <a href="#ad6e92e3504739bb2791cca77035df980">More...</a><br /></td></tr>
<tr class="separator:ad6e92e3504739bb2791cca77035df980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b377a776773482e43e5b89ebe0386b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a68b377a776773482e43e5b89ebe0386b">convertToQuaternions</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;inputState, <a class="el" href="classSimTK_1_1State.html">State</a> &amp;outputState) const</td></tr>
<tr class="memdesc:a68b377a776773482e43e5b89ebe0386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which may be modeled using Euler angles, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which represents the same configuration using quaternions instead.  <a href="#a68b377a776773482e43e5b89ebe0386b">More...</a><br /></td></tr>
<tr class="separator:a68b377a776773482e43e5b89ebe0386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9867fb6504a2d9e33062db098299d25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9867fb6504a2d9e33062db098299d25f">normalizeQuaternions</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a9867fb6504a2d9e33062db098299d25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose generalized coordinates q have been modified in some manner that doesn't necessarily keep quaternions normalized, fix them.  <a href="#a9867fb6504a2d9e33062db098299d25f">More...</a><br /></td></tr>
<tr class="separator:a9867fb6504a2d9e33062db098299d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Calculate whole-system properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods perform calculations that yield properties of the system as a whole.</p>
<p>These are <em>operators</em>, meaning that they make use of the supplied <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> but do not modify the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. They simply calculate a result and return it to you without storing it internally. Each method requires that the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> has already been realized to at least a particular stage which is documented with the method. </p>
</div></td></tr>
<tr class="memitem:aa1a9bc99d6feb480c714f57073be8b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1a9bc99d6feb480c714f57073be8b2e">calcSystemMass</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:aa1a9bc99d6feb480c714f57073be8b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total system mass.  <a href="#aa1a9bc99d6feb480c714f57073be8b2e">More...</a><br /></td></tr>
<tr class="separator:aa1a9bc99d6feb480c714f57073be8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459dbe161f3f40a31688851d0aab687c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a459dbe161f3f40a31688851d0aab687c">calcSystemMassCenterLocationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:a459dbe161f3f40a31688851d0aab687c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the position vector p_GC of the system mass center C, measured from the Ground origin, and expressed in Ground.  <a href="#a459dbe161f3f40a31688851d0aab687c">More...</a><br /></td></tr>
<tr class="separator:a459dbe161f3f40a31688851d0aab687c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29174087d29ce0fb47d974dee778973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af29174087d29ce0fb47d974dee778973">calcSystemMassPropertiesInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:af29174087d29ce0fb47d974dee778973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return total system mass, mass center location measured from the Ground origin, and system inertia taken about the Ground origin, expressed in Ground.  <a href="#af29174087d29ce0fb47d974dee778973">More...</a><br /></td></tr>
<tr class="separator:af29174087d29ce0fb47d974dee778973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec0416ba22b4b23012b605cf8f707ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5ec0416ba22b4b23012b605cf8f707ef">calcSystemCentralInertiaInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:a5ec0416ba22b4b23012b605cf8f707ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system inertia matrix taken about the system center of mass, expressed in Ground.  <a href="#a5ec0416ba22b4b23012b605cf8f707ef">More...</a><br /></td></tr>
<tr class="separator:a5ec0416ba22b4b23012b605cf8f707ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c4a8c901513ef0eaff6cabe030ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7e7c4a8c901513ef0eaff6cabe030ca6">calcSystemMassCenterVelocityInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:a7e7c4a8c901513ef0eaff6cabe030ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the velocity v_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G.  <a href="#a7e7c4a8c901513ef0eaff6cabe030ca6">More...</a><br /></td></tr>
<tr class="separator:a7e7c4a8c901513ef0eaff6cabe030ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3beee3925d85bc63e874afde3eeca2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae3beee3925d85bc63e874afde3eeca2c">calcSystemMassCenterAccelerationInGround</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:ae3beee3925d85bc63e874afde3eeca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the acceleration a_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G.  <a href="#ae3beee3925d85bc63e874afde3eeca2c">More...</a><br /></td></tr>
<tr class="separator:ae3beee3925d85bc63e874afde3eeca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9778e7621be2331052674953e2864d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9778e7621be2331052674953e2864d30">calcSystemMomentumAboutGroundOrigin</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:a9778e7621be2331052674953e2864d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the Ground origin and expressed in Ground.  <a href="#a9778e7621be2331052674953e2864d30">More...</a><br /></td></tr>
<tr class="separator:a9778e7621be2331052674953e2864d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8b7b6eaf6d1a7441ed605a30f13d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf8b7b6eaf6d1a7441ed605a30f13d96">calcSystemCentralMomentum</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:abf8b7b6eaf6d1a7441ed605a30f13d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the current system center of mass location C and expressed in Ground.  <a href="#abf8b7b6eaf6d1a7441ed605a30f13d96">More...</a><br /></td></tr>
<tr class="separator:abf8b7b6eaf6d1a7441ed605a30f13d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cca0ac3895c7ab813a99162d7c85aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac6cca0ac3895c7ab813a99162d7c85aa">calcKineticEnergy</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:ac6cca0ac3895c7ab813a99162d7c85aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total kinetic energy of all the mobilized bodies in this matter subsystem, given the configuration and velocities in <em>state</em>.  <a href="#ac6cca0ac3895c7ab813a99162d7c85aa">More...</a><br /></td></tr>
<tr class="separator:ac6cca0ac3895c7ab813a99162d7c85aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System and Task Space Kinematic Jacobian Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The system kinematic Jacobian maps between mobility space (generalized speeds and generalized forces) and Cartesian body space (mobilized body frame spatial velocities and spatial forces).</p>
<p>A task space Jacobian maps between mobility space and a specified set of task points or frames fixed to a subset of the bodies, and generally located away from the body frame. A task space Jacobian J can be used to construct various task space matrices such as the task space compliance matrix J M^-1 ~J or its inverse, the task space (or operational space) inertia matrix.</p>
<p>The system Jacobian J(q) maps n generalized speeds u to spatial velocities V of each of the nb mobilized bodies (including Ground), measured at the body frame origin relative to Ground, and expressed in the Ground frame. The transpose ~J of this matrix maps nb spatial forces to n generalized forces, where the spatial forces are applied at the body frame origin and expressed in Ground. Similarly, task space Jacobians map from n generalized speeds to nt task frame spatial velocities (expressed in Ground), and transposed task space Jacobians map between task frame spatial forces (or impulses), expressed in Ground, and generalized forces (or generalized impulses).</p>
<p>Simbody provides fast O(n) methods ("operators") that can form matrix-vector products like J*u or ~J*F without forming J. The "bias" term Jdot*u (also known as the Coriolis acceleration) is also available; this arises when working at the acceleration level because d/dt J*u = J*udot+Jdot*u (where dot means time derivative). The computational cost of these operators is O(n+nt) so it is <em>much</em> more efficient to work with a group of tasks simultaneously than to process one at a time, which would have complexity O(n*nt). Alternatively, we provide methods that will return all or part of J explicitly; in general it is <em>much</em> more efficient computationally to work with the O(n) matrix-vector multiply operators rather than to form explicit matrices and then perform O(n^2) matrix-vector products. Performance estimates are given with each method so that you can determine which methods to use. If you can, you should use the O(n) methods &ndash; it is a good habit to get into when using an O(n) multibody code like Simbody!</p>
<p>Note that the Jacobian is associated with an expressed-in frame for the velocity or force vector and a designated station (point) on each body. We always use the Ground frame for Jacobians. For the system Jacobian, the body origin is always the designated station; for task Jacobians different stations may be specified. We provide three different sets of methods for working with</p><ul>
<li>the full System Jacobian: J, nb X n 6-vectors (or 6*nb X n scalars)</li>
<li>the Station Jacobian for a set of nt task stations (points): JS, nt rows of n 3-vectors (or a 3*nt X n Matrix of scalars)</li>
<li>the Frame Jacobian for a set of nt task frames fixed to a body: JF, nt rows of n 6-vectors (or a 6*nt X n Matrix of scalars)</li>
</ul>
<p>The rotational part of a Jacobian is the same for any frame fixed to the same body. So for Frame Jacobians you need specify only a station on the body (the frame's origin point). That means if you want a 3*nt X n Orientation Jacobian, you can obtain it from alternate rows of a Frame Jacobian. Using the above terminology, the complete System Jacobian is a Frame Jacobian for which the task frames are the body frames, with each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> appearing only once and in order of <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (starting with Ground).</p>
<p>It is acceptable for the same body to appear more than once in a list of tasks; these are likely to conflict but that can be dealt with elsewhere. </p>
</div></td></tr>
<tr class="memitem:a6cdfd4c182fd6b3f129e8f2bc1b6e6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6">multiplyBySystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;Ju) const</td></tr>
<tr class="memdesc:a6cdfd4c182fd6b3f129e8f2bc1b6e6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) and a mobility-space vector u in O(n) time.  <a href="#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6">More...</a><br /></td></tr>
<tr class="separator:a6cdfd4c182fd6b3f129e8f2bc1b6e6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b13161134a51492ea355a1eaae99dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8b13161134a51492ea355a1eaae99dec">calcBiasForSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JDotu) const</td></tr>
<tr class="memdesc:a8b13161134a51492ea355a1eaae99dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for the System Jacobian, that is, the part of the acceleration that is due only to velocities.  <a href="#a8b13161134a51492ea355a1eaae99dec">More...</a><br /></td></tr>
<tr class="separator:a8b13161134a51492ea355a1eaae99dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1444c32982e68d8157a8435c61f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6f1444c32982e68d8157a8435c61f55">calcBiasForSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JDotu) const</td></tr>
<tr class="memdesc:af6f1444c32982e68d8157a8435c61f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 6*nb-vector of scalars rather than as an nb-vector of 2x3 spatial vectors.  <a href="#af6f1444c32982e68d8157a8435c61f55">More...</a><br /></td></tr>
<tr class="separator:af6f1444c32982e68d8157a8435c61f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e9006e2a8e513f940e5e337c82329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329">multiplyBySystemJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;F_G, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:a2a6e9006e2a8e513f940e5e337c82329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial force-like elements, one per body, in O(n) time to produce a generalized force-like result f=~J*F.  <a href="#a2a6e9006e2a8e513f940e5e337c82329">More...</a><br /></td></tr>
<tr class="separator:a2a6e9006e2a8e513f940e5e337c82329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e16d57c4d129a22311c26f4a555e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c9e16d57c4d129a22311c26f4a555e3">calcSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;J_G) const</td></tr>
<tr class="memdesc:a4c9e16d57c4d129a22311c26f4a555e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec).  <a href="#a4c9e16d57c4d129a22311c26f4a555e3">More...</a><br /></td></tr>
<tr class="separator:a4c9e16d57c4d129a22311c26f4a555e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca444046ca1a2cae0c80b7846c29abf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aca444046ca1a2cae0c80b7846c29abf4">calcSystemJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;J_G) const</td></tr>
<tr class="memdesc:aca444046ca1a2cae0c80b7846c29abf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a system Jacobian as a 6*nb X n Matrix of scalars rather than as an nb X n matrix of 2x3 spatial vectors.  <a href="#aca444046ca1a2cae0c80b7846c29abf4">More...</a><br /></td></tr>
<tr class="separator:aca444046ca1a2cae0c80b7846c29abf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9043c480738ccd9af077914c62e1c02a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9043c480738ccd9af077914c62e1c02a">multiplyByStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JSu) const</td></tr>
<tr class="memdesc:a9043c480738ccd9af077914c62e1c02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) that results from a particular set of generalized speeds u.  <a href="#a9043c480738ccd9af077914c62e1c02a">More...</a><br /></td></tr>
<tr class="separator:a9043c480738ccd9af077914c62e1c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5dbf65d8b88c13468888964cd511479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad5dbf65d8b88c13468888964cd511479">multiplyByStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u) const</td></tr>
<tr class="memdesc:ad5dbf65d8b88c13468888964cd511479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#ad5dbf65d8b88c13468888964cd511479">More...</a><br /></td></tr>
<tr class="separator:ad5dbf65d8b88c13468888964cd511479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e384f7e3dbf14be82f91156a942e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e5e384f7e3dbf14be82f91156a942e6">multiplyByStationJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;f_GP, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:a5e5e384f7e3dbf14be82f91156a942e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (points fixed to bodies) P.  <a href="#a5e5e384f7e3dbf14be82f91156a942e6">More...</a><br /></td></tr>
<tr class="separator:a5e5e384f7e3dbf14be82f91156a942e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fa4f9017618d84d4da705088a8e06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a45fa4f9017618d84d4da705088a8e06f">multiplyByStationJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;f_GP, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:a45fa4f9017618d84d4da705088a8e06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a45fa4f9017618d84d4da705088a8e06f">More...</a><br /></td></tr>
<tr class="separator:a45fa4f9017618d84d4da705088a8e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609c9185a6855337ad7e0a6a28352d73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a609c9185a6855337ad7e0a6a28352d73">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JS) const</td></tr>
<tr class="memdesc:a609c9185a6855337ad7e0a6a28352d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a station is a point fixed on a particular mobilized body).  <a href="#a609c9185a6855337ad7e0a6a28352d73">More...</a><br /></td></tr>
<tr class="separator:a609c9185a6855337ad7e0a6a28352d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27560a2741e1d8e93f41671101927f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af27560a2741e1d8e93f41671101927f3">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, <a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JS) const</td></tr>
<tr class="memdesc:af27560a2741e1d8e93f41671101927f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#af27560a2741e1d8e93f41671101927f3">More...</a><br /></td></tr>
<tr class="separator:af27560a2741e1d8e93f41671101927f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaf0210388cde7033d23f8254bf0b5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3eaf0210388cde7033d23f8254bf0b5a">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JS) const</td></tr>
<tr class="memdesc:a3eaf0210388cde7033d23f8254bf0b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a station Jacobian as a 3*nt x n Matrix rather than as a Matrix of Vec3 elements.  <a href="#a3eaf0210388cde7033d23f8254bf0b5a">More...</a><br /></td></tr>
<tr class="separator:a3eaf0210388cde7033d23f8254bf0b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea22d30ca5f984f6079b91eea0ed928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7ea22d30ca5f984f6079b91eea0ed928">calcStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JS) const</td></tr>
<tr class="memdesc:a7ea22d30ca5f984f6079b91eea0ed928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#a7ea22d30ca5f984f6079b91eea0ed928">More...</a><br /></td></tr>
<tr class="separator:a7ea22d30ca5f984f6079b91eea0ed928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991359a02df025302e67f90de61f9c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a991359a02df025302e67f90de61f9c13">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;JSDotu) const</td></tr>
<tr class="memdesc:a991359a02df025302e67f90de61f9c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for a station Jacobian, that is, the part of the station's acceleration that is due only to velocities.  <a href="#a991359a02df025302e67f90de61f9c13">More...</a><br /></td></tr>
<tr class="separator:a991359a02df025302e67f90de61f9c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6dd4c627e1aed36297001f2ff73d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8f6dd4c627e1aed36297001f2ff73d5c">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;stationPInB, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JSDotu) const</td></tr>
<tr class="memdesc:a8f6dd4c627e1aed36297001f2ff73d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 3*nt-vector of scalars rather than as an nt-vector of Vec3s.  <a href="#a8f6dd4c627e1aed36297001f2ff73d5c">More...</a><br /></td></tr>
<tr class="separator:a8f6dd4c627e1aed36297001f2ff73d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d0adf617de56f182165241c45d5dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab8d0adf617de56f182165241c45d5dfe">calcBiasForStationJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationPInB) const</td></tr>
<tr class="memdesc:ab8d0adf617de56f182165241c45d5dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature for when you just have a single station task.  <a href="#ab8d0adf617de56f182165241c45d5dfe">More...</a><br /></td></tr>
<tr class="separator:ab8d0adf617de56f182165241c45d5dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9c3d793cf53968c089dc59732ac639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d9c3d793cf53968c089dc59732ac639">multiplyByFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JFu) const</td></tr>
<tr class="memdesc:a2d9c3d793cf53968c089dc59732ac639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}, that result from a particular set of n generalized speeds u.  <a href="#a2d9c3d793cf53968c089dc59732ac639">More...</a><br /></td></tr>
<tr class="separator:a2d9c3d793cf53968c089dc59732ac639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d13f6ee1f192d26a6f1c7ac1fed670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a51d13f6ee1f192d26a6f1c7ac1fed670">multiplyByFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u) const</td></tr>
<tr class="memdesc:a51d13f6ee1f192d26a6f1c7ac1fed670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task; see the main signature for documentation.  <a href="#a51d13f6ee1f192d26a6f1c7ac1fed670">More...</a><br /></td></tr>
<tr class="separator:a51d13f6ee1f192d26a6f1c7ac1fed670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed9e569f3d409734fc8930e9774e629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaed9e569f3d409734fc8930e9774e629">multiplyByFrameJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;F_GAo, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:aaed9e569f3d409734fc8930e9774e629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi.  <a href="#aaed9e569f3d409734fc8930e9774e629">More...</a><br /></td></tr>
<tr class="separator:aaed9e569f3d409734fc8930e9774e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c3a91c6786c60bc247b33051c04627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac7c3a91c6786c60bc247b33051c04627">multiplyByFrameJacobianTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;F_GAo, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:ac7c3a91c6786c60bc247b33051c04627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#ac7c3a91c6786c60bc247b33051c04627">More...</a><br /></td></tr>
<tr class="separator:ac7c3a91c6786c60bc247b33051c04627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cd2dc07b0e88b0a2db0689221ae1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a62cd2dc07b0e88b0a2db0689221ae1b9">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JF) const</td></tr>
<tr class="memdesc:a62cd2dc07b0e88b0a2db0689221ae1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}.  <a href="#a62cd2dc07b0e88b0a2db0689221ae1b9">More...</a><br /></td></tr>
<tr class="separator:a62cd2dc07b0e88b0a2db0689221ae1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac949f57c30f6653d374f057e4ef3f22b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac949f57c30f6653d374f057e4ef3f22b">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, <a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JF) const</td></tr>
<tr class="memdesc:ac949f57c30f6653d374f057e4ef3f22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#ac949f57c30f6653d374f057e4ef3f22b">More...</a><br /></td></tr>
<tr class="separator:ac949f57c30f6653d374f057e4ef3f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2c501d7903e69f96f649a459cb4b5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4a2c501d7903e69f96f649a459cb4b5c">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JF) const</td></tr>
<tr class="memdesc:a4a2c501d7903e69f96f649a459cb4b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix rather than as an nt X n Matrix of SpatialVecs.  <a href="#a4a2c501d7903e69f96f649a459cb4b5c">More...</a><br /></td></tr>
<tr class="separator:a4a2c501d7903e69f96f649a459cb4b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48c3cd7ad27f3f478957c34f8df06b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab48c3cd7ad27f3f478957c34f8df06b3">calcFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;JF) const</td></tr>
<tr class="memdesc:ab48c3cd7ad27f3f478957c34f8df06b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#ab48c3cd7ad27f3f478957c34f8df06b3">More...</a><br /></td></tr>
<tr class="separator:ab48c3cd7ad27f3f478957c34f8df06b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e44a33e1b5d0649aa2baff031841aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac9e44a33e1b5d0649aa2baff031841aa">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;JFDotu) const</td></tr>
<tr class="memdesc:ac9e44a33e1b5d0649aa2baff031841aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration bias term for a task frame Jacobian, that is, the parts of the frames' accelerations that are due only to velocities.  <a href="#ac9e44a33e1b5d0649aa2baff031841aa">More...</a><br /></td></tr>
<tr class="separator:ac9e44a33e1b5d0649aa2baff031841aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e983ee73ca90dae676f0f1386519b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a14e983ee73ca90dae676f0f1386519b6">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;onBodyB, const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;originAoInB, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;JFDotu) const</td></tr>
<tr class="memdesc:a14e983ee73ca90dae676f0f1386519b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature that returns the bias as a 6*nt-vector of scalars rather than as an nt-vector of SpatialVec elements.  <a href="#a14e983ee73ca90dae676f0f1386519b6">More...</a><br /></td></tr>
<tr class="separator:a14e983ee73ca90dae676f0f1386519b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c30c4ab145c9b11c6dba86f18f1057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a76c30c4ab145c9b11c6dba86f18f1057">calcBiasForFrameJacobian</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> onBodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;originAoInB) const</td></tr>
<tr class="memdesc:a76c30c4ab145c9b11c6dba86f18f1057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified signature for when you just have a single frame task.  <a href="#a76c30c4ab145c9b11c6dba86f18f1057">More...</a><br /></td></tr>
<tr class="separator:a76c30c4ab145c9b11c6dba86f18f1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System matrix manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The documentation for the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> describes the system equations in matrix notion, although internal computations are generally matrix-free.</p>
<p>The operators in this section provide the ability to perform fast operations that can be described in terms of those matrices (e.g., multiply by the mass matrix) but are actually done using O(n), matrix-free algorithms. There are also routines here for obtaining the matrices explicitly, although working with explicit matrices should be avoided whenever performance is an issue.</p>
<p>The mass matrix M and constraint matrix G are the most significant. G=[P;V;A] is composed of submatrices P for position (holonomic), V for velocity (nonholonomic), and A for acceleration-only constraints. These matrices are sometimes needed separately. Also, these matrices are all in mobility space (generalized speeds u). When qdot != u, the matrix N in the equation qdot = N*u becomes important and operators for working with it efficiently are also provided here. In that case, the position constraint matrix in generalized coordinate q space, Pq, can also be accessed. (In terms of the other matrices, Pq=P*N^-1.) </p>
</div></td></tr>
<tr class="memitem:a4c95c1922247ca717f8f5b4751bf704a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c95c1922247ca717f8f5b4751bf704a">multiplyByM</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;a, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Ma) const</td></tr>
<tr class="memdesc:a4c95c1922247ca717f8f5b4751bf704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a supplied mobility-space vector (that is, it has one entry for each of the n mobilities).  <a href="#a4c95c1922247ca717f8f5b4751bf704a">More...</a><br /></td></tr>
<tr class="separator:a4c95c1922247ca717f8f5b4751bf704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a06d5c75f71747d4fa479e7abfd3971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971">multiplyByMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;v, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;MinvV) const</td></tr>
<tr class="memdesc:a3a06d5c75f71747d4fa479e7abfd3971"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a supplied vector with one entry per u-space mobility.  <a href="#a3a06d5c75f71747d4fa479e7abfd3971">More...</a><br /></td></tr>
<tr class="separator:a3a06d5c75f71747d4fa479e7abfd3971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c974a8abcd50c0f1d662bdc2297ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a49c974a8abcd50c0f1d662bdc2297ea9">calcM</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;M) const</td></tr>
<tr class="memdesc:a49c974a8abcd50c0f1d662bdc2297ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator explicitly calculates the n X n mass matrix M.  <a href="#a49c974a8abcd50c0f1d662bdc2297ea9">More...</a><br /></td></tr>
<tr class="separator:a49c974a8abcd50c0f1d662bdc2297ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04118e791c39959f7a093cd5781f9ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5">calcMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;MInv) const</td></tr>
<tr class="memdesc:a04118e791c39959f7a093cd5781f9ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix corresponding to free (non-prescribed) mobilities.  <a href="#a04118e791c39959f7a093cd5781f9ab5">More...</a><br /></td></tr>
<tr class="separator:a04118e791c39959f7a093cd5781f9ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf833dd0d297247f53ad4b956f4d8455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf833dd0d297247f53ad4b956f4d8455">calcProjectedMInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;GMInvGt) const</td></tr>
<tr class="memdesc:abf833dd0d297247f53ad4b956f4d8455"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates in O(m*n) time the m X m "projected inverse mass 
matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the acceleration-level constraint Jacobian mapped to generalized coordinates, and M (nXn) is the unconstrained system mass matrix.  <a href="#abf833dd0d297247f53ad4b956f4d8455">More...</a><br /></td></tr>
<tr class="separator:abf833dd0d297247f53ad4b956f4d8455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482586922bb1c58bc309e1a0b3d501e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a482586922bb1c58bc309e1a0b3d501e0">solveForConstraintImpulses</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;deltaV, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;impulse) const</td></tr>
<tr class="memdesc:a482586922bb1c58bc309e1a0b3d501e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of desired constraint-space speed changes, calculate the corresponding constraint-space impulses that would cause those changes.  <a href="#a482586922bb1c58bc309e1a0b3d501e0">More...</a><br /></td></tr>
<tr class="separator:a482586922bb1c58bc309e1a0b3d501e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339a373cf4480657d982cef58ffe74c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1">multiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Gulike) const</td></tr>
<tr class="memdesc:a339a373cf4480657d982cef58ffe74c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a "u-like" (mobility space) vector of length n.  <a href="#a339a373cf4480657d982cef58ffe74c1">More...</a><br /></td></tr>
<tr class="separator:a339a373cf4480657d982cef58ffe74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c080bc497aaa4bc2251c79da222f770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c080bc497aaa4bc2251c79da222f770">multiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;ulike, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;Gulike) const</td></tr>
<tr class="memdesc:a4c080bc497aaa4bc2251c79da222f770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Gulike=G*ulike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature.  <a href="#a4c080bc497aaa4bc2251c79da222f770">More...</a><br /></td></tr>
<tr class="separator:a4c080bc497aaa4bc2251c79da222f770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4cbd990b2cfff54a8fba1048bf21da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5b4cbd990b2cfff54a8fba1048bf21da">calcBiasForMultiplyByG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias) const</td></tr>
<tr class="memdesc:a5b4cbd990b2cfff54a8fba1048bf21da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method above.  <a href="#a5b4cbd990b2cfff54a8fba1048bf21da">More...</a><br /></td></tr>
<tr class="separator:a5b4cbd990b2cfff54a8fba1048bf21da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b31f1a35d519d303c64ad82428f9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1b31f1a35d519d303c64ad82428f9ae">calcG</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;G) const</td></tr>
<tr class="memdesc:aa1b31f1a35d519d303c64ad82428f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which appears in the system equations of motion.  <a href="#aa1b31f1a35d519d303c64ad82428f9ae">More...</a><br /></td></tr>
<tr class="separator:aa1b31f1a35d519d303c64ad82428f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbb14fe7232d63df52e3f56fd69a2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afbbb14fe7232d63df52e3f56fd69a2a0">calcBiasForAccelerationConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;bias) const</td></tr>
<tr class="memdesc:afbbb14fe7232d63df52e3f56fd69a2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints that are independent of the accelerations.  <a href="#afbbb14fe7232d63df52e3f56fd69a2a0">More...</a><br /></td></tr>
<tr class="separator:afbbb14fe7232d63df52e3f56fd69a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6961b2e3be325a50acfc71e18e1cd9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6961b2e3be325a50acfc71e18e1cd9f">calcConstraintAccelerationErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUDot, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;pvaerr) const</td></tr>
<tr class="memdesc:af6961b2e3be325a50acfc71e18e1cd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a complete set of nu generalized accelerations udot, this operator computes the constraint acceleration errors that result due to the constraints currently active in the given state:  <a href="#af6961b2e3be325a50acfc71e18e1cd9f">More...</a><br /></td></tr>
<tr class="separator:af6961b2e3be325a50acfc71e18e1cd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9da182a2dd46ad4159b0e2cd7efb50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50">multiplyByGTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;lambda, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:a8a9da182a2dd46ad4159b0e2cd7efb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector <em>lambda</em> of length m, returning a generalized-force like quantity <em>f</em> of length n.  <a href="#a8a9da182a2dd46ad4159b0e2cd7efb50">More...</a><br /></td></tr>
<tr class="separator:a8a9da182a2dd46ad4159b0e2cd7efb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab790bd6457ec2cb8bfef5af104615d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab790bd6457ec2cb8bfef5af104615d06">calcGTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Gt) const</td></tr>
<tr class="memdesc:ab790bd6457ec2cb8bfef5af104615d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Jacobian G = [P;V;A] which appears in the system equations of motion.  <a href="#ab790bd6457ec2cb8bfef5af104615d06">More...</a><br /></td></tr>
<tr class="separator:ab790bd6457ec2cb8bfef5af104615d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2783382d7d735bc7451c13289a79bc0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e">multiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;PqXqlike) const</td></tr>
<tr class="memdesc:a2783382d7d735bc7451c13289a79bc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint Jacobian and <em>qlike</em> is a "q-like" (generalized coordinate space) vector of length nq.  <a href="#a2783382d7d735bc7451c13289a79bc0e">More...</a><br /></td></tr>
<tr class="separator:a2783382d7d735bc7451c13289a79bc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6748363efdd106d1d1e3b21850daf2a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6748363efdd106d1d1e3b21850daf2a3">multiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qlike, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;biasp, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;PqXqlike) const</td></tr>
<tr class="memdesc:a6748363efdd106d1d1e3b21850daf2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Pq*qlike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature.  <a href="#a6748363efdd106d1d1e3b21850daf2a3">More...</a><br /></td></tr>
<tr class="separator:a6748363efdd106d1d1e3b21850daf2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c88d0bceee265e0e9b8d21b6c2e21c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5c88d0bceee265e0e9b8d21b6c2e21c7">calcBiasForMultiplyByPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;biasp) const</td></tr>
<tr class="memdesc:a5c88d0bceee265e0e9b8d21b6c2e21c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method above.  <a href="#a5c88d0bceee265e0e9b8d21b6c2e21c7">More...</a><br /></td></tr>
<tr class="separator:a5c88d0bceee265e0e9b8d21b6c2e21c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df63f08ff4e61cf541250971ad1ebe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2df63f08ff4e61cf541250971ad1ebe7">calcPq</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pq) const</td></tr>
<tr class="memdesc:a2df63f08ff4e61cf541250971ad1ebe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q.  <a href="#a2df63f08ff4e61cf541250971ad1ebe7">More...</a><br /></td></tr>
<tr class="separator:a2df63f08ff4e61cf541250971ad1ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad550234e8e7081f3e67e26beab104361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad550234e8e7081f3e67e26beab104361">multiplyByPqTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;lambdap, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;f) const</td></tr>
<tr class="memdesc:ad550234e8e7081f3e67e26beab104361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like vector <em>lambdap</em> of length mp, returning a generalized-force like quantity <em>f</em> of length n.  <a href="#ad550234e8e7081f3e67e26beab104361">More...</a><br /></td></tr>
<tr class="separator:ad550234e8e7081f3e67e26beab104361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d82fc3bc298f54c4cb1b24b672700e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1d82fc3bc298f54c4cb1b24b672700e9">calcPqTranspose</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pqt) const</td></tr>
<tr class="memdesc:a1d82fc3bc298f54c4cb1b24b672700e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This O(m*n) operator explicitly calculates the nq X mp transpose of the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q.  <a href="#a1d82fc3bc298f54c4cb1b24b672700e9">More...</a><br /></td></tr>
<tr class="separator:a1d82fc3bc298f54c4cb1b24b672700e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05664f6c7aa4e1b436656001ca5672e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05664f6c7aa4e1b436656001ca5672e0">calcP</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;P) const</td></tr>
<tr class="memdesc:a05664f6c7aa4e1b436656001ca5672e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (position) constraint errors with respect to the generalized speeds u; that is, P = partial( dperr/dt )/partial(u).  <a href="#a05664f6c7aa4e1b436656001ca5672e0">More...</a><br /></td></tr>
<tr class="separator:a05664f6c7aa4e1b436656001ca5672e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb15c6d72fcea701419624a26d786d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9bb15c6d72fcea701419624a26d786d6">calcPt</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;Pt) const</td></tr>
<tr class="memdesc:a9bb15c6d72fcea701419624a26d786d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nu X mp matrix ~P - see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05664f6c7aa4e1b436656001ca5672e0" title="Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (pos...">calcP()</a> for a description.  <a href="#a9bb15c6d72fcea701419624a26d786d6">More...</a><br /></td></tr>
<tr class="separator:a9bb15c6d72fcea701419624a26d786d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce701c8a6ca9a0b1caa681869371725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#acce701c8a6ca9a0b1caa681869371725">multiplyByN</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const</td></tr>
<tr class="memdesc:acce701c8a6ca9a0b1caa681869371725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q.  <a href="#acce701c8a6ca9a0b1caa681869371725">More...</a><br /></td></tr>
<tr class="separator:acce701c8a6ca9a0b1caa681869371725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c72df92eda36381a60e046a15ab30d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a37c72df92eda36381a60e046a15ab30d">multiplyByNInv</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const</td></tr>
<tr class="memdesc:a37c72df92eda36381a60e046a15ab30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u.  <a href="#a37c72df92eda36381a60e046a15ab30d">More...</a><br /></td></tr>
<tr class="separator:a37c72df92eda36381a60e046a15ab30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7369407ac98084b84b800e3a4a0c8ae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7369407ac98084b84b800e3a4a0c8ae2">multiplyByNDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, bool <a class="el" href="namespaceSimTK.html#a8279fd7a157b0f4078ea245377484d82">transpose</a>, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;in, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;out) const</td></tr>
<tr class="memdesc:a7369407ac98084b84b800e3a4a0c8ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q.  <a href="#a7369407ac98084b84b800e3a4a0c8ae2">More...</a><br /></td></tr>
<tr class="separator:a7369407ac98084b84b800e3a4a0c8ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous Operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Operators make use of the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> but do not write their results back into the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>, although they may realize the lazy-evaluation cache entries containing articulated body inertias and related computations.</p>
<p>If you want to avoid any implicit cache updates, use the explicit realization methods <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5f4f7709391f21a0e8298ed314c6161d" title="(Advanced) This method ensures that velocity-dependent computations that also depend on articulated b...">realizeArticulatedBodyVelocity()</a> first to force those computations to complete. </p>
</div></td></tr>
<tr class="memitem:a20b53ec5f00a7141a7486cc34998214f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20b53ec5f00a7141a7486cc34998214f">calcAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const</td></tr>
<tr class="memdesc:a20b53ec5f00a7141a7486cc34998214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the primary forward dynamics operator.  <a href="#a20b53ec5f00a7141a7486cc34998214f">More...</a><br /></td></tr>
<tr class="separator:a20b53ec5f00a7141a7486cc34998214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698a398ed2c0ca9b8ecb0b0d8b56fe2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a698a398ed2c0ca9b8ecb0b0d8b56fe2f">calcAccelerationIgnoringConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const</td></tr>
<tr class="memdesc:a698a398ed2c0ca9b8ecb0b0d8b56fe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator is similar to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20b53ec5f00a7141a7486cc34998214f" title="This is the primary forward dynamics operator. ">calcAcceleration()</a> but ignores the effects of acceleration constraints although it obeys prescribed accelerations.  <a href="#a698a398ed2c0ca9b8ecb0b0d8b56fe2f">More...</a><br /></td></tr>
<tr class="separator:a698a398ed2c0ca9b8ecb0b0d8b56fe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a93fe311723421ff87117ab65f8f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a29a93fe311723421ff87117ab65f8f81">calcResidualForceIgnoringConstraints</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUdot, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;residualMobilityForces) const</td></tr>
<tr class="memdesc:a29a93fe311723421ff87117ab65f8f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed motion they are ignored.  <a href="#a29a93fe311723421ff87117ab65f8f81">More...</a><br /></td></tr>
<tr class="separator:a29a93fe311723421ff87117ab65f8f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d70c8d0efb3850781dff2483a4cf017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d70c8d0efb3850781dff2483a4cf017">calcResidualForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;appliedMobilityForces, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;appliedBodyForces, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUdot, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownLambda, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;residualMobilityForces) const</td></tr>
<tr class="memdesc:a2d70c8d0efb3850781dff2483a4cf017"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the inverse dynamics operator for when you know both the accelerations and Lagrange multipliers for a constrained system.  <a href="#a2d70c8d0efb3850781dff2483a4cf017">More...</a><br /></td></tr>
<tr class="separator:a2d70c8d0efb3850781dff2483a4cf017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1097a191bdaa113ca97a875fc35ab96b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1097a191bdaa113ca97a875fc35ab96b">calcCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;R) const</td></tr>
<tr class="memdesc:a1097a191bdaa113ca97a875fc35ab96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator calculates the composite body inertias R given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized to Position stage.  <a href="#a1097a191bdaa113ca97a875fc35ab96b">More...</a><br /></td></tr>
<tr class="separator:a1097a191bdaa113ca97a875fc35ab96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c340ca99cb804e9e33d736dfa43c066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3c340ca99cb804e9e33d736dfa43c066">calcBodyAccelerationFromUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;knownUDot, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;A_GB) const</td></tr>
<tr class="memdesc:a3c340ca99cb804e9e33d736dfa43c066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) time the resulting body accelerations, including velocity-dependent terms taken from the supplied <em>state</em>.  <a href="#a3c340ca99cb804e9e33d736dfa43c066">More...</a><br /></td></tr>
<tr class="separator:a3c340ca99cb804e9e33d736dfa43c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bb7bcb8f73340ba63264bffb591ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a67bb7bcb8f73340ba63264bffb591ce7">calcConstraintForcesFromMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;multipliers, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const</td></tr>
<tr class="memdesc:a67bb7bcb8f73340ba63264bffb591ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treating all Constraints together, given a comprehensive set of m Lagrange multipliers <em>lambda</em>, generate the complete set of body spatial forces and mobility (generalized) forces applied by all the Constraints.  <a href="#a67bb7bcb8f73340ba63264bffb591ce7">More...</a><br /></td></tr>
<tr class="separator:a67bb7bcb8f73340ba63264bffb591ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af1e68128d882eebf1cd213640136aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1af1e68128d882eebf1cd213640136aa">calcMobilizerReactionForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;forcesAtMInG) const</td></tr>
<tr class="memdesc:a1af1e68128d882eebf1cd213640136aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the mobilizer reaction force generated at each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, as felt at the mobilizer's outboard frame M, and expressed in Ground.  <a href="#a1af1e68128d882eebf1cd213640136aa">More...</a><br /></td></tr>
<tr class="separator:a1af1e68128d882eebf1cd213640136aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89024a1ccf3f7d13bfb003ec80ac6f78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a89024a1ccf3f7d13bfb003ec80ac6f78">getMotionMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a89024a1ccf3f7d13bfb003ec80ac6f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the prescribed motion multipliers tau that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage.  <a href="#a89024a1ccf3f7d13bfb003ec80ac6f78">More...</a><br /></td></tr>
<tr class="separator:a89024a1ccf3f7d13bfb003ec80ac6f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b67fe155e25c8fb8ed341ffc6bde87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af4b67fe155e25c8fb8ed341ffc6bde87">calcMotionErrors</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;stage) const</td></tr>
<tr class="memdesc:af4b67fe155e25c8fb8ed341ffc6bde87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the degree to which the supplied <em>state</em> does not satisfy the prescribed motion requirements at a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>.  <a href="#af4b67fe155e25c8fb8ed341ffc6bde87">More...</a><br /></td></tr>
<tr class="separator:af4b67fe155e25c8fb8ed341ffc6bde87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db9db9729840c852fb16d2f196c59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af2db9db9729840c852fb16d2f196c59c">findMotionForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const</td></tr>
<tr class="memdesc:af2db9db9729840c852fb16d2f196c59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the generalized mobility space forces produced by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects active in this system.  <a href="#af2db9db9729840c852fb16d2f196c59c">More...</a><br /></td></tr>
<tr class="separator:af2db9db9729840c852fb16d2f196c59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeee63950e043cea04181318328489a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2aeee63950e043cea04181318328489a">getConstraintMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a2aeee63950e043cea04181318328489a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the constraint multipliers lambda that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage.  <a href="#a2aeee63950e043cea04181318328489a">More...</a><br /></td></tr>
<tr class="separator:a2aeee63950e043cea04181318328489a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaa035261197f6c1573a42d5ad003d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#accaa035261197f6c1573a42d5ad003d9">findConstraintForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const</td></tr>
<tr class="memdesc:accaa035261197f6c1573a42d5ad003d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the forces produced by all the active <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects in this system.  <a href="#accaa035261197f6c1573a42d5ad003d9">More...</a><br /></td></tr>
<tr class="separator:accaa035261197f6c1573a42d5ad003d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485e5ec94f8cd01e5e2e0f0e487ed046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a485e5ec94f8cd01e5e2e0f0e487ed046">calcMotionPower</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a485e5ec94f8cd01e5e2e0f0e487ed046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the power being generated or dissipated by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects currently active in this system.  <a href="#a485e5ec94f8cd01e5e2e0f0e487ed046">More...</a><br /></td></tr>
<tr class="separator:a485e5ec94f8cd01e5e2e0f0e487ed046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ec0203f2a334f39bb84c0331e0c795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af8ec0203f2a334f39bb84c0331e0c795">calcConstraintPower</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:af8ec0203f2a334f39bb84c0331e0c795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the power begin generated or dissipated by all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects currently active in this system.  <a href="#af8ec0203f2a334f39bb84c0331e0c795">More...</a><br /></td></tr>
<tr class="separator:af8ec0203f2a334f39bb84c0331e0c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46868b7cd5b218ffdf71caf527f74ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a46868b7cd5b218ffdf71caf527f74ef1">calcTreeEquivalentMobilityForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForces, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const</td></tr>
<tr class="memdesc:a46868b7cd5b218ffdf71caf527f74ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accounts for applied forces and inertial forces produced by non-zero velocities in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>.  <a href="#a46868b7cd5b218ffdf71caf527f74ef1">More...</a><br /></td></tr>
<tr class="separator:a46868b7cd5b218ffdf71caf527f74ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfa39aaf358b954690b5597e9607668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abbfa39aaf358b954690b5597e9607668">calcQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qdot) const</td></tr>
<tr class="memdesc:abbfa39aaf358b954690b5597e9607668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate qdot = N(q)*u in O(n) time (very fast).  <a href="#abbfa39aaf358b954690b5597e9607668">More...</a><br /></td></tr>
<tr class="separator:abbfa39aaf358b954690b5597e9607668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e56cf73148b15f8aeb47da72e2b0258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e56cf73148b15f8aeb47da72e2b0258">calcQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;udot, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qdotdot) const</td></tr>
<tr class="memdesc:a5e56cf73148b15f8aeb47da72e2b0258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast).  <a href="#a5e56cf73148b15f8aeb47da72e2b0258">More...</a><br /></td></tr>
<tr class="separator:a5e56cf73148b15f8aeb47da72e2b0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf84f7d5ee84ea774fe51e5c806a39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aadf84f7d5ee84ea774fe51e5c806a39f">addInStationForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> bodyB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;stationOnB, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;forceInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const</td></tr>
<tr class="memdesc:aadf84f7d5ee84ea774fe51e5c806a39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given body forces vector a force applied to a station (fixed point) S on a body B.  <a href="#aadf84f7d5ee84ea774fe51e5c806a39f">More...</a><br /></td></tr>
<tr class="separator:aadf84f7d5ee84ea774fe51e5c806a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11bc0dabe8467999e1e6f60bbcb5168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac11bc0dabe8467999e1e6f60bbcb5168">addInBodyTorque</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;torqueInG, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;bodyForcesInG) const</td></tr>
<tr class="memdesc:ac11bc0dabe8467999e1e6f60bbcb5168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given body forces vector a torque applied to a body B.  <a href="#ac11bc0dabe8467999e1e6f60bbcb5168">More...</a><br /></td></tr>
<tr class="separator:ac11bc0dabe8467999e1e6f60bbcb5168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae351805996c27b1a178b244226c4be37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae351805996c27b1a178b244226c4be37">addInMobilityForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mobodIx, <a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a> which, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> f, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;mobilityForces) const</td></tr>
<tr class="memdesc:ae351805996c27b1a178b244226c4be37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in to the given mobility forces vector a scalar generalized force, that is a force or torque applied to a mobilizer generalized speed.  <a href="#ae351805996c27b1a178b244226c4be37">More...</a><br /></td></tr>
<tr class="separator:ae351805996c27b1a178b244226c4be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Realization and response methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Realization methods request that some calculation be performed ("realized") if it has not already been done since the last change to one of the state variables on which the result depends, with the result being placed in the state cache.</p>
<p>Methods beginning with "get" are called <em>responses</em> and are used to extract pre-calculated information that has been realized into the cache.</p>
<p>Realization is normally initiated at the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> level. However, there are some "lazy" calculations in the SimbodyMatterSubsystem whose computations are delayed until needed; you can cause those calculations to be performed explicitly here if you want. </p>
</div></td></tr>
<tr class="memitem:afe15082955cdd01993a0bc8b390ed314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314">realizePositionKinematics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:afe15082955cdd01993a0bc8b390ed314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position kinematics is the first part of the <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a> realization, mapping generalized coordinates q to the spatial (Cartesian) poses of the mobilized bodies.  <a href="#afe15082955cdd01993a0bc8b390ed314">More...</a><br /></td></tr>
<tr class="separator:afe15082955cdd01993a0bc8b390ed314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d6e1a94635f1866523ac2788a27fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae3d6e1a94635f1866523ac2788a27fe2">realizeVelocityKinematics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae3d6e1a94635f1866523ac2788a27fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity kinematics is the first part of the <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a> realization, mapping generalized speeds u to the spatial (Cartesian) velocities of the mobilized bodies.  <a href="#ae3d6e1a94635f1866523ac2788a27fe2">More...</a><br /></td></tr>
<tr class="separator:ae3d6e1a94635f1866523ac2788a27fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeb334d652c5d87a7939faff9816706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706">realizeCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a5aeb334d652c5d87a7939faff9816706"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies.  <a href="#a5aeb334d652c5d87a7939faff9816706">More...</a><br /></td></tr>
<tr class="separator:a5aeb334d652c5d87a7939faff9816706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89fcf89490662254306e34157409010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010">realizeArticulatedBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ab89fcf89490662254306e34157409010"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method ensures that articulated body inertias (ABIs) are up to date with the most recent change to the configuration state variables q.  <a href="#ab89fcf89490662254306e34157409010">More...</a><br /></td></tr>
<tr class="separator:ab89fcf89490662254306e34157409010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f7709391f21a0e8298ed314c6161d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5f4f7709391f21a0e8298ed314c6161d">realizeArticulatedBodyVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a5f4f7709391f21a0e8298ed314c6161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This method ensures that velocity-dependent computations that also depend on articulated body inertias (ABIs) are up to date with the most recent changes to the configuration state variables q and velocity state variables u.  <a href="#a5f4f7709391f21a0e8298ed314c6161d">More...</a><br /></td></tr>
<tr class="separator:a5f4f7709391f21a0e8298ed314c6161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea863219c3efaff939c5ce79e77609a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1QIndex.html">QIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afea863219c3efaff939c5ce79e77609a">getFreeQIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:afea863219c3efaff939c5ce79e77609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>.  <a href="#afea863219c3efaff939c5ce79e77609a">More...</a><br /></td></tr>
<tr class="separator:afea863219c3efaff939c5ce79e77609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05833768270670f8987dad99eaf5b893"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05833768270670f8987dad99eaf5b893">getFreeUIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a05833768270670f8987dad99eaf5b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>.  <a href="#a05833768270670f8987dad99eaf5b893">More...</a><br /></td></tr>
<tr class="separator:a05833768270670f8987dad99eaf5b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88218b5302c36e8b5b08572da4a7fd21"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88218b5302c36e8b5b08572da4a7fd21">getFreeUDotIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a88218b5302c36e8b5b08572da4a7fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the generalized speeds whose time derivatives udot are unknown, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>.  <a href="#a88218b5302c36e8b5b08572da4a7fd21">More...</a><br /></td></tr>
<tr class="separator:a88218b5302c36e8b5b08572da4a7fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35d28f22f08a16c3f159297d213ff05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1UIndex.html">UIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae35d28f22f08a16c3f159297d213ff05">getKnownUDotIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:ae35d28f22f08a16c3f159297d213ff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the generalized speeds whose time derivatives udot are known, that is, locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>.  <a href="#ae35d28f22f08a16c3f159297d213ff05">More...</a><br /></td></tr>
<tr class="separator:ae35d28f22f08a16c3f159297d213ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f6ca2125eaa88294ebf3f3c8730f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a99f6ca2125eaa88294ebf3f3c8730f03">packFreeQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;allQ, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeQ) const</td></tr>
<tr class="memdesc:a99f6ca2125eaa88294ebf3f3c8730f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a generalized coordinate (q-space) Vector, select only those elements that are free (in the sense of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afea863219c3efaff939c5ce79e77609a" title="Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with ...">getFreeQIndex()</a>) and pack them in order into <code>packedFreeQ</code>, which must already be allocated to the correct length, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afea863219c3efaff939c5ce79e77609a" title="Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with ...">getFreeQIndex()</a>.size().  <a href="#a99f6ca2125eaa88294ebf3f3c8730f03">More...</a><br /></td></tr>
<tr class="separator:a99f6ca2125eaa88294ebf3f3c8730f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cb8530eafe8a39a0a133e6121cd9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a96cb8530eafe8a39a0a133e6121cd9b3">unpackFreeQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeQ, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;unpackedFreeQ) const</td></tr>
<tr class="memdesc:a96cb8530eafe8a39a0a133e6121cd9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a free-q Vector, unpack it into a q-space Vector which must already be allocated to the correct size.  <a href="#a96cb8530eafe8a39a0a133e6121cd9b3">More...</a><br /></td></tr>
<tr class="separator:a96cb8530eafe8a39a0a133e6121cd9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897fd865f47e78c32ea8bd92c13d91f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a897fd865f47e78c32ea8bd92c13d91f7">packFreeU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;allU, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeU) const</td></tr>
<tr class="memdesc:a897fd865f47e78c32ea8bd92c13d91f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a generalized speed (u- or mobility-space) Vector, select only those elements that are free (in the sense of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05833768270670f8987dad99eaf5b893" title="Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a Mot...">getFreeUIndex()</a>) and pack them in order into <code>packedFreeU</code>, which must already be allocated to the correct length, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05833768270670f8987dad99eaf5b893" title="Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a Mot...">getFreeUIndex()</a>.size().  <a href="#a897fd865f47e78c32ea8bd92c13d91f7">More...</a><br /></td></tr>
<tr class="separator:a897fd865f47e78c32ea8bd92c13d91f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59f9970c953c359dfdb6a5a0d36ca43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa59f9970c953c359dfdb6a5a0d36ca43">unpackFreeU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;packedFreeU, <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;unpackedFreeU) const</td></tr>
<tr class="memdesc:aa59f9970c953c359dfdb6a5a0d36ca43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a free-u Vector, unpack it into a u-space Vector which must already be allocated to the correct size.  <a href="#aa59f9970c953c359dfdb6a5a0d36ca43">More...</a><br /></td></tr>
<tr class="separator:aa59f9970c953c359dfdb6a5a0d36ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066a9473c79c1acbbd725b9eed6d1b0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a066a9473c79c1acbbd725b9eed6d1b0b">getCompositeBodyInertia</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:a066a9473c79c1acbbd725b9eed6d1b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the composite body inertia (CBI) R for a particular mobilized body.  <a href="#a066a9473c79c1acbbd725b9eed6d1b0b">More...</a><br /></td></tr>
<tr class="separator:a066a9473c79c1acbbd725b9eed6d1b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e5694de1803375055b78d60616acf7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#ab1473db0cef6d6f29b827de9f1b3cb9f">ArticulatedInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad1e5694de1803375055b78d60616acf7">getArticulatedBodyInertia</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:ad1e5694de1803375055b78d60616acf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the articulated body inertia (ABI) P for a particular mobilized body.  <a href="#ad1e5694de1803375055b78d60616acf7">More...</a><br /></td></tr>
<tr class="separator:ad1e5694de1803375055b78d60616acf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535addf33054ebf04b7fe4a15fb41891"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a535addf33054ebf04b7fe4a15fb41891">getGyroscopicForce</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:a535addf33054ebf04b7fe4a15fb41891"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the rotational velocity-dependent force <code>b</code> on the body due to rotational inertia.  <a href="#a535addf33054ebf04b7fe4a15fb41891">More...</a><br /></td></tr>
<tr class="separator:a535addf33054ebf04b7fe4a15fb41891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa902ae99663524016c0c037cbe25678d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa902ae99663524016c0c037cbe25678d">getMobilizerCoriolisAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:aa902ae99663524016c0c037cbe25678d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <em>cross-mobilizer</em> incremental contribution <code>A</code> to the Coriolis (angular velocity dependent) acceleration of a particular mobilized body; it is not too useful except as an intermediate calculation for more interesting quantities &ndash; you are probably interested in <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a> instead.  <a href="#aa902ae99663524016c0c037cbe25678d">More...</a><br /></td></tr>
<tr class="separator:aa902ae99663524016c0c037cbe25678d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924f05c60c6b21db34cc54e56ed28d51"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51">getTotalCoriolisAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:a924f05c60c6b21db34cc54e56ed28d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total Coriolis acceleration of a particular mobilized body, including the effect of the parent's angular velocity as well as the mobilizer's.  <a href="#a924f05c60c6b21db34cc54e56ed28d51">More...</a><br /></td></tr>
<tr class="separator:a924f05c60c6b21db34cc54e56ed28d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35935a456ddf2d7193bdd9175f8082a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad35935a456ddf2d7193bdd9175f8082a">getTotalCentrifugalForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:ad35935a456ddf2d7193bdd9175f8082a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the total rotational velocity-dependent force acting on this body B, including forces due to Coriolis acceleration and gyroscopic forces due to rotational inertia.  <a href="#ad35935a456ddf2d7193bdd9175f8082a">More...</a><br /></td></tr>
<tr class="separator:ad35935a456ddf2d7193bdd9175f8082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Testing and debugging utilities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section provide alternate ways of calculating quantities for which we provide more efficient methods above.</p>
<p>You should use the better methods normally, but these can be very useful for regression testing and Simbody development because the answers are obtained differently. Numerical results should agree with the faster methods to within numerical precision. </p>
</div></td></tr>
<tr class="memitem:a92f4107db4cd697fbbea6064c9769770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a92f4107db4cd697fbbea6064c9769770">calcMobilizerReactionForcesUsingFreebodyMethod</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;forcesAtMInG) const</td></tr>
<tr class="memdesc:a92f4107db4cd697fbbea6064c9769770"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a slower alternative to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1af1e68128d882eebf1cd213640136aa" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>, for use in regression testing and Simbody development.  <a href="#a92f4107db4cd697fbbea6064c9769770">More...</a><br /></td></tr>
<tr class="separator:a92f4107db4cd697fbbea6064c9769770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ad897ab748ef0fb1f8118da3488310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a26ad897ab748ef0fb1f8118da3488310">invalidatePositionKinematics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a26ad897ab748ef0fb1f8118da3488310"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of position kinematics, which otherwise remains valid until an instance-stage variable or a generalized coordinate q is modified.  <a href="#a26ad897ab748ef0fb1f8118da3488310">More...</a><br /></td></tr>
<tr class="separator:a26ad897ab748ef0fb1f8118da3488310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6524e4441791639ccea7922c7ef05ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6524e4441791639ccea7922c7ef05ae">isPositionKinematicsRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:af6524e4441791639ccea7922c7ef05ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether position kinematics has already been realized.  <a href="#af6524e4441791639ccea7922c7ef05ae">More...</a><br /></td></tr>
<tr class="separator:af6524e4441791639ccea7922c7ef05ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e6bc6be5137475bb5a7d042c30abc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a38e6bc6be5137475bb5a7d042c30abc4">invalidateVelocityKinematics</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a38e6bc6be5137475bb5a7d042c30abc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of velocity kinematics, which otherwise remains valid until an instance-stage variable, generalized coordinate q, or generalized speed u is modified, or if PositionKinematics is explicitly invalidated.  <a href="#a38e6bc6be5137475bb5a7d042c30abc4">More...</a><br /></td></tr>
<tr class="separator:a38e6bc6be5137475bb5a7d042c30abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a6dc6be701b48912ef810dfb2d4178"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a60a6dc6be701b48912ef810dfb2d4178">isVelocityKinematicsRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a60a6dc6be701b48912ef810dfb2d4178"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether velocity kinematics has already been realized.  <a href="#a60a6dc6be701b48912ef810dfb2d4178">More...</a><br /></td></tr>
<tr class="separator:a60a6dc6be701b48912ef810dfb2d4178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60342f4ac0206fdcc69cd2c9ec9e7edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a60342f4ac0206fdcc69cd2c9ec9e7edb">invalidateCompositeBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a60342f4ac0206fdcc69cd2c9ec9e7edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly.  <a href="#a60342f4ac0206fdcc69cd2c9ec9e7edb">More...</a><br /></td></tr>
<tr class="separator:a60342f4ac0206fdcc69cd2c9ec9e7edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac8ae03c63624316b52e6308d44c095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afac8ae03c63624316b52e6308d44c095">isCompositeBodyInertiasRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:afac8ae03c63624316b52e6308d44c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether composite body inertias have already been realized.  <a href="#afac8ae03c63624316b52e6308d44c095">More...</a><br /></td></tr>
<tr class="separator:afac8ae03c63624316b52e6308d44c095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e93d47be0cf6d154c79f5abbf77dc8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3e93d47be0cf6d154c79f5abbf77dc8d">invalidateArticulatedBodyInertias</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a3e93d47be0cf6d154c79f5abbf77dc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of articulated body inertias (ABIs), which otherwise remain valid until a position-stage variable is modified or any other prerequisite is invalidated.  <a href="#a3e93d47be0cf6d154c79f5abbf77dc8d">More...</a><br /></td></tr>
<tr class="separator:a3e93d47be0cf6d154c79f5abbf77dc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f79736449b361d0dc6d8163956cb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88f79736449b361d0dc6d8163956cb14">isArticulatedBodyInertiasRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a88f79736449b361d0dc6d8163956cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether articulated body inertias have already been realized.  <a href="#a88f79736449b361d0dc6d8163956cb14">More...</a><br /></td></tr>
<tr class="separator:a88f79736449b361d0dc6d8163956cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ec5fcfd3c4bf69e07f910398c711e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a517ec5fcfd3c4bf69e07f910398c711e">invalidateArticulatedBodyVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a517ec5fcfd3c4bf69e07f910398c711e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of articulated body velocity computations, which otherwise remain valid until a velocity- or position-stage variable is modified or any other prerequisite is invalidated.  <a href="#a517ec5fcfd3c4bf69e07f910398c711e">More...</a><br /></td></tr>
<tr class="separator:a517ec5fcfd3c4bf69e07f910398c711e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b53d7cb079d2725630a07a88ee6ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae6b53d7cb079d2725630a07a88ee6ce5">isArticulatedBodyVelocityRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ae6b53d7cb079d2725630a07a88ee6ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Check whether articulated body velocity computations have already been realized.  <a href="#ae6b53d7cb079d2725630a07a88ee6ce5">More...</a><br /></td></tr>
<tr class="separator:ae6b53d7cb079d2725630a07a88ee6ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Proposed particle API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>(NOT IMPLEMENTED YET) These methods are a proposed API for explicit handling of particles.</p>
<p>Currently a particle should be implemented as point mass with a Cartesian (translation) mobilizer to Ground instead. The idea here would be to special-case particles to make them faster; there would be no additional functionality. </p>
</div></td></tr>
<tr class="memitem:a70dda1803dd267a0ff8fd2ead9d87d43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a70dda1803dd267a0ff8fd2ead9d87d43">getNumParticles</a> () const</td></tr>
<tr class="memdesc:a70dda1803dd267a0ff8fd2ead9d87d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a70dda1803dd267a0ff8fd2ead9d87d43">More...</a><br /></td></tr>
<tr class="separator:a70dda1803dd267a0ff8fd2ead9d87d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7568dedc65e4192f352941ce2c1b9204"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7568dedc65e4192f352941ce2c1b9204">getAllParticleLocations</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a7568dedc65e4192f352941ce2c1b9204"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a7568dedc65e4192f352941ce2c1b9204">More...</a><br /></td></tr>
<tr class="separator:a7568dedc65e4192f352941ce2c1b9204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e889523956b3298623c9c188611f04d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0e889523956b3298623c9c188611f04d">getAllParticleVelocities</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a0e889523956b3298623c9c188611f04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a0e889523956b3298623c9c188611f04d">More...</a><br /></td></tr>
<tr class="separator:a0e889523956b3298623c9c188611f04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7e5f0273577de86575f69780d20137"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a7e5f0273577de86575f69780d20137">getParticleLocation</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const</td></tr>
<tr class="memdesc:a8a7e5f0273577de86575f69780d20137"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a8a7e5f0273577de86575f69780d20137">More...</a><br /></td></tr>
<tr class="separator:a8a7e5f0273577de86575f69780d20137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab12bf1f46e3d6a4b51fc29f74dcee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a25ab12bf1f46e3d6a4b51fc29f74dcee">getParticleVelocity</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const</td></tr>
<tr class="memdesc:a25ab12bf1f46e3d6a4b51fc29f74dcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a25ab12bf1f46e3d6a4b51fc29f74dcee">More...</a><br /></td></tr>
<tr class="separator:a25ab12bf1f46e3d6a4b51fc29f74dcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6303ed78859b5caed9890fdaa6c5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2f6303ed78859b5caed9890fdaa6c5d0">updAllParticleMasses</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="memdesc:a2f6303ed78859b5caed9890fdaa6c5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a2f6303ed78859b5caed9890fdaa6c5d0">More...</a><br /></td></tr>
<tr class="separator:a2f6303ed78859b5caed9890fdaa6c5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1fe7f8546288976f36f63c8880eff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7e1fe7f8546288976f36f63c8880eff3">setAllParticleMasses</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;masses) const</td></tr>
<tr class="memdesc:a7e1fe7f8546288976f36f63c8880eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a7e1fe7f8546288976f36f63c8880eff3">More...</a><br /></td></tr>
<tr class="separator:a7e1fe7f8546288976f36f63c8880eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e937177c779bd66adc9479bfdf40f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0e937177c779bd66adc9479bfdf40f0d">updAllParticleLocations</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a0e937177c779bd66adc9479bfdf40f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a0e937177c779bd66adc9479bfdf40f0d">More...</a><br /></td></tr>
<tr class="separator:a0e937177c779bd66adc9479bfdf40f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863d0cec4aa678a4f2ad15e3361bc18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad863d0cec4aa678a4f2ad15e3361bc18">updAllParticleVelocities</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:ad863d0cec4aa678a4f2ad15e3361bc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ad863d0cec4aa678a4f2ad15e3361bc18">More...</a><br /></td></tr>
<tr class="separator:ad863d0cec4aa678a4f2ad15e3361bc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773653c6df2b82b3ab3af862323875fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a773653c6df2b82b3ab3af862323875fb">updParticleLocation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const</td></tr>
<tr class="memdesc:a773653c6df2b82b3ab3af862323875fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a773653c6df2b82b3ab3af862323875fb">More...</a><br /></td></tr>
<tr class="separator:a773653c6df2b82b3ab3af862323875fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3cf54f24cbe78c0f69cf985cb55d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6f3cf54f24cbe78c0f69cf985cb55d01">updParticleVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const</td></tr>
<tr class="memdesc:a6f3cf54f24cbe78c0f69cf985cb55d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a6f3cf54f24cbe78c0f69cf985cb55d01">More...</a><br /></td></tr>
<tr class="separator:a6f3cf54f24cbe78c0f69cf985cb55d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d413858e567337af53555890ee0a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae9d413858e567337af53555890ee0a4a">setParticleLocation</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;r) const</td></tr>
<tr class="memdesc:ae9d413858e567337af53555890ee0a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ae9d413858e567337af53555890ee0a4a">More...</a><br /></td></tr>
<tr class="separator:ae9d413858e567337af53555890ee0a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d75c972ca647b8f87a7971aa8f41821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6d75c972ca647b8f87a7971aa8f41821">setParticleVelocity</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;v) const</td></tr>
<tr class="memdesc:a6d75c972ca647b8f87a7971aa8f41821"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a6d75c972ca647b8f87a7971aa8f41821">More...</a><br /></td></tr>
<tr class="separator:a6d75c972ca647b8f87a7971aa8f41821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccdf701488ba7b30e854ef0d7d71980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abccdf701488ba7b30e854ef0d7d71980">setAllParticleLocations</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;r) const</td></tr>
<tr class="memdesc:abccdf701488ba7b30e854ef0d7d71980"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#abccdf701488ba7b30e854ef0d7d71980">More...</a><br /></td></tr>
<tr class="separator:abccdf701488ba7b30e854ef0d7d71980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01835793e11406321e24d5fd2e6737e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a01835793e11406321e24d5fd2e6737e7">setAllParticleVelocities</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;v) const</td></tr>
<tr class="memdesc:a01835793e11406321e24d5fd2e6737e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a01835793e11406321e24d5fd2e6737e7">More...</a><br /></td></tr>
<tr class="separator:a01835793e11406321e24d5fd2e6737e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30501d4d3438031f43660158ec1b3a73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a30501d4d3438031f43660158ec1b3a73">getAllParticleMasses</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:a30501d4d3438031f43660158ec1b3a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#a30501d4d3438031f43660158ec1b3a73">More...</a><br /></td></tr>
<tr class="separator:a30501d4d3438031f43660158ec1b3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbbca20710f38a6f9ff4f303310d5b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abcbbca20710f38a6f9ff4f303310d5b2">getAllParticleAccelerations</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;) const</td></tr>
<tr class="memdesc:abcbbca20710f38a6f9ff4f303310d5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#abcbbca20710f38a6f9ff4f303310d5b2">More...</a><br /></td></tr>
<tr class="separator:abcbbca20710f38a6f9ff4f303310d5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e73e4fab6f22e308686b1a3e1ce3b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ac0e73e4fab6f22e308686b1a3e1ce3b2">getParticleAcceleration</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, ParticleIndex p) const</td></tr>
<tr class="memdesc:ac0e73e4fab6f22e308686b1a3e1ce3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: total number of particles.  <a href="#ac0e73e4fab6f22e308686b1a3e1ce3b2">More...</a><br /></td></tr>
<tr class="separator:ac0e73e4fab6f22e308686b1a3e1ce3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If you are still using any methods in this section, please stop.</p>
<p>If that's a problem, please post to the Simbody forum and explain why the method should not be deprecated. </p>
</div></td></tr>
<tr class="memitem:a6ed041c37c2c385e1328373388e25708"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6ed041c37c2c385e1328373388e25708">getMobilizerCentrifugalForces</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> mbx) const</td></tr>
<tr class="memdesc:a6ed041c37c2c385e1328373388e25708"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> This is an obscure internal quantity and shouldn't have been exposed; see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad35935a456ddf2d7193bdd9175f8082a" title="This is the total rotational velocity-dependent force acting on this body B, including forces due to ...">getTotalCentrifugalForces()</a> instead.  <a href="#a6ed041c37c2c385e1328373388e25708">More...</a><br /></td></tr>
<tr class="separator:a6ed041c37c2c385e1328373388e25708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1Subsystem"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1Subsystem')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1Subsystem.html">SimTK::Subsystem</a></td></tr>
<tr class="memitem:a7e70c91bba5e96343d6f2ea676833dbd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a7e70c91bba5e96343d6f2ea676833dbd">Subsystem</a> ()</td></tr>
<tr class="memdesc:a7e70c91bba5e96343d6f2ea676833dbd inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates and empty handle with a null <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> pointer.  <a href="classSimTK_1_1Subsystem.html#a7e70c91bba5e96343d6f2ea676833dbd">More...</a><br /></td></tr>
<tr class="separator:a7e70c91bba5e96343d6f2ea676833dbd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b0c9b22049a700172635d0e54ad1f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#adb8b0c9b22049a700172635d0e54ad1f">Subsystem</a> (const <a class="el" href="classSimTK_1_1Subsystem.html">Subsystem</a> &amp;)</td></tr>
<tr class="memdesc:adb8b0c9b22049a700172635d0e54ad1f inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor clones the <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> object if there is one and makes this the owner handle of the new clone.  <a href="classSimTK_1_1Subsystem.html#adb8b0c9b22049a700172635d0e54ad1f">More...</a><br /></td></tr>
<tr class="separator:adb8b0c9b22049a700172635d0e54ad1f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f580d4f23447f6f3f39fffae0831d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Subsystem.html">Subsystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a839f580d4f23447f6f3f39fffae0831d">operator=</a> (const <a class="el" href="classSimTK_1_1Subsystem.html">Subsystem</a> &amp;)</td></tr>
<tr class="memdesc:a839f580d4f23447f6f3f39fffae0831d inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment deletes the <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> object if there is one and then behaves like the copy constructor.  <a href="classSimTK_1_1Subsystem.html#a839f580d4f23447f6f3f39fffae0831d">More...</a><br /></td></tr>
<tr class="separator:a839f580d4f23447f6f3f39fffae0831d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272011429bb671b2af21ccdd929d42ee inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a272011429bb671b2af21ccdd929d42ee">~Subsystem</a> ()</td></tr>
<tr class="memdesc:a272011429bb671b2af21ccdd929d42ee inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor deletes the referenced <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> object if this is the owner handle of that object, otherwise does nothing.  <a href="classSimTK_1_1Subsystem.html#a272011429bb671b2af21ccdd929d42ee">More...</a><br /></td></tr>
<tr class="separator:a272011429bb671b2af21ccdd929d42ee inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d1809105f123986510e8acfe92e42 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1QIndex.html">QIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a9f6d1809105f123986510e8acfe92e42">allocateQ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;qInit) const</td></tr>
<tr class="separator:a9f6d1809105f123986510e8acfe92e42 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7747b6c23c1453eeaec1fc76055bcbba inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a7747b6c23c1453eeaec1fc76055bcbba">allocateU</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;uInit) const</td></tr>
<tr class="separator:a7747b6c23c1453eeaec1fc76055bcbba inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190c4f64987162edfb43cc908505360b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ZIndex.html">ZIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a190c4f64987162edfb43cc908505360b">allocateZ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;zInit) const</td></tr>
<tr class="separator:a190c4f64987162edfb43cc908505360b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbec2f17a572bd4ef3041a535ca81a6 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#accbec2f17a572bd4ef3041a535ca81a6">allocateDiscreteVariable</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *v) const</td></tr>
<tr class="separator:accbec2f17a572bd4ef3041a535ca81a6 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fdc532ff3c4c7b1c4b87c30ccf2325 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ac8fdc532ff3c4c7b1c4b87c30ccf2325">allocateAutoUpdateDiscreteVariable</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> invalidates, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *v, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> updateDependsOn) const</td></tr>
<tr class="separator:ac8fdc532ff3c4c7b1c4b87c30ccf2325 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a1c2030ff96ef370f6d54518a1f3d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a3a9a1c2030ff96ef370f6d54518a1f3d">allocateCacheEntry</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> dependsOn, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> computedBy, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *v) const</td></tr>
<tr class="separator:a3a9a1c2030ff96ef370f6d54518a1f3d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bbe2fc9db8027fed03a8f781f74bd7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a81bbe2fc9db8027fed03a8f781f74bd7">allocateCacheEntry</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *v) const</td></tr>
<tr class="separator:a81bbe2fc9db8027fed03a8f781f74bd7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9151eabbcf887ca0623db6ba419842f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa9151eabbcf887ca0623db6ba419842f">allocateLazyCacheEntry</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;state, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> earliest, <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> *v) const</td></tr>
<tr class="separator:aa9151eabbcf887ca0623db6ba419842f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9806ccce58238adfbcc0893dd72266 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1QErrIndex.html">QErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a4c9806ccce58238adfbcc0893dd72266">allocateQErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nqerr) const</td></tr>
<tr class="separator:a4c9806ccce58238adfbcc0893dd72266 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291160dd867c5a05e473f783b8ec2c1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UErrIndex.html">UErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ae291160dd867c5a05e473f783b8ec2c1">allocateUErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nuerr) const</td></tr>
<tr class="separator:ae291160dd867c5a05e473f783b8ec2c1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12151f7dcc583ffcecc36b6fed9b89a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1UDotErrIndex.html">UDotErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ac12151f7dcc583ffcecc36b6fed9b89a">allocateUDotErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, int nudoterr) const</td></tr>
<tr class="separator:ac12151f7dcc583ffcecc36b6fed9b89a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0cd93f5c96d7ec4e31906890d0b703 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1EventTriggerByStageIndex.html">EventTriggerByStageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#adb0cd93f5c96d7ec4e31906890d0b703">allocateEventTriggersByStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g, int ntriggers) const</td></tr>
<tr class="separator:adb0cd93f5c96d7ec4e31906890d0b703 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59e4be8fefd40950aefc74b964a94b2 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ab59e4be8fefd40950aefc74b964a94b2">getQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:ab59e4be8fefd40950aefc74b964a94b2 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb580389dd54ffbcdb166fdc8143d76a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#acb580389dd54ffbcdb166fdc8143d76a">getU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:acb580389dd54ffbcdb166fdc8143d76a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b850d00ebb65faf4e86ccda3bc038 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ab08b850d00ebb65faf4e86ccda3bc038">getZ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:ab08b850d00ebb65faf4e86ccda3bc038 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e15b9a6d4d4d750191cfb68fd6f611d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a2e15b9a6d4d4d750191cfb68fd6f611d">getUWeights</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a2e15b9a6d4d4d750191cfb68fd6f611d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002269f046e5f69a19b281b54de64637 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a002269f046e5f69a19b281b54de64637">getZWeights</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a002269f046e5f69a19b281b54de64637 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4aa9ce5b4791f8d3a3adf87201bcdd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a1a4aa9ce5b4791f8d3a3adf87201bcdd">updQ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a1a4aa9ce5b4791f8d3a3adf87201bcdd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d5bb249ee2278ec6420b5e874e5a40 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a17d5bb249ee2278ec6420b5e874e5a40">updU</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a17d5bb249ee2278ec6420b5e874e5a40 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3dc35416644d01e1b9104d27500c42 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a3a3dc35416644d01e1b9104d27500c42">updZ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a3a3dc35416644d01e1b9104d27500c42 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85a9e6d922cf58a01f8916e5c9871d2 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ad85a9e6d922cf58a01f8916e5c9871d2">getQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:ad85a9e6d922cf58a01f8916e5c9871d2 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48d8f41fe558c7432311457ac65d9c0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#af48d8f41fe558c7432311457ac65d9c0">getUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:af48d8f41fe558c7432311457ac65d9c0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac629c316c83a480d1608d9a311dfc4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a1ac629c316c83a480d1608d9a311dfc4">getZDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a1ac629c316c83a480d1608d9a311dfc4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9deb5aade8566e05581efc9d2ae887 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#acb9deb5aade8566e05581efc9d2ae887">getQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:acb9deb5aade8566e05581efc9d2ae887 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1e41d22ee4f2e3458d9a245a1bc601 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aae1e41d22ee4f2e3458d9a245a1bc601">updQDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aae1e41d22ee4f2e3458d9a245a1bc601 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeafc1fd0afa9a135c6770c51b2d0e2c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#afeafc1fd0afa9a135c6770c51b2d0e2c">updUDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:afeafc1fd0afa9a135c6770c51b2d0e2c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477f6b20db7158f97c43d5df8517300c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a477f6b20db7158f97c43d5df8517300c">updZDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a477f6b20db7158f97c43d5df8517300c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2d76d42bf61e680d8ee07ca9138877 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#adc2d76d42bf61e680d8ee07ca9138877">updQDotDot</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:adc2d76d42bf61e680d8ee07ca9138877 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681bdf2ee5da05d05982e238af0e40b7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a681bdf2ee5da05d05982e238af0e40b7">getQErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a681bdf2ee5da05d05982e238af0e40b7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6021ea81f6c5cf66838b3fdb9489c3 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#acc6021ea81f6c5cf66838b3fdb9489c3">getUErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:acc6021ea81f6c5cf66838b3fdb9489c3 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140105cf85819cb782a5501695d86c9b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a140105cf85819cb782a5501695d86c9b">getQErrWeights</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a140105cf85819cb782a5501695d86c9b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65656f850c839ac82d1ab1b19fdf71a9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a65656f850c839ac82d1ab1b19fdf71a9">getUErrWeights</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a65656f850c839ac82d1ab1b19fdf71a9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff8bc209919f086d50dd632ad7c1698 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a0ff8bc209919f086d50dd632ad7c1698">getUDotErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a0ff8bc209919f086d50dd632ad7c1698 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c90eaa40dad51d422ef7d46c7c211 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aad2c90eaa40dad51d422ef7d46c7c211">getMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aad2c90eaa40dad51d422ef7d46c7c211 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf69221ef178359c07e64f232752bd8f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aaf69221ef178359c07e64f232752bd8f">getEventTriggersByStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g) const</td></tr>
<tr class="separator:aaf69221ef178359c07e64f232752bd8f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff4a3a3fe9c435a5a2fa14c61dc417d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a3ff4a3a3fe9c435a5a2fa14c61dc417d">updQErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a3ff4a3a3fe9c435a5a2fa14c61dc417d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa232aeb56f65eb236dc85222f36cb20b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa232aeb56f65eb236dc85222f36cb20b">updUErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aa232aeb56f65eb236dc85222f36cb20b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83371c86c7717ae73cdeb82f68cc0d74 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a83371c86c7717ae73cdeb82f68cc0d74">updUDotErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a83371c86c7717ae73cdeb82f68cc0d74 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334b57da36c50dd9fe0a4cec614c0dbe inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a334b57da36c50dd9fe0a4cec614c0dbe">updMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a334b57da36c50dd9fe0a4cec614c0dbe inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a387099bcfab2ae7e37e41cf44da556 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a3a387099bcfab2ae7e37e41cf44da556">updEventTriggersByStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g) const</td></tr>
<tr class="separator:a3a387099bcfab2ae7e37e41cf44da556 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0063b4d411a7f33fdd531ae06f41cf inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemQIndex.html">SystemQIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aae0063b4d411a7f33fdd531ae06f41cf">getQStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aae0063b4d411a7f33fdd531ae06f41cf inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef3d400ed11febc50c8d6c4ec257e7c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a8ef3d400ed11febc50c8d6c4ec257e7c">getNQ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a8ef3d400ed11febc50c8d6c4ec257e7c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6716b066b3e2c6a7d43a1881a15f5dac inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUIndex.html">SystemUIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a6716b066b3e2c6a7d43a1881a15f5dac">getUStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a6716b066b3e2c6a7d43a1881a15f5dac inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4bcc1e59956cd396ba9e920fadff9f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aef4bcc1e59956cd396ba9e920fadff9f">getNU</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aef4bcc1e59956cd396ba9e920fadff9f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d92bae18514655a58598015ad1ab06a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemZIndex.html">SystemZIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a7d92bae18514655a58598015ad1ab06a">getZStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a7d92bae18514655a58598015ad1ab06a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9313d5417eb8e94a5feb5e30c8153a0c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a9313d5417eb8e94a5feb5e30c8153a0c">getNZ</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a9313d5417eb8e94a5feb5e30c8153a0c inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9b551ee50b0f76abce01280d539342 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemQErrIndex.html">SystemQErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#add9b551ee50b0f76abce01280d539342">getQErrStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:add9b551ee50b0f76abce01280d539342 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d29ae6120c7903e71877a84f4476ad inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a11d29ae6120c7903e71877a84f4476ad">getNQErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a11d29ae6120c7903e71877a84f4476ad inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79f2ba687985858e5e398aff4fd594 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUErrIndex.html">SystemUErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a4e79f2ba687985858e5e398aff4fd594">getUErrStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a4e79f2ba687985858e5e398aff4fd594 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadad6ef89fdd237c28046f2b1d5cde10 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aadad6ef89fdd237c28046f2b1d5cde10">getNUErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:aadad6ef89fdd237c28046f2b1d5cde10 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7083c61efa58eb1d643ffda9bec52e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemUDotErrIndex.html">SystemUDotErrIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a8d7083c61efa58eb1d643ffda9bec52e">getUDotErrStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a8d7083c61efa58eb1d643ffda9bec52e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b495dafceec2e05d6f65c09ed588c6f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a6b495dafceec2e05d6f65c09ed588c6f">getNUDotErr</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a6b495dafceec2e05d6f65c09ed588c6f inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445d2ad2f551bb79069602b6bb09defd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemMultiplierIndex.html">SystemMultiplierIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a445d2ad2f551bb79069602b6bb09defd">getMultipliersStart</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a445d2ad2f551bb79069602b6bb09defd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6182e6eb86e4f78f33d6bfb24b2ae26e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a6182e6eb86e4f78f33d6bfb24b2ae26e">getNMultipliers</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a6182e6eb86e4f78f33d6bfb24b2ae26e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb804e672eee741222b0604b8be2573 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SystemEventTriggerByStageIndex.html">SystemEventTriggerByStageIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a9eb804e672eee741222b0604b8be2573">getEventTriggerStartByStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g) const</td></tr>
<tr class="separator:a9eb804e672eee741222b0604b8be2573 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd08ff9b746dbe9905c3d6d9927bdc76 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#abd08ff9b746dbe9905c3d6d9927bdc76">getNEventTriggersByStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g) const</td></tr>
<tr class="separator:abd08ff9b746dbe9905c3d6d9927bdc76 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d40378db23488f29752a400cf2c09 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#abc6d40378db23488f29752a400cf2c09">setQ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;q) const</td></tr>
<tr class="separator:abc6d40378db23488f29752a400cf2c09 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8867693a49b3e658fb9e9448e7468f1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ab8867693a49b3e658fb9e9448e7468f1">setU</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;u) const</td></tr>
<tr class="separator:ab8867693a49b3e658fb9e9448e7468f1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2077649f394b37c675f54ba318e8bfa4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a2077649f394b37c675f54ba318e8bfa4">setZ</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;z) const</td></tr>
<tr class="separator:a2077649f394b37c675f54ba318e8bfa4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71314ba80208db2819b268d72ba6e37b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a71314ba80208db2819b268d72ba6e37b">getStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s) const</td></tr>
<tr class="separator:a71314ba80208db2819b268d72ba6e37b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b4ae58755969cc81f248fe6cb6b28d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ae5b4ae58755969cc81f248fe6cb6b28d">advanceToStage</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1Stage.html">Stage</a> g) const</td></tr>
<tr class="separator:ae5b4ae58755969cc81f248fe6cb6b28d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e09f0439e46df418b50cba3daafa1a8 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a9e09f0439e46df418b50cba3daafa1a8">getDiscreteVariable</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> index) const</td></tr>
<tr class="separator:a9e09f0439e46df418b50cba3daafa1a8 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9dc954c9c305551efe4bf40774dd7e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a5b9dc954c9c305551efe4bf40774dd7e">updDiscreteVariable</a> (<a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> index) const</td></tr>
<tr class="separator:a5b9dc954c9c305551efe4bf40774dd7e inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5876c9f98cced646aecb7de4c5f1028 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa5876c9f98cced646aecb7de4c5f1028">getCacheEntry</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> index) const</td></tr>
<tr class="separator:aa5876c9f98cced646aecb7de4c5f1028 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0793a845b66cbdc349f3af7aab796e33 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a0793a845b66cbdc349f3af7aab796e33">updCacheEntry</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> index) const</td></tr>
<tr class="separator:a0793a845b66cbdc349f3af7aab796e33 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57212598a62461d877efa8294ffb583 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ad57212598a62461d877efa8294ffb583">getDiscreteVarLastUpdateTime</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:ad57212598a62461d877efa8294ffb583 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d3234173076c164136dda847b85781 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a35d3234173076c164136dda847b85781">getDiscreteVarUpdateIndex</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:a35d3234173076c164136dda847b85781 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8af3e0a13f2c29bbfc79b2b3efd69cd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ab8af3e0a13f2c29bbfc79b2b3efd69cd">getDiscreteVarUpdateValue</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:ab8af3e0a13f2c29bbfc79b2b3efd69cd inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c272d7e733a72a622fcb2bdff4e21d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractValue.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a69c272d7e733a72a622fcb2bdff4e21d">updDiscreteVarUpdateValue</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:a69c272d7e733a72a622fcb2bdff4e21d inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b74d9beab2b83c91cb21a6da474a93 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa9b74d9beab2b83c91cb21a6da474a93">isDiscreteVarUpdateValueRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:aa9b74d9beab2b83c91cb21a6da474a93 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a57f67353fe8cec9feaf53b48b092b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a71a57f67353fe8cec9feaf53b48b092b">markDiscreteVarUpdateValueRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1DiscreteVariableIndex.html">DiscreteVariableIndex</a> dx) const</td></tr>
<tr class="separator:a71a57f67353fe8cec9feaf53b48b092b inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda6e5d58e782f6837e1ce9b1a3e083 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#acbda6e5d58e782f6837e1ce9b1a3e083">isCacheValueRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> cx) const</td></tr>
<tr class="separator:acbda6e5d58e782f6837e1ce9b1a3e083 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19cce97955a972ff495ea75abb9b31 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aeb19cce97955a972ff495ea75abb9b31">markCacheValueRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> cx) const</td></tr>
<tr class="separator:aeb19cce97955a972ff495ea75abb9b31 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809ec65edc98c810b516dcdf3ca75edf inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a809ec65edc98c810b516dcdf3ca75edf">markCacheValueNotRealized</a> (const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;s, <a class="el" href="classSimTK_1_1CacheEntryIndex.html">CacheEntryIndex</a> cx) const</td></tr>
<tr class="separator:a809ec65edc98c810b516dcdf3ca75edf inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86ec913ea2c8ba7dea9aac26d5efbf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa86ec913ea2c8ba7dea9aac26d5efbf9">getName</a> () const</td></tr>
<tr class="memdesc:aa86ec913ea2c8ba7dea9aac26d5efbf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#aa86ec913ea2c8ba7dea9aac26d5efbf9">More...</a><br /></td></tr>
<tr class="separator:aa86ec913ea2c8ba7dea9aac26d5efbf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7feb44262ce62ae247138e14fd218e1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1String.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ae7feb44262ce62ae247138e14fd218e1">getVersion</a> () const</td></tr>
<tr class="memdesc:ae7feb44262ce62ae247138e14fd218e1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> version string if one was given on construction.  <a href="classSimTK_1_1Subsystem.html#ae7feb44262ce62ae247138e14fd218e1">More...</a><br /></td></tr>
<tr class="separator:ae7feb44262ce62ae247138e14fd218e1 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71028fa779a10df32a35e8addf7b6d90 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a71028fa779a10df32a35e8addf7b6d90">isInSystem</a> () const</td></tr>
<tr class="memdesc:a71028fa779a10df32a35e8addf7b6d90 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this Subsystem is contained in a <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>.  <a href="classSimTK_1_1Subsystem.html#a71028fa779a10df32a35e8addf7b6d90">More...</a><br /></td></tr>
<tr class="separator:a71028fa779a10df32a35e8addf7b6d90 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d97586ef0de05645f8a85a21b4ce51 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a96d97586ef0de05645f8a85a21b4ce51">isInSameSystem</a> (const <a class="el" href="classSimTK_1_1Subsystem.html">Subsystem</a> &amp;otherSubsystem) const</td></tr>
<tr class="memdesc:a96d97586ef0de05645f8a85a21b4ce51 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this Subsystem is contained in the same <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> as contains the given <em>otherSubsystem</em>.  <a href="classSimTK_1_1Subsystem.html#a96d97586ef0de05645f8a85a21b4ce51">More...</a><br /></td></tr>
<tr class="separator:a96d97586ef0de05645f8a85a21b4ce51 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb29438b2a5a2a0da53782347518395 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1System.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a7fb29438b2a5a2a0da53782347518395">getSystem</a> () const</td></tr>
<tr class="memdesc:a7fb29438b2a5a2a0da53782347518395 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that contains this Subsystem.  <a href="classSimTK_1_1Subsystem.html#a7fb29438b2a5a2a0da53782347518395">More...</a><br /></td></tr>
<tr class="separator:a7fb29438b2a5a2a0da53782347518395 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd8258cb8e785ecbfa3cd64a9bfe41 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1System.html">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a64bd8258cb8e785ecbfa3cd64a9bfe41">updSystem</a> ()</td></tr>
<tr class="memdesc:a64bd8258cb8e785ecbfa3cd64a9bfe41 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that contains this Subsystem.  <a href="classSimTK_1_1Subsystem.html#a64bd8258cb8e785ecbfa3cd64a9bfe41">More...</a><br /></td></tr>
<tr class="separator:a64bd8258cb8e785ecbfa3cd64a9bfe41 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9f125002bbf6d43ce56db375f947a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ae3a9f125002bbf6d43ce56db375f947a">setSystem</a> (<a class="el" href="classSimTK_1_1System.html">System</a> &amp;system, <a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a> subx)</td></tr>
<tr class="memdesc:ae3a9f125002bbf6d43ce56db375f947a inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform this Subsystem of the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that contains it, as well as the <a class="el" href="classSimTK_1_1SubsystemIndex.html" title="Provide a unique integer type for identifying Subsystems. ">SubsystemIndex</a> which the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> has assigned to it.  <a href="classSimTK_1_1Subsystem.html#ae3a9f125002bbf6d43ce56db375f947a">More...</a><br /></td></tr>
<tr class="separator:ae3a9f125002bbf6d43ce56db375f947a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b404afe9bdfef11e9e47009d8e1b85 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1SubsystemIndex.html">SubsystemIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a18b404afe9bdfef11e9e47009d8e1b85">getMySubsystemIndex</a> () const</td></tr>
<tr class="memdesc:a18b404afe9bdfef11e9e47009d8e1b85 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classSimTK_1_1SubsystemIndex.html" title="Provide a unique integer type for identifying Subsystems. ">SubsystemIndex</a> within the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>.  <a href="classSimTK_1_1Subsystem.html#a18b404afe9bdfef11e9e47009d8e1b85">More...</a><br /></td></tr>
<tr class="separator:a18b404afe9bdfef11e9e47009d8e1b85 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f73029cab8f19f64b8c991eddf7c7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#ad81f73029cab8f19f64b8c991eddf7c7">isEmptyHandle</a> () const</td></tr>
<tr class="memdesc:ad81f73029cab8f19f64b8c991eddf7c7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this handle has a null <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> pointer.  <a href="classSimTK_1_1Subsystem.html#ad81f73029cab8f19f64b8c991eddf7c7">More...</a><br /></td></tr>
<tr class="separator:ad81f73029cab8f19f64b8c991eddf7c7 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5fc328469af5792b21a752f721efee inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a1d5fc328469af5792b21a752f721efee">isSameSubsystem</a> (const <a class="el" href="classSimTK_1_1Subsystem.html">Subsystem</a> &amp;otherSubsystem) const</td></tr>
<tr class="memdesc:a1d5fc328469af5792b21a752f721efee inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <code>this</code> <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> handle refers to the same <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> object as handle <em>otherSubsystem</em>.  <a href="classSimTK_1_1Subsystem.html#a1d5fc328469af5792b21a752f721efee">More...</a><br /></td></tr>
<tr class="separator:a1d5fc328469af5792b21a752f721efee inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69c75c6b19681edb29b547660b5bf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a5b69c75c6b19681edb29b547660b5bf9">isOwnerHandle</a> () const</td></tr>
<tr class="memdesc:a5b69c75c6b19681edb29b547660b5bf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> handle the owner of the <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Subsystem::Guts</a> object it points to? This is <code>true</code> if the handle is empty or if its <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html" title="The abstract parent of all Subsystem implementation classes. ">Guts</a> object points back to this handle.  <a href="classSimTK_1_1Subsystem.html#a5b69c75c6b19681edb29b547660b5bf9">More...</a><br /></td></tr>
<tr class="separator:a5b69c75c6b19681edb29b547660b5bf9 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d290abc88f708d036046dfd806395a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aa8d290abc88f708d036046dfd806395a">subsystemTopologyHasBeenRealized</a> () const</td></tr>
<tr class="memdesc:aa8d290abc88f708d036046dfd806395a inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this Subsystem's realizeTopology() method has been called since the last topological change or call to <a class="el" href="classSimTK_1_1Subsystem.html#a708dbbfa97dce557710b6e0e79e02332" title="Always call this method when a topological change is made to this Subsystem to indicate that any Stag...">invalidateSubsystemTopologyCache()</a>.  <a href="classSimTK_1_1Subsystem.html#aa8d290abc88f708d036046dfd806395a">More...</a><br /></td></tr>
<tr class="separator:aa8d290abc88f708d036046dfd806395a inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708dbbfa97dce557710b6e0e79e02332 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a708dbbfa97dce557710b6e0e79e02332">invalidateSubsystemTopologyCache</a> () const</td></tr>
<tr class="memdesc:a708dbbfa97dce557710b6e0e79e02332 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always call this method when a topological change is made to this Subsystem to indicate that any <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a58721a4474cb55368c71692a698504b0" title="System topology realized. ">Stage::Topology</a> cache values may need recomputation.  <a href="classSimTK_1_1Subsystem.html#a708dbbfa97dce557710b6e0e79e02332">More...</a><br /></td></tr>
<tr class="separator:a708dbbfa97dce557710b6e0e79e02332 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8941d1bc537da9c4b8ac83509f46f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">MeasureIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a2f8941d1bc537da9c4b8ac83509f46f0">adoptMeasure</a> (<a class="el" href="classSimTK_1_1AbstractMeasure.html">AbstractMeasure</a> &amp;)</td></tr>
<tr class="memdesc:a2f8941d1bc537da9c4b8ac83509f46f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a2f8941d1bc537da9c4b8ac83509f46f0">More...</a><br /></td></tr>
<tr class="separator:a2f8941d1bc537da9c4b8ac83509f46f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496dea7d7d716e03f93eb5833519c2e4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1AbstractMeasure.html">AbstractMeasure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a496dea7d7d716e03f93eb5833519c2e4">getMeasure</a> (MeasureIndex) const</td></tr>
<tr class="memdesc:a496dea7d7d716e03f93eb5833519c2e4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a496dea7d7d716e03f93eb5833519c2e4">More...</a><br /></td></tr>
<tr class="separator:a496dea7d7d716e03f93eb5833519c2e4 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4795a77c1d1d3e1369227554b4f610 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aca4795a77c1d1d3e1369227554b4f610 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Measure__.html">Measure_</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#aca4795a77c1d1d3e1369227554b4f610">getMeasure_</a> (MeasureIndex mx) const</td></tr>
<tr class="memdesc:aca4795a77c1d1d3e1369227554b4f610 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#aca4795a77c1d1d3e1369227554b4f610">More...</a><br /></td></tr>
<tr class="separator:aca4795a77c1d1d3e1369227554b4f610 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5796e2e73ad32d671d0c1ec82549f781 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html">Subsystem::Guts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a5796e2e73ad32d671d0c1ec82549f781">getSubsystemGuts</a> () const</td></tr>
<tr class="memdesc:a5796e2e73ad32d671d0c1ec82549f781 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a5796e2e73ad32d671d0c1ec82549f781">More...</a><br /></td></tr>
<tr class="separator:a5796e2e73ad32d671d0c1ec82549f781 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3ab15a9eaf4f22af9bcaf30d44fc64 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html">Subsystem::Guts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a6c3ab15a9eaf4f22af9bcaf30d44fc64">updSubsystemGuts</a> ()</td></tr>
<tr class="memdesc:a6c3ab15a9eaf4f22af9bcaf30d44fc64 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a6c3ab15a9eaf4f22af9bcaf30d44fc64">More...</a><br /></td></tr>
<tr class="separator:a6c3ab15a9eaf4f22af9bcaf30d44fc64 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaededb44ed2df0a7f6c823ba5bf2bb inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a8aaededb44ed2df0a7f6c823ba5bf2bb">adoptSubsystemGuts</a> (<a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html">Subsystem::Guts</a> *g)</td></tr>
<tr class="memdesc:a8aaededb44ed2df0a7f6c823ba5bf2bb inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a8aaededb44ed2df0a7f6c823ba5bf2bb">More...</a><br /></td></tr>
<tr class="separator:a8aaededb44ed2df0a7f6c823ba5bf2bb inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5b5170becdbc1120da9254d2ac48f5 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#afb5b5170becdbc1120da9254d2ac48f5">Subsystem</a> (<a class="el" href="classSimTK_1_1Subsystem_1_1Guts.html">Subsystem::Guts</a> *g)</td></tr>
<tr class="memdesc:afb5b5170becdbc1120da9254d2ac48f5 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#afb5b5170becdbc1120da9254d2ac48f5">More...</a><br /></td></tr>
<tr class="separator:afb5b5170becdbc1120da9254d2ac48f5 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a53c5c0cc074ef0d1c54eb08271f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1Subsystem.html#a1c5a53c5c0cc074ef0d1c54eb08271f0">hasGuts</a> () const</td></tr>
<tr class="memdesc:a1c5a53c5c0cc074ef0d1c54eb08271f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a> name if one was given on construction of the concrete <a class="el" href="classSimTK_1_1Subsystem.html" title="A Subsystem is expected to be part of a larger System and to have interdependencies with other subsys...">Subsystem</a>.  <a href="classSimTK_1_1Subsystem.html#a1c5a53c5c0cc074ef0d1c54eb08271f0">More...</a><br /></td></tr>
<tr class="separator:a1c5a53c5c0cc074ef0d1c54eb08271f0 inherit pub_methods_classSimTK_1_1Subsystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ada91148391d89bcdcfd812c91cf16fbb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ada91148391d89bcdcfd812c91cf16fbb">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;)</td></tr>
<tr class="memdesc:ada91148391d89bcdcfd812c91cf16fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump some debug information about the given subsystem to the given output stream; this is <em>not</em> for serialization.  <a href="#ada91148391d89bcdcfd812c91cf16fbb">More...</a><br /></td></tr>
<tr class="separator:ada91148391d89bcdcfd812c91cf16fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This subsystem contains the bodies ("matter") in the multibody system, the mobilizers (joints) that define the generalized coordinates used to represent the motion of those bodies, and constraints that must be satisfied by the values of those coordinates. </p>
<p>There are many methods in the API for this class. For whole-system information and calculations, the methods here are the right ones to use. For information associated with individual objects contained in the subsystem, such as <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> and <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects, it is generally easier to obtain the information through the contained objects' APIs instead.</p>
<p>This class is a "handle" containing only an opaque reference to the underlying implementation class.</p>
<h3>Theory discussion</h3>
<p>The bodies, mobilizers, and constraints are represented mathematically with the following set of equations: </p><pre>
                     qdot = N u                 Kinematic differential eqns.
                     zdot = zdot(t,q,u,z)       Auxiliary states</pre><pre>         M udot + ~G mult = f(t,q,u,z)          Equations of motion
         G udot           = b(t,q,u)</pre><pre>                 where</pre><pre>          [P]    [bp]
        G=[V]  b=[bv]  f = T + ~J*(F-C)
          [A]    [ba]</pre><pre>          pdotdot = P udot - bp(t,q,u) = 0      Acceleration constraints
             vdot = V udot - bv(t,q,u) = 0
    a(t,q,u,udot) = A udot - ba(t,q,u) = 0</pre><pre>                   pdot = P u - c(t,q) = 0      Velocity constraints
                              v(t,q,u) = 0</pre><pre>                                p(t,q) = 0      Position constraints
                                  n(q) = 0      Normalization constraints
</pre><p> where M(q) is the mass matrix, G(t,q,u) the acceleration constraint matrix, C(q,u) the coriolis and gyroscopic forces, T is user-applied joint mobility forces, F is user-applied body forces and torques and gravity. J(q) is the System Jacobian (partial velocity matrix) whose transpose ~J maps spatial forces to joint mobility forces. p(t,q) are the holonomic (position) constraints, v(t,q,u) the non-holonomic (velocity) constraints, and a(t,q,u,udot) the acceleration-only constraints, which must be linear in udot, with A(t,q,u) the coefficient matrix for a(). pdot, pdotdot are obtained by differentiation of p(), vdot by differentiation of v(). P(t,q)=Dpdot/Du (yes, that's u, not q &ndash; we can get Pq=Dp/Dq when we need it as Pq=P*N^-1) and V(t,q,u)=Dv/Du. (We use capital "D" to indicate partial derivative.) n(q) is the set of quaternion normalization constraints, which exist only at the position level and are uncoupled from everything else.</p>
<p>We calculate the constraint multipliers like this: </p><pre>
          G M^-1 ~G mult = G udot0 - b
          where    udot0 = M^-1 f
</pre><p> using the pseudo inverse of G M^-1 ~G to give a least squares solution for mult: mult = pinv(G M^-1 ~G)(G M^-1 f - b). Then the real udot is udot = udot0 - udotC, with udotC = M^-1 ~G mult. Note: M^-1* is an O(n) operator that provides the desired result; it <em>does not</em> require forming or factoring M.</p>
<p>NOTE: only the following constraint matrices have to be formed and factored: </p><pre>
   [G M^-1 ~G]   to calculate multipliers</pre><pre>   [P N^-1]      for projection onto position manifold (a.k.a. Pq)</pre><pre>   [ P ]         for projection onto velocity manifold
   [ V ]  
</pre><p>When working in a weighted norm with weights W on the state variables and weights T (1/tolerance) on the constraint errors, the matrices we need are actually [Tp Pq Wq^-1], [Tpv [P;V] Wu^-1], etc. with T and W diagonal weighting matrices. These can then be used to find least squares solutions in the weighted norms.</p>
<p>In many cases these matrices consist of decoupled blocks which can be solved independently. (TODO: take advantage of that whenever possible to solve a set of smaller systems rather than one large one.) Also, in the majority of biosimulation applications we are likely to have only holonomic (position) constraints, so there is no V or A and G=P is the whole story. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1b1f2127fdc50c1c92b5a20db22cd43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1f2127fdc50c1c92b5a20db22cd43f">&#9670;&nbsp;</a></span>SimbodyMatterSubsystem() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MultibodySystem.html">MultibodySystem</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a4b5ec5c33a93af6d9e3a8ebc6bf37b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5ec5c33a93af6d9e3a8ebc6bf37b51">&#9670;&nbsp;</a></span>SimbodyMatterSubsystem() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an orphan matter subsystem containing only the Ground body (mobilized body 0); normally use the other constructor to place the subsystem in a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>

</div>
</div>
<a id="ac49f39cefdaee87456ea572c72e1f1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49f39cefdaee87456ea572c72e1f1a1">&#9670;&nbsp;</a></span>~SimbodyMatterSubsystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::SimbodyMatterSubsystem::~SimbodyMatterSubsystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor destroys the subsystem implementation object only if this handle is the last reference. </p>
<p>Normally, there is a <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> that holds a reference to the subsystem implementation, so this destruction will do nothing. </p>

</div>
</div>
<a id="af874cd8e7ca24c492042a0eef52ec9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af874cd8e7ca24c492042a0eef52ec9e8">&#9670;&nbsp;</a></span>SimbodyMatterSubsystem() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::SimbodyMatterSubsystem::SimbodyMatterSubsystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is not very useful. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5b8a5a13e1dc86d8ba8044b351c6bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b8a5a13e1dc86d8ba8044b351c6bdc">&#9670;&nbsp;</a></span>getMobilizedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::SimbodyMatterSubsystem::getMobilizedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. MobilizedBodyIndex(0) selects the Ground mobilized body. </p>

</div>
</div>
<a id="a5142442d0d59524a47f604584040fdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5142442d0d59524a47f604584040fdc1">&#9670;&nbsp;</a></span>updMobilizedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a>&amp; SimTK::SimbodyMatterSubsystem::updMobilizedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. MobilizedBodyIndex(0) selects the Ground mobilized body. </p>

</div>
</div>
<a id="a903434aff60bd8c1cce43cdfad8906d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903434aff60bd8c1cce43cdfad8906d2">&#9670;&nbsp;</a></span>getGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; SimTK::SimbodyMatterSubsystem::getGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a read-only (const) reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem. </p>

</div>
</div>
<a id="a0851b330170f8e5a0700382ddf58bd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0851b330170f8e5a0700382ddf58bd22">&#9670;&nbsp;</a></span>updGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; SimTK::SimbodyMatterSubsystem::updGround </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a writable reference to the Ground <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> within this matter subsystem; you need a writable reference if you're adding a mobilized body that is directly connected to Ground. </p>

</div>
</div>
<a id="a7776baa71fc6d342f3140284b56553fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7776baa71fc6d342f3140284b56553fb">&#9670;&nbsp;</a></span>Ground()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBody_1_1Ground.html">MobilizedBody::Ground</a>&amp; SimTK::SimbodyMatterSubsystem::Ground </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a synonym for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> that makes for nicer-looking examples. </p>
<p>Note: topology is not marked invalid upon returning a writable reference here; that will be done only if a non-const method of the returned <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> is called. That means it is OK to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a7776baa71fc6d342f3140284b56553fb" title="This is a synonym for updGround() that makes for nicer-looking examples. ">Ground()</a> to satisfy a const argument; it won't have an "invalidate topology" side effect. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a0851b330170f8e5a0700382ddf58bd22" title="Return a writable reference to the Ground MobilizedBody within this matter subsystem; you need a writ...">updGround()</a> </dd></dl>

</div>
</div>
<a id="a24c1a9d82a9736a481ed6b354ba00e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c1a9d82a9736a481ed6b354ba00e6a">&#9670;&nbsp;</a></span>getConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Constraint.html">Constraint</a>&amp; SimTK::SimbodyMatterSubsystem::getConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a read-only (const) reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. </p>

</div>
</div>
<a id="a85ca8b7eb162893128a6abc69d522e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca8b7eb162893128a6abc69d522e62">&#9670;&nbsp;</a></span>updConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a>&amp; SimTK::SimbodyMatterSubsystem::updConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a>, return a writable reference to the corresponding <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> within this matter subsystem. </p>
<p>This method will fail if the index is invalid or out of range. </p>

</div>
</div>
<a id="a19657abf3c40de3bc74bede59f8b1f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19657abf3c40de3bc74bede59f8b1f7d">&#9670;&nbsp;</a></span>setShowDefaultGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setShowDefaultGeometry </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normally the matter subsystem will attempt to generate some decorative geometry as a sketch of the defined multibody system; you can disable that with this method. </p>

</div>
</div>
<a id="a86f8327dfdc9c8cd1b382cf27e7cd37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f8327dfdc9c8cd1b382cf27e7cd37a">&#9670;&nbsp;</a></span>getShowDefaultGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::getShowDefaultGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether this matter subsystem is set to generate default decorative geometry that can be used to visualize this multibody system. </p>

</div>
</div>
<a id="a45f40d04cfab14431af5abbaf60e1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f40d04cfab14431af5abbaf60e1cce">&#9670;&nbsp;</a></span>getNumBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumBodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bodies includes all mobilized bodies <em>including</em> Ground, which is the first mobilized body, at <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> 0. </p>
<p>(Note: if special particle handling were implemented, the count here would <em>not</em> include particles.) Bodies and their inboard mobilizers have the same index since they are grouped together as a <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>. <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> numbering (using unique integer type <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>) starts with Ground at MobilizedBodyIndex(0) with a regular labeling such that children have higher indices than their parents. Ground does not have a mobilizer (or I suppose you could think of its mobilizer as the Weld joint that attaches it to the universe), but otherwise every mobilized body has a unique body and mobilizer.</p>
<p>Example:</p><ul>
<li>Here we use a model of a planar pendulum with 1 degree-of-freedom.</li>
<li>The command <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a45f40d04cfab14431af5abbaf60e1cce" title="The number of bodies includes all mobilized bodies including Ground, which is the first mobilized bod...">getNumBodies()</a> will return 2. <br />
 - Why? Ground counts as a mobilized body, and so does the pendulum.</li>
<li>Note that Ground is at MobilizedBodyIndex(0), and the pendulum is at the MobilizedBodyIndex(1). </li>
</ul>

</div>
</div>
<a id="acfcd1876e2525cc9fb102cd299cce203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcd1876e2525cc9fb102cd299cce203">&#9670;&nbsp;</a></span>getNumConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the total number of defined constraints, each of which may generate more than one constraint equation. </p>
<p>This is the number of <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects that were defined; in a given <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> some of these may be disabled. </p>

</div>
</div>
<a id="abcd2acffb10679e18813eeddb734fc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd2acffb10679e18813eeddb734fc2d">&#9670;&nbsp;</a></span>getNumMobilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumMobilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sum of all the mobilizer degrees of freedom. </p>
<p>This is also the length of the state variable vector u and the mobility forces array. </p>

</div>
</div>
<a id="aaa2f35fc427997efab70e1825caaf472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f35fc427997efab70e1825caaf472">&#9670;&nbsp;</a></span>getTotalQAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getTotalQAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sum of all the q vector allocations for each joint. </p>
<p>There may be some that are not in use for particular modeling options. </p>

</div>
</div>
<a id="a59d3e416b8263877d3e599774554f78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d3e416b8263877d3e599774554f78d">&#9670;&nbsp;</a></span>adoptMobilizedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> SimTK::SimbodyMatterSubsystem::adoptMobilizedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBody.html">MobilizedBody</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach new matter by attaching it to the indicated parent body (not normally called by users &ndash; see <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>). </p>
<p>The mobilizer and mass properties are provided by <em>child</em>. A new <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> is assigned for the child; it is guaranteed to be numerically larger than the <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> of the parent. We take over ownership of <em>child's</em> implementation object from the given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> handle, leaving that handle as a reference to the implementation object now owned by the matter subsystem. It is an error if the given <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> handle wasn't the owner of the implementation object to which it refers. </p><dl class="section note"><dt>Note</dt><dd>This method is usually called by concrete <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> constructors; it does not normally need to be called by end users. </dd></dl>

</div>
</div>
<a id="adf98f3426a2778ba1db81c5d76bccce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf98f3426a2778ba1db81c5d76bccce2">&#9670;&nbsp;</a></span>adoptConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a> SimTK::SimbodyMatterSubsystem::adoptConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> object to the matter subsystem (not normally called by users &ndash; see <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>). </p>
<p>The details of the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> are opaque here. A new <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is assigned. We take over ownership of the implementation object from the given <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> handle, leaving that handle as a reference to the implementation object now owned by the matter subsystem. It is an error if the given <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> handle wasn't the owner of the implementation object to which it refers. </p><dl class="section note"><dt>Note</dt><dd>This method is usually called by concrete <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> constructors; it does not normally need to be called by end users. </dd></dl>

</div>
</div>
<a id="a1f6b02ae234cc0784aa40f4a6d94cf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6b02ae234cc0784aa40f4a6d94cf27">&#9670;&nbsp;</a></span>adoptUnilateralContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnilateralContactIndex SimTK::SimbodyMatterSubsystem::adoptUnilateralContact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Experimental) </p>

</div>
</div>
<a id="a9be69c620957a93b9b797b3c4d2ed124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be69c620957a93b9b797b3c4d2ed124">&#9670;&nbsp;</a></span>getNumUnilateralContacts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumUnilateralContacts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a5a4f3a61791e7ac3870a899e8216952b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4f3a61791e7ac3870a899e8216952b">&#9670;&nbsp;</a></span>getUnilateralContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a>&amp; SimTK::SimbodyMatterSubsystem::getUnilateralContact </td>
          <td>(</td>
          <td class="paramtype">UnilateralContactIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a7d443f6085527aaa5a0e754d6ea42a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d443f6085527aaa5a0e754d6ea42a57">&#9670;&nbsp;</a></span>updUnilateralContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1UnilateralContact.html">UnilateralContact</a>&amp; SimTK::SimbodyMatterSubsystem::updUnilateralContact </td>
          <td>(</td>
          <td class="paramtype">UnilateralContactIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="ade345270c030aaf4e4521b49c6dd4231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade345270c030aaf4e4521b49c6dd4231">&#9670;&nbsp;</a></span>adoptStateLimitedFriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StateLimitedFrictionIndex SimTK::SimbodyMatterSubsystem::adoptStateLimitedFriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Experimental) </p>

</div>
</div>
<a id="a00faa4c404c31ded89c06f0ad7c1d509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00faa4c404c31ded89c06f0ad7c1d509">&#9670;&nbsp;</a></span>getNumStateLimitedFrictions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumStateLimitedFrictions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a357b654dad770f79263dafaa2aafeb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b654dad770f79263dafaa2aafeb06">&#9670;&nbsp;</a></span>getStateLimitedFriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a>&amp; SimTK::SimbodyMatterSubsystem::getStateLimitedFriction </td>
          <td>(</td>
          <td class="paramtype">StateLimitedFrictionIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a9ae7adcc1ce992f808f2402649e81e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae7adcc1ce992f808f2402649e81e95">&#9670;&nbsp;</a></span>updStateLimitedFriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1StateLimitedFriction.html">StateLimitedFriction</a>&amp; SimTK::SimbodyMatterSubsystem::updStateLimitedFriction </td>
          <td>(</td>
          <td class="paramtype">StateLimitedFrictionIndex&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a matter subsystem containing only the Ground body (mobilized body 0), and add the subsystem to the indicated <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a>. </p>
<p>The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> takes over ownership of the subsystem, which is not copied. The <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> and this subsystem handle both refer to the same subsystem after this call. </p>

</div>
</div>
<a id="a29e07d273b578e2d1ae9935de12da608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e07d273b578e2d1ae9935de12da608">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a>&amp; SimTK::SimbodyMatterSubsystem::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment is not very useful. </p>

</div>
</div>
<a id="a0164088f7e48b71db08706c65b6467ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0164088f7e48b71db08706c65b6467ea">&#9670;&nbsp;</a></span>setUseEulerAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setUseEulerAngles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useEulerAngles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For all mobilizers offering unrestricted orientation, decide what method we should use to model their orientations. </p>
<p>Choices are: quaternions (best for dynamics), or rotation angles (1-2-3 Euler sequence, good for optimization). Changing this flag invalidates Model stage and above in the supplied <em>state</em>, leaving it realized only through Topology stage, so you must call realizeModel() on the containing <a class="el" href="classSimTK_1_1MultibodySystem.html" title="The job of the MultibodySystem class is to coordinate the activities of various subsystems which can ...">MultibodySystem</a> prior to using this <em>state</em> in further calculations. </p>

</div>
</div>
<a id="adf982ad4fe5e4a869346593fb454db89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf982ad4fe5e4a869346593fb454db89">&#9670;&nbsp;</a></span>getUseEulerAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::getUseEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current setting of the "use Euler angles" model variable as set in the supplied <em>state</em>. </p>

</div>
</div>
<a id="a88a8b52991614ad6b600cafa82cf917b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a8b52991614ad6b600cafa82cf917b">&#9670;&nbsp;</a></span>getNumQuaternionsInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumQuaternionsInUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of quaternions in use by the mobilizers of this system, given the current setting of the "use Euler angles" flag in the supplied <em>state</em>, and the types of mobilizers in the multibody tree. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d662f1db0c80568e51c88da5d1fef4a" title="Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and th...">isUsingQuaternion()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea1463bd323e19002ff3b05c7cb3d7c5" title="If the given mobilizer is currently using a quaternion to represent orientation, return the Quaternio...">getQuaternionPoolIndex()</a> </dd></dl>

</div>
</div>
<a id="a3d662f1db0c80568e51c88da5d1fef4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d662f1db0c80568e51c88da5d1fef4a">&#9670;&nbsp;</a></span>isUsingQuaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isUsingQuaternion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and the setting of the "use Euler angles" flag in the supplied <em>state</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88a8b52991614ad6b600cafa82cf917b" title="Return the number of quaternions in use by the mobilizers of this system, given the current setting o...">getNumQuaternionsInUse()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aea1463bd323e19002ff3b05c7cb3d7c5" title="If the given mobilizer is currently using a quaternion to represent orientation, return the Quaternio...">getQuaternionPoolIndex()</a> </dd></dl>

</div>
</div>
<a id="aea1463bd323e19002ff3b05c7cb3d7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1463bd323e19002ff3b05c7cb3d7c5">&#9670;&nbsp;</a></span>getQuaternionPoolIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuaternionPoolIndex SimTK::SimbodyMatterSubsystem::getQuaternionPoolIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the given mobilizer is currently using a quaternion to represent orientation, return the QuaternionPoolIndex (a small integer) assigned to that quaternion. </p>
<p>This is used, for example, to find which normalization constraint error is associated with which quaternion. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3d662f1db0c80568e51c88da5d1fef4a" title="Check whether a given mobilizer is currently using quaternions, based on the type of mobilizer and th...">isUsingQuaternion()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88a8b52991614ad6b600cafa82cf917b" title="Return the number of quaternions in use by the mobilizers of this system, given the current setting o...">getNumQuaternionsInUse()</a> </dd></dl>

</div>
</div>
<a id="a4a54e463f72432d1b1c97fb3f324439f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a54e463f72432d1b1c97fb3f324439f">&#9670;&nbsp;</a></span>setConstraintIsDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setConstraintIsDisabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"><em>constraintIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldDisableConstraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable or enable the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> whose <a class="el" href="classSimTK_1_1ConstraintIndex.html" title="This is for arrays indexed by constraint number within a subsystem (typically the SimbodyMatterSubsys...">ConstraintIndex</a> is supplied within the supplied <em>state</em>. </p>
<p>Whether a <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is disabled is an Instance-stage state variable so enabling or disabling invalidates Instance stage and higher in the given <em>state</em>, leaving the <em>state</em> realized no higher than Model stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe4fa4b6ac99dfd2505f6d95189864d4" title="Determine whether a particular Constraint is currently disabled in the given state. ">isConstraintDisabled()</a> </dd></dl>

</div>
</div>
<a id="afe4fa4b6ac99dfd2505f6d95189864d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4fa4b6ac99dfd2505f6d95189864d4">&#9670;&nbsp;</a></span>isConstraintDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isConstraintDisabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ConstraintIndex.html">ConstraintIndex</a>&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a particular <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> is currently disabled in the given <em>state</em>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4a54e463f72432d1b1c97fb3f324439f" title="Disable or enable the Constraint whose ConstraintIndex is supplied within the supplied state...">setConstraintIsDisabled()</a> </dd></dl>

</div>
</div>
<a id="ad6e92e3504739bb2791cca77035df980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e92e3504739bb2791cca77035df980">&#9670;&nbsp;</a></span>convertToEulerAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::convertToEulerAngles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>inputState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>outputState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which may be modeled using quaternions, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which represents the same configuration using Euler angles instead. </p>
<p>If the <em>inputState</em> already uses Euler angles, the output will just be a duplicate. All continuous and discrete <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> variables will be copied to the <em>outputState</em> but they will not necessarily have been realized to the same level as the <em>inputState</em>. </p>

</div>
</div>
<a id="a68b377a776773482e43e5b89ebe0386b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b377a776773482e43e5b89ebe0386b">&#9670;&nbsp;</a></span>convertToQuaternions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::convertToQuaternions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>inputState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>outputState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which may be modeled using Euler angles, copy it to another <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> which represents the same configuration using quaternions instead. </p>
<p>If the <em>inputState</em> already uses quaternions, the output will just be a duplicate. All continuous and discrete <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> variables will be copied to the <em>outputState</em> but they will not necessarily have been realized to the same level as the <em>inputState</em>. </p>

</div>
</div>
<a id="a9867fb6504a2d9e33062db098299d25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9867fb6504a2d9e33062db098299d25f">&#9670;&nbsp;</a></span>normalizeQuaternions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::normalizeQuaternions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose generalized coordinates q have been modified in some manner that doesn't necessarily keep quaternions normalized, fix them. </p>
<p>Note that all of Simbody's integrators and solvers take care of this automatically so most users will never need to make this call.</p>
<p>Since we are modifying q's here, <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a> is invalidated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a9bc99d6feb480c714f57073be8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a9bc99d6feb480c714f57073be8b2e">&#9670;&nbsp;</a></span>calcSystemMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::SimbodyMatterSubsystem::calcSystemMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total system mass. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a459dbe161f3f40a31688851d0aab687c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459dbe161f3f40a31688851d0aab687c">&#9670;&nbsp;</a></span>calcSystemMassCenterLocationInGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::SimbodyMatterSubsystem::calcSystemMassCenterLocationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the position vector p_GC of the system mass center C, measured from the Ground origin, and expressed in Ground. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="af29174087d29ce0fb47d974dee778973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29174087d29ce0fb47d974dee778973">&#9670;&nbsp;</a></span>calcSystemMassPropertiesInGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a9d54d39dfaae29e62c7c1375620f1802">MassProperties</a> SimTK::SimbodyMatterSubsystem::calcSystemMassPropertiesInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return total system mass, mass center location measured from the Ground origin, and system inertia taken about the Ground origin, expressed in Ground. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a5ec0416ba22b4b23012b605cf8f707ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec0416ba22b4b23012b605cf8f707ef">&#9670;&nbsp;</a></span>calcSystemCentralInertiaInGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a71d271165c00227f5ff5951f1218029b">Inertia</a> SimTK::SimbodyMatterSubsystem::calcSystemCentralInertiaInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the system inertia matrix taken about the system center of mass, expressed in Ground. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a7e7c4a8c901513ef0eaff6cabe030ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7c4a8c901513ef0eaff6cabe030ca6">&#9670;&nbsp;</a></span>calcSystemMassCenterVelocityInGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::SimbodyMatterSubsystem::calcSystemMassCenterVelocityInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the velocity v_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="ae3beee3925d85bc63e874afde3eeca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3beee3925d85bc63e874afde3eeca2c">&#9670;&nbsp;</a></span>calcSystemMassCenterAccelerationInGround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::SimbodyMatterSubsystem::calcSystemMassCenterAccelerationInGround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the acceleration a_GC = d/dt p_GC of the system mass center C in the Ground frame G, measured from Ground origin and expressed in G. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a id="a9778e7621be2331052674953e2864d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9778e7621be2331052674953e2864d30">&#9670;&nbsp;</a></span>calcSystemMomentumAboutGroundOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::SimbodyMatterSubsystem::calcSystemMomentumAboutGroundOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the Ground origin and expressed in Ground. </p>
<p>(The linear component is independent of the "about" point.) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf8b7b6eaf6d1a7441ed605a30f13d96" title="Return the momentum of the system as a whole (angular, linear) measured in the Ground frame...">calcSystemCentralMomentum()</a> </dd></dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="abf8b7b6eaf6d1a7441ed605a30f13d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8b7b6eaf6d1a7441ed605a30f13d96">&#9670;&nbsp;</a></span>calcSystemCentralMomentum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::SimbodyMatterSubsystem::calcSystemCentralMomentum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the momentum of the system as a whole (angular, linear) measured in the Ground frame, taken about the current system center of mass location C and expressed in Ground. </p>
<p>(The linear component is independent of the "about" point.) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9778e7621be2331052674953e2864d30" title="Return the momentum of the system as a whole (angular, linear) measured in the Ground frame...">calcSystemMomentumAboutGroundOrigin()</a> </dd></dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="ac6cca0ac3895c7ab813a99162d7c85aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cca0ac3895c7ab813a99162d7c85aa">&#9670;&nbsp;</a></span>calcKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::SimbodyMatterSubsystem::calcKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total kinetic energy of all the mobilized bodies in this matter subsystem, given the configuration and velocities in <em>state</em>. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="a6cdfd4c182fd6b3f129e8f2bc1b6e6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6">&#9670;&nbsp;</a></span>multiplyBySystemJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ju</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) and a mobility-space vector u in O(n) time. </p>
<p>If the vector u is a set of generalized speeds, then this produces the body spatial velocities that result from those generalized speeds. That is, the result is V_GB = J*u where V_GB[i] is the spatial velocity of the i'th body's body frame origin (in Ground) that results from the given set of generalized speeds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ju</td><td>This is the product V=J*u as described above. Each element is a spatial vector, one per mobilized body, to be indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a>. If the input vector is a set of generalized speeds u, then the results are nb spatial velocities V_GBi (that is, a pair of vectors w_GBi and v_GBi giving angular and linear velocity). Note that Ground is body 0 so the 0th element V_GB0=V_GG=Ju[0] is always zero on return.</td></tr>
  </table>
  </dd>
</dl>
<p>The kinematic Jacobian (partial velocity matrix) J is defined as follows: </p><pre>
      partial(V)                                 T                        T
  J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
      partial(u)
</pre><p> Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a spatial vector). The transpose of this matrix maps spatial forces to generalized forces; see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a>.</p>
<p>Note that we're using "monogram" notation for the spatial velocities, where </p><pre>
            G Bi
    V_GBi =  V
</pre><p> the spatial velocity of body i's body frame Bi (at its origin), measured and expressed in the Ground frame G.</p>
<h3>Performance discussion</h3>
<p>This is a very fast operator, costing about 12*(nb+n) flops, where nb is the number of bodies and n the number of mobilities (degrees of freedom) u. In contrast, even if you have already calculated the entire nbXnX6 matrix J, the multiplication J*u would cost 12*nb*n flops. As an example, for a 20 body system with a free flying base and 19 pin joints (25 dofs altogether), this method takes 12*(20+25)=540 flops while the explicit matrix-vector multiply would take 12*20*25=6000 flops. So this method is already &gt;10X faster for that small system; for larger systems the difference grows rapidly.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c9e16d57c4d129a22311c26f4a555e3" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> </dd></dl>

</div>
</div>
<a id="a8b13161134a51492ea355a1eaae99dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b13161134a51492ea355a1eaae99dec">&#9670;&nbsp;</a></span>calcBiasForSystemJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the acceleration bias term for the System Jacobian, that is, the part of the acceleration that is due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as a spatial acceleration of each body frame in Ground.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JDotu</td><td>The product JDot*u where JDot = d/dt J, and u is the vector of generalized speeds taken from <em>state</em>. This is a Vector of nb SpatialVec elements.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The spatial velocity V_GBi of each body i can be obtained from the generalized speeds u by V = {V_GBi} = J*u. Taking the time derivative in G gives </p><pre>
    A = d/dt V = {A_GBi} = J*udot + JDot*u
</pre><p> where JDot=JDot(q,u). This method returns JDot*u, which depends only on configuration q and speeds u. Note that the same u is used to calculate JDot, which is linear in u, so this term is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method simply extracts the total Coriolis acceleration for each body that is already available in the <em>state</em> cache so there is no computation done here. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a> </dd></dl>

</div>
</div>
<a id="af6f1444c32982e68d8157a8435c61f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1444c32982e68d8157a8435c61f55">&#9670;&nbsp;</a></span>calcBiasForSystemJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns the bias as a 6*nb-vector of scalars rather than as an nb-vector of 2x3 spatial vectors. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="a2a6e9006e2a8e513f940e5e337c82329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6e9006e2a8e513f940e5e337c82329">&#9670;&nbsp;</a></span>multiplyBySystemJacobianTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyBySystemJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial force-like elements, one per body, in O(n) time to produce a generalized force-like result f=~J*F. </p>
<p>If F_G is actually a set of spatial forces applied at the body frame origin of each body, and expressed in the Ground frame, then the result is the equivalent set of generalized forces f that would produce the same accelerations as F_G.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_G</td><td>This is a vector of SpatialVec elements, one per mobilized body and in order of <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (with the 0th entry a force on Ground; hence ignored). Each SpatialVec is a spatial force-like pair of 3-vectors (torque,force) with the force applied at the body origin and the vectors expressed in Ground. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the product f=~J*F_G as described above. This result is in the generalized force space, that is, it has one scalar entry for each of the n system mobilities (velocity degrees of freedom). Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<p>The kinematic Jacobian (partial velocity matrix) J is defined as follows: </p><pre>
      partial(V)                                 T                        T
  J = ----------, V = [V_GB0 V_GB1 ... V_GB nb-1] ,  u = [u0 u1 ... u n-1]
      partial(u)
</pre><p> Thus the element J(i,j)=partial(V_GBi)/partial(uj) (each element of J is a spatial vector). J maps generalized speeds to spatial velocities (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>); its transpose ~J maps spatial forces to generalized forces.</p>
<p>Note that we're using "monogram" notation for the spatial velocities, where </p><pre>
            G Bi
    V_GBi =  V
</pre><p> the spatial velocity of body i's body frame Bi (at its origin), measured and expressed in the Ground frame G.</p>
<h3>Performance discussion</h3>
<p>This is a very fast operator, costing about 18*nb+11*n flops, where nb is the number of bodies and n the number of mobilities (degrees of freedom) u. In contrast, even if you have already calculated the entire 6*nbXnu matrix J, the multiplication ~J*F would cost 12*nb*n flops. As an example, for a 20 body system with a free flying base and 19 pin joints (25 dofs altogether), this method takes 18*20+11*25=635 flops while the explicit matrix-vector multiply would take 12*20*25=6000 flops. So this method is already &gt;9X faster for that small system; for larger systems the difference grows rapidly.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c9e16d57c4d129a22311c26f4a555e3" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> </dd></dl>

</div>
</div>
<a id="a4c9e16d57c4d129a22311c26f4a555e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9e16d57c4d129a22311c26f4a555e3">&#9670;&nbsp;</a></span>calcSystemJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>J_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a 2x3 spatial vector (SpatialVec). </p>
<p>This matrix maps generalized speeds to the spatial velocities of all the bodies, which will be at the body origins, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the spatial velocities of all nb bodies as V_G = J_G*u. The transpose of this matrix maps a set of spatial forces F_G, applied at the body frame origins and expressed in Ground, to the equivalent set of n generalized forces f: f = ~J_G*F_G.</p>
<dl class="section note"><dt>Note</dt><dd>The 0th row of the returned Jacobian is always zero since it represents the spatial velocity of Ground.</dd></dl>
<h3>Performance discussion</h3>
<p>Before using this method, consider whether you really need to form this very large matrix which necessarily will take O(n^2) space and time; it will almost always be <em>much</em> faster to use the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> method that directly calculate the matrix-vector product in O(n) time without explicitly forming the matrix. Here are the details:</p>
<p>As currently implemented, forming the full Jacobian J costs about 12*n*(nb+n) flops. Assuming nb ~= n, this is about 24*n^2 flops. Then if you want to form a product J*u explicitly, the matrix-vector multiply will cost about 12*n^2 flops each time you do it. In contrast the J*u product is calculated using <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> in about 24*n flops. Even for very small systems it is cheaper to make repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> than to form J explicitly and multiply by it. See the Performance section for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> for more comparisons.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c9e16d57c4d129a22311c26f4a555e3" title="Explicitly calculate and return the nb x nu whole-system kinematic Jacobian J_G, with each element a ...">calcSystemJacobian()</a> alternate signature using scalar elements </dd></dl>

</div>
</div>
<a id="aca444046ca1a2cae0c80b7846c29abf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca444046ca1a2cae0c80b7846c29abf4">&#9670;&nbsp;</a></span>calcSystemJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>J_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns a system Jacobian as a 6*nb X n Matrix of scalars rather than as an nb X n matrix of 2x3 spatial vectors. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a id="a9043c480738ccd9af077914c62e1c02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9043c480738ccd9af077914c62e1c02a">&#9670;&nbsp;</a></span>multiplyByStationJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JSu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) that results from a particular set of generalized speeds u. </p>
<p>The result is the station velocities measured and expressed in Ground.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JSu</td><td>The resulting product JS*u, where JS is the station task Jacobian. Resized to nt if needed.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>It is almost always better to use this method than to form an explicit 3*nt X n station task Jacobian explicitly and then multiply by it. If you have only one or two tasks, so that the matrix is only 3xn or 6xn, and then perform many multiplies with that matrix, it might be slightly cheaper to form it. For example, it is about 4X cheaper to use this method than to form a one-task Station Jacobian JS explicitly and use it once. However, because this would be such a skinny matrix (3 X n) explicit multiplication is cheap so if you will re-use this same Jacobian repeatedly before recalculating (at least 6 times) then it may be worth calculating and saving it. Here are the details:</p>
<p>A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 27*nt + 24*n flops. In contrast, assuming you already have the 3*nt X n station Jacobian JS available, you can compute the JS*u product in about 6*nt*n flops, 3X faster for one task, about even for three tasks, and slower for more than three tasks. However forming JS costs about 40*nt+90*n flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a609c9185a6855337ad7e0a6a28352d73" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a>). So to form a one-task Jacobian and use it once is 4X more expensive (96*n vs 24*n), but if you use it more than 5 times it is cheaper to do it explicitly. Forming a one-task JS and using it 100 times costs about 690*n flops while calling this method 100 times would cost about 2400*n flops.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e5e384f7e3dbf14be82f91156a942e6" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a609c9185a6855337ad7e0a6a28352d73" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a> </dd></dl>

</div>
</div>
<a id="ad5dbf65d8b88c13468888964cd511479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5dbf65d8b88c13468888964cd511479">&#9670;&nbsp;</a></span>multiplyByStationJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::SimbodyMatterSubsystem::multiplyByStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>
<dl class="section return"><dt>Returns</dt><dd>JS*u, where JS is the station task Jacobian. </dd></dl>

</div>
</div>
<a id="a5e5e384f7e3dbf14be82f91156a942e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e384f7e3dbf14be82f91156a942e6">&#9670;&nbsp;</a></span>multiplyByStationJacobianTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_GP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (points fixed to bodies) P. </p>
<p>The applied forces f_GP should be 3-vectors expressed in Ground. This is considerably faster than forming the Jacobian explicitly and then performing the matrix-vector multiply.</p>
<h3>Performance discussion</h3>
<p>Cost is about 30*nt + 18*nb + 11*n. Assuming nb ~= n, this is roughly 30*(n+nt). In contrast, forming the complete 3*nt X n matrix would cost about 90*(n+nt/2), and subsequent explicit matrix-vector multiplies would cost about 6*nt*n each.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9043c480738ccd9af077914c62e1c02a" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a609c9185a6855337ad7e0a6a28352d73" title="Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a...">calcStationJacobian()</a> </dd></dl>

</div>
</div>
<a id="a45fa4f9017618d84d4da705088a8e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fa4f9017618d84d4da705088a8e06f">&#9670;&nbsp;</a></span>multiplyByStationJacobianTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByStationJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>f_GP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a id="a609c9185a6855337ad7e0a6a28352d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609c9185a6855337ad7e0a6a28352d73">&#9670;&nbsp;</a></span>calcStationJacobian() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly calculate and return the 3*nt x n kinematic Jacobian JS for a set of nt station tasks P (a station is a point fixed on a particular mobilized body). </p>
<p>This matrix maps generalized speeds to the Cartesian velocity of each station, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the Cartesian velocities of stations P as v_GP = JS*u, where v_GP is a 3*nt column vector. The transpose of this matrix maps a 3*nt vector of forces f_GP (expressed in Ground and applied to P) to the equivalent set of n generalized forces f: f = ~JS*f_GP.</p>
<dl class="section note"><dt>Note</dt><dd>It is almost always far more efficient to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9043c480738ccd9af077914c62e1c02a" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e5e384f7e3dbf14be82f91156a942e6" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a> to form matrix-vector products rather than to use this method to form the Jacobian explicitly. See the performance discussions there.</dd></dl>
<p>Overloaded signatures of this method are available to allow you to obtain the Jacobian either as an nt X n Matrix with Vec3 elements, or as 3*nt X n Matrix with scalar elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JS</td><td>The resulting nt X n station task Jacobian. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>The cost of a call to this method is about 42*nt + 54*nb + 33*n flops. If we assume that nb ~= n &gt;&gt; 1, this is roughly 90*(n+nt/2) flops. Then once the Station Jacobian JS has been formed, each JS*u matrix-vector product costs 6*nt*n flops to form. When nt is small enough (say one or two tasks), and you plan to re-use it a lot, this can be computationally efficient; but for single use or more than a few tasks you can do much better with <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9043c480738ccd9af077914c62e1c02a" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e5e384f7e3dbf14be82f91156a942e6" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a9043c480738ccd9af077914c62e1c02a" title="Calculate the Cartesian ground-frame velocities of a set of task stations (points fixed on bodies) th...">multiplyByStationJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5e5e384f7e3dbf14be82f91156a942e6" title="Calculate the generalized forces resulting from a single force applied to a set of nt station tasks (...">multiplyByStationJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a id="af27560a2741e1d8e93f41671101927f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27560a2741e1d8e93f41671101927f3">&#9670;&nbsp;</a></span>calcStationJacobian() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a id="a3eaf0210388cde7033d23f8254bf0b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaf0210388cde7033d23f8254bf0b5a">&#9670;&nbsp;</a></span>calcStationJacobian() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns a station Jacobian as a 3*nt x n Matrix rather than as a Matrix of Vec3 elements. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a id="a7ea22d30ca5f984f6079b91eea0ed928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea22d30ca5f984f6079b91eea0ed928">&#9670;&nbsp;</a></span>calcStationJacobian() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>

</div>
</div>
<a id="a991359a02df025302e67f90de61f9c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991359a02df025302e67f90de61f9c13">&#9670;&nbsp;</a></span>calcBiasForStationJacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JSDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the acceleration bias term for a station Jacobian, that is, the part of the station's acceleration that is due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as a linear acceleration of the station in Ground.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the stations of interest are fixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stationPInB</td><td>The array of nt station points P of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its station P, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JSDotu</td><td>The resulting product JSDot*u, where JSDot is the time derivative of JS, the station task Jacobian. Resized to nt if needed.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The velocity v_GP of a station point P in the Ground frame G can be obtained from the generalized speeds u using the station Jacobian for P, as </p><pre>
    v_GP = JS_P*u
</pre><p> Taking the time derivative in G gives </p><pre>
    a_GP = JS_P*udot + JSDot_P*u
</pre><p> This method returns JSDot_P*u, which depends only on configuration and velocities. We allow for a set of task points P so that all their bias terms can be calculated in a single sweep of the multibody tree. Note that u is taken from the <em>state</em> and that the same u shown above is also used to calculate JSDot_P, which is linear in u, so the bias term is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method just obtains body B's total Coriolis acceleration already available in the <em>state</em> cache and shifts it to station point P. Cost is 48*nt flops. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a>, <a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720" title="Shift a relative spatial acceleration measured at some point to that same relative spatial quantity b...">shiftAccelerationBy()</a> </dd></dl>

</div>
</div>
<a id="a8f6dd4c627e1aed36297001f2ff73d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6dd4c627e1aed36297001f2ff73d5c">&#9670;&nbsp;</a></span>calcBiasForStationJacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JSDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns the bias as a 3*nt-vector of scalars rather than as an nt-vector of Vec3s. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="ab8d0adf617de56f182165241c45d5dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d0adf617de56f182165241c45d5dfe">&#9670;&nbsp;</a></span>calcBiasForStationJacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::SimbodyMatterSubsystem::calcBiasForStationJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationPInB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature for when you just have a single station task. </p>
<dl class="section return"><dt>Returns</dt><dd>JSDot*u, where JSDot is the station Jacobian time derivative. </dd></dl>

</div>
</div>
<a id="a2d9c3d793cf53968c089dc59732ac639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9c3d793cf53968c089dc59732ac639">&#9670;&nbsp;</a></span>multiplyByFrameJacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JFu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}, that result from a particular set of n generalized speeds u. </p>
<p>The result is each task frame's angular and linear velocity measured and expressed in Ground. Using this method is considerably faster than forming the 6*nt X n Frame Jacobian explicitly and then performing the matrix-vector multiply. See the performance analysis below for details.</p>
<p>There is a simplified signature of this method available if you have only a single frame task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>A mobility-space Vector, such as a set of generalized speeds. The length and order must match the mobilities of this system (that is n, the number of generalized speeds u, <em>not</em> nq, the number of generalized coordinates q). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JFu</td><td>The resulting product JF*u, where JF is the frame task Jacobian. Resized if needed to a Vector of nt SpatialVec entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All frames A fixed to a given body B have the same angular velocity so we do not actually need to know the task frames' orientations here, just the location on B of their origin points Ao. If you have a Transform X_BA giving the pose of frame A in the body frame B, you can extract the position vector for the origin point Ao using X_BA.p() and pass that as the <em>originAoInB</em> parameter here.</dd></dl>
<h3>Performance discussion</h3>
<p>A call to this method costs 27*nt + 12*(nb+n) flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 25*(nt+n) flops. In contrast, assuming you already have the 6*nt X n Frame Jacobian JF available, you can compute the JF*u product in about 12*nt*n flops. If you have just one task (nt==1) this explicit multiplication is about twice as fast; at two tasks it is about even and for more than two it is more expensive. However forming JF costs about 180*(n+nt/4) flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a62cd2dc07b0e88b0a2db0689221ae1b9" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a>). So to form a one-task Jacobian and use it once is almost 8X more expensive (192*n vs 25*n), but if you use it more than 16 times it is (marginally) cheaper to do it explicitly (for one task). For example, forming a one-task JF and using it 100 times costs 1392*n flops while calling this method 100 times would cost about 2500*n flops.</p>
<p>Conclusion: in almost all practical cases you are better off using this operator rather than forming JF, even if you have only a single frame task and certainly if you have more than two tasks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaed9e569f3d409734fc8930e9774e629" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. ">multiplyByFrameJacobianTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a62cd2dc07b0e88b0a2db0689221ae1b9" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a> </dd></dl>

</div>
</div>
<a id="a51d13f6ee1f192d26a6f1c7ac1fed670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d13f6ee1f192d26a6f1c7ac1fed670">&#9670;&nbsp;</a></span>multiplyByFrameJacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified signature for when you just have a single frame task; see the main signature for documentation. </p>
<dl class="section return"><dt>Returns</dt><dd>JF*u, where JF is the single frame task Jacobian. </dd></dl>

</div>
</div>
<a id="aaed9e569f3d409734fc8930e9774e629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed9e569f3d409734fc8930e9774e629">&#9670;&nbsp;</a></span>multiplyByFrameJacobianTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_GAo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. </p>
<p>The applied forces are spatial vectors (pairs of 3-vectors) expressed in Ground. Use of this O(n) method is considerably faster than forming the 6*nt X n Jacobian explicitly and then performing an O(n^2) matrix-vector multiply.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_GAo</td><td>A Vector of nt spatial forces, each applied one of the task frames. These are expressed in Ground. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>The Vector of n generalized forces that results from applying the forces <em>F_GAo</em> to the task frames. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>A call to this method costs 33*nt + 18*nb + 11*n flops. If you assume that nb ~= n &gt;&gt; 1, you could say this is about 30*(n+nt) flops. In contrast, assuming you already have the 6*nt X n Frame Jacobian JF available, you can compute the ~JF*F product in about 12*nt*n flops. For one or two tasks that would be faster than applying the operator. However forming JF costs about 180*(n+nt/4) flops (see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a62cd2dc07b0e88b0a2db0689221ae1b9" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a>). So to form even a one-task Frame Jacobian and use it once is about 6X more expensive than using the operator (192*n vs 30*n), but if you use it more than 10 times it is (marginally) cheaper to do it explicitly. For example, forming a one-task JF and using it 100 times costs around 1392*n flops while calling this method 100 times would cost about 3000*n flops.</p>
<p>Conclusion: in almost all practical cases you are better off using this operator rather than forming JF, even if you have only a single frame task and certainly if you have more than two tasks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d9c3d793cf53968c089dc59732ac639" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a62cd2dc07b0e88b0a2db0689221ae1b9" title="Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai...">calcFrameJacobian()</a> </dd></dl>

</div>
</div>
<a id="ac7c3a91c6786c60bc247b33051c04627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c3a91c6786c60bc247b33051c04627">&#9670;&nbsp;</a></span>multiplyByFrameJacobianTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByFrameJacobianTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &amp;&#160;</td>
          <td class="paramname"><em>F_GAo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="a62cd2dc07b0e88b0a2db0689221ae1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd2dc07b0e88b0a2db0689221ae1b9">&#9670;&nbsp;</a></span>calcFrameJacobian() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Matrix__.html">Matrix_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly calculate and return the 6*nt x n frame task Jacobian JF for a set of nt frame tasks A={Ai} fixed to nt bodies B={Bi}. </p>
<p>This matrix maps generalized speeds to the Cartesian spatial velocity (angular and linear velocity) of each frame, measured and expressed in Ground. That is, if you have a set of n generalized speeds u, you can find the Cartesian spatial velocities of task frames A as V_GA = JF*u, where V_GA is a 6*nt column vector. The transpose of this matrix maps a 6*nt vector of spatial forces F_GA (expressed in Ground and applied to the origins of frames A) to the equivalent set of n generalized forces f: f = ~JF*F_GA.</p>
<dl class="section note"><dt>Note</dt><dd>It is almost always far more efficient to use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d9c3d793cf53968c089dc59732ac639" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaed9e569f3d409734fc8930e9774e629" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. ">multiplyByFrameJacobianTranspose()</a> to form matrix-vector products rather than to use this method to form the Jacobian explicitly. See the performance discussion there.</dd></dl>
<p>Overloaded signatures of this method are available to allow you to obtain the Jacobian either as an nt X n Matrix with SpatialVec elements, or as 6*nt X n Matrix with scalar elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Position stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JF</td><td>The resulting nt X n frame task Jacobian, with each element a SpatialVec. Resized if necessary.</td></tr>
  </table>
  </dd>
</dl>
<h3>Performance discussion</h3>
<p>The cost of a call to this method is about 42*nt + 108*nb + 66*n flops. If we assume that nb ~= n &gt;&gt; 1, this is roughly 180*(n+nt/4) flops. Then once the Frame Jacobian JF has been formed, each JF*u matrix-vector product costs about 12*nt*n flops to form. When nt is small enough (say one or two tasks), and you plan to re-use it a lot, this can be computationally efficient; but for single use or more than a few tasks you can do much better with <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d9c3d793cf53968c089dc59732ac639" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaed9e569f3d409734fc8930e9774e629" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. ">multiplyByFrameJacobianTranspose()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d9c3d793cf53968c089dc59732ac639" title="Calculate the spatial velocities of a set of nt task frames A={Ai} fixed to nt bodies B={Bi}...">multiplyByFrameJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aaed9e569f3d409734fc8930e9774e629" title="Calculate the n generalized forces f resulting from a set of spatial forces (torque,force pairs) F applied at nt task frames Ai fixed to nt bodies Bi. ">multiplyByFrameJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a id="ac949f57c30f6653d374f057e4ef3f22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac949f57c30f6653d374f057e4ef3f22b">&#9670;&nbsp;</a></span>calcFrameJacobian() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1RowVector__.html">RowVector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="a4a2c501d7903e69f96f649a459cb4b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2c501d7903e69f96f649a459cb4b5c">&#9670;&nbsp;</a></span>calcFrameJacobian() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns a frame Jacobian as a 6*nt X n Matrix rather than as an nt X n Matrix of SpatialVecs. </p>
<p>See the other signature for documentation and important performance considerations. </p>

</div>
</div>
<a id="ab48c3cd7ad27f3f478957c34f8df06b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48c3cd7ad27f3f478957c34f8df06b3">&#9670;&nbsp;</a></span>calcFrameJacobian() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>JF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="ac9e44a33e1b5d0649aa2baff031841aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e44a33e1b5d0649aa2baff031841aa">&#9670;&nbsp;</a></span>calcBiasForFrameJacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>JFDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the acceleration bias term for a task frame Jacobian, that is, the parts of the frames' accelerations that are due only to velocities. </p>
<p>This term is also known as the Coriolis acceleration, and it is returned here as spatial accelerations of the frames in Ground.</p>
<p>There is a simplified signature of this method available if you have only a single frame task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has already been realized through Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">onBodyB</td><td>An array of nt mobilized bodies (one per task) to which the task frames of interest are fixed. These may be in any order and the same body may appear more than once if there are multiple task frames on it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">originAoInB</td><td>An array of nt frame origin points Ao for the task frames of interest (one per task), each corresponding to one of the bodies B from <em>onBodyB</em>, given as vectors from each body B's origin Bo to its task frame origin Ao, expressed in frame B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JFDotu</td><td>The result JFDot*u, where JF is the task frame Jacobian and JFDot its time derivative, and u is the set of generalized speeds taken from the the supplied <em>state</em>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Theory</h3>
<p>The spatial velocity V_GA of frame A can be obtained from the generalized speeds u using the frame Jacobian for A, as V_GA = JF*u. Taking the time derivative in G gives </p><pre>
    A_GA = JF*udot + JFDot*u
</pre><p> This method returns JFDot*u, which depends only on configuration and velocities. Note that the same u is used to calculate JFDot, which is linear in u, so the term JFDot*u is quadratic in u.</p>
<h3>Implementation</h3>
<p>This method just obtains body B's total Coriolis acceleration already available in the <em>state</em> cache and shifts it to the A frame's origin Ao, for each of the nt task frames. Cost is 48*nt flops.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a>, <a class="el" href="group__SpatialAlgebraUtilities.html#ga4cd275315e4cfd899f739fad664c1720" title="Shift a relative spatial acceleration measured at some point to that same relative spatial quantity b...">shiftAccelerationBy()</a> </dd></dl>

</div>
</div>
<a id="a14e983ee73ca90dae676f0f1386519b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e983ee73ca90dae676f0f1386519b6">&#9670;&nbsp;</a></span>calcBiasForFrameJacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>JFDotu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate signature that returns the bias as a 6*nt-vector of scalars rather than as an nt-vector of SpatialVec elements. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="a76c30c4ab145c9b11c6dba86f18f1057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c30c4ab145c9b11c6dba86f18f1057">&#9670;&nbsp;</a></span>calcBiasForFrameJacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> SimTK::SimbodyMatterSubsystem::calcBiasForFrameJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>onBodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>originAoInB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplified signature for when you just have a single frame task. </p>
<dl class="section return"><dt>Returns</dt><dd>JFDot*u, where JFDot is the frame task Jacobian time derivative and u the generalized speeds taken from <em>state</em>. </dd></dl>

</div>
</div>
<a id="a4c95c1922247ca717f8f5b4751bf704a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95c1922247ca717f8f5b4751bf704a">&#9670;&nbsp;</a></span>multiplyByM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a supplied mobility-space vector (that is, it has one entry for each of the n mobilities). </p>
<p>If v is a set of mobility accelerations (generalized accelerations udot), then the result is a generalized force (f=M*udot). Only the supplied vector is used, and M depends only on position states, so the result here is not affected by velocities in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. Constraints and prescribed motions are ignored.</p>
<p>The current implementation requires about 120*n flops and does not require realization of composite-body or articulated-body inertias. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a3a06d5c75f71747d4fa479e7abfd3971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a06d5c75f71747d4fa479e7abfd3971">&#9670;&nbsp;</a></span>multiplyByMInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByMInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>MinvV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a supplied vector with one entry per u-space mobility. </p>
<p>If v is a set of generalized forces f, the result is a generalized acceleration (udot=M^-1*f). Only the supplied vector is used, and M depends only on position states, so the result here is not affected by velocities in <em>state</em>. In particular, you'll have to obtain your own inertial forces and put them in f if you want them included.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>This is a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has been realized through Position stage, from which the current system configuration and articulated body inertias are obtained. If necessary, the articulated body inertias will be realized in the state the first time this is called. They will then be retained in the <em>state</em> cache for speed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>This is a generalized-force like vector in mobility space (u-space). If there is any prescribed motion specified using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking (see below), then only the entries of v corresponding to non-prescribed mobilities are examined by this method; the prescribed ones are not referenced at all. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MinvV</td><td>This is the result M^-1*v. If there is any prescribed motion specified using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locks (see below), then only the non-prescribed entries in MinvV are calculated; the prescribed ones are set to zero.</td></tr>
  </table>
  </dd>
</dl>
<h3>Behavior with prescribed motion</h3>
<p>If you prescribe the motion of one or more mobilizers using <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking, the behavior of this method is altered. (This does <em>not</em> apply if you use <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects to specify the motion.) With prescribed motion enabled, this method works only with the free (non-prescribed) mobilities. Only the entries in <em>v</em> corresponding to free mobilities are examined, and only the entries in the result <em>MinvV</em> corresponding to free mobilities are calculated; the others are set to zero.</p>
<h3>Theory</h3>
<p>View the unconstrained, prescribed zero-velocity equations of motion M udot + tau = f as partitioned into "free" and "prescribed" variables like this: </p><pre>
    [M_ff ~M_fp] [udot_f]   [ 0 ]   [f_f]
    [          ] [      ] + [   ] = [   ]
    [M_fp  M_pp] [udot_p]   [tau]   [f_p]
</pre><p> The free and prescribed variables have been grouped here for clarity but in general they are interspersed among the columns and rows of M.</p>
<p>Given that decomposition, this method returns </p><pre>
    [udot_f]   [udot_f]   [M_ff^-1  0  ][f_f]
    [      ] = [      ] = [            ][   ]
    [udot_p]   [  0   ]   [   0     0  ][f_p]
</pre><p> When there is no prescribed motion M_ff is the entire mass matrix, and the result is udot_f=udot=M^-1*f. When there is prescribed motion, M_ff is a submatrix of M, and the result is the nf elements of udot_f, with udot_p=0.</p>
<h3>Implementation</h3>
<p>This is a stripped-down version of forward dynamics. It requires the hybrid free/prescribed articulated body inertias to have been realized and will initiate that calculation if necessary the first time it is called for a given configuration q. The M^-1*f calculation requires two sweeps of the multibody tree, an inward sweep to accumulate forces, followed by an outward sweep to propagate accelerations.</p>
<h3>Performance</h3>
<p>If the supplied <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> does not already contain realized values for the articulated body inertias, then they will be realized when this operator is first called for a new set of positions. Calculating articulated body inertias is O(n) but relatively expensive. Once the appropriate articulated body inertias are available, repeated calls to this operator are very fast, with worst case around 80*n flops when all mobilizers have 1 dof. If you want to force realization of the articulated body inertias, call the method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a>.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> (articulated body inertias realized first if necessary)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c95c1922247ca717f8f5b4751bf704a" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a> </dd></dl>

</div>
</div>
<a id="a49c974a8abcd50c0f1d662bdc2297ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c974a8abcd50c0f1d662bdc2297ea9">&#9670;&nbsp;</a></span>calcM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator explicitly calculates the n X n mass matrix M. </p>
<p>Note that this is inherently an O(n^2) operation since the mass matrix has n^2 elements (although only n(n+1)/2 are unique due to symmetry). <em>DO NOT USE THIS CALL DURING NORMAL DYNAMICS</em>. To do so would change an O(n) operation into an O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators like <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c95c1922247ca717f8f5b4751bf704a" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a> which calculates the matrix-vector product M*v in O(n) without explicitly forming M. Also, don't invert this matrix numerically to get M^-1. Instead, call the method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> which can produce M^-1 directly.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c95c1922247ca717f8f5b4751bf704a" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> </dd></dl>

</div>
</div>
<a id="a04118e791c39959f7a093cd5781f9ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04118e791c39959f7a093cd5781f9ab5">&#9670;&nbsp;</a></span>calcMInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcMInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>MInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix corresponding to free (non-prescribed) mobilities. </p>
<p>The returned matrix is always n X n, but rows and columns corresponding to prescribed mobilities are zero. This is an O(n^2) operation, which is of course within a constant factor of optimal for returning a matrix with n^2 elements explicitly. (There are actually only n(n+1)/2 unique elements since the matrix is symmetric.) <em>DO NOT USE THIS CALL DURING NORMAL DYNAMICS</em>. To do so would change an O(n) operation into an O(n^2) one. Instead, see if you can accomplish what you need with O(n) operators like <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> which calculates the matrix-vector product M^-1*v in O(n) without explicitly forming M or M^-1. If you need M explicitly, you can get it with the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a49c974a8abcd50c0f1d662bdc2297ea9" title="This operator explicitly calculates the n X n mass matrix M. ">calcM()</a> method.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> (articulated body inertias realized first if necessary)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a49c974a8abcd50c0f1d662bdc2297ea9" title="This operator explicitly calculates the n X n mass matrix M. ">calcM()</a> </dd></dl>

</div>
</div>
<a id="abf833dd0d297247f53ad4b956f4d8455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf833dd0d297247f53ad4b956f4d8455">&#9670;&nbsp;</a></span>calcProjectedMInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcProjectedMInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>GMInvGt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator calculates in O(m*n) time the m X m "projected inverse mass 
matrix" or "constraint compliance matrix" W=G*M^-1*~G, where G (mXn) is the acceleration-level constraint Jacobian mapped to generalized coordinates, and M (nXn) is the unconstrained system mass matrix. </p>
<p>In case there is prescribed motion specified with <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or mobilizer locking, M^-1 here is really M_ff^-1, that is, it is restricted to the free (non-prescribed) mobilities, but scattered into a full n X n matrix (conceptually). See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> for more information.</p>
<p>W is the projection of the inverse mass matrix into the constraint coordinate space (that is, the vector space of the multipliers lambda). It can be used to solve for the constraint forces that will eliminate a given constraint acceleration error: </p><pre>
    (1)     W * lambda = aerr
    (2)     aerr = G*udot - b(t,q,u)
</pre><p> where udot is an unconstrained generalized acceleration. Note that you can view equation (1) as a dynamic system in a reduced set of m generalized coordinates, with the caveat that W may be singular.</p>
<p>In general W is singular and does not uniquely determine lambda. Simbody normally calculates a least squares solution for lambda so that loads are distributed among redundant constraints.</p>
<dl class="section note"><dt>Note</dt><dd>If you just need to multiply W by a vector or matrix, you do not need to form W explicitly. Instead you can use the method described in the Implementation section to produce a W*v product in the O(n) time it takes to compute a single column of W.</dd></dl>
<h3>Implementation</h3>
<p>We are able to form W without forming G or M^-1 and without performing any matrix-matrix multiplies. Instead, W is calculated using m applications of O(n) operators:</p><ul>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> by a unit vector to form a column of ~G</li>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> to form a column of M^-1 ~G</li>
<li><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> to form a column of W</li>
</ul>
<p>Even if G and M^-1 were already available, computing W by matrix multiplication would cost O(m^2*n + m*n^2) time and O(m*n) intermediate storage. Here we do it in O(m*n) time with O(n) intermediate storage, which is a <em>lot</em> better.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> (articulated body inertias realized first if necessary)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1b31f1a35d519d303c64ad82428f9ae" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab790bd6457ec2cb8bfef5af104615d06" title="This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Ja...">calcGTranspose()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a04118e791c39959f7a093cd5781f9ab5" title="This operator explicitly calculates the inverse of the part of the system mobility-space mass matrix ...">calcMInv()</a> </dd></dl>

</div>
</div>
<a id="a482586922bb1c58bc309e1a0b3d501e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482586922bb1c58bc309e1a0b3d501e0">&#9670;&nbsp;</a></span>solveForConstraintImpulses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::solveForConstraintImpulses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>deltaV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>impulse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of desired constraint-space speed changes, calculate the corresponding constraint-space impulses that would cause those changes. </p>
<p>Here we are solving the equation </p><pre>
    W * impulse = deltaV
</pre><p> for <em>impulse</em>, where W=G*M^-1*~G is the "projected inverse mass matrix" as described for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf833dd0d297247f53ad4b956f4d8455" title="This operator calculates in O(m*n) time the m X m &quot;projected inverse mass  matrix&quot; or &quot;constraint com...">calcProjectedMInv()</a>. In general W is singular due to constraint redundancies, so the solution for <em>impulse</em> is not unique. Simbody handles redundant constraints by finding least squares solutions, and this operator method duplicates the method Simbody uses for determining the rank and performing the factorization of W.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> whose generalized coordinates and speeds define the matrix W. Must already be realized to Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deltaV</td><td>The set of desired velocity changes to be produced by the impulse, in constraint space. These will consist of observed velocity constraint violations (-verr) and constraint violations that would be generated by impulsive applied forces (-G*M^-1*f). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">impulse</td><td>The set of constraint multiplier-space impulses that will produce the desired velocity changes without violating the constraints.</td></tr>
  </table>
  </dd>
</dl>
<p>To convert these constraint-space impulses into updates to the mobility-space generalized speeds u, use code like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4b5ec5c33a93af6d9e3a8ebc6bf37b51">SimbodyMatterSubsystem</a>&amp; matter=...;</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> deltaV=...;  <span class="comment">// constraint space speed change desired; length m</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> impulse;     <span class="comment">// constraint space impulses; length m</span></div><div class="line"><a class="code" href="classSimTK_1_1SimbodyMatterSubsystem.html#a482586922bb1c58bc309e1a0b3d501e0">solveForConstraintImpulses</a>(state, deltaV, impulse);</div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> f;           <span class="comment">// mobility space impulses; length n</span></div><div class="line"><a class="code" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> du;          <span class="comment">// change to generalized speeds u; length n</span></div><div class="line">matter.multiplyByGTranspose(s,impulse,f);</div><div class="line">matter.multiplyByMInv(s,f,du);</div><div class="line">state.updU() += du; <span class="comment">// update generalized speeds</span></div></div><!-- fragment --><p>Note that the length of the constraint-space vectors is m=mp+mv+ma, the total number of acceleration-level constraints including the second time derivatives of the position (holonomic) constraints, the first time derivatives of the velocity (nonholonomic) constraints, and the acceleration-only constraints. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#abf833dd0d297247f53ad4b956f4d8455" title="This operator calculates in O(m*n) time the m X m &quot;projected inverse mass  matrix&quot; or &quot;constraint com...">calcProjectedMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> </dd></dl>

</div>
</div>
<a id="a339a373cf4480657d982cef58ffe74c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339a373cf4480657d982cef58ffe74c1">&#9670;&nbsp;</a></span>multiplyByG() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Gulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a "u-like" (mobility space) vector of length n. </p>
<p>m is the number of active acceleration-level constraint equations, n is the number of mobilities. This is an O(m+n) operation.</p>
<p>If you are going to call this method repeatedly at the same time, positions and velocities, you should precalculate the bias term once and supply it to the alternate signature of this method. See the Implementation section for more information.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="section user"><dt>Implementation</dt><dd>This is accomplished by treating the input vector <em>ulike</em> as though it were a set of generalized accelerations (for nonholonomic and acceleration-only constraints) or generalized speeds (for holonomic constraints). These are mapped to body accelerations (or velocities) in O(n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3c340ca99cb804e9e33d736dfa43c066" title="Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) ...">calcBodyAccelerationFromUDot()</a> for more information (converting from generalized speeds to velocities is just multiplying by the <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> Jacobian). The method <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5b4cbd990b2cfff54a8fba1048bf21da" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> is used to determine the state-dependent term of the constraint error equations. Then a second call is made to evaluate the bias term aerr(t,q,u;0)=-b(t,q,u). We then calculate Gulike = aerr(t,q,u;ulike)-aerr(t,q,u;0) in O(m) time. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5b4cbd990b2cfff54a8fba1048bf21da" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> </dd></dl>

</div>
</div>
<a id="a4c080bc497aaa4bc2251c79da222f770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c080bc497aaa4bc2251c79da222f770">&#9670;&nbsp;</a></span>multiplyByG() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>ulike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>Gulike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply Gulike=G*ulike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5b4cbd990b2cfff54a8fba1048bf21da" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByG() method abo...">calcBiasForMultiplyByG()</a> </dd></dl>

</div>
</div>
<a id="a5b4cbd990b2cfff54a8fba1048bf21da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4cbd990b2cfff54a8fba1048bf21da">&#9670;&nbsp;</a></span>calcBiasForMultiplyByG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, positions q, and speeds u; must be realized through Velocity stage so that all body spatial velocities are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bias</td><td>This is the bias vector for use in repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>. It will be resized if necessary to length m=mp+mv+ma, the total number of active acceleration-level constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="section user"><dt>Implementation</dt><dd>This method uses either velocity- or acceleration- level constraint error functions with zero input to determine the bias term for use in <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>. <a class="el" href="classSimTK_1_1Body.html" title="The Body class represents a reference frame that can be used to describe mass properties and geometry...">Body</a> quantities and generalized quantities are supplied to each of the m active constraints' (constant time) error methods to calculate <pre>
   pverr(t,q,u;ulike)=G*ulike - c(t,q)    (holonomic) 
or aerr(t,q,u;ulike)=G*ulike - b(t,q,u)   (nonholonomic or acceleration-only)
</pre> with ulike=0, giving the bias term in O(m) time.</dd></dl>
<p>If you want the acceleration-level bias terms b for all the constraints, even if they are holonomic, use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afbbb14fe7232d63df52e3f56fd69a2a0" title="Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints...">calcBiasForAccelerationConstraints()</a>. </p>

</div>
</div>
<a id="aa1b31f1a35d519d303c64ad82428f9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b31f1a35d519d303c64ad82428f9ae">&#9670;&nbsp;</a></span>calcG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which appears in the system equations of motion. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a> method instead of this one, which forms the matrix-vector product G*v in O(m+n) time without explicitly forming G.</p>
<dl class="section user"><dt>Implementation</dt><dd>This method generates G columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, which makes use of the constraint error methods to perform a G*v product in O(m+n) time. To within numerical error, for non-working constraints this should be identical to the transpose of the matrix returned by calcGt() which uses the constraint force methods instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, calcGt(), <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2df63f08ff4e61cf541250971ad1ebe7" title="This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian...">calcPq()</a> </dd></dl>

</div>
</div>
<a id="afbbb14fe7232d63df52e3f56fd69a2a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbb14fe7232d63df52e3f56fd69a2a0">&#9670;&nbsp;</a></span>calcBiasForAccelerationConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForAccelerationConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints that are independent of the accelerations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, positions q, and speeds u; must be realized through Velocity stage so that all body spatial velocities are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bias</td><td>This is the bias vector for all the acceleration constraint equations together. It will be resized if necessary to length m=mp+mv+ma, the total number of active acceleration-level constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Velocity stage </dd></dl>
<dl class="section user"><dt>Implementation</dt><dd>We have constant-time constraint acceleration error methods <pre>   
paerr(t,q,u;udot)=P*udot - b_p(t,q,u) 
vaerr(t,q,u;udot)=V*udot - b_v(t,q,u) 
 aerr(t,q,u;udot)=A*udot - b_a(t,q,u)   
</pre> that together define the acceleration constraint equation G*udot-b=0 where G=[P;V;A] and b=[b_p b_v b_a]. There is one of these error functions for each Constraint, with paerr() the twice-differentiated position (holonomic) constraints, vaerr() the once-differentiated velocity (nonholonomic) constraints, and aerr() the acceleration-only constraints. This method sets <code>udot</code> = 0 and invokes each of those methods to obtain bias = -[b_p b_v b_a].</dd></dl>
<h3>Performance note</h3>
<p>The actual acceleration constraint functions require both udot and body accelerations for the constrained bodies; even with udot==0 body accelerations may have a non-zero velocity-dependent component (the coriolis accelerations). Those are already available in the state, but only as accelerations in Ground. For constraints that have a non-Ground Ancestor, we have to convert the accelerations to A at a cost of 105 flops/constrained body.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6961b2e3be325a50acfc71e18e1cd9f" title="Given a complete set of nu generalized accelerations udot, this operator computes the constraint acce...">calcConstraintAccelerationErrors()</a> </dd></dl>

</div>
</div>
<a id="af6961b2e3be325a50acfc71e18e1cd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6961b2e3be325a50acfc71e18e1cd9f">&#9670;&nbsp;</a></span>calcConstraintAccelerationErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcConstraintAccelerationErrors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>pvaerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a complete set of nu generalized accelerations udot, this operator computes the constraint acceleration errors that result due to the constraints currently active in the given state: </p>
<pre>
       pvaerr = G udot - b(t,q,u)</pre><pre>             where</pre><pre>              [P]    [bp]
            G=[V]  b=[bv]
              [A]    [ba]
</pre><p> The quantity <a class="el" href="classSimTK_1_1Subsystem.html#a0ff8bc209919f086d50dd632ad7c1698">Subsystem::getUDotErr()</a> is computed by the same operation as this method performs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUDot</td><td>A complete set of generalized accelerations. Must have the same length as the number of mobilities nu, or if length zero the udots will be taken as all zero in which case only the bias vector -b will be returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvaerr</td><td>The error in the acceleration-level constraint equations. All acceleration-level constraints are included: holonomic second derivatives, nonholonomic first derivatives, and acceleration-only constraints. The vector will be resized if necessary to length m=mp+mv+ma, the total number of active acceleration-level constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation</dt><dd>This operator takes O(m+n) time.</dd></dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1b31f1a35d519d303c64ad82428f9ae" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afbbb14fe7232d63df52e3f56fd69a2a0" title="Calculate the acceleration constraint bias vector, that is, the terms in the acceleration constraints...">calcBiasForAccelerationConstraints()</a> </dd></dl>

</div>
</div>
<a id="a8a9da182a2dd46ad4159b0e2cd7efb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9da182a2dd46ad4159b0e2cd7efb50">&#9670;&nbsp;</a></span>multiplyByGTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByGTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (=[P;V;A]) and a multiplier-like vector <em>lambda</em> of length m, returning a generalized-force like quantity <em>f</em> of length n. </p>
<p>m=mp+mv+ma is the total number of active constraint equations, n (==nu) is the number of mobilities (generalized speeds u). If lambda is a set of constraint multipliers, then f=~G*lambda is the set of forces generated by the constraints, mapped into generalized forces. This is an O(m+n) operation.</p>
<p>Because the velocity (non-holonomic) or acceleration-only constraint Jacobians V and A can have velocity dependence, the <em>state</em> supplied here must generally be realized through Velocity stage. If the system has only position (holonomic) constraints then the <em>state</em> need be realized only through Position stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has been realized through Velocity stage (or Position stage if the system has no velocity-dependent constraint Jacobians). Configuration and velocities if needed are taken from <em>state</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>A multiplier-like vector to be multiplied by ~G. Its length must be the same as the total number of active constraint equations m. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the generalized force-like output. It will be resized if necessary to length equal to the number of mobilities (generalized speeds) n (==nu).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation</dt><dd>This is accomplished by treating the input vector <em>lambda</em> as though it were a set of Lagrange multipliers, then calling each of the active Constraints' (constant time) force generation methods, providing the appropriate subset of the multipliers each time. That gives body forces F0 and mobility forces f0 in O(m) time. We then use the equivalent of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> to convert the returned body spatial forces to generalized forces in O(n) time, and finally return the generalized force-like result f = ~J*F0 + f0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a339a373cf4480657d982cef58ffe74c1" title="Returns Gulike = G*ulike, the product of the mXn acceleration constraint Jacobian G and a &quot;u-like&quot; (m...">multiplyByG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a id="ab790bd6457ec2cb8bfef5af104615d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab790bd6457ec2cb8bfef5af104615d06">&#9670;&nbsp;</a></span>calcGTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcGTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Gt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This O(nm) operator explicitly calculates the n X m transpose of the acceleration-level constraint Jacobian G = [P;V;A] which appears in the system equations of motion. </p>
<p>This method generates ~G columnwise use the constraint force generating methods which map constraint multipliers to constraint forces. To within numerical error, this should be identical to the transpose of the matrix returned by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1b31f1a35d519d303c64ad82428f9ae" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a> which uses a different method. Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> method instead of this one, which forms the matrix-vector product ~G*v in O(n) time without explicitly forming ~G. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#aa1b31f1a35d519d303c64ad82428f9ae" title="This O(m*n) operator explicitly calculates the m X n acceleration-level constraint Jacobian G which a...">calcG()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a8a9da182a2dd46ad4159b0e2cd7efb50" title="Returns f = ~G*lambda, the product of the n X m transpose of the acceleration constraint Jacobian G (...">multiplyByGTranspose()</a> </dd></dl>

</div>
</div>
<a id="a2783382d7d735bc7451c13289a79bc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2783382d7d735bc7451c13289a79bc0e">&#9670;&nbsp;</a></span>multiplyByPq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByPq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>PqXqlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint Jacobian and <em>qlike</em> is a "q-like" (generalized coordinate space) vector of length nq. </p>
<p>Here mp is the number of active position-level constraint equations in this system.</p>
<p>If you are going to call this method repeatedly at the same time t and configuration q and want maximum efficiency, you can gain a factor of almost 2X by precalculating a bias term once using <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5c88d0bceee265e0e9b8d21b6c2e21c7" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> and supplying it to the alternate signature of this method. See the Theory section below for an explanation of the bias term.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Position stage</dd></dl>
<h3>Theory</h3>
<p>Simbody's position (holonomic) constraints are defined by the constraint error equation </p><pre>
    (1)    perr(t;q) = p(t,q)
</pre><p> where we try to maintain perr=0 at all times. We also have available time derivatives of equation (1); the first time derivative is relevant here: </p><pre>
    (2)    pverr(t,q;qdot) = dperr/dt = Pq * qdot + Pt
</pre><p> where Pq=Dperr/Dq and Pt=Dperr/Dt (capital "D" means partial derivative). Pt=Pt(t,q) is called the "bias" term. (Note that because u=N^-1*qdot we also have Pq=P*N^-1, where P=Dpverr/Du is the very useful mobility-space holonomic constraint Jacobian.) Eq. (2) can be used to perform efficient multiplication by Pq, since it can be used to calculate Pq*qlike+Pt, and a second evaluation at qlike=0 can be used to calculate the unwanted bias term for removal: </p><pre>
    (3)    Pq*qlike = pverr(t,q;qlike) - pverr(t,q;0)  
</pre><p> Despite appearances, eq. (2) calculates its result in constant time per constraint equation, for a total cost that is O(n) or more strictly O(mp+nq). The matrix Pq is never actually formed; instead the matrix-vector product is calculated directly.</p>
<h3>Implementation</h3>
<p>We treat the input vector <em>qlike</em> as though it were a set of generalized coordinate derivatives qdot. These are mapped to body velocities V in O(n) time, using V=Jq*qdot, where Jq is the coordinate space system Jacobian (partial velocity matrix), with Jq=J*N^-1. Then the body velocities and qdots are supplied to each of the mp active position constraints' (constant time) velocity error methods to get pverr(t,q;qlike)=Pq*qlike-Pt in O(n) time. A second call is made to evaluate the bias term pverr(t,q;0)=-Pt. We then calculate the result <em>PqXqlike</em> = pverr(t,q;qlike)-pverr(t,q;0) in O(n) time using equation (3).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5c88d0bceee265e0e9b8d21b6c2e21c7" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> </dd></dl>

</div>
</div>
<a id="a6748363efdd106d1d1e3b21850daf2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6748363efdd106d1d1e3b21850daf2a3">&#9670;&nbsp;</a></span>multiplyByPq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByPq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qlike</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>biasp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>PqXqlike</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply Pq*qlike using the supplied precalculated bias vector to improve performance (approximately 2X) over the other signature. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5c88d0bceee265e0e9b8d21b6c2e21c7" title="Calculate the bias vector needed for the higher-performance signature of the multiplyByPq() method ab...">calcBiasForMultiplyByPq()</a> </dd></dl>

</div>
</div>
<a id="a5c88d0bceee265e0e9b8d21b6c2e21c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c88d0bceee265e0e9b8d21b6c2e21c7">&#9670;&nbsp;</a></span>calcBiasForMultiplyByPq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBiasForMultiplyByPq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>biasp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the bias vector needed for the higher-performance signature of the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Provides time t, and positions q; must be realized through Position stage so that all body spatial poses are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">biasp</td><td>This is the bias vector for use in repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>. It will be resized if necessary to length mp, the total number of active position-level (holonomic) constraint equations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Position stage</dd></dl>
<p>See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> for theory and implementation; this method is just performing the qlike=0 case described there for calculating the bias term Pt. </p>

</div>
</div>
<a id="a2df63f08ff4e61cf541250971ad1ebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df63f08ff4e61cf541250971ad1ebe7">&#9670;&nbsp;</a></span>calcPq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcPq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This O(m*n) operator explicitly calculates the mp X nq position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> method instead of this one, which forms the matrix-vector product Pq*v in O(m+n) time without explicitly forming Pq.</p>
<p>Note that quaternion normalization constraints are <em>not</em> included in mp; we do not consider those holonomic constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Position stage</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized through Position stage so that time and the pose (configuration) of each body is known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pq</td><td>The position constraint Jacobian Dperr/Dq. This will be resized to mp X nq if necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation</dt><dd>This method generates Pq columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>, which makes use of the position constraint velocity-level error methods to perrform a Pq*v product in O(m+n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> for a more detailed explanation. If Pq's columns are in contiguous memory we'll work in place, otherwise columns are generated into a contiguous temporary and then copied into Pq.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a> </dd></dl>

</div>
</div>
<a id="ad550234e8e7081f3e67e26beab104361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad550234e8e7081f3e67e26beab104361">&#9670;&nbsp;</a></span>multiplyByPqTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByPqTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lambdap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint Jacobian Pq (=P*N^-1) and a multiplier-like vector <em>lambdap</em> of length mp, returning a generalized-force like quantity <em>f</em> of length n. </p>
<p>mp is the number of active position constraint equations, n (==nu) is the number of mobilities (generalized speeds u). If lambdap is a set of mp constraint multipliers, then f=~G*lambdap is the set of forces generated by the position constraints, mapped into generalized forces. This is an O(mp+n) operation.</p>
<p>A holonomic constraint Jacobian cannot have a velocity dependence, so the <em>state</em> need be realized only to Position stage here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> that has been realized through Position stage. Time and configuration are taken from <em>state</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambdap</td><td>A multiplier-like vector to be multiplied by ~Pq. Its length must be the same as the number of active position constraint equations mp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>This is the generalized force-like output. It will be resized if necessary to length equal to the number of mobilities (generalized speeds) n (==nu).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation</dt><dd>This is accomplished by treating the input vector <em>lambdap</em> as though it were a set of Lagrange multipliers, then calling each of the active holonomic Constraints' (constant time) force generation methods, providing the appropriate subset of the multipliers each time. That gives body forces F0 and mobility forces f0 in O(mp) time. We then use the equivalent of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> to convert the returned body spatial forces to generalized forces in O(n) time, and finally return the generalized force-like result f = ~J*F0 + f0. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2783382d7d735bc7451c13289a79bc0e" title="Calculate in O(n) time the product Pq*qlike where Pq is the mp X nq position (holonomic) constraint J...">multiplyByPq()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2a6e9006e2a8e513f940e5e337c82329" title="Calculate the product of the transposed kinematic Jacobian ~J (==J^T) and a vector F_G of spatial for...">multiplyBySystemJacobianTranspose()</a> </dd></dl>

</div>
</div>
<a id="a1d82fc3bc298f54c4cb1b24b672700e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d82fc3bc298f54c4cb1b24b672700e9">&#9670;&nbsp;</a></span>calcPqTranspose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcPqTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pqt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This O(m*n) operator explicitly calculates the nq X mp transpose of the position-level (holonomic) constraint Jacobian Pq (=P*N^-1), the partial derivative of the position error equations with respect to q. </p>
<p>Consider using the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad550234e8e7081f3e67e26beab104361" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> method instead of this one, which forms the matrix-vector product ~Pq*v in O(m+n) time without explicitly forming ~Pq.</p>
<p>Note that quaternion normalization constraints are <em>not</em> included in mp; we do not consider those holonomic constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> realized to Position stage</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized through Position stage so that time and the pose (configuration) of each body is known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pqt</td><td>The transposed position constraint Jacobian ~Pq=(Dperr/Dq)^T. This will be resized to nq X mp if necessary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation</dt><dd>This method generates <em>Pqt</em> columnwise using repeated calls to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad550234e8e7081f3e67e26beab104361" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a>, which makes use of the position constraint force generating methods to perform a ~Pq*v product in O(m+n) time. See <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad550234e8e7081f3e67e26beab104361" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> for a more detailed explanation. If Pqt's columns are in contiguous memory we'll work in place, otherwise columns are generated into a contiguous temporary and then copied into Pqt.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad550234e8e7081f3e67e26beab104361" title="Returns f = ~Pq*lambdap, the product of the n X mp transpose of the position (holonomic) constraint J...">multiplyByPqTranspose()</a> </dd></dl>

</div>
</div>
<a id="a05664f6c7aa4e1b436656001ca5672e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05664f6c7aa4e1b436656001ca5672e0">&#9670;&nbsp;</a></span>calcP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (position) constraint errors with respect to the generalized speeds u; that is, P = partial( dperr/dt )/partial(u). </p>
<p>Here mp is the number of holonomic constraint equations (not including quaternion normalization constraints) and nu is the total number of generalized speeds as found in the supplied <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. P is resized if necessary; an error will be thrown if the Matrix is not the right size and not resizeable.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> is realized to Position stage </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Calculates the m X n matrix in O(m*n) time, which is good if you really need this matrix. However, in many cases what is really needed is the product of this matrix with a vector which can be done in O(n) time; consider whether you really need the whole matrix explicitly. </dd></dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a9bb15c6d72fcea701419624a26d786d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb15c6d72fcea701419624a26d786d6">&#9670;&nbsp;</a></span>calcPt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcPt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga68f30258553b9b50cb6aefa6d82e3e8e">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nu X mp matrix ~P - see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05664f6c7aa4e1b436656001ca5672e0" title="Returns the mp X nu matrix P which is the Jacobian of the first time derivative of the holonomic (pos...">calcP()</a> for a description. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="acce701c8a6ca9a0b1caa681869371725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce701c8a6ca9a0b1caa681869371725">&#9670;&nbsp;</a></span>multiplyByN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate out_q = N(q)*in_u (like qdot=N*u) or out_u = ~N*in_q. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by N on the right, with the Vectors viewed as RowVectors instead. This is an O(n) operator since N is block diagonal. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a37c72df92eda36381a60e046a15ab30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c72df92eda36381a60e046a15ab30d">&#9670;&nbsp;</a></span>multiplyByNInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByNInv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate out_u = NInv(q)*in_q (like u=NInv*qdot) or out_q = ~NInv*in_u. </p>
<p>Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NInv on the right, with the Vectors viewed as RowVectors instead. This is an O(N) operator since NInv is block diagonal. The configuration q is taken from the supplied state. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a7369407ac98084b84b800e3a4a0c8ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7369407ac98084b84b800e3a4a0c8ae2">&#9670;&nbsp;</a></span>multiplyByNDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::multiplyByNDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate out_q = NDot(q,u)*in_u or out_u = ~NDot(q,u)*in_q. </p>
<p>This is used, for example, as part of the conversion between udot and qdotdot. Note that one of "in" and "out" is always "q-like" while the other is "u-like", but which is which changes if the matrix is transposed. Note that the transposed operation here is the same as multiplying by NDot on the right, with the Vectors viewed as RowVectors instead. This is an O(N) operator since NDot is block diagonal. Configuration q and generalized speeds u are taken from the supplied state. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="a20b53ec5f00a7141a7486cc34998214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b53ec5f00a7141a7486cc34998214f">&#9670;&nbsp;</a></span>calcAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the primary forward dynamics operator. </p>
<p>It takes a state which has been realized to the Dynamics stage, a complete set of forces to apply, and returns the accelerations that result. Only the forces supplied here, and those calculated internally from prescribed motion, constraints, and centrifugal effects, affect the results. Acceleration constraints are always satisfied on return as long as the constraints are consistent. If the position and velocity constraints aren't already satisified in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>, results are harder to interpret physically, but they will still be calculated and the acceleration constraints will still be satisfied. No attempt will be made to satisfy position and velocity constraints, or to set prescribed positions and velocities, nor even to check whether these are satisfied; position and velocity constraint and prescribed positions and velocities are simply irrelevant here.</p>
<p>Given applied forces f_applied, this operator solves this set of equations: </p><pre>
     M udot + tau + ~G lambda + f_inertial = f_applied       (1)
                                  G udot   = b               (2)
                                    udot_p = udot_p(t,q,u,z) (3)
</pre><p> where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are: the free generalized accelerations udot_f, the constraint multipliers lambda, and the prescribed motion generalized forces tau_p. A subset udot_p of udot may have been prescribed as a known function of state via <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects or locks associated with the mobilized bodies. On return all the entries in udot will have been set to their calculated or prescribed values, and body spatial accelerations A_GB (that is, measured and expressed in Ground) are also returned. Lambda and tau_p are necessarily calculated but are not returned here.</p>
<p>f_applied is the set of generalized (mobility) forces equivalent to the <em>appliedMobilityForces</em> and <em>appliedBodyForces</em> arguments supplied here. That is, </p><pre>
    f_applied = appliedMobilityForces + ~J * appliedBodyForces
</pre><p> where J is the system Jacobian mapping between spatial and generalized coordinates. Typically these forces will have been calculated as a function of state so we will have f_applied(t,q,u,z).</p>
<p>M(t,q), G(t,q,u), and b(t,q,u) are defined by the mobilized bodies and constraints present in the system. f_inertial(q,u) includes the velocity-dependent gyroscopic and coriolis forces due to rigid body rotations and is extracted internally from the already-realized state.</p>
<p>Note that this method does not allow you to specify your own prescribed udots; those are calculated from the mobilizers' state-dependent <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> specifications (or are zero due to mobilizer locks) that are already part of the system.</p>
<p>This is an O(n*m + m^3) operator where n is the number of generalized speeds and m the number of constraint equations (mobilities with prescribed motion are counted in n, not m).</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated. ">Stage::Dynamics</a></code> (articulated body inertia will be realized if needed) </dd></dl>

</div>
</div>
<a id="a698a398ed2c0ca9b8ecb0b0d8b56fe2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698a398ed2c0ca9b8ecb0b0d8b56fe2f">&#9670;&nbsp;</a></span>calcAccelerationIgnoringConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcAccelerationIgnoringConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator is similar to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20b53ec5f00a7141a7486cc34998214f" title="This is the primary forward dynamics operator. ">calcAcceleration()</a> but ignores the effects of acceleration constraints although it obeys prescribed accelerations. </p>
<p>The supplied forces, prescribed motion forces, and velocity-induced centrifugal and gyroscopic effects are properly accounted for, but any forces that would have resulted from enforcing the constraints are not present. This operator solves the equations </p><pre>
            M udot + tau + f_inertial = f_applied           (1)
                               udot_p = udot_p(t,q,u,z)     (2)
</pre><p> where udot={udot_f,udot_p}, tau={0,tau_p}. The unknowns are the free generalized accelerations udot_f and the prescribed motion generalized forces tau_p. f_inertial contains the velocity-dependent gyroscopic and coriolis forces due to rigid body rotations. No constraint forces are included.</p>
<p>On return all the entries in udot will have been set to their calculated or prescribed values, and body spatial accelerations A_GB (that is, measured and expressed in Ground) are also returned. tau_p is not returned.</p>
<p>This is an O(n) operator.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated. ">Stage::Dynamics</a></code> (articulated body inertia will be realized if needed) </dd></dl>

</div>
</div>
<a id="a29a93fe311723421ff87117ab65f8f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a93fe311723421ff87117ab65f8f81">&#9670;&nbsp;</a></span>calcResidualForceIgnoringConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcResidualForceIgnoringConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>residualMobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed motion they are ignored. </p>
<p>This method solves </p><pre>
     f_residual = M udot + f_inertial - f_applied
</pre><p> for f_residual in O(n) time, meaning that the mass matrix M is never formed. Inverse dynamics is considerably faster than forward dynamics, even though both are O(n) in Simbody.</p>
<p>In the above equation we solve for the residual forces <code>f_residual</code> given desired accelerations and (optionally) a set of applied forces. Here <code>f_applied</code> is the mobility-space equivalent of all the applied forces (including mobility and body forces), <code>f_inertial</code> is the mobility-space equivalent of the velocity-dependent inertial forces due to rigid body rotations (coriolis and gyroscopic forces), and <code>udot</code> is the given set of values for the desired generalized accelerations. The returned <code>f_residual</code> is the additional generalized force (that is, mobility force) that would have to be applied at each mobility to give the desired <code>udot</code>. The inertial forces depend on the velocities <code>u</code> already realized in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. Otherwise, only the explicitly-supplied forces affect the results of this operator; any forces that may be present elsewhere in the system are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> valid for the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>, already realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedMobilityForces</td><td>One scalar generalized force applied per mobility. Can be zero length if there are no mobility forces; otherwise must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedBodyForces</td><td>One spatial force for each body. A spatial force is a force applied to the body origin and a torque on the body, each expressed in the Ground frame. Gravity, if present, is specified here as a body force. The supplied Vector must be either zero length (interpreted as all-zero) or have exactly one entry per body in the matter subsystem, starting with Ground as body zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUdot</td><td>These are the desired generalized accelerations, one per mobility. If this is zero length it will be treated as all-zero; otherwise it must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residualMobilityForces</td><td>These are the residual generalized forces which, if added to the applied forces, would produce the given <em>knownUdot</em> in forward dynamics (assuming the system is unconstrained). This will be resized if necessary to have length nu; that is, one scalar entry per mobility. You can view this as a measure of how much the given <em>knownUdot</em> fails to satisfy the equations of motion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a2d70c8d0efb3850781dff2483a4cf017" title="This is the inverse dynamics operator for when you know both the accelerations and Lagrange multiplie...">calcResidualForce()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a4c95c1922247ca717f8f5b4751bf704a" title="This operator calculates in O(n) time the product M*v where M is the system mass matrix and v is a su...">multiplyByM()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a20b53ec5f00a7141a7486cc34998214f" title="This is the primary forward dynamics operator. ">calcAcceleration()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a698a398ed2c0ca9b8ecb0b0d8b56fe2f" title="This operator is similar to calcAcceleration() but ignores the effects of acceleration constraints al...">calcAccelerationIgnoringConstraints()</a> </dd></dl>

</div>
</div>
<a id="a2d70c8d0efb3850781dff2483a4cf017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d70c8d0efb3850781dff2483a4cf017">&#9670;&nbsp;</a></span>calcResidualForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcResidualForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>appliedMobilityForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>appliedBodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownLambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>residualMobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the inverse dynamics operator for when you know both the accelerations and Lagrange multipliers for a constrained system. </p>
<p>Prescribed motion is ignored. Using position and velocity from the given state, a set of applied forces, and a known set of generalized accelerations udot and constraint multipliers lambda, it calculates the additional generalized forces that would be required to satisfy Newton's 2nd law, f=Ma. That is, this operator returns </p><pre>
    f_residual = M udot + ~G lambda + f_inertial - f_applied
</pre><p> where f_applied is the mobility-space equivalent to all the applied forces (including mobility and body forces), f_inertial is the mobility-space equivalent of the velocity-dependent inertial forces due to rigid body rotations (coriolis and gyroscopic forces), and the udots and lambdas are given values of the generalized accelerations and constraint multipliers, resp.</p>
<p>Note that there is no requirement that the given udots satisfy the constraint equations; we simply solve the above equation for <code>f_residual</code>.</p>
<p>The inertial forces depend on the velocities <code>u</code> already realized in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. Otherwise, only the explicitly-supplied forces affect the results of this operator; any forces that may be defined elsewhere in the system are ignored here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> valid for the containing <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a>, already realized to <code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedMobilityForces</td><td>One scalar generalized force applied per mobility. Can be zero length if there are no mobility forces; otherwise must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">appliedBodyForces</td><td>One spatial force for each body. A spatial force is a force applied to the body origin and a torque on the body, each expressed in the Ground frame. Gravity, if present, is specified here as a body force. The supplied Vector must be either zero length (interpreted as all-zero) or have exactly one entry per body in the matter subsystem, starting with Ground as body zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUdot</td><td>These are the specified generalized accelerations, one per mobility so the length should be nu. If this is zero length it will be treated as all-zero of length nu; otherwise it must have exactly one entry per mobility in the matter subsystem. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownLambda</td><td>These are the specified Lagrange multipliers, one per constraint equation. If this is zero length it will be treated as all-zero; otherwise it must have exactly m entries, where m=mp+mv+ma is the total number of position, velocity, and acceleration-only constraints. There are no entries here corresponding to quaternion constraints, which do not generate forces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residualMobilityForces</td><td>These are the residual generalized forces which, if added to the applied forces along with the constraint forces ~G*lambda, would produce the given <em>knownUdot</em> in unconstrained forward dynamics. This will be resized if necessary to have length nu; that is, one scalar entry per mobility. You can view this as a measure of how much the given udot and lambda fail to satisfy the equations of motion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a29a93fe311723421ff87117ab65f8f81" title="This is the inverse dynamics operator for the tree system; if there are any constraints or prescribed...">calcResidualForceIgnoringConstraints()</a> </dd></dl>

</div>
</div>
<a id="a1097a191bdaa113ca97a875fc35ab96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1097a191bdaa113ca97a875fc35ab96b">&#9670;&nbsp;</a></span>calcCompositeBodyInertias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcCompositeBodyInertias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>, <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operator calculates the composite body inertias R given a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized to Position stage. </p>
<p>Composite body inertias are the spatial mass properties of the rigid body formed by a particular body and all bodies outboard of that body as if all the outboard mobilizers were welded in their current orientations.</p>
<p>This is a very fast O(n) operator.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a3c340ca99cb804e9e33d736dfa43c066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c340ca99cb804e9e33d736dfa43c066">&#9670;&nbsp;</a></span>calcBodyAccelerationFromUDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcBodyAccelerationFromUDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>knownUDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_GB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a complete set of n generalized accelerations udot, this kinematic operator calculates in O(n) time the resulting body accelerations, including velocity-dependent terms taken from the supplied <em>state</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><em>state</em> must already be realized to Velocity stage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> from which position- and velocity- related terms are taken; must already have been realized to Velocity stage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">knownUDot</td><td>A complete set of generalized accelerations. Must have the same length as the number of mobilities nu, or if length zero the udots will be taken as all zero in which case only velocity-dependent (Coriolis) accelerations will be returned in <em>A_GB</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_GB</td><td>Spatial accelerations of all the body frames measured and expressed in the Ground frame, resulting from supplied generalized accelerations <em>knownUDot</em> and velocity-dependent acceleration terms taken from <em>state</em>. This will be resized if necessary to the number of bodies <em>including</em> Ground so that the returned array may be indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> with A_GB[0]==0 always. The angular acceleration vector for <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a> i is A_GB[i][0]; linear acceleration of the body's origin is A_GB[i][1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Theory</dt><dd>The generalized speeds u and spatial velocities V are related by the system Jacobian J as V=J*u. Thus the spatial accelerations A=Vdot=J*udot+Jdot*u.</dd></dl>
<dl class="section user"><dt>Implementation</dt><dd>The Coriolis accelerations Jdot*u are already available in a <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized to Velocity stage. The J*udot term is equivalent to an application of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a> to the <em>knownUdot</em> vector. The current implementation uses 12*nu + 18*nb flops to produce nb body accelerations.</dd></dl>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a6cdfd4c182fd6b3f129e8f2bc1b6e6e6" title="Calculate the product of the System kinematic Jacobian J (also known as the partial velocity matrix) ...">multiplyBySystemJacobian()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a> </dd></dl>

</div>
</div>
<a id="a67bb7bcb8f73340ba63264bffb591ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67bb7bcb8f73340ba63264bffb591ce7">&#9670;&nbsp;</a></span>calcConstraintForcesFromMultipliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcConstraintForcesFromMultipliers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>multipliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treating all Constraints together, given a comprehensive set of m Lagrange multipliers <em>lambda</em>, generate the complete set of body spatial forces and mobility (generalized) forces applied by all the Constraints. </p>
<p>Spatial forces are applied at each body's origin and the moment and force vectors therein are expressed in the Ground frame. Watch the sign &ndash; normally constraint forces have opposite sign from applied forces, because our equations of motion are </p><pre>   M udot + ~G lambda = f_applied  </pre><p> If you want to take Simbody-calculated multipliers and use them to generate forces that look like applied forces, negate the multipliers in the argument passed to this call.</p>
<p><a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> must be realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a> to call this operator (although typically the multipliers are obtained by realizing to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>).</p>
<p>This is an O(m) operator. In particular it does <em>not</em> involve forming or multiplying by the constraint force matrix ~G. Instead, one constant-time call is made to each Constraint's calcConstraintForce methods.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="a1af1e68128d882eebf1cd213640136aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af1e68128d882eebf1cd213640136aa">&#9670;&nbsp;</a></span>calcMobilizerReactionForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forcesAtMInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the mobilizer reaction force generated at each <a class="el" href="classSimTK_1_1MobilizedBody.html" title="A MobilizedBody is Simbody&#39;s fundamental body-and-joint object used to parameterize a system&#39;s motion...">MobilizedBody</a>, as felt at the mobilizer's outboard frame M, and expressed in Ground. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td><br />
 A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> compatible with this <a class="el" href="classSimTK_1_1System.html" title="This is the base class that serves as the parent of all SimTK System objects; most commonly Simbody&#39;s...">System</a> that has already been realized to <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forcesAtMInG</td><td><br />
 A Vector of spatial force vectors, indexed by <a class="el" href="classSimTK_1_1MobilizedBodyIndex.html" title="This is for arrays indexed by mobilized body number within a subsystem (typically the SimbodyMatterSu...">MobilizedBodyIndex</a> (beginning with 0 for Ground), giving the reaction moment and force applied by each body's unique inboard mobilizer to that body. The force is returned as though it were applied at the origin of the body's mobilizer frame M. The returned force is expressed in the Ground frame. Applied mobility (generalized) forces are <em>included</em> in the returned reaction forces.</td></tr>
  </table>
  </dd>
</dl>
<p>A simple way to think of the reaction force is to think of cutting the mobilizer, then imagine the force required to make the system move in the same manner as when the mobilizer was present. This is what the reaction forces accomplish. With that definition, mobility forces (that is, generalized forces as opposed to body forces) are <em>included</em> in the reactions. Some conventions do not include the mobility forces in the definition of a reaction force. We chose to include them since this preserves Newton's 3rd law of equal and opposite reactions between bodies. Ours is the same convention as used in SD/FAST.</p>
<dl class="section note"><dt>Note</dt><dd>You can think of the Ground body being welded to the universe at the Ground origin. The reactions reported for Ground are the ones that would occur in that Weld mobilizer if it were really present. That is, it includes the effects of all the base bodies on Ground.</dd></dl>
<h3>How to find the reaction felt by the parent body</h3>
<p>A mobilizer connects a frame F fixed on the parent (inboard) body P to a frame M fixed on the child (outboard) body B. It exerts equal and opposite reaction forces on the two bodies, at a given location in space. This method reports the force on the child body, as though it were applied at the origin Mo of frame M, and expressed in the Ground frame. The force on the parent body <em>at Mo</em> is just the negative of the returned value. However, it is more likely that you would want it as felt <em>at Fo</em>, the origin of the F frame on the parent. Here is one way to calculate that from the returned quantities: </p><div class="fragment"><div class="line">matter.calcMobilizerReactionForces(state,forcesAtMInG); <span class="comment">// This method.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nb = matter.getNumBodies();</div><div class="line">Vector_&lt;SpatialVec&gt; forcesAtFInG(nb); <span class="comment">// to hold the result</span></div><div class="line">forcesAtFInG[0] = -forcesAtMInG[0]; <span class="comment">// Ground is &quot;welded&quot; at origin</span></div><div class="line"><span class="keywordflow">for</span> (MobilizedBodyIndex i(1); i &lt; nb; ++i) {</div><div class="line">    <span class="keyword">const</span> MobilizedBody&amp; mobod  = matter.getMobilizedBody(i);</div><div class="line">    <span class="keyword">const</span> MobilizedBody&amp; parent = mobod.getParentMobilizedBody();</div><div class="line">    <span class="comment">// Want to shift reaction by p_MF, the vector from M to F across the</span></div><div class="line">    <span class="comment">// mobilizer, and negate. Can get p_FM; must reexpress in G.</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; p_FM = mobod.getMobilizerTransform(state).p();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; R_PF = mobod.getInboardFrame(state).R(); <span class="comment">// In parent.</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a>&amp; R_GP = parent.getBodyTransform(state).R();</div><div class="line">    <a class="code" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> R_GF   =   R_GP*R_PF;  <span class="comment">// F frame orientation in Ground.</span></div><div class="line">    <a class="code" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>     p_MF_G = -(R_GF*p_FM); <span class="comment">// Re-express and negate shift vector. </span></div><div class="line">    forcesAtFInG[i] = -<a class="code" href="group__SpatialAlgebraUtilities.html#ga2b44f1ea5624daf334b4aa6c0e07ea0e">shiftForceBy</a>(forcesAtMInG[i], p_MF_G);</div><div class="line">}</div></div><!-- fragment --><h3>Implementation</h3>
<p>This method combines already-calculated quantities to calculate the reactions. See Abhi Jain's 2011 book "Robot and Multibody Dynamics", Eq. 7.34 page 128: </p><pre>   F_reaction = PPlus*APlus + zPlus  </pre><p> where P is the articulated body inertia, A is the spatial acceleration, a the Coriolis acceleration and z the articulated body forces, and "Plus" indicates that we evaluate these on the inboard (parent) side of the mobilizer rather than on the body's side. (The alternative P(A-a)+z given there does not work for prescribed mobilizers unless you replace "a" with "a_underscore" from equation 16.14.) After calculating F_reaction at the body frame origin Bo, we shift it to M for reporting.</p>
<h3>Performance</h3>
<p>The cost of the above calculation is 114 flops/body. The code presented above for converting from M to F costs an additional 81 flops/body if you use it.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1MobilizedBody.html#a70afa8a35e994c37a61019570d11b712" title="Return the spatial reaction force (moment and force) applied by the mobilizer to body B at the locati...">SimTK::MobilizedBody::findMobilizerReactionOnBodyAtMInGround()</a> </dd>
<dd>
<a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a92f4107db4cd697fbbea6064c9769770" title="This is a slower alternative to calcMobilizerReactionForces(), for use in regression testing and Simb...">calcMobilizerReactionForcesUsingFreebodyMethod()</a> </dd></dl>

</div>
</div>
<a id="a89024a1ccf3f7d13bfb003ec80ac6f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89024a1ccf3f7d13bfb003ec80ac6f78">&#9670;&nbsp;</a></span>getMotionMultipliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::SimbodyMatterSubsystem::getMotionMultipliers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the prescribed motion multipliers tau that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage. </p>
<p>The result contains entries only for prescribed mobilities; if you want these unpacked into u-space mobility forces, use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af2db9db9729840c852fb16d2f196c59c" title="Find the generalized mobility space forces produced by all the Motion objects active in this system...">findMotionForces()</a> instead. A mobilizer may follow prescribed motion either because of a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> object or a call to <a class="el" href="classSimTK_1_1MobilizedBody.html#a4b2134c59f8d9925b0db50d8da174c22" title="Lock this mobilizer&#39;s position or velocity at its current value, or lock the acceleration to zero...">MobilizedBody::lock()</a>.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a id="af4b67fe155e25c8fb8ed341ffc6bde87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b67fe155e25c8fb8ed341ffc6bde87">&#9670;&nbsp;</a></span>calcMotionErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> SimTK::SimbodyMatterSubsystem::calcMotionErrors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the degree to which the supplied <em>state</em> does not satisfy the prescribed motion requirements at a particular <a class="el" href="classSimTK_1_1Stage.html" title="This class is basically a glorified enumerated type, type-safe and range checked but permitting conve...">Stage</a>. </p>
<p>For Position and Velocity stage, a call to the prescribe() solver using the same stage will eliminate the error. Accelerations should have been calculated to satisfy all prescribed accelerations, so the returned value should be zero always. The returned Vector has one element per known (prescribed) q, known u, or known udot.</p>
<p>The <em>state</em> must be realized to Time stage to check Position errors, Position stage to check Velocity errors, and Acceleration stage to check Acceleration errors.</p>
<p>Errors are calculated actualValue - prescribedValue so a positive error indicates that the value in <em>state</em> is too large. </p>

</div>
</div>
<a id="af2db9db9729840c852fb16d2f196c59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2db9db9729840c852fb16d2f196c59c">&#9670;&nbsp;</a></span>findMotionForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::findMotionForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the generalized mobility space forces produced by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects active in this system. </p>
<p>These are the same values as returned by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a89024a1ccf3f7d13bfb003ec80ac6f78" title="Return a reference to the prescribed motion multipliers tau that have already been calculated in the ...">getMotionMultipliers()</a> but unpacked into u-space slots, with zeroes corresponding to any "free" mobilities, that is, those whose motion is not prescribed.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a id="a2aeee63950e043cea04181318328489a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeee63950e043cea04181318328489a">&#9670;&nbsp;</a></span>getConstraintMultipliers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::SimbodyMatterSubsystem::getConstraintMultipliers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the constraint multipliers lambda that have already been calculated in the given <em>state</em>, which must have been realized through Acceleration stage. </p>
<p><a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> multipliers are not directly interpretable as forces; if you want the actual forces use <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#accaa035261197f6c1573a42d5ad003d9" title="Find the forces produced by all the active Constraint objects in this system. ">findConstraintForces()</a> instead. If you want to know individual <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> contributions to these forces, ask the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects rather than this <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html" title="This subsystem contains the bodies (&quot;matter&quot;) in the multibody system, the mobilizers (joints) that d...">SimbodyMatterSubsystem</a> object.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a id="accaa035261197f6c1573a42d5ad003d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaa035261197f6c1573a42d5ad003d9">&#9670;&nbsp;</a></span>findConstraintForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::findConstraintForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the forces produced by all the active <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects in this system. </p>
<p>Constraints produce both body spatial forces and generalized mobility-space forces. The supplied <em>state</em> must have been realized through Acceleration stage.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>

</div>
</div>
<a id="a485e5ec94f8cd01e5e2e0f0e487ed046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485e5ec94f8cd01e5e2e0f0e487ed046">&#9670;&nbsp;</a></span>calcMotionPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::SimbodyMatterSubsystem::calcMotionPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the power being generated or dissipated by all the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects currently active in this system. </p>
<p>The sign is chosen so that a positive value for power means the <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> is adding energy to the system; negative means it is removing energy. The <em>state</em> must already have been realized through Acceleration stage so that the prescribed motion forces are available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized through Acceleration stage from which we obtain the prescribed motion forces and the velocities needed to calculate power.</td></tr>
  </table>
  </dd>
</dl>
<h3>Implementation</h3>
<p>We calculate power=-dot(tau, u) where tau is the set of mobility reaction forces generated by <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a> objects and mobilizer locks (tau[i]==0 if mobility i is free), and u is the set of all generalized speeds.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af8ec0203f2a334f39bb84c0331e0c795" title="Return the power begin generated or dissipated by all the Constraint objects currently active in this...">calcConstraintPower()</a> </dd></dl>

</div>
</div>
<a id="af8ec0203f2a334f39bb84c0331e0c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ec0203f2a334f39bb84c0331e0c795">&#9670;&nbsp;</a></span>calcConstraintPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::SimbodyMatterSubsystem::calcConstraintPower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the power begin generated or dissipated by all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects currently active in this system. </p>
<p>The sign is chosen so that a positive value for power means the Constraints (taken together) are adding energy to the system; negative means they are removing energy. The <em>state</em> must already have been realized through Acceleration stage so that the constraint forces are available.</p>
<p>Note that if you want to know the power output of an individual <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>, you should call that <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>'s calcPower() method; here they are all summed together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>A <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> realized through Acceleration stage from which we obtain the constraint forces and the velocities needed to calculate power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed sum over all the <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a> objects of the power being generated or dissipated by each <a class="el" href="classSimTK_1_1Constraint.html" title="This is the base class for all Constraint classes, which is just a handle for the underlying hidden i...">Constraint</a>. A positive value means that together the constraints are adding energy to the system; negative means they are removing energy.</dd></dl>
<h3>Implementation</h3>
<p>We calculate power=-(dot(F,V)+dot(f,u)) where F is the set of body spatial reaction forces produced by the Constraints, V is the body spatial velocities, f is the set of mobility reaction forces produced by the Constraints, and u is the set of generalized speeds.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a485e5ec94f8cd01e5e2e0f0e487ed046" title="Calculate the power being generated or dissipated by all the Motion objects currently active in this ...">calcMotionPower()</a> </dd></dl>

</div>
</div>
<a id="a46868b7cd5b218ffdf71caf527f74ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46868b7cd5b218ffdf71caf527f74ef1">&#9670;&nbsp;</a></span>calcTreeEquivalentMobilityForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcTreeEquivalentMobilityForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accounts for applied forces and inertial forces produced by non-zero velocities in the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a>. </p>
<p>Returns a set of mobility forces which replace both the applied bodyForces and the inertial forces. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13ab0a24de476c174b03fc0dc8d463a3563" title="Forces calculated. ">Stage::Dynamics</a></code> </dd></dl>

</div>
</div>
<a id="abbfa39aaf358b954690b5597e9607668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfa39aaf358b954690b5597e9607668">&#9670;&nbsp;</a></span>calcQDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate qdot = N(q)*u in O(n) time (very fast). </p>
<p>Note that q is taken from the supplied state while u is an argument to this operator method. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="a5e56cf73148b15f8aeb47da72e2b0258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e56cf73148b15f8aeb47da72e2b0258">&#9670;&nbsp;</a></span>calcQDotDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcQDotDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>udot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>qdotdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate qdotdot = N(q)*udot + Ndot(q,u)*u in O(n) time (very fast). </p>
<p>Note that q and u are taken from the supplied state while udot is an argument to this operator method. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="aadf84f7d5ee84ea774fe51e5c806a39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf84f7d5ee84ea774fe51e5c806a39f">&#9670;&nbsp;</a></span>addInStationForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::addInStationForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>bodyB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>stationOnB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>forceInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in to the given body forces vector a force applied to a station (fixed point) S on a body B. </p>
<p>The new force is added into the existing spatial force slot for the body. Note that this does not actually apply any forces to the multibody system! This is just a "helper" utility that makes it easier to fill in a body forces array. This has no effect on the system unless you later supply the body forces array for use.</p>
<p>Provide the station in the body frame, force in the Ground frame. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code> </dd></dl>

</div>
</div>
<a id="ac11bc0dabe8467999e1e6f60bbcb5168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11bc0dabe8467999e1e6f60bbcb5168">&#9670;&nbsp;</a></span>addInBodyTorque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::addInBodyTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torqueInG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodyForcesInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in to the given body forces vector a torque applied to a body B. </p>
<p>The new torque is added into the existing spatial force slot for the body. Note that this does not actually apply any torques to the multibody system! This is just a "helper" utility that makes it easier to fill in a body forces array. This has no effect on the system unless you later supply the body forces array for use. Provide the torque vector in the Ground frame. </p>

</div>
</div>
<a id="ae351805996c27b1a178b244226c4be37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae351805996c27b1a178b244226c4be37">&#9670;&nbsp;</a></span>addInMobilityForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::addInMobilityForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mobodIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizerUIndex.html">MobilizerUIndex</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>mobilityForces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in to the given mobility forces vector a scalar generalized force, that is a force or torque applied to a mobilizer generalized speed. </p>
<p>Note that this does not actually apply any forces to the multibody system! This is just a "helper" utility that makes it easier to fill in a mobility forces array. This has no effect on the system unless you later supply the mobility forces array for use. The meaning of a generalized force f is determined by the definition of the corresponding generalized speed u, so that f*u has physical units of power. </p>

</div>
</div>
<a id="afe15082955cdd01993a0bc8b390ed314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe15082955cdd01993a0bc8b390ed314">&#9670;&nbsp;</a></span>realizePositionKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::realizePositionKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position kinematics is the first part of the <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a> realization, mapping generalized coordinates q to the spatial (Cartesian) poses of the mobilized bodies. </p>
<p>This mapping depends only on instance variables and q; it is time-independent, so does not get invalidated by a time change. This computation is normally initiated by a <code>realize(state,Stage::Position)</code> call, but you can realize just the kinematics explicitly here. The calculation will <em>not</em> be repeated when realizing <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a> for the same q values. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a26ad897ab748ef0fb1f8118da3488310" title="(Advanced) Force invalidation of position kinematics, which otherwise remains valid until an instance...">invalidatePositionKinematics()</a> </dd></dl>

</div>
</div>
<a id="ae3d6e1a94635f1866523ac2788a27fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d6e1a94635f1866523ac2788a27fe2">&#9670;&nbsp;</a></span>realizeVelocityKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::realizeVelocityKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity kinematics is the first part of the <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a> realization, mapping generalized speeds u to the spatial (Cartesian) velocities of the mobilized bodies. </p>
<p>This mapping depends only on instance variables, position kinematics, and u; it is time-independent, so does not get invalidated by a time change. This computation is normally initiated by a <code>realize(state,Stage::Velocity)</code> call, but you can realize just the kinematics explicitly here. The calculation will <em>not</em> be repeated when realizing <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a> for the same q and u values. Note that you must already have realized position kinematics in order to call this method. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, or <code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> and <code>PositionKinematics</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a38e6bc6be5137475bb5a7d042c30abc4" title="(Advanced) Force invalidation of velocity kinematics, which otherwise remains valid until an instance...">invalidateVelocityKinematics()</a> </dd></dl>

</div>
</div>
<a id="a5aeb334d652c5d87a7939faff9816706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aeb334d652c5d87a7939faff9816706">&#9670;&nbsp;</a></span>realizeCompositeBodyInertias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::realizeCompositeBodyInertias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks whether composite body inertias have already been computed since the last change to a Position stage state variable (q) and if so returns immediately at little cost; otherwise, it initiates computation of composite body inertias for all of the mobilized bodies. </p>
<p>These are not otherwise computed unless specifically requested. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, or <code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> and <code>PositionKinematics</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a60342f4ac0206fdcc69cd2c9ec9e7edb" title="(Advanced) This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will not recalculate them if called repeatedly. ">invalidateCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a id="ab89fcf89490662254306e34157409010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89fcf89490662254306e34157409010">&#9670;&nbsp;</a></span>realizeArticulatedBodyInertias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::realizeArticulatedBodyInertias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method ensures that articulated body inertias (ABIs) are up to date with the most recent change to the configuration state variables q. </p>
<p>If already up to date, it returns immediately at little cost; otherwise, it initiates the relatively expensive computation of ABIs for all of the mobilized bodies, which will then be retained for reuse until the next configuration change. ABIs are not otherwise computed until they are needed for forward dynamics computations, typically due to realization of <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>. Invoking any operator that needs the effect of the inverse mass matrix will realize ABIs implicitly. They are guaranteed to be available by <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, or <code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> and <code>PositionKinematics</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3e93d47be0cf6d154c79f5abbf77dc8d" title="(Advanced) Force invalidation of articulated body inertias (ABIs), which otherwise remain valid until...">invalidateArticulatedBodyInertias()</a> </dd></dl>

</div>
</div>
<a id="a5f4f7709391f21a0e8298ed314c6161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4f7709391f21a0e8298ed314c6161d">&#9670;&nbsp;</a></span>realizeArticulatedBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::realizeArticulatedBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) This method ensures that velocity-dependent computations that also depend on articulated body inertias (ABIs) are up to date with the most recent changes to the configuration state variables q and velocity state variables u. </p>
<p>If already up to date, it returns immediately at little cost; otherwise, it initiates the computations for all of the mobilized bodies, which will then be retained for reuse until the next velocity change. ABI-dependent computations are not otherwise computed until they are needed for forward dynamics computations, typically due to realization of <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>. Invoking any operator that needs the effect of both the inverse mass matrix and internal Coriolis forces will realize these computations implicitly. They are guaranteed to be available by <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13a8bd64db14a555b7478679e9462888950" title="Accelerations and multipliers calculated. ">Stage::Acceleration</a>.</p>
<p>Note that this method does not implicitly realize anything it depends on; you must make sure its prerequisites VelocityKinematics and ArticulatedBodyInertias are already realized; see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae3d6e1a94635f1866523ac2788a27fe2" title="Velocity kinematics is the first part of the Stage::Velocity realization, mapping generalized speeds ...">realizeVelocityKinematics()</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a> for that purpose.</p>
<p>The actual computations here are not made available through the API since (unlike the ABIs) they are not particularly meaningful. They do save time during repeated acceleration computations where forces are changing but configuration and velocity are fixed; these are common. The ability to force realization here is provided so that you can make sure the state cache doesn't get implicitly updated behind your back; this can be necessary in some multithreaded applications.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> and <code>VelocityKinematics</code> and <code>ArticulatedBodyInertias</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a517ec5fcfd3c4bf69e07f910398c711e" title="(Advanced) Force invalidation of articulated body velocity computations, which otherwise remain valid...">invalidateArticulatedBodyVelocity()</a> </dd></dl>

</div>
</div>
<a id="afea863219c3efaff939c5ce79e77609a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea863219c3efaff939c5ce79e77609a">&#9670;&nbsp;</a></span>getFreeQIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1QIndex.html">QIndex</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getFreeQIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a05833768270670f8987dad99eaf5b893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05833768270670f8987dad99eaf5b893">&#9670;&nbsp;</a></span>getFreeUIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getFreeUIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a88218b5302c36e8b5b08572da4a7fd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88218b5302c36e8b5b08572da4a7fd21">&#9670;&nbsp;</a></span>getFreeUDotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getFreeUDotIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the generalized speeds whose time derivatives udot are unknown, that is, not locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>. </p>
<p>This is the complement of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae35d28f22f08a16c3f159297d213ff05" title="Return a list of the generalized speeds whose time derivatives udot are known, that is...">getKnownUDotIndex()</a>. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="ae35d28f22f08a16c3f159297d213ff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35d28f22f08a16c3f159297d213ff05">&#9670;&nbsp;</a></span>getKnownUDotIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt;<a class="el" href="classSimTK_1_1UIndex.html">UIndex</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getKnownUDotIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the generalized speeds whose time derivatives udot are known, that is, locked or prescribed with a <a class="el" href="classSimTK_1_1Motion.html" title="A Motion object belongs to a particular MobilizedBody and prescribes how the associated motion is to ...">Motion</a>. </p>
<p>This is the complement of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88218b5302c36e8b5b08572da4a7fd21" title="Return a list of the generalized speeds whose time derivatives udot are unknown, that is...">getFreeUDotIndex()</a>. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a99f6ca2125eaa88294ebf3f3c8730f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f6ca2125eaa88294ebf3f3c8730f03">&#9670;&nbsp;</a></span>packFreeQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::packFreeQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>allQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a generalized coordinate (q-space) Vector, select only those elements that are free (in the sense of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afea863219c3efaff939c5ce79e77609a" title="Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with ...">getFreeQIndex()</a>) and pack them in order into <code>packedFreeQ</code>, which must already be allocated to the correct length, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afea863219c3efaff939c5ce79e77609a" title="Return a list of the generalized coordinates q that are free, that is, not locked or prescribed with ...">getFreeQIndex()</a>.size(). </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a96cb8530eafe8a39a0a133e6121cd9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cb8530eafe8a39a0a133e6121cd9b3">&#9670;&nbsp;</a></span>unpackFreeQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::unpackFreeQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>unpackedFreeQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a free-q Vector, unpack it into a q-space Vector which must already be allocated to the correct size. </p>
<p>The not-free elements already in <code>unpackedFreeQ</code> are not touched. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a897fd865f47e78c32ea8bd92c13d91f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897fd865f47e78c32ea8bd92c13d91f7">&#9670;&nbsp;</a></span>packFreeU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::packFreeU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>allU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a generalized speed (u- or mobility-space) Vector, select only those elements that are free (in the sense of <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05833768270670f8987dad99eaf5b893" title="Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a Mot...">getFreeUIndex()</a>) and pack them in order into <code>packedFreeU</code>, which must already be allocated to the correct length, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a05833768270670f8987dad99eaf5b893" title="Return a list of the generalized speeds u that are free, that is, not locked or prescribed with a Mot...">getFreeUIndex()</a>.size(). </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="aa59f9970c953c359dfdb6a5a0d36ca43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59f9970c953c359dfdb6a5a0d36ca43">&#9670;&nbsp;</a></span>unpackFreeU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::unpackFreeU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>packedFreeU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>unpackedFreeU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a free-u Vector, unpack it into a u-space Vector which must already be allocated to the correct size. </p>
<p>The not-free elements already in <code>unpackedFreeU</code> are not touched. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a></code> </dd></dl>

</div>
</div>
<a id="a066a9473c79c1acbbd725b9eed6d1b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066a9473c79c1acbbd725b9eed6d1b0b">&#9670;&nbsp;</a></span>getCompositeBodyInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a01fddf4cefc9b5c82cb55789127abe53">SpatialInertia</a>&amp; SimTK::SimbodyMatterSubsystem::getCompositeBodyInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the composite body inertia (CBI) R for a particular mobilized body. </p>
<p>You can call this any time after the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> has been realized to Position stage (or in fact any time after PositionKinematics have been realized). However, the first call to this method will trigger realization of all the CBIs if they have not already been calculated using <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>. Ground is mobilized body zero; its CBI has infinite mass and principle moments of inertia, and center of mass at (0,0,0).</p>
<p>Although CBIs can be useful in inverse dynamics calculations, Simbody does not use them for that purpose so they won't be calculated unless requested.</p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314" title="Position kinematics is the first part of the Stage::Position realization, mapping generalized coordin...">realizePositionKinematics()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a> </dd></dl>

</div>
</div>
<a id="ad1e5694de1803375055b78d60616acf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e5694de1803375055b78d60616acf7">&#9670;&nbsp;</a></span>getArticulatedBodyInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#ab1473db0cef6d6f29b827de9f1b3cb9f">ArticulatedInertia</a>&amp; SimTK::SimbodyMatterSubsystem::getArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the articulated body inertia (ABI) P for a particular mobilized body. </p>
<p>These are normally not needed until some forward dynamics operation is to be performed, such as realize(Acceleration) or applying the <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a> operator. ABIs are expensive to calculate and require invertible mass properties so we normally defer their calculation until they are actually required. However, you can ask for an ABI anytime after the <a class="el" href="classSimTK_1_1State.html" title="This object is intended to contain all state information for a SimTK::System, except topological info...">State</a> has been realized to Position stage (or in fact any time after PositionKinematics have been realized). If ABIs haven't been calculated yet for the current configuration, either implicitly as discussed above or explicitly with <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a>, then their calculation will be triggered by the first call to this method (they must all be calculated at the same time). ABIs are saved once calculated and will be reused until the configuration q changes.</p>
<p>Ground is mobilized body zero; its articulated body inertia is the same as its composite body inertia &ndash; an ordinary Spatial Inertia but with infinite mass and principle moments of inertia, and center of mass at (0,0,0). </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13aa387747781b9d06f99cad1168864c747" title="Spatial configuration available. ">Stage::Position</a></code>, or <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a> and <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314" title="Position kinematics is the first part of the Stage::Position realization, mapping generalized coordin...">realizePositionKinematics()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3a06d5c75f71747d4fa479e7abfd3971" title="This operator calculates in O(n) time the product M^-1*v where M is the system mass matrix and v is a...">multiplyByMInv()</a>, <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314" title="Position kinematics is the first part of the Stage::Position realization, mapping generalized coordin...">realizePositionKinematics()</a> </dd></dl>

</div>
</div>
<a id="a535addf33054ebf04b7fe4a15fb41891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535addf33054ebf04b7fe4a15fb41891">&#9670;&nbsp;</a></span>getGyroscopicForce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::SimbodyMatterSubsystem::getGyroscopicForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the rotational velocity-dependent force <code>b</code> on the body due to rotational inertia. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="aa902ae99663524016c0c037cbe25678d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa902ae99663524016c0c037cbe25678d">&#9670;&nbsp;</a></span>getMobilizerCoriolisAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::SimbodyMatterSubsystem::getMobilizerCoriolisAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the <em>cross-mobilizer</em> incremental contribution <code>A</code> to the Coriolis (angular velocity dependent) acceleration of a particular mobilized body; it is not too useful except as an intermediate calculation for more interesting quantities &ndash; you are probably interested in <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a924f05c60c6b21db34cc54e56ed28d51" title="This is the total Coriolis acceleration of a particular mobilized body, including the effect of the p...">getTotalCoriolisAcceleration()</a> instead. </p>
<dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="a924f05c60c6b21db34cc54e56ed28d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924f05c60c6b21db34cc54e56ed28d51">&#9670;&nbsp;</a></span>getTotalCoriolisAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::SimbodyMatterSubsystem::getTotalCoriolisAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the total Coriolis acceleration of a particular mobilized body, including the effect of the parent's angular velocity as well as the mobilizer's. </p>
<p>This is one element of Jdot*u where J is the system kinematic Jacobian and u is the current set of generalized speeds in the supplied state. It is thus the remainder term in calculation of body accelerations from generalized accelerations udot: since <code>V=J*u</code>, <code>A=J*udot + Jdot*u</code>. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="ad35935a456ddf2d7193bdd9175f8082a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35935a456ddf2d7193bdd9175f8082a">&#9670;&nbsp;</a></span>getTotalCentrifugalForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::SimbodyMatterSubsystem::getTotalCentrifugalForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the total rotational velocity-dependent force acting on this body B, including forces due to Coriolis acceleration and gyroscopic forces due to rotational inertia. </p>
<p>This is <code>F=M*a+b</code> where <code>M</code> is the spatial inertia matrix of body B (<em>not</em> its articulated body inertia), <code>a</code> is the total spatial Coriolis acceleration of B, and <code>b</code> is the (rotational velocity-dependent) spatial gyroscopic force acting on B. </p><dl class="section user"><dt>Required stage</dt><dd><code><a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13adaccf0c0afccae921811f5dd93e781e1" title="Spatial velocities available. ">Stage::Velocity</a></code> </dd></dl>

</div>
</div>
<a id="a92f4107db4cd697fbbea6064c9769770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f4107db4cd697fbbea6064c9769770">&#9670;&nbsp;</a></span>calcMobilizerReactionForcesUsingFreebodyMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::calcMobilizerReactionForcesUsingFreebodyMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>forcesAtMInG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a slower alternative to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1af1e68128d882eebf1cd213640136aa" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>, for use in regression testing and Simbody development. </p>
<p>This method builds a freebody "diagram" for each body in turn to determine the unknown reaction force at its inboard mobilizer.</p>
<p>The given <em>state</em> must have been realized through Acceleration stage.</p>
<h3>Implementation</h3>
<p>We use a tip-to-base recursion in which we assemble all applied body forces from force elements, constraints, and gyroscopic effects and compare that with the apparent rigid body force determined from F=M*A where M is a body's spatial inertia (in G) and A its already-calculated spatial acceleration. The difference is the missing force applied by the body's mobilizer, i.e. the reaction force. That is shifted to the M frame and reported. Then the equal and opposite reaction is applied to the parent body and included in its collection of applied forces, which can be used to determine its reaction force and so on.</p>
<p>This is is about 3X slower than the method used by <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1af1e68128d882eebf1cd213640136aa" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a1af1e68128d882eebf1cd213640136aa" title="Calculate the mobilizer reaction force generated at each MobilizedBody, as felt at the mobilizer&#39;s ou...">calcMobilizerReactionForces()</a> </dd></dl>

</div>
</div>
<a id="a26ad897ab748ef0fb1f8118da3488310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ad897ab748ef0fb1f8118da3488310">&#9670;&nbsp;</a></span>invalidatePositionKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::invalidatePositionKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of position kinematics, which otherwise remains valid until an instance-stage variable or a generalized coordinate q is modified. </p>
<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314" title="Position kinematics is the first part of the Stage::Position realization, mapping generalized coordin...">realizePositionKinematics()</a>, which otherwise will not recalculate if called repeatedly. Note that this also invalidates Position stage and above in <code>state</code> because position kinematics is assumed to be valid after Position stage, regardless of lazy evaluation status. </p>

</div>
</div>
<a id="af6524e4441791639ccea7922c7ef05ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6524e4441791639ccea7922c7ef05ae">&#9670;&nbsp;</a></span>isPositionKinematicsRealized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isPositionKinematicsRealized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Check whether position kinematics has already been realized. </p>
<p>This will be true after <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#afe15082955cdd01993a0bc8b390ed314" title="Position kinematics is the first part of the Stage::Position realization, mapping generalized coordin...">realizePositionKinematics()</a> or realize(Position); false after invalidation of <a class="el" href="classSimTK_1_1Stage.html#ac3ebdb6f8942a72c65886e5286dd8a13af4ff7049cee385e9f602ab8378beee4a" title="Physical parameters set. ">Stage::Instance</a>, a change to a generalized coordinate <code>q</code>, or after a call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a26ad897ab748ef0fb1f8118da3488310" title="(Advanced) Force invalidation of position kinematics, which otherwise remains valid until an instance...">invalidatePositionKinematics()</a>. </p>

</div>
</div>
<a id="a38e6bc6be5137475bb5a7d042c30abc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e6bc6be5137475bb5a7d042c30abc4">&#9670;&nbsp;</a></span>invalidateVelocityKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::invalidateVelocityKinematics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of velocity kinematics, which otherwise remains valid until an instance-stage variable, generalized coordinate q, or generalized speed u is modified, or if PositionKinematics is explicitly invalidated. </p>
<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae3d6e1a94635f1866523ac2788a27fe2" title="Velocity kinematics is the first part of the Stage::Velocity realization, mapping generalized speeds ...">realizeVelocityKinematics()</a>, which otherwise will not recalculate if called repeatedly. Note that this also invalidates Velocity stage and above in <code>state</code> because velocity kinematics is assumed to be valid after Velocity stage, regardless of lazy evaluation status. </p>

</div>
</div>
<a id="a60a6dc6be701b48912ef810dfb2d4178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a6dc6be701b48912ef810dfb2d4178">&#9670;&nbsp;</a></span>isVelocityKinematicsRealized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isVelocityKinematicsRealized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Check whether velocity kinematics has already been realized. </p>
<p>This will be true after <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ae3d6e1a94635f1866523ac2788a27fe2" title="Velocity kinematics is the first part of the Stage::Velocity realization, mapping generalized speeds ...">realizeVelocityKinematics()</a> or realize(Velocity); false if <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6524e4441791639ccea7922c7ef05ae" title="(Advanced) Check whether position kinematics has already been realized. ">isPositionKinematicsRealized()</a> would return false, after a change to a generalized speed <code>u</code>, or after a call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a38e6bc6be5137475bb5a7d042c30abc4" title="(Advanced) Force invalidation of velocity kinematics, which otherwise remains valid until an instance...">invalidateVelocityKinematics()</a>. </p>

</div>
</div>
<a id="a60342f4ac0206fdcc69cd2c9ec9e7edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60342f4ac0206fdcc69cd2c9ec9e7edb">&#9670;&nbsp;</a></span>invalidateCompositeBodyInertias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::invalidateCompositeBodyInertias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>, which otherwise will not recalculate them if called repeatedly. </p>

</div>
</div>
<a id="afac8ae03c63624316b52e6308d44c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac8ae03c63624316b52e6308d44c095">&#9670;&nbsp;</a></span>isCompositeBodyInertiasRealized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isCompositeBodyInertiasRealized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Check whether composite body inertias have already been realized. </p>
<p>This will be true only after an explicit call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5aeb334d652c5d87a7939faff9816706" title="This method checks whether composite body inertias have already been computed since the last change t...">realizeCompositeBodyInertias()</a>; false if <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6524e4441791639ccea7922c7ef05ae" title="(Advanced) Check whether position kinematics has already been realized. ">isPositionKinematicsRealized()</a> would return false or after a call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a60342f4ac0206fdcc69cd2c9ec9e7edb" title="(Advanced) This is useful for timing computation time for realizeCompositeBodyInertias(), which otherwise will not recalculate them if called repeatedly. ">invalidateCompositeBodyInertias()</a>. </p>

</div>
</div>
<a id="a3e93d47be0cf6d154c79f5abbf77dc8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e93d47be0cf6d154c79f5abbf77dc8d">&#9670;&nbsp;</a></span>invalidateArticulatedBodyInertias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::invalidateArticulatedBodyInertias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of articulated body inertias (ABIs), which otherwise remain valid until a position-stage variable is modified or any other prerequisite is invalidated. </p>
<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a>, which otherwise will not recalculate if called repeatedly. Note that this also invalidates Acceleration stage in <code>state</code> because ABIs are assumed to be valid after Acceleration stage, regardless of lazy evaluation status. </p>

</div>
</div>
<a id="a88f79736449b361d0dc6d8163956cb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f79736449b361d0dc6d8163956cb14">&#9670;&nbsp;</a></span>isArticulatedBodyInertiasRealized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isArticulatedBodyInertiasRealized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Check whether articulated body inertias have already been realized. </p>
<p>This will be true after <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ab89fcf89490662254306e34157409010" title="This method ensures that articulated body inertias (ABIs) are up to date with the most recent change ...">realizeArticulatedBodyInertias()</a> or realize(Acceleration); false if <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#af6524e4441791639ccea7922c7ef05ae" title="(Advanced) Check whether position kinematics has already been realized. ">isPositionKinematicsRealized()</a> would return false, or after a call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a3e93d47be0cf6d154c79f5abbf77dc8d" title="(Advanced) Force invalidation of articulated body inertias (ABIs), which otherwise remain valid until...">invalidateArticulatedBodyInertias()</a>. </p>

</div>
</div>
<a id="a517ec5fcfd3c4bf69e07f910398c711e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517ec5fcfd3c4bf69e07f910398c711e">&#9670;&nbsp;</a></span>invalidateArticulatedBodyVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::invalidateArticulatedBodyVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) <a class="el" href="classSimTK_1_1Force.html" title="This is the base class from which all Force element handle classes derive. ">Force</a> invalidation of articulated body velocity computations, which otherwise remain valid until a velocity- or position-stage variable is modified or any other prerequisite is invalidated. </p>
<p>This is useful for timing computation time for <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5f4f7709391f21a0e8298ed314c6161d" title="(Advanced) This method ensures that velocity-dependent computations that also depend on articulated b...">realizeArticulatedBodyVelocity()</a>, which otherwise will not recalculate if called repeatedly. Note that this also invalidates Acceleration stage in <code>state</code> because these computations are assumed to be valid after Acceleration stage, regardless of lazy evaluation status. </p>

</div>
</div>
<a id="ae6b53d7cb079d2725630a07a88ee6ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b53d7cb079d2725630a07a88ee6ce5">&#9670;&nbsp;</a></span>isArticulatedBodyVelocityRealized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::SimbodyMatterSubsystem::isArticulatedBodyVelocityRealized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Check whether articulated body velocity computations have already been realized. </p>
<p>This will be true after <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a5f4f7709391f21a0e8298ed314c6161d" title="(Advanced) This method ensures that velocity-dependent computations that also depend on articulated b...">realizeArticulatedBodyVelocity()</a> or realize(Acceleration); false if <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a88f79736449b361d0dc6d8163956cb14" title="(Advanced) Check whether articulated body inertias have already been realized. ">isArticulatedBodyInertiasRealized()</a> or <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a60a6dc6be701b48912ef810dfb2d4178" title="(Advanced) Check whether velocity kinematics has already been realized. ">isVelocityKinematicsRealized()</a> would return false, or after a call to <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#a517ec5fcfd3c4bf69e07f910398c711e" title="(Advanced) Force invalidation of articulated body velocity computations, which otherwise remain valid...">invalidateArticulatedBodyVelocity()</a>. </p>

</div>
</div>
<a id="a70dda1803dd267a0ff8fd2ead9d87d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dda1803dd267a0ff8fd2ead9d87d43">&#9670;&nbsp;</a></span>getNumParticles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimTK::SimbodyMatterSubsystem::getNumParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a7568dedc65e4192f352941ce2c1b9204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7568dedc65e4192f352941ce2c1b9204">&#9670;&nbsp;</a></span>getAllParticleLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getAllParticleLocations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a0e889523956b3298623c9c188611f04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e889523956b3298623c9c188611f04d">&#9670;&nbsp;</a></span>getAllParticleVelocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getAllParticleVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a8a7e5f0273577de86575f69780d20137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7e5f0273577de86575f69780d20137">&#9670;&nbsp;</a></span>getParticleLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::SimbodyMatterSubsystem::getParticleLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a25ab12bf1f46e3d6a4b51fc29f74dcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ab12bf1f46e3d6a4b51fc29f74dcee">&#9670;&nbsp;</a></span>getParticleVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::SimbodyMatterSubsystem::getParticleVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a2f6303ed78859b5caed9890fdaa6c5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6303ed78859b5caed9890fdaa6c5d0">&#9670;&nbsp;</a></span>updAllParticleMasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::SimbodyMatterSubsystem::updAllParticleMasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a7e1fe7f8546288976f36f63c8880eff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1fe7f8546288976f36f63c8880eff3">&#9670;&nbsp;</a></span>setAllParticleMasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setAllParticleMasses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>masses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a0e937177c779bd66adc9479bfdf40f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e937177c779bd66adc9479bfdf40f0d">&#9670;&nbsp;</a></span>updAllParticleLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::updAllParticleLocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="ad863d0cec4aa678a4f2ad15e3361bc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad863d0cec4aa678a4f2ad15e3361bc18">&#9670;&nbsp;</a></span>updAllParticleVelocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::updAllParticleVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a773653c6df2b82b3ab3af862323875fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773653c6df2b82b3ab3af862323875fb">&#9670;&nbsp;</a></span>updParticleLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::SimbodyMatterSubsystem::updParticleLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a6f3cf54f24cbe78c0f69cf985cb55d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3cf54f24cbe78c0f69cf985cb55d01">&#9670;&nbsp;</a></span>updParticleVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::SimbodyMatterSubsystem::updParticleVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="ae9d413858e567337af53555890ee0a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d413858e567337af53555890ee0a4a">&#9670;&nbsp;</a></span>setParticleLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setParticleLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a6d75c972ca647b8f87a7971aa8f41821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d75c972ca647b8f87a7971aa8f41821">&#9670;&nbsp;</a></span>setParticleVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setParticleVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="abccdf701488ba7b30e854ef0d7d71980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccdf701488ba7b30e854ef0d7d71980">&#9670;&nbsp;</a></span>setAllParticleLocations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setAllParticleLocations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a01835793e11406321e24d5fd2e6737e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01835793e11406321e24d5fd2e6737e7">&#9670;&nbsp;</a></span>setAllParticleVelocities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::SimbodyMatterSubsystem::setAllParticleVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt; <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a30501d4d3438031f43660158ec1b3a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30501d4d3438031f43660158ec1b3a73">&#9670;&nbsp;</a></span>getAllParticleMasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gacd32706a1c8d3ee7c84c56bf048e7f1f">Vector</a>&amp; SimTK::SimbodyMatterSubsystem::getAllParticleMasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="abcbbca20710f38a6f9ff4f303310d5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbbca20710f38a6f9ff4f303310d5b2">&#9670;&nbsp;</a></span>getAllParticleAccelerations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Vector__.html">Vector_</a>&lt;<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&gt;&amp; SimTK::SimbodyMatterSubsystem::getAllParticleAccelerations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="ac0e73e4fab6f22e308686b1a3e1ce3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e73e4fab6f22e308686b1a3e1ce3b2">&#9670;&nbsp;</a></span>getParticleAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&amp; SimTK::SimbodyMatterSubsystem::getParticleAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParticleIndex&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: total number of particles. </p>

</div>
</div>
<a id="a6ed041c37c2c385e1328373388e25708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed041c37c2c385e1328373388e25708">&#9670;&nbsp;</a></span>getMobilizerCentrifugalForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__SpatialAlgebraUtilities.html#ga09c3f8ce9203cc999a69e18bdfa299ea">SpatialVec</a>&amp; SimTK::SimbodyMatterSubsystem::getMobilizerCentrifugalForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1State.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1MobilizedBodyIndex.html">MobilizedBodyIndex</a>&#160;</td>
          <td class="paramname"><em>mbx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> This is an obscure internal quantity and shouldn't have been exposed; see <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html#ad35935a456ddf2d7193bdd9175f8082a" title="This is the total rotational velocity-dependent force acting on this body B, including forces due to ...">getTotalCentrifugalForces()</a> instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ada91148391d89bcdcfd812c91cf16fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada91148391d89bcdcfd812c91cf16fbb">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump some debug information about the given subsystem to the given output stream; this is <em>not</em> for serialization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="SimbodyMatterSubsystem_8h_source.html">SimbodyMatterSubsystem.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1SimbodyMatterSubsystem.html">SimbodyMatterSubsystem</a></li>
    <li class="footer">Generated on Fri Dec 6 2019 17:28:08 for Simbody by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
