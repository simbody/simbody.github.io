<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::ArrayView_&lt; T, X &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1ArrayView__.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1ArrayView__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ArrayView_&lt; T, X &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>, extending <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> to add the ability to modify elements, but not the ability to change size or reallocate.  
 <a href="classSimTK_1_1ArrayView__.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::ArrayView_&lt; T, X &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1ArrayView__.png" usemap="#SimTK::ArrayView_5F_3C_20T_2C_20X_20_3E_map" alt=""/>
  <map id="SimTK::ArrayView_5F_3C_20T_2C_20X_20_3E_map" name="SimTK::ArrayView_5F_3C_20T_2C_20X_20_3E_map">
<area href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we..." alt="SimTK::ArrayViewConst_&lt; T, X &gt;" shape="rect" coords="0,0,423,24"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; ObservationIx, MarkerIx &gt;" shape="rect" coords="433,112,856,136"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::Transform_ &gt;" shape="rect" coords="433,168,856,192"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ContactDetail &gt;" shape="rect" coords="433,224,856,248"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; FreeQIndex, SimTK::QIndex &gt;" shape="rect" coords="433,280,856,304"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::OBBNode &gt;" shape="rect" coords="433,336,856,360"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::Contact, int &gt;" shape="rect" coords="433,392,856,416"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::BoundedRT &gt;" shape="rect" coords="433,448,856,472"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; StateLimitedFrictionIndex &gt;" shape="rect" coords="433,504,856,528"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; UnilateralContactIndex &gt;" shape="rect" coords="433,560,856,584"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; ContactCliqueId, short &gt;" shape="rect" coords="433,616,856,640"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; std::string &gt;" shape="rect" coords="433,672,856,696"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; ObservationIx, OSensorIx &gt;" shape="rect" coords="433,728,856,752"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; OSensorIx, ObservationIx &gt;" shape="rect" coords="433,784,856,808"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; Real, AssemblyConditionIndex &gt;" shape="rect" coords="433,840,856,864"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::Rotation_, ObservationIx &gt;" shape="rect" coords="433,896,856,920"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::QIndex, FreeQIndex &gt;" shape="rect" coords="433,952,856,976"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; int &gt;" shape="rect" coords="433,1008,856,1032"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::UncondRT &gt;" shape="rect" coords="433,1064,856,1088"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; AssemblyConditionIndex &gt;" shape="rect" coords="433,1120,856,1144"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; Marker, MarkerIx &gt;" shape="rect" coords="433,1176,856,1200"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::MultiplierIndex &gt;" shape="rect" coords="433,1232,856,1256"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::UniSpeedRT &gt;" shape="rect" coords="433,1288,856,1312"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::UniContactRT &gt;" shape="rect" coords="433,1344,856,1368"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::AbstractMeasure::Implementation * &gt;" shape="rect" coords="433,1400,856,1424"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; ActiveIndex, SimTK::MultiplierIndex &gt;" shape="rect" coords="433,1456,856,1480"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::Vec, ObservationIx &gt;" shape="rect" coords="433,1512,856,1536"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; MarkerIx, ObservationIx &gt;" shape="rect" coords="433,1568,856,1592"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::QIndex &gt;" shape="rect" coords="433,1624,856,1648"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::CacheEntryIndex &gt;" shape="rect" coords="433,1680,856,1704"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; const SimTK::EventReporter * &gt;" shape="rect" coords="433,1736,856,1760"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::StateLtdFrictionRT &gt;" shape="rect" coords="433,1792,856,1816"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::AssemblyCondition *, AssemblyConditionIndex &gt;" shape="rect" coords="433,1848,856,1872"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::Vec &gt;" shape="rect" coords="433,1904,856,1928"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::MultiplierIndex, ActiveIndex &gt;" shape="rect" coords="433,1960,856,1984"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; OSensor, OSensorIx &gt;" shape="rect" coords="433,2016,856,2040"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; Real &gt;" shape="rect" coords="433,2072,856,2096"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; T *, size_t &gt;" shape="rect" coords="433,2128,856,2152"/>
<area href="classSimTK_1_1Array__.html" alt="SimTK::Array_&lt; SimTK::ImpulseSolver::ConstraintLtdFrictionRT &gt;" shape="rect" coords="433,2184,856,2208"/>
<area href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ..." alt="SimTK::Array_&lt; T, X &gt;" shape="rect" coords="433,2240,856,2264"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Types required of STL containers, plus index_type which is an extension, and packed_size_type which is an implementation detail. </p>
</div></td></tr>
<tr class="memitem:aeb29ff328a71341945e442234f50e253"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb29ff328a71341945e442234f50e253">value_type</a></td></tr>
<tr class="separator:aeb29ff328a71341945e442234f50e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79baa909a71d2f8c75b1120776ccca3"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ae79baa909a71d2f8c75b1120776ccca3">index_type</a></td></tr>
<tr class="separator:ae79baa909a71d2f8c75b1120776ccca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fd72f5f77716f823f8c0a9a87974"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3950fd72f5f77716f823f8c0a9a87974">pointer</a></td></tr>
<tr class="separator:a3950fd72f5f77716f823f8c0a9a87974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8dabb125276c7fcdaa215b23f808f"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad6e8dabb125276c7fcdaa215b23f808f">const_pointer</a></td></tr>
<tr class="separator:ad6e8dabb125276c7fcdaa215b23f808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b454ffabc27881011e3dcfea4014"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab4b4b454ffabc27881011e3dcfea4014">reference</a></td></tr>
<tr class="separator:ab4b4b454ffabc27881011e3dcfea4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611de0d81f0e43b256704e817d63ae47"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a611de0d81f0e43b256704e817d63ae47">const_reference</a></td></tr>
<tr class="separator:a611de0d81f0e43b256704e817d63ae47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6566e08689eb53ae89a2b000ed4a4140"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6566e08689eb53ae89a2b000ed4a4140">iterator</a></td></tr>
<tr class="separator:a6566e08689eb53ae89a2b000ed4a4140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14185eed75d43f044775a366c02590c0"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a14185eed75d43f044775a366c02590c0">const_iterator</a></td></tr>
<tr class="separator:a14185eed75d43f044775a366c02590c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e9c961a4621efd1bfe21bf099ca77"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a704e9c961a4621efd1bfe21bf099ca77">reverse_iterator</a></td></tr>
<tr class="separator:a704e9c961a4621efd1bfe21bf099ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1232d267e9b8c139cca1512b412a6d1"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac1232d267e9b8c139cca1512b412a6d1">const_reverse_iterator</a></td></tr>
<tr class="separator:ac1232d267e9b8c139cca1512b412a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e901cbddbca41c54b22c6216ac804b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab6e901cbddbca41c54b22c6216ac804b">size_type</a></td></tr>
<tr class="separator:ab6e901cbddbca41c54b22c6216ac804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad962ee7e4110ac6c20bdfa340f81dc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abad962ee7e4110ac6c20bdfa340f81dc">difference_type</a></td></tr>
<tr class="separator:abad962ee7e4110ac6c20bdfa340f81dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9536141dcc61cfc646bb1f2062e5e558"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a9536141dcc61cfc646bb1f2062e5e558">packed_size_type</a></td></tr>
<tr class="separator:a9536141dcc61cfc646bb1f2062e5e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td></tr>
<tr class="memdesc:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object stored in this container.  <a href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">More...</a><br /></td></tr>
<tr class="separator:a39bda86e859db1597f4d49d8037d0660 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td></tr>
<tr class="memdesc:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type (an extension).  <a href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">More...</a><br /></td></tr>
<tr class="separator:af92bca96f3089b5f0d4133fce9c7cded inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td></tr>
<tr class="memdesc:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable pointer to a value_type.  <a href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">More...</a><br /></td></tr>
<tr class="separator:a2825bef320398cbf8d8f2e2b8631632e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td></tr>
<tr class="memdesc:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const pointer to a value_type.  <a href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">More...</a><br /></td></tr>
<tr class="separator:a7fdc551f402dc69766e819733ee6f08b inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td></tr>
<tr class="memdesc:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable value_type reference.  <a href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">More...</a><br /></td></tr>
<tr class="separator:aacce6f572b1deffcefa3f3aae5263b1c inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td></tr>
<tr class="memdesc:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const value_type reference.  <a href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">More...</a><br /></td></tr>
<tr class="separator:a460302f601c4a2c2d63837cb1e5d875a inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td></tr>
<tr class="memdesc:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable iterator for this container (same as pointer here).  <a href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">More...</a><br /></td></tr>
<tr class="separator:a416a8bff8ad197d4dfb2d41866acbd23 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td></tr>
<tr class="memdesc:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for this container (same as const_pointer here).  <a href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">More...</a><br /></td></tr>
<tr class="separator:a76215b9c0677fca5706f11038f496963 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td></tr>
<tr class="memdesc:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A writable reverse iterator for this container.  <a href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">More...</a><br /></td></tr>
<tr class="separator:a4b566573f0b94c804a6b6e0514c78bce inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td></tr>
<tr class="memdesc:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reverse iterator for this container.  <a href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">More...</a><br /></td></tr>
<tr class="separator:ab26d002d51080ddd32f8899e5ea3ea40 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td></tr>
<tr class="memdesc:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integral type suitable for all indices and sizes for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">More...</a><br /></td></tr>
<tr class="separator:abaaff64afd3daaed43f1acecbe2bbfe7 inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt; X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td></tr>
<tr class="memdesc:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type that can represent the difference between any two legitimate index values for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">More...</a><br /></td></tr>
<tr class="separator:a1f604d5e70ddbe7eb0bf9a80a236951e inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">typedef ArrayIndexPackType&lt; <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td></tr>
<tr class="memdesc:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type we actually use internally to store size_type values.  <a href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">More...</a><br /></td></tr>
<tr class="separator:af01fd47de6bffe601337c1ef0a45e88d inherit pub_types_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, conversion, and destruction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Constructors here are limited to those that don't allocate new data, however they can reference writable data. </p>
</div></td></tr>
<tr class="memitem:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">ArrayView_</a> ()</td></tr>
<tr class="memdesc:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="classSimTK_1_1ArrayView__.html#aa8e89ce2da1f241ae70e38cfe63ba980">More...</a><br /></td></tr>
<tr class="separator:aa8e89ce2da1f241ae70e38cfe63ba980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddf75311833fc599a934c3f3d5a57d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">ArrayView_</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:ad1ddf75311833fc599a934c3f3d5a57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow.  <a href="classSimTK_1_1ArrayView__.html#ad1ddf75311833fc599a934c3f3d5a57d">More...</a><br /></td></tr>
<tr class="separator:ad1ddf75311833fc599a934c3f3d5a57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6104f869055379b0fbd146aeefa919"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">ArrayView_</a> (T *first, const T *last1)</td></tr>
<tr class="memdesc:a8e6104f869055379b0fbd146aeefa919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a range of writable memory.  <a href="classSimTK_1_1ArrayView__.html#a8e6104f869055379b0fbd146aeefa919">More...</a><br /></td></tr>
<tr class="separator:a8e6104f869055379b0fbd146aeefa919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">ArrayView_</a> (std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a176653cfecc6ee9dd5cbb08f53725a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct to reference memory owned by a writable std::vector.  <a href="classSimTK_1_1ArrayView__.html#a176653cfecc6ee9dd5cbb08f53725a34">More...</a><br /></td></tr>
<tr class="separator:a176653cfecc6ee9dd5cbb08f53725a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b1cc7aa9e01c80acc744ede6407cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aed5b1cc7aa9e01c80acc744ede6407cc">operator const Array_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:aed5b1cc7aa9e01c80acc744ede6407cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost).  <a href="classSimTK_1_1ArrayView__.html#aed5b1cc7aa9e01c80acc744ede6407cc">More...</a><br /></td></tr>
<tr class="separator:aed5b1cc7aa9e01c80acc744ede6407cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7f785e236628b37192a5380d0a479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">operator Array_&lt; T, X &gt; &amp;</a> ()</td></tr>
<tr class="memdesc:a6ef7f785e236628b37192a5380d0a479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost).  <a href="classSimTK_1_1ArrayView__.html#a6ef7f785e236628b37192a5380d0a479">More...</a><br /></td></tr>
<tr class="separator:a6ef7f785e236628b37192a5380d0a479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848acb2e30474663b3d708e80f2b6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">disconnect</a> ()</td></tr>
<tr class="memdesc:a7848acb2e30474663b3d708e80f2b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method â€“ clears the handle without doing anything to the data.">disconnect()</a> method &ndash; clears the handle without doing anything to the data.  <a href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc">More...</a><br /></td></tr>
<tr class="separator:a7848acb2e30474663b3d708e80f2b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">~ArrayView_</a> ()</td></tr>
<tr class="memdesc:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information.  <a href="classSimTK_1_1ArrayView__.html#a509b38ff0b42a6ff6b38cd3b26f4096f">More...</a><br /></td></tr>
<tr class="separator:a509b38ff0b42a6ff6b38cd3b26f4096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Assignment is permitted only if the source and destination are the same size.</p>
<p>The semantics here are different than for a resizeable <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> object: here the meaning is elementwise assignment rather than destruction followed by copy construction. That is, if our elements are of type T, and the source elements are of type T2, we will use the operator of T that best matches the signature T::operator=(const T2&amp;) to perform the assignments. When the source also has type T, this is just T's copy assignment operator. We never perform any element destruction or construction here. </p>
</div></td></tr>
<tr class="memitem:a1a3e84580379c69d92ab24d96fa6c180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;src)</td></tr>
<tr class="memdesc:a1a3e84580379c69d92ab24d96fa6c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment; source must be the same size as this array.  <a href="classSimTK_1_1ArrayView__.html#a1a3e84580379c69d92ab24d96fa6c180">More...</a><br /></td></tr>
<tr class="separator:a1a3e84580379c69d92ab24d96fa6c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a7f8826e1792377e63d47b9c9a3c53584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a7f8826e1792377e63d47b9c9a3c53584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a7f8826e1792377e63d47b9c9a3c53584">More...</a><br /></td></tr>
<tr class="separator:a7f8826e1792377e63d47b9c9a3c53584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">operator=</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:acb5dc46e5a1126a8e30882e53a86c62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#acb5dc46e5a1126a8e30882e53a86c62d">More...</a><br /></td></tr>
<tr class="separator:acb5dc46e5a1126a8e30882e53a86c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d"><td class="memTemplParams" colspan="2">template&lt;class T2 , class X2 &gt; </td></tr>
<tr class="memitem:a45bc77b91b7751a909ca6524346c9e8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">operator=</a> (const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a45bc77b91b7751a909ca6524346c9e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a45bc77b91b7751a909ca6524346c9e8d">More...</a><br /></td></tr>
<tr class="separator:a45bc77b91b7751a909ca6524346c9e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memTemplParams" colspan="2">template&lt;class T2 , class A2 &gt; </td></tr>
<tr class="memitem:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">operator=</a> (const std::vector&lt; T2, A2 &gt; &amp;src)</td></tr>
<tr class="memdesc:a68daffa0f934e5f3d6f75adcb5d93367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible.  <a href="classSimTK_1_1ArrayView__.html#a68daffa0f934e5f3d6f75adcb5d93367">More...</a><br /></td></tr>
<tr class="separator:a68daffa0f934e5f3d6f75adcb5d93367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6a21ecbf455765267d5d12bde8628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">operator=</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a29e6a21ecbf455765267d5d12bde8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill assignment &ndash; all elements are set to fillValue.  <a href="classSimTK_1_1ArrayView__.html#a29e6a21ecbf455765267d5d12bde8628">More...</a><br /></td></tr>
<tr class="separator:a29e6a21ecbf455765267d5d12bde8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbebca5377888478d004f882a6c24e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">fill</a> (const T &amp;fillValue)</td></tr>
<tr class="memdesc:a1dbebca5377888478d004f882a6c24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element.  <a href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2">More...</a><br /></td></tr>
<tr class="separator:a1dbebca5377888478d004f882a6c24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a7d28c5d7a0586b39260b4a167f10c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">assign</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> n, const T &amp;fillValue)</td></tr>
<tr class="memdesc:a06a7d28c5d7a0586b39260b4a167f10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size.  <a href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c">More...</a><br /></td></tr>
<tr class="separator:a06a7d28c5d7a0586b39260b4a167f10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a"><td class="memTemplParams" colspan="2">template&lt;class T2 &gt; </td></tr>
<tr class="memitem:a39312ebedf1ce457f129b39c69d4515a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">assign</a> (const T2 *first, const T2 *last1)</td></tr>
<tr class="memdesc:a39312ebedf1ce457f129b39c69d4515a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array.  <a href="classSimTK_1_1ArrayView__.html#a39312ebedf1ce457f129b39c69d4515a">More...</a><br /></td></tr>
<tr class="separator:a39312ebedf1ce457f129b39c69d4515a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136"><td class="memTemplParams" colspan="2">template&lt;class Iter &gt; </td></tr>
<tr class="memitem:afb5c2516d03bb21d24ea4e87af777136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">assign</a> (const Iter &amp;first, const Iter &amp;last1)</td></tr>
<tr class="memdesc:afb5c2516d03bb21d24ea4e87af777136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant).  <a href="classSimTK_1_1ArrayView__.html#afb5c2516d03bb21d24ea4e87af777136">More...</a><br /></td></tr>
<tr class="separator:afb5c2516d03bb21d24ea4e87af777136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide read and write access to individual elements that are currently present in the array; the ArrayViewConst_&lt;T,X&gt; base class provides the read-only (const) methods. </p>
</div></td></tr>
<tr class="memitem:a8b61bbc4573a1ceb006a2ce00eb9b1ee"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8b61bbc4573a1ceb006a2ce00eb9b1ee">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:a8b61bbc4573a1ceb006a2ce00eb9b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="classSimTK_1_1ArrayView__.html#a8b61bbc4573a1ceb006a2ce00eb9b1ee">More...</a><br /></td></tr>
<tr class="separator:a8b61bbc4573a1ceb006a2ce00eb9b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c9a87081523151ddbf1d22a853e4e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a943c9a87081523151ddbf1d22a853e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a writable (lvalue) reference.  <a href="classSimTK_1_1ArrayView__.html#a943c9a87081523151ddbf1d22a853e4e">More...</a><br /></td></tr>
<tr class="separator:a943c9a87081523151ddbf1d22a853e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fb9c25420a0202ace54bf01a49a07"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aee4fb9c25420a0202ace54bf01a49a07">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:aee4fb9c25420a0202ace54bf01a49a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayView__.html#aee4fb9c25420a0202ace54bf01a49a07">More...</a><br /></td></tr>
<tr class="separator:aee4fb9c25420a0202ace54bf01a49a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f3650f5d31037f0051431eb02b57b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:ab93f3650f5d31037f0051431eb02b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayView__.html#ab93f3650f5d31037f0051431eb02b57b">More...</a><br /></td></tr>
<tr class="separator:ab93f3650f5d31037f0051431eb02b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9b2cd521db0ae0b2b56bd8b0e8838f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acf9b2cd521db0ae0b2b56bd8b0e8838f">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:acf9b2cd521db0ae0b2b56bd8b0e8838f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayView__.html#acf9b2cd521db0ae0b2b56bd8b0e8838f">More...</a><br /></td></tr>
<tr class="separator:acf9b2cd521db0ae0b2b56bd8b0e8838f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538c58736523ef56cafe9d926ec6e8f5"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">updElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i)</td></tr>
<tr class="memdesc:a538c58736523ef56cafe9d926ec6e8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayView__.html#a538c58736523ef56cafe9d926ec6e8f5">More...</a><br /></td></tr>
<tr class="separator:a538c58736523ef56cafe9d926ec6e8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05c55b3fe25b7cac1adb40415701cef"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac05c55b3fe25b7cac1adb40415701cef">front</a> () const</td></tr>
<tr class="memdesc:ac05c55b3fe25b7cac1adb40415701cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#ac05c55b3fe25b7cac1adb40415701cef">More...</a><br /></td></tr>
<tr class="separator:ac05c55b3fe25b7cac1adb40415701cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">front</a> ()</td></tr>
<tr class="memdesc:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the first element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#a1c3c26db7d7178a3e3c0b4603c7d0fcd">More...</a><br /></td></tr>
<tr class="separator:a1c3c26db7d7178a3e3c0b4603c7d0fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2342c3da808e5da540ea5eea430cce"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aeb2342c3da808e5da540ea5eea430cce">back</a> () const</td></tr>
<tr class="memdesc:aeb2342c3da808e5da540ea5eea430cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#aeb2342c3da808e5da540ea5eea430cce">More...</a><br /></td></tr>
<tr class="separator:aeb2342c3da808e5da540ea5eea430cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf707303e5e68fb5147fa36862c2bc57"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">back</a> ()</td></tr>
<tr class="memdesc:abf707303e5e68fb5147fa36862c2bc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the last element in this array, which must not be empty.  <a href="classSimTK_1_1ArrayView__.html#abf707303e5e68fb5147fa36862c2bc57">More...</a><br /></td></tr>
<tr class="separator:abf707303e5e68fb5147fa36862c2bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying).  <a href="classSimTK_1_1ArrayView__.html#ab89285bb25b06bc6a1b53fca6e63e3b7">More...</a><br /></td></tr>
<tr class="separator:ab89285bb25b06bc6a1b53fca6e63e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">updSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length)</td></tr>
<tr class="memdesc:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="classSimTK_1_1ArrayView__.html#a33b3799cc9d10a4e4a6781292f7bdc15">More...</a><br /></td></tr>
<tr class="separator:a33b3799cc9d10a4e4a6781292f7bdc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods deal in iterators, which are STL generalized pointers.</p>
<p>For this class, iterators are just ordinary pointers to T, and you may depend on that. By necessity, reverse iterators can't be just pointers; however, they contain an ordinary iterator (i.e. a pointer) that can be obtained by calling the reverse iterator's base() method. </p>
</div></td></tr>
<tr class="memitem:acfd0054fa1b411aa09edeb85b5f994a4"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4">cbegin</a> () const</td></tr>
<tr class="memdesc:acfd0054fa1b411aa09edeb85b5f994a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a>, which may be null (0) in that case but does not have to be.  <a href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4">More...</a><br /></td></tr>
<tr class="separator:acfd0054fa1b411aa09edeb85b5f994a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385a3a9743c8965c9a00f77db978339"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0385a3a9743c8965c9a00f77db978339">begin</a> () const</td></tr>
<tr class="memdesc:a0385a3a9743c8965c9a00f77db978339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4" title="Return a const pointer to the first element of this array if any, otherwise end(),...">cbegin()</a>.  <a href="classSimTK_1_1ArrayView__.html#a0385a3a9743c8965c9a00f77db978339">More...</a><br /></td></tr>
<tr class="separator:a0385a3a9743c8965c9a00f77db978339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa468711f19b67b25232650df6eeea608"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">begin</a> ()</td></tr>
<tr class="memdesc:aa468711f19b67b25232650df6eeea608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a>.  <a href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608">More...</a><br /></td></tr>
<tr class="separator:aa468711f19b67b25232650df6eeea608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854b4d187de22f6b7f2575ec16fb4fed"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed">cend</a> () const</td></tr>
<tr class="memdesc:a854b4d187de22f6b7f2575ec16fb4fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed">More...</a><br /></td></tr>
<tr class="separator:a854b4d187de22f6b7f2575ec16fb4fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86675d5260136d99f837c137ce01d0c"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ad86675d5260136d99f837c137ce01d0c">end</a> () const</td></tr>
<tr class="memdesc:ad86675d5260136d99f837c137ce01d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="classSimTK_1_1ArrayView__.html#ad86675d5260136d99f837c137ce01d0c">More...</a><br /></td></tr>
<tr class="separator:ad86675d5260136d99f837c137ce01d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5b2a07f725b6e943d45ad786bf02cb"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">end</a> ()</td></tr>
<tr class="memdesc:ace5b2a07f725b6e943d45ad786bf02cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to what would be the element just after the last one in this array.  <a href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb">More...</a><br /></td></tr>
<tr class="separator:ace5b2a07f725b6e943d45ad786bf02cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7e8546725ca792aa315054f7c92f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24">crbegin</a> () const</td></tr>
<tr class="memdesc:a2f7e8546725ca792aa315054f7c92f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24">More...</a><br /></td></tr>
<tr class="separator:a2f7e8546725ca792aa315054f7c92f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfad5c666de9b4d50e4d68df3b3536b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#accfad5c666de9b4d50e4d68df3b3536b">rbegin</a> () const</td></tr>
<tr class="memdesc:accfad5c666de9b4d50e4d68df3b3536b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="classSimTK_1_1ArrayView__.html#accfad5c666de9b4d50e4d68df3b3536b">More...</a><br /></td></tr>
<tr class="separator:accfad5c666de9b4d50e4d68df3b3536b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add040a16da503b139f280a9e1a41c61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">rbegin</a> ()</td></tr>
<tr class="memdesc:add040a16da503b139f280a9e1a41c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d">More...</a><br /></td></tr>
<tr class="separator:add040a16da503b139f280a9e1a41c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee15eb401904198d43db394ebfa96c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c">crend</a> () const</td></tr>
<tr class="memdesc:acfee15eb401904198d43db394ebfa96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c">More...</a><br /></td></tr>
<tr class="separator:acfee15eb401904198d43db394ebfa96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cda4c5af7c53c8ac0692a6ac19aa8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#af3cda4c5af7c53c8ac0692a6ac19aa8d">rend</a> () const</td></tr>
<tr class="memdesc:af3cda4c5af7c53c8ac0692a6ac19aa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="classSimTK_1_1ArrayView__.html#af3cda4c5af7c53c8ac0692a6ac19aa8d">More...</a><br /></td></tr>
<tr class="separator:af3cda4c5af7c53c8ac0692a6ac19aa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe28b711d20b58b18f5ad1bce34145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">rend</a> ()</td></tr>
<tr class="memdesc:a70fe28b711d20b58b18f5ad1bce34145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145">More...</a><br /></td></tr>
<tr class="separator:a70fe28b711d20b58b18f5ad1bce34145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac454dc1045c20cd273cc5e4f317e9045"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045">cdata</a> () const</td></tr>
<tr class="memdesc:ac454dc1045c20cd273cc5e4f317e9045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045">More...</a><br /></td></tr>
<tr class="separator:ac454dc1045c20cd273cc5e4f317e9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcad040471afe709b30a4aea6e021fb"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a6dcad040471afe709b30a4aea6e021fb">data</a> () const</td></tr>
<tr class="memdesc:a6dcad040471afe709b30a4aea6e021fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="classSimTK_1_1ArrayView__.html#a6dcad040471afe709b30a4aea6e021fb">More...</a><br /></td></tr>
<tr class="separator:a6dcad040471afe709b30a4aea6e021fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318481efdb8fd67f17e28e67cc8cce24"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">data</a> ()</td></tr>
<tr class="memdesc:a318481efdb8fd67f17e28e67cc8cce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array.  <a href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24">More...</a><br /></td></tr>
<tr class="separator:a318481efdb8fd67f17e28e67cc8cce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor allocates no heap space and is very fast.  <a href="classSimTK_1_1ArrayViewConst__.html#a6008f8ca816619f1b4a67c94027a2d59">More...</a><br /></td></tr>
<tr class="separator:a6008f8ca816619f1b4a67c94027a2d59 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">ArrayViewConst_</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a> &amp;src)</td></tr>
<tr class="memdesc:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is shallow; the constructed const array object will be referencing the original source data.  <a href="classSimTK_1_1ArrayViewConst__.html#a5412fa0b837f5e090f343180b2dbcdc8">More...</a><br /></td></tr>
<tr class="separator:a5412fa0b837f5e090f343180b2dbcdc8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">ArrayViewConst_</a> (const T *first, const T *last1)</td></tr>
<tr class="memdesc:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an ArrayViewConst_&lt;T&gt; by referencing (sharing) a given range of const data [first,last1), without copying that data.  <a href="classSimTK_1_1ArrayViewConst__.html#aba351ab4073da6f9d4c13855b039df6b">More...</a><br /></td></tr>
<tr class="separator:aba351ab4073da6f9d4c13855b039df6b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">ArrayViewConst_</a> (const std::vector&lt; T, A &gt; &amp;src)</td></tr>
<tr class="memdesc:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ArrayViewConst_&lt;T&gt; by referencing (sharing) the data in a const std::vector&lt;T&gt;, without copying the data; this is also an implicit conversion.  <a href="classSimTK_1_1ArrayViewConst__.html#acbb823ad8bafa05dae5c1a06b426c4a8">More...</a><br /></td></tr>
<tr class="separator:acbb823ad8bafa05dae5c1a06b426c4a8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a47a95ec8a50e2dfacd78cffb8eb0f9e7">operator const ArrayView_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const ArrayView_&lt;T,X&gt;&amp;, which is harmless since the const result won't permit writing on the elements.  <a href="classSimTK_1_1ArrayViewConst__.html#a47a95ec8a50e2dfacd78cffb8eb0f9e7">More...</a><br /></td></tr>
<tr class="separator:a47a95ec8a50e2dfacd78cffb8eb0f9e7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ae20cb3a99db498fbb2734893e57edfd3">operator const Array_&lt; T, X &gt; &amp;</a> () const</td></tr>
<tr class="memdesc:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implicit conversion to const Array_&lt;T,X&gt;&amp;, which is harmless since the const result can't be used to write on or resize the data.  <a href="classSimTK_1_1ArrayViewConst__.html#ae20cb3a99db498fbb2734893e57edfd3">More...</a><br /></td></tr>
<tr class="separator:ae20cb3a99db498fbb2734893e57edfd3 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">disconnect</a> ()</td></tr>
<tr class="memdesc:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect this array handle from any data to which it refers, restoring it to the condition it would be in if it had just been default-constructed.  <a href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643">More...</a><br /></td></tr>
<tr class="separator:ace600fbc0738888ceef29cc7c0846643 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">~ArrayViewConst_</a> ()</td></tr>
<tr class="memdesc:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">disconnect()</a> for more information.  <a href="classSimTK_1_1ArrayViewConst__.html#a5f34fb008e433a59e3957ab27b811839">More...</a><br /></td></tr>
<tr class="separator:a5f34fb008e433a59e3957ab27b811839 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a5d385a525b7d9fa78d52ba03875a824a">size</a> () const</td></tr>
<tr class="memdesc:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of elements stored in this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a5d385a525b7d9fa78d52ba03875a824a">More...</a><br /></td></tr>
<tr class="separator:a5d385a525b7d9fa78d52ba03875a824a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a48443f6c8b0fdc38c59ac3093c952ab8">max_size</a> () const</td></tr>
<tr class="memdesc:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum allowable size for this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a48443f6c8b0fdc38c59ac3093c952ab8">More...</a><br /></td></tr>
<tr class="separator:a48443f6c8b0fdc38c59ac3093c952ab8 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a117d86d441778646b7f0f374076804bb">empty</a> () const</td></tr>
<tr class="memdesc:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no elements currently stored in this array.  <a href="classSimTK_1_1ArrayViewConst__.html#a117d86d441778646b7f0f374076804bb">More...</a><br /></td></tr>
<tr class="separator:a117d86d441778646b7f0f374076804bb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb">capacity</a> () const</td></tr>
<tr class="memdesc:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements this array can currently hold without requiring reallocation.  <a href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb">More...</a><br /></td></tr>
<tr class="separator:aa7022bc0735937736ad44e135eb18dcb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a039a8a78c4f5c11942f20fd9b7aaed0a">allocated</a> () const</td></tr>
<tr class="memdesc:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amount of heap space owned by this array; this is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa7022bc0735937736ad44e135eb18dcb" title="Return the number of elements this array can currently hold without requiring reallocation.">capacity()</a> for owner arrays but is zero for non-owners.  <a href="classSimTK_1_1ArrayViewConst__.html#a039a8a78c4f5c11942f20fd9b7aaed0a">More...</a><br /></td></tr>
<tr class="separator:a039a8a78c4f5c11942f20fd9b7aaed0a inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af5bce2a59ea7822c0cf96ee60edb42d0">isOwner</a> () const</td></tr>
<tr class="memdesc:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this array own the data to which it refers? If not, it can't be resized, and the destructor will not free any heap space nor call any element destructors.  <a href="classSimTK_1_1ArrayViewConst__.html#af5bce2a59ea7822c0cf96ee60edb42d0">More...</a><br /></td></tr>
<tr class="separator:af5bce2a59ea7822c0cf96ee60edb42d0 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ac84df26d2ab345b08523b9cf3257baa7">operator[]</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select an element by its index, returning a const reference.  <a href="classSimTK_1_1ArrayViewConst__.html#ac84df26d2ab345b08523b9cf3257baa7">More...</a><br /></td></tr>
<tr class="separator:ac84df26d2ab345b08523b9cf3257baa7 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a8036e2c7f024a76f591ad02aeb3471b2">at</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as operator[] but always range-checked, even in a Release build.  <a href="classSimTK_1_1ArrayViewConst__.html#a8036e2c7f024a76f591ad02aeb3471b2">More...</a><br /></td></tr>
<tr class="separator:a8036e2c7f024a76f591ad02aeb3471b2 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aa636fb3c7cbfd76887e160dc0ec1e890">getElt</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> i) const</td></tr>
<tr class="memdesc:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed.  <a href="classSimTK_1_1ArrayViewConst__.html#aa636fb3c7cbfd76887e160dc0ec1e890">More...</a><br /></td></tr>
<tr class="separator:aa636fb3c7cbfd76887e160dc0ec1e890 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab831f9845265f592bf52958114494887">front</a> () const</td></tr>
<tr class="memdesc:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the first element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="classSimTK_1_1ArrayViewConst__.html#ab831f9845265f592bf52958114494887">More...</a><br /></td></tr>
<tr class="separator:ab831f9845265f592bf52958114494887 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ae57850a4310fb369b204da2540ae9edb">back</a> () const</td></tr>
<tr class="memdesc:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the last element in this array, which must not be empty (we'll check in a Debug build but not Release).  <a href="classSimTK_1_1ArrayViewConst__.html#ae57850a4310fb369b204da2540ae9edb">More...</a><br /></td></tr>
<tr class="separator:ae57850a4310fb369b204da2540ae9edb inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab4a2d86c2282fbc047e3146a30460f02">operator()</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> that refers only to those element (without copying).  <a href="classSimTK_1_1ArrayViewConst__.html#ab4a2d86c2282fbc047e3146a30460f02">More...</a><br /></td></tr>
<tr class="separator:ab4a2d86c2282fbc047e3146a30460f02 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a19d89ea9ad91ddb6f982897831457e42">getSubArray</a> (<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a> index, <a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> length) const</td></tr>
<tr class="memdesc:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as const form of operator()(index,length); exists to provide non-operator access to that functionality in case it is needed.  <a href="classSimTK_1_1ArrayViewConst__.html#a19d89ea9ad91ddb6f982897831457e42">More...</a><br /></td></tr>
<tr class="separator:a19d89ea9ad91ddb6f982897831457e42 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323">cbegin</a> () const</td></tr>
<tr class="memdesc:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>, which may be null (0) in that case but does not have to be.  <a href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323">More...</a><br /></td></tr>
<tr class="separator:a72a83af62f0ddb92cc78db7f850a8323 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451">cend</a> () const</td></tr>
<tr class="memdesc:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be.  <a href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451">More...</a><br /></td></tr>
<tr class="separator:ad843bb394725a89d7816d913bea0b451 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646">begin</a> () const</td></tr>
<tr class="memdesc:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646" title="The const version of begin() is the same as cbegin().">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a72a83af62f0ddb92cc78db7f850a8323" title="Return a const pointer to the first element of this array if any, otherwise cend(),...">cbegin()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a2d6a4981b1c67e18b935df7b7a6e0646">More...</a><br /></td></tr>
<tr class="separator:a2d6a4981b1c67e18b935df7b7a6e0646 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b">end</a> () const</td></tr>
<tr class="memdesc:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b" title="The const version of end() is the same as cend().">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ad843bb394725a89d7816d913bea0b451" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a54fe24e6874ca30b136c55c3922c453b">More...</a><br /></td></tr>
<tr class="separator:a54fe24e6874ca30b136c55c3922c453b inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059">crbegin</a> () const</td></tr>
<tr class="memdesc:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty.  <a href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059">More...</a><br /></td></tr>
<tr class="separator:aabb4e38eb132e33b043afc81a51bd059 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15">crend</a> () const</td></tr>
<tr class="memdesc:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array.  <a href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15">More...</a><br /></td></tr>
<tr class="separator:a81d79eb44677fdca99008b4f6200dd15 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9">rbegin</a> () const</td></tr>
<tr class="memdesc:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9" title="The const version of rbegin() is the same as crbegin().">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aabb4e38eb132e33b043afc81a51bd059" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#a84eb354267fd0c30ab868c67698f16b9">More...</a><br /></td></tr>
<tr class="separator:a84eb354267fd0c30ab868c67698f16b9 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab">rend</a> () const</td></tr>
<tr class="memdesc:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of <a class="el" href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab" title="The const version of rend() is the same as crend().">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayViewConst__.html#a81d79eb44677fdca99008b4f6200dd15" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#adfa4afc1fb5e2b95feab3becc4506aab">More...</a><br /></td></tr>
<tr class="separator:adfa4afc1fb5e2b95feab3becc4506aab inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108">cdata</a> () const</td></tr>
<tr class="memdesc:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty.  <a href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108">More...</a><br /></td></tr>
<tr class="separator:aed7e9bfee6bf3bd7c2f21b76c5436108 inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc">data</a> () const</td></tr>
<tr class="memdesc:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const version of the <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc" title="The const version of the data() method is identical to cdata().">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayViewConst__.html#aed7e9bfee6bf3bd7c2f21b76c5436108" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>.  <a href="classSimTK_1_1ArrayViewConst__.html#ab9a4e0b01b5d2da57bbad70cf4b535fc">More...</a><br /></td></tr>
<tr class="separator:ab9a4e0b01b5d2da57bbad70cf4b535fc inherit pub_methods_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:addfc86d8a0833c34bdeb0369a43a478a"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:addfc86d8a0833c34bdeb0369a43a478a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#addfc86d8a0833c34bdeb0369a43a478a">toXmlElement</a> (const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;thing, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:addfc86d8a0833c34bdeb0369a43a478a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> objects.  <a href="classSimTK_1_1ArrayView__.html#addfc86d8a0833c34bdeb0369a43a478a">More...</a><br /></td></tr>
<tr class="separator:addfc86d8a0833c34bdeb0369a43a478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Array_&lt;T&gt; serialization and I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are at namespace scope but are logically part of the Array classes.</p>
<p>These deal with reading and writing Arrays from and to streams, which places an additional requirement on the element type T: the element must support the same operation you are trying to do on the Array as a whole. </p>
</div></td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a2f916862f035a63e2406b6c47c57a2f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">readUnformatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:a2f916862f035a63e2406b6c47c57a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read.  <a href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3">More...</a><br /></td></tr>
<tr class="separator:a2f916862f035a63e2406b6c47c57a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:aa87616be589a0d76e0461c1d7c869e91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">readFormatted</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;v)</td></tr>
<tr class="memdesc:aa87616be589a0d76e0461c1d7c869e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView.">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array.  <a href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91">More...</a><br /></td></tr>
<tr class="separator:aa87616be589a0d76e0461c1d7c869e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a3c0c0d7769abbfe61b560361afe19f03"><td class="memTemplItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">fillArrayViewFromStream</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:a3c0c0d7769abbfe61b560361afe19f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a fixed number of elements from a stream into an ArrayView.  <a href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03">More...</a><br /></td></tr>
<tr class="separator:a3c0c0d7769abbfe61b560361afe19f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:acc7c28435897527058bfecae5e2f407a"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;out)</td></tr>
<tr class="memdesc:acc7c28435897527058bfecae5e2f407a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces.  <a href="classSimTK_1_1ArrayView__.html#acc7c28435897527058bfecae5e2f407a">More...</a><br /></td></tr>
<tr class="separator:acc7c28435897527058bfecae5e2f407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classSimTK_1_1ArrayViewConst__"><td colspan="2" onclick="javascript:toggleInherit('related_classSimTK_1_1ArrayViewConst__')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classSimTK_1_1ArrayViewConst__.html">SimTK::ArrayViewConst_&lt; T, X &gt;</a></td></tr>
<tr class="memitem:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memTemplParams" colspan="2">template&lt;class T , class X &gt; </td></tr>
<tr class="memitem:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a07b335c7df6083df174eb52e12c98f0e">toXmlElement</a> (const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T, X &gt; &amp;thing, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> objects.  <a href="classSimTK_1_1ArrayViewConst__.html#a07b335c7df6083df174eb52e12c98f0e">More...</a><br /></td></tr>
<tr class="separator:a07b335c7df6083df174eb52e12c98f0e inherit related_classSimTK_1_1ArrayViewConst__"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Size and capacity</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbd71f01ce73bf54e552955f1e1aa56bf"></a>These methods report the number of elements (size) or the amount of allocated heap space (capacity) or both but cannot be used to change size. </p>
</td></tr>
<tr class="memitem:a8ea9dee838be0641eaecfcd51683671f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size</a> () const</td></tr>
<tr class="separator:a8ea9dee838be0641eaecfcd51683671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215a3ff14686d94d053ecb9207974a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a215a3ff14686d94d053ecb9207974a58">max_size</a> () const</td></tr>
<tr class="separator:a215a3ff14686d94d053ecb9207974a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752461253da4daacbbfd1d864d5087e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a752461253da4daacbbfd1d864d5087e0">empty</a> () const</td></tr>
<tr class="separator:a752461253da4daacbbfd1d864d5087e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f99a02af36c8cf9507615c1b7ef640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a52f99a02af36c8cf9507615c1b7ef640">capacity</a> () const</td></tr>
<tr class="separator:a52f99a02af36c8cf9507615c1b7ef640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e7a0fba6f5e6196ce2b491b91379b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#ac7e7a0fba6f5e6196ce2b491b91379b0">allocated</a> () const</td></tr>
<tr class="separator:ac7e7a0fba6f5e6196ce2b491b91379b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc533c835c84c95085708279bb4be17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ArrayView__.html#a0dc533c835c84c95085708279bb4be17">isOwner</a> () const</td></tr>
<tr class="separator:a0dc533c835c84c95085708279bb4be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class X&gt;<br />
class SimTK::ArrayView_&lt; T, X &gt;</h3>

<p>This <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> helper class is the base class for <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>, extending <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a> to add the ability to modify elements, but not the ability to change size or reallocate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of object to be stored in this container. </td></tr>
    <tr><td class="paramname">X</td><td>The type to be used for indexing this container, with default unsigned (not size_t). Any integral type may be used, as well as user types that satisfy the requirements discussed with class <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>, <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="structSimTK_1_1ArrayIndexTraits.html" title="This templatized type is used by the Array_&lt;T,X&gt; classes to obtain the information they need to use t...">ArrayIndexTraits</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aeb29ff328a71341945e442234f50e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb29ff328a71341945e442234f50e253">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a39bda86e859db1597f4d49d8037d0660">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae79baa909a71d2f8c75b1120776ccca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79baa909a71d2f8c75b1120776ccca3">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3950fd72f5f77716f823f8c0a9a87974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3950fd72f5f77716f823f8c0a9a87974">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a2825bef320398cbf8d8f2e2b8631632e">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6e8dabb125276c7fcdaa215b23f808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e8dabb125276c7fcdaa215b23f808f">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a7fdc551f402dc69766e819733ee6f08b">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4b4b454ffabc27881011e3dcfea4014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b4b454ffabc27881011e3dcfea4014">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#aacce6f572b1deffcefa3f3aae5263b1c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a611de0d81f0e43b256704e817d63ae47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611de0d81f0e43b256704e817d63ae47">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a460302f601c4a2c2d63837cb1e5d875a">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6566e08689eb53ae89a2b000ed4a4140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6566e08689eb53ae89a2b000ed4a4140">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14185eed75d43f044775a366c02590c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14185eed75d43f044775a366c02590c0">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a704e9c961a4621efd1bfe21bf099ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704e9c961a4621efd1bfe21bf099ca77">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a416a8bff8ad197d4dfb2d41866acbd23">iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1232d267e9b8c139cca1512b412a6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1232d267e9b8c139cca1512b412a6d1">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a76215b9c0677fca5706f11038f496963">const_iterator</a>&gt; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6e901cbddbca41c54b22c6216ac804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e901cbddbca41c54b22c6216ac804b">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abad962ee7e4110ac6c20bdfa340f81dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad962ee7e4110ac6c20bdfa340f81dc">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structSimTK_1_1ArrayIndexTraits.html">ArrayIndexTraits</a>&lt;X&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#a1f604d5e70ddbe7eb0bf9a80a236951e">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9536141dcc61cfc646bb1f2062e5e558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9536141dcc61cfc646bb1f2062e5e558">&#9670;&nbsp;</a></span>packed_size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ArrayIndexPackType&lt;<a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayViewConst__.html#af01fd47de6bffe601337c1ef0a45e88d">packed_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa8e89ce2da1f241ae70e38cfe63ba980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e89ce2da1f241ae70e38cfe63ba980">&#9670;&nbsp;</a></span>ArrayView_() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor allocates no heap space and is very fast. </p>

</div>
</div>
<a id="ad1ddf75311833fc599a934c3f3d5a57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ddf75311833fc599a934c3f3d5a57d">&#9670;&nbsp;</a></span>ArrayView_() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is shallow. </p>

</div>
</div>
<a id="a8e6104f869055379b0fbd146aeefa919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6104f869055379b0fbd146aeefa919">&#9670;&nbsp;</a></span>ArrayView_() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a range of writable memory. </p>

</div>
</div>
<a id="a176653cfecc6ee9dd5cbb08f53725a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176653cfecc6ee9dd5cbb08f53725a34">&#9670;&nbsp;</a></span>ArrayView_() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct to reference memory owned by a writable std::vector. </p>

</div>
</div>
<a id="a509b38ff0b42a6ff6b38cd3b26f4096f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509b38ff0b42a6ff6b38cd3b26f4096f">&#9670;&nbsp;</a></span>~ArrayView_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::~<a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor just disconnects the array view handle from its data; see <a class="el" href="classSimTK_1_1ArrayViewConst__.html#ace600fbc0738888ceef29cc7c0846643" title="Disconnect this array handle from any data to which it refers, restoring it to the condition it would...">ArrayViewConst_&lt;T,X&gt;::disconnect()</a> for more information. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aed5b1cc7aa9e01c80acc744ede6407cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5b1cc7aa9e01c80acc744ede6407cc">&#9670;&nbsp;</a></span>operator const Array_&lt; T, X &gt; &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion of const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to const <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost). </p>

</div>
</div>
<a id="a6ef7f785e236628b37192a5380d0a479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef7f785e236628b37192a5380d0a479">&#9670;&nbsp;</a></span>operator Array_&lt; T, X &gt; &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T, X &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit conversion of non-const <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> to <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a>&amp; (zero cost). </p>

</div>
</div>
<a id="a7848acb2e30474663b3d708e80f2b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7848acb2e30474663b3d708e80f2b6bc">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward to base class <a class="el" href="classSimTK_1_1ArrayView__.html#a7848acb2e30474663b3d708e80f2b6bc" title="Forward to base class disconnect() method â€“ clears the handle without doing anything to the data.">disconnect()</a> method &ndash; clears the handle without doing anything to the data. </p>

</div>
</div>
<a id="a1a3e84580379c69d92ab24d96fa6c180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3e84580379c69d92ab24d96fa6c180">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment; source must be the same size as this array. </p>

</div>
</div>
<a id="a7f8826e1792377e63d47b9c9a3c53584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8826e1792377e63d47b9c9a3c53584">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayViewConst__.html">ArrayViewConst_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a id="acb5dc46e5a1126a8e30882e53a86c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5dc46e5a1126a8e30882e53a86c62d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a id="a45bc77b91b7751a909ca6524346c9e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bc77b91b7751a909ca6524346c9e8d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class T2 , class X2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Array__.html">Array_</a>&lt; T2, X2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any other array object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a id="a68daffa0f934e5f3d6f75adcb5d93367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68daffa0f934e5f3d6f75adcb5d93367">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class T2 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T2, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from any std::vector object is allowed as long as the number of elements matches and the types are assignment compatible. </p>

</div>
</div>
<a id="a29e6a21ecbf455765267d5d12bde8628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e6a21ecbf455765267d5d12bde8628">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill assignment &ndash; all elements are set to fillValue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> </dd></dl>

</div>
</div>
<a id="a1dbebca5377888478d004f882a6c24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbebca5377888478d004f882a6c24e2">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the supplied fill value to each element of this array, using T's copy assignment operator for each element. </p>
<p>Note that this also serves to allow fill from an object whose type T2 is different from T, as long as there is a constructor T(T2) that works since that can be invoked (implicitly or explicitly) to convert the T2 object to type T prior to the call. </p>

</div>
</div>
<a id="a06a7d28c5d7a0586b39260b4a167f10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a7d28c5d7a0586b39260b4a167f10c">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a1dbebca5377888478d004f882a6c24e2" title="Assign the supplied fill value to each element of this array, using T&#39;s copy assignment operator for ...">fill()</a> but has the usual std::vector signature for compatibility; it will only work if the given number of elements is the same as this array's (fixed) size. </p>

</div>
</div>
<a id="a39312ebedf1ce457f129b39c69d4515a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39312ebedf1ce457f129b39c69d4515a">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to make it a copy of the elements in range [first,last1) given by ordinary pointers, provided that the range is the same size as the array. </p>
<p>It is not allowed for the source range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a T=T2 assignment operator that works. Note that although the source arguments are pointers, those may be iterators for some container depending on implementation details of the container. Specifically, any <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>, or <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> iterator is an ordinary pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>A pointer to the first element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>A pointer to the element one past the last element to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1-first == <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The T=T2 assignment operator will be called exactly <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> times. </dd></dl>

</div>
</div>
<a id="afb5c2516d03bb21d24ea4e87af777136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5c2516d03bb21d24ea4e87af777136">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<div class="memtemplate">
template&lt;class Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iter &amp;&#160;</td>
          <td class="paramname"><em>last1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign to this array to make it a copy of the elements in range [first,last1) given by non-pointer iterators (the pointer case is handled with a specialized <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> variant). </p>
<p>It is not allowed for this range to include any of the elements currently in the array. The source elements can be of a type T2 that may be the same or different than this array's element type T as long as there is a T=T2 operator that works.</p>
<p>The source must have the same number of elements as the current (fixed) size of this ArrayView. For input_iterators we'll be happy if we get enough elements and won't insist that the input stream is empty after that. For forward_ and bidirectional_iterators we'll copy the elements and complain at the end if there are too few or too many. For random_access_iterators we'll check in advance since we can do that fast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>An iterator pointing to the first element to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>An iterator pointing to the element one past the last element to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This variant of <a class="el" href="classSimTK_1_1ArrayView__.html#a06a7d28c5d7a0586b39260b4a167f10c" title="This is the same as fill() but has the usual std::vector signature for compatibility; it will only wo...">assign()</a> will not be called when the iterators are forward iterators from <a class="el" href="classSimTK_1_1ArrayViewConst__.html" title="This Array_ helper class is the base class for ArrayView_ which is the base class for Array_; here we...">ArrayViewConst_</a>, <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a>, or <a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">Array_</a> objects since those are ordinary pointers.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>last1 is reachable from first </dd>
<dd>
distance(first,last1)==<a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>The T=T2 assignment operator will be called exactly <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> times. </dd></dl>

</div>
</div>
<a id="a8b61bbc4573a1ceb006a2ce00eb9b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b61bbc4573a1ceb006a2ce00eb9b1ee">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a const reference. </p>
<p>Note that only a value of the array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a943c9a87081523151ddbf1d22a853e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943c9a87081523151ddbf1d22a853e4e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select an element by its index, returning a writable (lvalue) reference. </p>
<p>Note that only a value of the Array's templatized index type is allowed (default is unsigned). This will be range-checked in a Debug build but not in Release. </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="aee4fb9c25420a0202ace54bf01a49a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4fb9c25420a0202ace54bf01a49a07">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<p><br  />
 </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="ab93f3650f5d31037f0051431eb02b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93f3650f5d31037f0051431eb02b57b">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as operator[] but always range-checked, even in a Release build. </p>
<p><br  />
 </p><dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="acf9b2cd521db0ae0b2b56bd8b0e8838f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9b2cd521db0ae0b2b56bd8b0e8838f">&#9670;&nbsp;</a></span>getElt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::getElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a id="a538c58736523ef56cafe9d926ec6e8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538c58736523ef56cafe9d926ec6e8f5">&#9670;&nbsp;</a></span>updElt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::updElt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the non-const form of operator[]; exists to provide a non-operator method for element access in case that's needed. </p>

</div>
</div>
<a id="ac05c55b3fe25b7cac1adb40415701cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05c55b3fe25b7cac1adb40415701cef">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="a1c3c26db7d7178a3e3c0b4603c7d0fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3c26db7d7178a3e3c0b4603c7d0fcd">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the first element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="aeb2342c3da808e5da540ea5eea430cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2342c3da808e5da540ea5eea430cce">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="abf707303e5e68fb5147fa36862c2bc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf707303e5e68fb5147fa36862c2bc57">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the last element in this array, which must not be empty. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The array is not empty. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant time. </dd></dl>

</div>
</div>
<a id="ab89285bb25b06bc6a1b53fca6e63e3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89285bb25b06bc6a1b53fca6e63e3b7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a contiguous subarray of the elements of this array and create another <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> that refers only to those element (without copying). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the first element to be included in the subarray; this can be one past the end of the array if <em>length</em> is zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of the subarray to be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new ArrayView_&lt;T,X&gt; object referencing the original data. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <em>length==0</em> the returned array will be in a default-constructed, all-zero and null state with no connection to the original data. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>index</em> &gt;= 0, <em>length</em> &gt;= 0 </dd>
<dd>
<em>index</em> + <em>length</em> &lt;= <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> </dd>
<dd>
We'll validate preconditions in Debug builds but not Release. </dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Dirt cheap; no element construction or destruction or heap allocation is required. </dd></dl>

</div>
</div>
<a id="a33b3799cc9d10a4e4a6781292f7bdc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3799cc9d10a4e4a6781292f7bdc15">&#9670;&nbsp;</a></span>updSubArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::updSubArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#af92bca96f3089b5f0d4133fce9c7cded">index_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as non-const operator()(index,length); exists to provide non-operator access to that functionality in case it is needed. </p>

</div>
</div>
<a id="acfd0054fa1b411aa09edeb85b5f994a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd0054fa1b411aa09edeb85b5f994a4">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a>, which may be null (0) in that case but does not have to be. </p>
<p>This method is from the C++11 standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a id="a0385a3a9743c8965c9a00f77db978339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385a3a9743c8965c9a00f77db978339">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4" title="Return a const pointer to the first element of this array if any, otherwise end(),...">cbegin()</a>. </p>

</div>
</div>
<a id="aa468711f19b67b25232650df6eeea608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa468711f19b67b25232650df6eeea608">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first element of this array if any, otherwise <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a>. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin()</a> == <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a> for an empty array. </p>

</div>
</div>
<a id="a854b4d187de22f6b7f2575ec16fb4fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854b4d187de22f6b7f2575ec16fb4fed">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to what would be the element just after the last one in the array; this may be null (0) if there are no elements but doesn't have to be. </p>
<p>This method is from the C++11 standard; there is also an overloaded <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a> from the original standard that returns a const pointer. </p>

</div>
</div>
<a id="ad86675d5260136d99f837c137ce01d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86675d5260136d99f837c137ce01d0c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a>. </p>

</div>
</div>
<a id="ace5b2a07f725b6e943d45ad786bf02cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5b2a07f725b6e943d45ad786bf02cb">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to what would be the element just after the last one in this array. </p>
<p>If the array is empty, this <em>may</em> return null (0) but does not have to &ndash; the only thing you can be sure of is that <a class="el" href="classSimTK_1_1ArrayView__.html#aa468711f19b67b25232650df6eeea608" title="Return a writable pointer to the first element of this array if any, otherwise end().">begin()</a>==<a class="el" href="classSimTK_1_1ArrayView__.html#ace5b2a07f725b6e943d45ad786bf02cb" title="Return a writable pointer to what would be the element just after the last one in this array.">end()</a> for an empty array. </p>

</div>
</div>
<a id="a2f7e8546725ca792aa315054f7c92f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7e8546725ca792aa315054f7c92f24">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a> if the array is empty. </p>

</div>
</div>
<a id="accfad5c666de9b4d50e4d68df3b3536b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfad5c666de9b4d50e4d68df3b3536b">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#add040a16da503b139f280a9e1a41c61d" title="Return a writable reverse iterator pointing to the last element in the array or rend() if the array i...">rbegin()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#a2f7e8546725ca792aa315054f7c92f24" title="Return a const reverse iterator pointing to the last element in the array or crend() if the array is ...">crbegin()</a>. </p>

</div>
</div>
<a id="add040a16da503b139f280a9e1a41c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add040a16da503b139f280a9e1a41c61d">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reverse iterator pointing to the last element in the array or <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> if the array is empty. </p>

</div>
</div>
<a id="acfee15eb401904198d43db394ebfa96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee15eb401904198d43db394ebfa96c">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a id="af3cda4c5af7c53c8ac0692a6ac19aa8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cda4c5af7c53c8ac0692a6ac19aa8d">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#ab26d002d51080ddd32f8899e5ea3ea40">const_reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of <a class="el" href="classSimTK_1_1ArrayView__.html#a70fe28b711d20b58b18f5ad1bce34145" title="Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been ...">rend()</a> is the same as <a class="el" href="classSimTK_1_1ArrayView__.html#acfee15eb401904198d43db394ebfa96c" title="Return the past-the-end reverse iterator that tests equal to a reverse iterator that has been increme...">crend()</a>. </p>

</div>
</div>
<a id="a70fe28b711d20b58b18f5ad1bce34145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fe28b711d20b58b18f5ad1bce34145">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#a4b566573f0b94c804a6b6e0514c78bce">reverse_iterator</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable past-the-end reverse iterator that tests equal to a reverse iterator that has been incremented past the front of the array. </p>
<p>You cannot dereference this iterator. </p>

</div>
</div>
<a id="ac454dc1045c20cd273cc5e4f317e9045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac454dc1045c20cd273cc5e4f317e9045">&#9670;&nbsp;</a></span>cdata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::cdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) if the array is empty. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a> is not in the C++11 standard although it would seem obvious in view of the <a class="el" href="classSimTK_1_1ArrayView__.html#acfd0054fa1b411aa09edeb85b5f994a4" title="Return a const pointer to the first element of this array if any, otherwise end(),...">cbegin()</a> and <a class="el" href="classSimTK_1_1ArrayView__.html#a854b4d187de22f6b7f2575ec16fb4fed" title="Return a const pointer to what would be the element just after the last one in the array; this may be...">cend()</a> methods that had to be added. The C++11 overloaded const <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is also available. </dd></dl>

</div>
</div>
<a id="a6dcad040471afe709b30a4aea6e021fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcad040471afe709b30a4aea6e021fb">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The const version of the <a class="el" href="classSimTK_1_1ArrayView__.html#a318481efdb8fd67f17e28e67cc8cce24" title="Return a writable pointer to the first allocated element of the array, or a null pointer if no space ...">data()</a> method is identical to <a class="el" href="classSimTK_1_1ArrayView__.html#ac454dc1045c20cd273cc5e4f317e9045" title="Return a const pointer to the first element of the array, or possibly (but not necessarily) null (0) ...">cdata()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the C++11 std::vector. </dd></dl>

</div>
</div>
<a id="a318481efdb8fd67f17e28e67cc8cce24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318481efdb8fd67f17e28e67cc8cce24">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable pointer to the first allocated element of the array, or a null pointer if no space is associated with the array. </p>
<dl class="section note"><dt>Note</dt><dd>This method is from the C++11 std::vector. </dd></dl>

</div>
</div>
<a id="a8ea9dee838be0641eaecfcd51683671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea9dee838be0641eaecfcd51683671f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a215a3ff14686d94d053ecb9207974a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215a3ff14686d94d053ecb9207974a58">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a752461253da4daacbbfd1d864d5087e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752461253da4daacbbfd1d864d5087e0">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f99a02af36c8cf9507615c1b7ef640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f99a02af36c8cf9507615c1b7ef640">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7e7a0fba6f5e6196ce2b491b91379b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e7a0fba6f5e6196ce2b491b91379b0">&#9670;&nbsp;</a></span>allocated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ArrayViewConst__.html#abaaff64afd3daaed43f1acecbe2bbfe7">size_type</a> <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dc533c835c84c95085708279bb4be17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc533c835c84c95085708279bb4be17">&#9670;&nbsp;</a></span>isOwner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ArrayView__.html">SimTK::ArrayView_</a>&lt; T, X &gt;::isOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2f916862f035a63e2406b6c47c57a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f916862f035a63e2406b6c47c57a2f3">&#9670;&nbsp;</a></span>readUnformatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readUnformatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#a2f916862f035a63e2406b6c47c57a2f3" title="Specialization of readUnformatted() for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated toke...">readUnformatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; reads whitespace-separated tokens until the expected number have been read. </p>
<p>If fewer are available we fail. </p>

</div>
</div>
<a id="aa87616be589a0d76e0461c1d7c869e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87616be589a0d76e0461c1d7c869e91">&#9670;&nbsp;</a></span>readFormatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readFormatted </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization of <a class="el" href="classSimTK_1_1ArrayView__.html#aa87616be589a0d76e0461c1d7c869e91" title="Specialization of readFormatted() for fixed-length ArrayView_&lt;T,X&gt;; uses fillArrayViewFromStream() to...">readFormatted()</a> for fixed-length ArrayView_&lt;T,X&gt;; uses <a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView.">fillArrayViewFromStream()</a> to consume an appropriately-formatted fixed-size array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ArrayView__.html#a3c0c0d7769abbfe61b560361afe19f03" title="Read in a fixed number of elements from a stream into an ArrayView.">fillArrayViewFromStream()</a> for details </dd></dl>

</div>
</div>
<a id="a3c0c0d7769abbfe61b560361afe19f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0c0d7769abbfe61b560361afe19f03">&#9670;&nbsp;</a></span>fillArrayViewFromStream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::istream &amp; fillArrayViewFromStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a fixed number of elements from a stream into an ArrayView. </p>
<p>See <a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array.">fillArrayFromStream()</a> for more information; this works the same way. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1Array__.html#a34546fb36b84171e76276a508121a3ce" title="Read in a fixed number of elements from a stream into an Array.">fillArrayFromStream()</a> </dd></dl>

</div>
</div>
<a id="acc7c28435897527058bfecae5e2f407a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7c28435897527058bfecae5e2f407a">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a (fixed size n) ArrayView_&lt;T&gt; from a stream as a sequence of space- or comma-separated values of type T, optionally delimited by parentheses, square brackets, or curly braces. </p>
<p>If there are no delimiters then we will read <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> values and then stop. Otherwise, there must be exactly <a class="el" href="classSimTK_1_1ArrayView__.html#a8ea9dee838be0641eaecfcd51683671f">size()</a> values within the brackets. Each element is read in with its own operator "&gt;&gt;" so this won't work if no such operator is defined for type T. </p>

</div>
</div>
<a id="addfc86d8a0833c34bdeb0369a43a478a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfc86d8a0833c34bdeb0369a43a478a">&#9670;&nbsp;</a></span>toXmlElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1Xml_1_1Element.html">Xml::Element</a> toXmlElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a>&lt; T, X &gt; &amp;&#160;</td>
          <td class="paramname"><em>thing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial specialization for XML serialization of <a class="el" href="classSimTK_1_1ArrayView__.html" title="This Array_ helper class is the base class for Array_, extending ArrayViewConst_ to add the ability t...">ArrayView_</a> objects. </p>
<p>The result is a single element with tag word <code>&lt;Array&gt;</code> with the given name (if any) and a version number as attributes. Then each entry is a subelement, as produced by type T's <code><a class="el" href="classSimTK_1_1ArrayView__.html#addfc86d8a0833c34bdeb0369a43a478a" title="Partial specialization for XML serialization of ArrayView_ objects.">toXmlElement()</a></code> method. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
<li><a class="el" href="Xml_8h_source.html">Xml.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ArrayView__.html">ArrayView_</a></li>
    <li class="footer">Generated on Sat May 17 2025 15:42:31 for Simbody by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
