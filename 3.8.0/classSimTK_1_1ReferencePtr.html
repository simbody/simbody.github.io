<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::ReferencePtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1ReferencePtr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSimTK_1_1ReferencePtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ReferencePtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a smart pointer that implements "cross reference" semantics where a pointer data member of some object is intended to refer to some target object in a larger data structure.  
 <a href="classSimTK_1_1ReferencePtr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acfa754609f3bd0da239932c1abe6393c"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#acfa754609f3bd0da239932c1abe6393c">element_type</a></td></tr>
<tr class="memdesc:acfa754609f3bd0da239932c1abe6393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the contained object.  <a href="classSimTK_1_1ReferencePtr.html#acfa754609f3bd0da239932c1abe6393c">More...</a><br /></td></tr>
<tr class="separator:acfa754609f3bd0da239932c1abe6393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc96cbd0f3977bc66c6b4dc85c904e71"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#afc96cbd0f3977bc66c6b4dc85c904e71">pointer</a></td></tr>
<tr class="memdesc:afc96cbd0f3977bc66c6b4dc85c904e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to the contained object.  <a href="classSimTK_1_1ReferencePtr.html#afc96cbd0f3977bc66c6b4dc85c904e71">More...</a><br /></td></tr>
<tr class="separator:afc96cbd0f3977bc66c6b4dc85c904e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bc2cf328cb84835e3cf13edb488e3c"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aa3bc2cf328cb84835e3cf13edb488e3c">reference</a></td></tr>
<tr class="memdesc:aa3bc2cf328cb84835e3cf13edb488e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a reference to the contained object.  <a href="classSimTK_1_1ReferencePtr.html#aa3bc2cf328cb84835e3cf13edb488e3c">More...</a><br /></td></tr>
<tr class="separator:aa3bc2cf328cb84835e3cf13edb488e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ae2bdaf492273c447c67e2a54315321ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ae2bdaf492273c447c67e2a54315321ec">ReferencePtr</a> () noexcept</td></tr>
<tr class="memdesc:ae2bdaf492273c447c67e2a54315321ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creates an empty object.  <a href="classSimTK_1_1ReferencePtr.html#ae2bdaf492273c447c67e2a54315321ec">More...</a><br /></td></tr>
<tr class="separator:ae2bdaf492273c447c67e2a54315321ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59984974e4d841998c08702b6260299e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a59984974e4d841998c08702b6260299e">ReferencePtr</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:a59984974e4d841998c08702b6260299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from <code>nullptr</code> is the same as the default constructor.  <a href="classSimTK_1_1ReferencePtr.html#a59984974e4d841998c08702b6260299e">More...</a><br /></td></tr>
<tr class="separator:a59984974e4d841998c08702b6260299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050648f040a4ba0c8bae7f0660f9112"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a3050648f040a4ba0c8bae7f0660f9112">ReferencePtr</a> (T *tp) noexcept</td></tr>
<tr class="memdesc:a3050648f040a4ba0c8bae7f0660f9112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a given pointer stores the pointer.  <a href="classSimTK_1_1ReferencePtr.html#a3050648f040a4ba0c8bae7f0660f9112">More...</a><br /></td></tr>
<tr class="separator:a3050648f040a4ba0c8bae7f0660f9112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f9177db63d86b95a98684ab2122996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a33f9177db63d86b95a98684ab2122996">ReferencePtr</a> (T &amp;t) noexcept</td></tr>
<tr class="memdesc:a33f9177db63d86b95a98684ab2122996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a reference stores the address of the supplied object.  <a href="classSimTK_1_1ReferencePtr.html#a33f9177db63d86b95a98684ab2122996">More...</a><br /></td></tr>
<tr class="separator:a33f9177db63d86b95a98684ab2122996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d391b7418e661aeb877492ad5ec1c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ac6d391b7418e661aeb877492ad5ec1c2">ReferencePtr</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ac6d391b7418e661aeb877492ad5ec1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor unconditionally sets the pointer to null; see class comments for why.  <a href="classSimTK_1_1ReferencePtr.html#ac6d391b7418e661aeb877492ad5ec1c2">More...</a><br /></td></tr>
<tr class="separator:ac6d391b7418e661aeb877492ad5ec1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b86aabde6e00931c0eeb7b5905881c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aa9b86aabde6e00931c0eeb7b5905881c">ReferencePtr</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aa9b86aabde6e00931c0eeb7b5905881c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor copies the pointer from the source and leaves the source empty.  <a href="classSimTK_1_1ReferencePtr.html#aa9b86aabde6e00931c0eeb7b5905881c">More...</a><br /></td></tr>
<tr class="separator:aa9b86aabde6e00931c0eeb7b5905881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a31d7efcd8e7226510abcc300d6d75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a24a31d7efcd8e7226510abcc300d6d75">ReferencePtr</a> (int mustBeZero) noexcept</td></tr>
<tr class="memdesc:a24a31d7efcd8e7226510abcc300d6d75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Use ReferencePtr(nullptr) or just ReferencePtr() instead.  <a href="classSimTK_1_1ReferencePtr.html#a24a31d7efcd8e7226510abcc300d6d75">More...</a><br /></td></tr>
<tr class="separator:a24a31d7efcd8e7226510abcc300d6d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr class="memitem:af3d4add3d2ecf211fcbf7c4fc86aa454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#af3d4add3d2ecf211fcbf7c4fc86aa454">operator=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;src) noexcept</td></tr>
<tr class="memdesc:af3d4add3d2ecf211fcbf7c4fc86aa454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment sets the pointer to nullptr (except for a self-assign); see class comments for why.  <a href="classSimTK_1_1ReferencePtr.html#af3d4add3d2ecf211fcbf7c4fc86aa454">More...</a><br /></td></tr>
<tr class="separator:af3d4add3d2ecf211fcbf7c4fc86aa454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea1af8416ba2de3316550fbcfaa7e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aceea1af8416ba2de3316550fbcfaa7e3">operator=</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aceea1af8416ba2de3316550fbcfaa7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment copies the pointer from the source and leaves the source empty.  <a href="classSimTK_1_1ReferencePtr.html#aceea1af8416ba2de3316550fbcfaa7e3">More...</a><br /></td></tr>
<tr class="separator:aceea1af8416ba2de3316550fbcfaa7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c73c3c9c0ac2c4e164412c8ce43b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ad6c73c3c9c0ac2c4e164412c8ce43b52">operator=</a> (T &amp;t) noexcept</td></tr>
<tr class="memdesc:ad6c73c3c9c0ac2c4e164412c8ce43b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the currently-referenced object by a reference to the source object; no destruction occurs.  <a href="classSimTK_1_1ReferencePtr.html#ad6c73c3c9c0ac2c4e164412c8ce43b52">More...</a><br /></td></tr>
<tr class="separator:ad6c73c3c9c0ac2c4e164412c8ce43b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b021e73ce47f057a810fa84d73742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a27b021e73ce47f057a810fa84d73742c">operator=</a> (T *tp) noexcept</td></tr>
<tr class="memdesc:a27b021e73ce47f057a810fa84d73742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This form of assignment replaces the current pointer with the given one; no destruction occurs.  <a href="classSimTK_1_1ReferencePtr.html#a27b021e73ce47f057a810fa84d73742c">More...</a><br /></td></tr>
<tr class="separator:a27b021e73ce47f057a810fa84d73742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr class="memitem:a826ac5f0aab7ddba25db4f7f12923b61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a826ac5f0aab7ddba25db4f7f12923b61">~ReferencePtr</a> () noexcept</td></tr>
<tr class="memdesc:a826ac5f0aab7ddba25db4f7f12923b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor does nothing.  <a href="classSimTK_1_1ReferencePtr.html#a826ac5f0aab7ddba25db4f7f12923b61">More...</a><br /></td></tr>
<tr class="separator:a826ac5f0aab7ddba25db4f7f12923b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr class="memitem:a2986f4b348bacba5b125285be348f0dc"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a2986f4b348bacba5b125285be348f0dc">get</a> () const noexcept</td></tr>
<tr class="memdesc:a2986f4b348bacba5b125285be348f0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contained pointer, or null if the container is empty.  <a href="classSimTK_1_1ReferencePtr.html#a2986f4b348bacba5b125285be348f0dc">More...</a><br /></td></tr>
<tr class="separator:a2986f4b348bacba5b125285be348f0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a30a58e680f4d953f8a2448fffc990"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ab4a30a58e680f4d953f8a2448fffc990">getRef</a> () const</td></tr>
<tr class="memdesc:ab4a30a58e680f4d953f8a2448fffc990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the target object.  <a href="classSimTK_1_1ReferencePtr.html#ab4a30a58e680f4d953f8a2448fffc990">More...</a><br /></td></tr>
<tr class="separator:ab4a30a58e680f4d953f8a2448fffc990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3aa165b00c4c48d69a5586af02e826"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aca3aa165b00c4c48d69a5586af02e826">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aca3aa165b00c4c48d69a5586af02e826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contained pointer.  <a href="classSimTK_1_1ReferencePtr.html#aca3aa165b00c4c48d69a5586af02e826">More...</a><br /></td></tr>
<tr class="separator:aca3aa165b00c4c48d69a5586af02e826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e5c8d6e14338c74810260e75a3f57d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a61e5c8d6e14338c74810260e75a3f57d">operator*</a> () const</td></tr>
<tr class="memdesc:a61e5c8d6e14338c74810260e75a3f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "dereference" operator returns a reference to the target object.  <a href="classSimTK_1_1ReferencePtr.html#a61e5c8d6e14338c74810260e75a3f57d">More...</a><br /></td></tr>
<tr class="separator:a61e5c8d6e14338c74810260e75a3f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Methods</div></td></tr>
<tr class="memitem:a109417146e900d08bdee1825cae83655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a109417146e900d08bdee1825cae83655">reset</a> (T *tp=nullptr) noexcept</td></tr>
<tr class="memdesc:a109417146e900d08bdee1825cae83655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the stored pointer with a different one; no destruction occurs.  <a href="classSimTK_1_1ReferencePtr.html#a109417146e900d08bdee1825cae83655">More...</a><br /></td></tr>
<tr class="separator:a109417146e900d08bdee1825cae83655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9649342a1d0fe16f9d922524431b2ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a9649342a1d0fe16f9d922524431b2ede">swap</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a9649342a1d0fe16f9d922524431b2ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this ReferencePtr with another one.  <a href="classSimTK_1_1ReferencePtr.html#a9649342a1d0fe16f9d922524431b2ede">More...</a><br /></td></tr>
<tr class="separator:a9649342a1d0fe16f9d922524431b2ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea47f61f7acda8f1066721823874725f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aea47f61f7acda8f1066721823874725f">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aea47f61f7acda8f1066721823874725f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this container is empty.  <a href="classSimTK_1_1ReferencePtr.html#aea47f61f7acda8f1066721823874725f">More...</a><br /></td></tr>
<tr class="separator:aea47f61f7acda8f1066721823874725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efc3a9126fb60065c14139dc9f22da2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a9efc3a9126fb60065c14139dc9f22da2">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a9efc3a9126fb60065c14139dc9f22da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a conversion to type bool that returns true if the container is non-null (that is, not empty).  <a href="classSimTK_1_1ReferencePtr.html#a9efc3a9126fb60065c14139dc9f22da2">More...</a><br /></td></tr>
<tr class="separator:a9efc3a9126fb60065c14139dc9f22da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4692ecdf481295126683d8e9aa868512"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a4692ecdf481295126683d8e9aa868512">release</a> () noexcept</td></tr>
<tr class="memdesc:a4692ecdf481295126683d8e9aa868512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the pointer from this container, leaving the container empty.  <a href="classSimTK_1_1ReferencePtr.html#a4692ecdf481295126683d8e9aa868512">More...</a><br /></td></tr>
<tr class="separator:a4692ecdf481295126683d8e9aa868512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da2f6b6149283fe6240098d56a94513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a4da2f6b6149283fe6240098d56a94513">clear</a> () noexcept</td></tr>
<tr class="memdesc:a4da2f6b6149283fe6240098d56a94513"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ReferencePtr.html#a109417146e900d08bdee1825cae83655" title="Replace the stored pointer with a different one; no destruction occurs.">reset()</a> instead.  <a href="classSimTK_1_1ReferencePtr.html#a4da2f6b6149283fe6240098d56a94513">More...</a><br /></td></tr>
<tr class="separator:a4da2f6b6149283fe6240098d56a94513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59227cca85e5bb61a8e9f55578c5c486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a59227cca85e5bb61a8e9f55578c5c486">operator T*</a> () const noexcept</td></tr>
<tr class="memdesc:a59227cca85e5bb61a8e9f55578c5c486"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ReferencePtr.html#a2986f4b348bacba5b125285be348f0dc" title="Return the contained pointer, or null if the container is empty.">get()</a> rather than implicit conversion from ReferencePtr&lt;T&gt; to T*.  <a href="classSimTK_1_1ReferencePtr.html#a59227cca85e5bb61a8e9f55578c5c486">More...</a><br /></td></tr>
<tr class="separator:a59227cca85e5bb61a8e9f55578c5c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:acb409621294e97c013f0d7cc1b6e7adf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb409621294e97c013f0d7cc1b6e7adf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#acb409621294e97c013f0d7cc1b6e7adf">swap</a> (<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;p1, <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;p2) noexcept</td></tr>
<tr class="memdesc:acb409621294e97c013f0d7cc1b6e7adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ReferencePtr.html#a9649342a1d0fe16f9d922524431b2ede" title="Swap the contents of this ReferencePtr with another one.">swap()</a> member of the <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> class.  <a href="classSimTK_1_1ReferencePtr.html#acb409621294e97c013f0d7cc1b6e7adf">More...</a><br /></td></tr>
<tr class="separator:acb409621294e97c013f0d7cc1b6e7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd6fe99743f7d5742f5062b17dddf4"><td class="memTemplParams" colspan="2">template&lt;class charT , class traits , class T &gt; </td></tr>
<tr class="memitem:a48fd6fe99743f7d5742f5062b17dddf4"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a48fd6fe99743f7d5742f5062b17dddf4">operator&lt;&lt;</a> (std::basic_ostream&lt; charT, traits &gt; &amp;os, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a48fd6fe99743f7d5742f5062b17dddf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> object.  <a href="classSimTK_1_1ReferencePtr.html#a48fd6fe99743f7d5742f5062b17dddf4">More...</a><br /></td></tr>
<tr class="separator:a48fd6fe99743f7d5742f5062b17dddf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db615685bd43a4a65f5c74e04a8543b"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a9db615685bd43a4a65f5c74e04a8543b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a9db615685bd43a4a65f5c74e04a8543b">operator==</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9db615685bd43a4a65f5c74e04a8543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> containers.  <a href="classSimTK_1_1ReferencePtr.html#a9db615685bd43a4a65f5c74e04a8543b">More...</a><br /></td></tr>
<tr class="separator:a9db615685bd43a4a65f5c74e04a8543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d869abbd5b22e5dedcfb74522dc62f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d869abbd5b22e5dedcfb74522dc62f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a3d869abbd5b22e5dedcfb74522dc62f8">operator==</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a3d869abbd5b22e5dedcfb74522dc62f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>.  <a href="classSimTK_1_1ReferencePtr.html#a3d869abbd5b22e5dedcfb74522dc62f8">More...</a><br /></td></tr>
<tr class="separator:a3d869abbd5b22e5dedcfb74522dc62f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93ab6bbec7fe9639bcb2a21e35faeee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af93ab6bbec7fe9639bcb2a21e35faeee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#af93ab6bbec7fe9639bcb2a21e35faeee">operator==</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af93ab6bbec7fe9639bcb2a21e35faeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>.  <a href="classSimTK_1_1ReferencePtr.html#af93ab6bbec7fe9639bcb2a21e35faeee">More...</a><br /></td></tr>
<tr class="separator:af93ab6bbec7fe9639bcb2a21e35faeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21de858728673d9b2ad5a13d16968834"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a21de858728673d9b2ad5a13d16968834"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a21de858728673d9b2ad5a13d16968834">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a21de858728673d9b2ad5a13d16968834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator for two compatible <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to.  <a href="classSimTK_1_1ReferencePtr.html#a21de858728673d9b2ad5a13d16968834">More...</a><br /></td></tr>
<tr class="separator:a21de858728673d9b2ad5a13d16968834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b0d4707df6ab0234cde92083f0c9a9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a26b0d4707df6ab0234cde92083f0c9a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a26b0d4707df6ab0234cde92083f0c9a9">operator&lt;</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a26b0d4707df6ab0234cde92083f0c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison against a <code>nullptr</code>.  <a href="classSimTK_1_1ReferencePtr.html#a26b0d4707df6ab0234cde92083f0c9a9">More...</a><br /></td></tr>
<tr class="separator:a26b0d4707df6ab0234cde92083f0c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edf98850fbf672950758702ac4ab5a2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2edf98850fbf672950758702ac4ab5a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a2edf98850fbf672950758702ac4ab5a2">operator&lt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2edf98850fbf672950758702ac4ab5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison of a <code>nullptr</code> against this container.  <a href="classSimTK_1_1ReferencePtr.html#a2edf98850fbf672950758702ac4ab5a2">More...</a><br /></td></tr>
<tr class="separator:a2edf98850fbf672950758702ac4ab5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c9712f3167ff67fa367979f6351852"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a51c9712f3167ff67fa367979f6351852"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a51c9712f3167ff67fa367979f6351852">operator!=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a51c9712f3167ff67fa367979f6351852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer inequality test defined as <code>!(lhs==rhs)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a51c9712f3167ff67fa367979f6351852">More...</a><br /></td></tr>
<tr class="separator:a51c9712f3167ff67fa367979f6351852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d51c050687bb5644e31e8a344ceca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a463d51c050687bb5644e31e8a344ceca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a463d51c050687bb5644e31e8a344ceca">operator!=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a463d51c050687bb5644e31e8a344ceca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a463d51c050687bb5644e31e8a344ceca">More...</a><br /></td></tr>
<tr class="separator:a463d51c050687bb5644e31e8a344ceca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7077576a15f7b68c3aef13150611196a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7077576a15f7b68c3aef13150611196a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a7077576a15f7b68c3aef13150611196a">operator!=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7077576a15f7b68c3aef13150611196a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a7077576a15f7b68c3aef13150611196a">More...</a><br /></td></tr>
<tr class="separator:a7077576a15f7b68c3aef13150611196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262ea6d7707bbd62395b7c8405123618"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a262ea6d7707bbd62395b7c8405123618"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a262ea6d7707bbd62395b7c8405123618">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a262ea6d7707bbd62395b7c8405123618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-than test defined as <code>rhs &lt; lhs</code>.  <a href="classSimTK_1_1ReferencePtr.html#a262ea6d7707bbd62395b7c8405123618">More...</a><br /></td></tr>
<tr class="separator:a262ea6d7707bbd62395b7c8405123618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81fe3a4c0c229992824421d88dea25c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa81fe3a4c0c229992824421d88dea25c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#aa81fe3a4c0c229992824421d88dea25c">operator&gt;</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:aa81fe3a4c0c229992824421d88dea25c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>.  <a href="classSimTK_1_1ReferencePtr.html#aa81fe3a4c0c229992824421d88dea25c">More...</a><br /></td></tr>
<tr class="separator:aa81fe3a4c0c229992824421d88dea25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b911e1cfecd7fdfa268eb01a0f8fcb5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7b911e1cfecd7fdfa268eb01a0f8fcb5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a7b911e1cfecd7fdfa268eb01a0f8fcb5">operator&gt;</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7b911e1cfecd7fdfa268eb01a0f8fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>.  <a href="classSimTK_1_1ReferencePtr.html#a7b911e1cfecd7fdfa268eb01a0f8fcb5">More...</a><br /></td></tr>
<tr class="separator:a7b911e1cfecd7fdfa268eb01a0f8fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aef7c1b969255322c86628f7d903f39"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1aef7c1b969255322c86628f7d903f39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a1aef7c1b969255322c86628f7d903f39">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1aef7c1b969255322c86628f7d903f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a1aef7c1b969255322c86628f7d903f39">More...</a><br /></td></tr>
<tr class="separator:a1aef7c1b969255322c86628f7d903f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d838b1365b90f8c61a9dd2f5825249d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d838b1365b90f8c61a9dd2f5825249d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a5d838b1365b90f8c61a9dd2f5825249d">operator&gt;=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a5d838b1365b90f8c61a9dd2f5825249d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a5d838b1365b90f8c61a9dd2f5825249d">More...</a><br /></td></tr>
<tr class="separator:a5d838b1365b90f8c61a9dd2f5825249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f68e72a3b62e1256af3d0f9aa9869e8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f68e72a3b62e1256af3d0f9aa9869e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a7f68e72a3b62e1256af3d0f9aa9869e8">operator&gt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a7f68e72a3b62e1256af3d0f9aa9869e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>.  <a href="classSimTK_1_1ReferencePtr.html#a7f68e72a3b62e1256af3d0f9aa9869e8">More...</a><br /></td></tr>
<tr class="separator:a7f68e72a3b62e1256af3d0f9aa9869e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48cb39c807b3c4aa341ab25cd64a8be"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ac48cb39c807b3c4aa341ab25cd64a8be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#ac48cb39c807b3c4aa341ab25cd64a8be">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ac48cb39c807b3c4aa341ab25cd64a8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments).  <a href="classSimTK_1_1ReferencePtr.html#ac48cb39c807b3c4aa341ab25cd64a8be">More...</a><br /></td></tr>
<tr class="separator:ac48cb39c807b3c4aa341ab25cd64a8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a378f341a5b205294aa8b272e365b37"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4a378f341a5b205294aa8b272e365b37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a4a378f341a5b205294aa8b272e365b37">operator&lt;=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t)</td></tr>
<tr class="memdesc:a4a378f341a5b205294aa8b272e365b37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments).  <a href="classSimTK_1_1ReferencePtr.html#a4a378f341a5b205294aa8b272e365b37">More...</a><br /></td></tr>
<tr class="separator:a4a378f341a5b205294aa8b272e365b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6adc772d4cf4acaa1ab69465db5faf1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af6adc772d4cf4acaa1ab69465db5faf1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#af6adc772d4cf4acaa1ab69465db5faf1">operator&lt;=</a> (std::nullptr_t, const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:af6adc772d4cf4acaa1ab69465db5faf1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments).  <a href="classSimTK_1_1ReferencePtr.html#af6adc772d4cf4acaa1ab69465db5faf1">More...</a><br /></td></tr>
<tr class="separator:af6adc772d4cf4acaa1ab69465db5faf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2030863f077661630affff8cb73e97e7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2030863f077661630affff8cb73e97e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ReferencePtr.html#a2030863f077661630affff8cb73e97e7">operator!=</a> (const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;lhs, int mustBeZero)</td></tr>
<tr class="memdesc:a2030863f077661630affff8cb73e97e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>(Deprecated)</b> Use <code>nullptr</code> instead of <code>0</code>.  <a href="classSimTK_1_1ReferencePtr.html#a2030863f077661630affff8cb73e97e7">More...</a><br /></td></tr>
<tr class="separator:a2030863f077661630affff8cb73e97e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class SimTK::ReferencePtr&lt; T &gt;</h3>

<p>This is a smart pointer that implements "cross reference" semantics where a pointer data member of some object is intended to refer to some target object in a larger data structure. </p>
<p>Judicious use of this container will allow you to use compiler-generated copy constructors and copy assignment operators for classes which would otherwise have to implement their own in order to properly initialize these pointer data members, which must not be copied.</p>
<p>The contained pointer is initialized to <code>nullptr</code> on construction, and it is reinitialized to null upon copy construction or copy assignment. That's because we are assuming this is part of copying the entire data structure and copying the old pointer would create a reference into the old data structure rather than the new copy. This pointer does not own the target to which it points, and there is no reference counting so it will become stale if the target is deleted.</p>
<p>The pointer <em>is</em> moved intact for move construction or move assignment. That allows <code>std::vector&lt;<a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a>&lt;T&gt;&gt;</code> or <code><a class="el" href="classSimTK_1_1Array__.html" title="The Array_&lt;T&gt; container class is a plug-compatible replacement for the C++ standard template library ...">SimTK::Array_</a>&lt;<a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a>&lt;T&gt;&gt;</code> to behave properly when their contents have to be moved for expansion.</p>
<p>Whether you can write through the pointer is controlled by whether type T is a const type. For example ReferencePtr&lt;int&gt; is equivalent to an int*, while ReferencePtr&lt;const int&gt; is equivalent to a const int*.</p>
<p>This class is entirely inline and has no computational or space overhead; it contains just a single pointer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSimTK_1_1ClonePtr.html" title="Smart pointer with deep copy semantics.">ClonePtr</a>, <a class="el" href="classSimTK_1_1CloneOnWritePtr.html" title="Smart pointer with deep copy semantics but with the copying delayed until an attempt is made to write...">CloneOnWritePtr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acfa754609f3bd0da239932c1abe6393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa754609f3bd0da239932c1abe6393c">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#acfa754609f3bd0da239932c1abe6393c">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the contained object. </p>

</div>
</div>
<a id="afc96cbd0f3977bc66c6b4dc85c904e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc96cbd0f3977bc66c6b4dc85c904e71">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#afc96cbd0f3977bc66c6b4dc85c904e71">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a pointer to the contained object. </p>

</div>
</div>
<a id="aa3bc2cf328cb84835e3cf13edb488e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bc2cf328cb84835e3cf13edb488e3c">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html#aa3bc2cf328cb84835e3cf13edb488e3c">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of a reference to the contained object. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae2bdaf492273c447c67e2a54315321ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bdaf492273c447c67e2a54315321ec">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates an empty object. </p>

</div>
</div>
<a id="a59984974e4d841998c08702b6260299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59984974e4d841998c08702b6260299e">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from <code>nullptr</code> is the same as the default constructor. </p>
<p>This is an implicit conversion that allows <code>nullptr</code> to be used to initialize a ReferencePtr. </p>

</div>
</div>
<a id="a3050648f040a4ba0c8bae7f0660f9112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3050648f040a4ba0c8bae7f0660f9112">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a given pointer stores the pointer. </p>

</div>
</div>
<a id="a33f9177db63d86b95a98684ab2122996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f9177db63d86b95a98684ab2122996">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a reference stores the address of the supplied object. </p>

</div>
</div>
<a id="ac6d391b7418e661aeb877492ad5ec1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d391b7418e661aeb877492ad5ec1c2">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor unconditionally sets the pointer to null; see class comments for why. </p>

</div>
</div>
<a id="aa9b86aabde6e00931c0eeb7b5905881c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b86aabde6e00931c0eeb7b5905881c">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor copies the pointer from the source and leaves the source empty. </p>

</div>
</div>
<a id="a24a31d7efcd8e7226510abcc300d6d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a31d7efcd8e7226510abcc300d6d75">&#9670;&nbsp;</a></span>ReferencePtr() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mustBeZero</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Use ReferencePtr(nullptr) or just ReferencePtr() instead. </p>
<p>For backwards compatibility, this allows initialization by "0" rather than <code>nullptr</code>. </p>

</div>
</div>
<a id="a826ac5f0aab7ddba25db4f7f12923b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826ac5f0aab7ddba25db4f7f12923b61">&#9670;&nbsp;</a></span>~ReferencePtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::~<a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor does nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3d4add3d2ecf211fcbf7c4fc86aa454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d4add3d2ecf211fcbf7c4fc86aa454">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment sets the pointer to nullptr (except for a self-assign); see class comments for why. </p>
<p><br  />
 </p>

</div>
</div>
<a id="aceea1af8416ba2de3316550fbcfaa7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceea1af8416ba2de3316550fbcfaa7e3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment copies the pointer from the source and leaves the source empty. </p>
<p>Nothing happens for self-assign. </p>

</div>
</div>
<a id="ad6c73c3c9c0ac2c4e164412c8ce43b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c73c3c9c0ac2c4e164412c8ce43b52">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the currently-referenced object by a reference to the source object; no destruction occurs. </p>

</div>
</div>
<a id="a27b021e73ce47f057a810fa84d73742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b021e73ce47f057a810fa84d73742c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This form of assignment replaces the current pointer with the given one; no destruction occurs. </p>

</div>
</div>
<a id="a2986f4b348bacba5b125285be348f0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2986f4b348bacba5b125285be348f0dc">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contained pointer, or null if the container is empty. </p>

</div>
</div>
<a id="ab4a30a58e680f4d953f8a2448fffc990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a30a58e680f4d953f8a2448fffc990">&#9670;&nbsp;</a></span>getRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::getRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the target object. </p>
<p>Fails if the pointer is null. </p>

</div>
</div>
<a id="aca3aa165b00c4c48d69a5586af02e826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3aa165b00c4c48d69a5586af02e826">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contained pointer. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="a61e5c8d6e14338c74810260e75a3f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e5c8d6e14338c74810260e75a3f57d">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The "dereference" operator returns a reference to the target object. </p>
<p>This will fail if the container is empty. </p>

</div>
</div>
<a id="a109417146e900d08bdee1825cae83655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109417146e900d08bdee1825cae83655">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tp</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the stored pointer with a different one; no destruction occurs. </p>

</div>
</div>
<a id="a9649342a1d0fe16f9d922524431b2ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9649342a1d0fe16f9d922524431b2ede">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the contents of this ReferencePtr with another one. </p>
<p>This is very fast. </p>

</div>
</div>
<a id="aea47f61f7acda8f1066721823874725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea47f61f7acda8f1066721823874725f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this container is empty. </p>

</div>
</div>
<a id="a9efc3a9126fb60065c14139dc9f22da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efc3a9126fb60065c14139dc9f22da2">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a conversion to type bool that returns true if the container is non-null (that is, not empty). </p>

</div>
</div>
<a id="a4692ecdf481295126683d8e9aa868512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4692ecdf481295126683d8e9aa868512">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the pointer from this container, leaving the container empty. </p>
<p>The pointer is returned. </p>

</div>
</div>
<a id="a4da2f6b6149283fe6240098d56a94513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da2f6b6149283fe6240098d56a94513">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ReferencePtr.html#a109417146e900d08bdee1825cae83655" title="Replace the stored pointer with a different one; no destruction occurs.">reset()</a> instead. </p>

</div>
</div>
<a id="a59227cca85e5bb61a8e9f55578c5c486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59227cca85e5bb61a8e9f55578c5c486">&#9670;&nbsp;</a></span>operator T*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ReferencePtr.html">SimTK::ReferencePtr</a>&lt; T &gt;::operator T* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Use <a class="el" href="classSimTK_1_1ReferencePtr.html#a2986f4b348bacba5b125285be348f0dc" title="Return the contained pointer, or null if the container is empty.">get()</a> rather than implicit conversion from ReferencePtr&lt;T&gt; to T*. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="acb409621294e97c013f0d7cc1b6e7adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb409621294e97c013f0d7cc1b6e7adf">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overload of the STL std::swap() algorithm which uses the cheap built-in <a class="el" href="classSimTK_1_1ReferencePtr.html#a9649342a1d0fe16f9d922524431b2ede" title="Swap the contents of this ReferencePtr with another one.">swap()</a> member of the <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> class. </p>
<p>(This function is defined in the <code><a class="el" href="namespaceSimTK.html" title="This is the top-level SimTK namespace into which all SimTK names are placed to avoid collision with o...">SimTK</a></code> namespace.) </p>

</div>
</div>
<a id="a48fd6fe99743f7d5742f5062b17dddf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd6fe99743f7d5742f5062b17dddf4">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class charT , class traits , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; charT, traits &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; charT, traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the system-dependent representation of the pointer contained in a <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> object. </p>
<p>This is equivalent to <code>os &lt;&lt; p.get();</code>. </p>

</div>
</div>
<a id="a9db615685bd43a4a65f5c74e04a8543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db615685bd43a4a65f5c74e04a8543b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for equality the managed pointers contained in two compatible <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> containers. </p>
<p>Returns <code>true</code> if the pointers refer to the same object or if both are null. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a id="a3d869abbd5b22e5dedcfb74522dc62f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d869abbd5b22e5dedcfb74522dc62f8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>lhs.empty()</code>. </p>

</div>
</div>
<a id="af93ab6bbec7fe9639bcb2a21e35faeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93ab6bbec7fe9639bcb2a21e35faeee">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison against <code>nullptr</code>; same as <code>rhs.empty()</code>. </p>

</div>
</div>
<a id="a21de858728673d9b2ad5a13d16968834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21de858728673d9b2ad5a13d16968834">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator for two compatible <a class="el" href="classSimTK_1_1ReferencePtr.html" title="This is a smart pointer that implements &quot;cross reference&quot; semantics where a pointer data member of so...">ReferencePtr</a> containers, comparing the <em>pointers</em>, not the <em>objects</em> they point to. </p>
<p>Returns <code>true</code> if the lhs pointer tests less than the rhs pointer. A null pointer tests less than any non-null pointer. It must be possible for one of the pointer types <code>T*</code> and <code>U*</code> to be implicitly converted to the other. </p>

</div>
</div>
<a id="a26b0d4707df6ab0234cde92083f0c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b0d4707df6ab0234cde92083f0c9a9">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison against a <code>nullptr</code>. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method always returns <code>false</code>. </p>

</div>
</div>
<a id="a2edf98850fbf672950758702ac4ab5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edf98850fbf672950758702ac4ab5a2">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than comparison of a <code>nullptr</code> against this container. </p>
<p>A null pointer tests less than any non-null pointer and equal to another null pointer, so this method returns <code>true</code> unless the container is empty. </p>

</div>
</div>
<a id="a51c9712f3167ff67fa367979f6351852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c9712f3167ff67fa367979f6351852">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer inequality test defined as <code>!(lhs==rhs)</code>. </p>

</div>
</div>
<a id="a463d51c050687bb5644e31e8a344ceca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463d51c050687bb5644e31e8a344ceca">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(lhs==nullptr)</code>. </p>

</div>
</div>
<a id="a7077576a15f7b68c3aef13150611196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7077576a15f7b68c3aef13150611196a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> inequality test defined as <code>!(nullptr==rhs)</code>. </p>

</div>
</div>
<a id="a262ea6d7707bbd62395b7c8405123618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262ea6d7707bbd62395b7c8405123618">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-than test defined as <code>rhs &lt; lhs</code>. </p>

</div>
</div>
<a id="aa81fe3a4c0c229992824421d88dea25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81fe3a4c0c229992824421d88dea25c">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>nullptr &lt; lhs</code>. </p>

</div>
</div>
<a id="a7b911e1cfecd7fdfa268eb01a0f8fcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b911e1cfecd7fdfa268eb01a0f8fcb5">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-than test defined as <code>rhs &lt; nullptr</code>. </p>

</div>
</div>
<a id="a1aef7c1b969255322c86628f7d903f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aef7c1b969255322c86628f7d903f39">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer greater-or-equal test defined as <code>!(lhs &lt; rhs)</code>. </p>

</div>
</div>
<a id="a5d838b1365b90f8c61a9dd2f5825249d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d838b1365b90f8c61a9dd2f5825249d">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(lhs &lt; nullptr)</code>. </p>

</div>
</div>
<a id="a7f68e72a3b62e1256af3d0f9aa9869e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f68e72a3b62e1256af3d0f9aa9869e8">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> greater-or-equal test defined as <code>!(nullptr &lt; rhs)</code>. </p>

</div>
</div>
<a id="ac48cb39c807b3c4aa341ab25cd64a8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48cb39c807b3c4aa341ab25cd64a8be">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer less-or-equal test defined as <code>!(rhs &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a id="a4a378f341a5b205294aa8b272e365b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a378f341a5b205294aa8b272e365b37">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(nullptr &lt; lhs)</code> (note reversed arguments). </p>

</div>
</div>
<a id="af6adc772d4cf4acaa1ab69465db5faf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6adc772d4cf4acaa1ab69465db5faf1">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>nullptr</code> less-or-equal test defined as <code>!(rhs &lt; nullptr)</code> (note reversed arguments). </p>

</div>
</div>
<a id="a2030863f077661630affff8cb73e97e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2030863f077661630affff8cb73e97e7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mustBeZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>(Deprecated)</b> Use <code>nullptr</code> instead of <code>0</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ReferencePtr_8h_source.html">ReferencePtr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ReferencePtr.html">ReferencePtr</a></li>
    <li class="footer">Generated on Sat May 17 2025 15:42:31 for Simbody by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
