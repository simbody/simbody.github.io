<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simbody: SimTK::ContactGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Simbody
   &#160;<span id="projectnumber">3.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSimTK_1_1ContactGeometry.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSimTK_1_1ContactGeometry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SimTK::ContactGeometry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> object describes the shape of all or part of the boundary of a solid object, for the purpose of modeling with Simbody physical effects that occur at the surface of that object, such as contact and wrapping forces.  
 <a href="classSimTK_1_1ContactGeometry.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for SimTK::ContactGeometry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classSimTK_1_1ContactGeometry.png" usemap="#SimTK::ContactGeometry_map" alt=""/>
  <map id="SimTK::ContactGeometry_map" name="SimTK::ContactGeometry_map">
<area href="classSimTK_1_1ContactGeometry_1_1Brick.html" title="This ContactGeometry subclass represents a rectangular solid centered at the origin." alt="SimTK::ContactGeometry::Brick" shape="rect" coords="268,56,526,80"/>
<area href="classSimTK_1_1ContactGeometry_1_1Cylinder.html" title="This ContactGeometry subclass represents a cylinder centered at the origin, with radius r in the x-y ..." alt="SimTK::ContactGeometry::Cylinder" shape="rect" coords="268,112,526,136"/>
<area href="classSimTK_1_1ContactGeometry_1_1Ellipsoid.html" title="This ContactGeometry subclass represents an ellipsoid centered at the origin, with its principal axes..." alt="SimTK::ContactGeometry::Ellipsoid" shape="rect" coords="268,168,526,192"/>
<area href="classSimTK_1_1ContactGeometry_1_1HalfSpace.html" title="This ContactGeometry subclass represents an object that occupies the entire half-space x&gt;0." alt="SimTK::ContactGeometry::HalfSpace" shape="rect" coords="268,224,526,248"/>
<area href="classSimTK_1_1ContactGeometry_1_1SmoothHeightMap.html" title="This ContactGeometry subclass represents a smooth surface fit through a set of sampled points using b..." alt="SimTK::ContactGeometry::SmoothHeightMap" shape="rect" coords="268,280,526,304"/>
<area href="classSimTK_1_1ContactGeometry_1_1Sphere.html" title="This ContactGeometry subclass represents a sphere centered at the origin." alt="SimTK::ContactGeometry::Sphere" shape="rect" coords="268,336,526,360"/>
<area href="classSimTK_1_1ContactGeometry_1_1Torus.html" title="This ContactGeometry subclass represents a torus centered at the origin with the axial direction alig..." alt="SimTK::ContactGeometry::Torus" shape="rect" coords="268,392,526,416"/>
<area href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html" title="This ContactGeometry subclass represents an arbitrary shape described by a mesh of triangular faces." alt="SimTK::ContactGeometry::TriangleMesh" shape="rect" coords="268,448,526,472"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1Brick.html">Brick</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents a rectangular solid centered at the origin.  <a href="classSimTK_1_1ContactGeometry_1_1Brick.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1Cylinder.html">Cylinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents a cylinder centered at the origin, with radius r in the x-y plane, and infinite length along z.  <a href="classSimTK_1_1ContactGeometry_1_1Cylinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1Ellipsoid.html">Ellipsoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents an ellipsoid centered at the origin, with its principal axes pointing along the x, y, and z axes and half dimensions a,b, and c (all &gt; 0) along those axes, respectively.  <a href="classSimTK_1_1ContactGeometry_1_1Ellipsoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html">GeodesicKnotPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The state of a geodesic at a (knot) point along the geodesic.  <a href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1HalfSpace.html">HalfSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents an object that occupies the entire half-space x&gt;0.  <a href="classSimTK_1_1ContactGeometry_1_1HalfSpace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1SmoothHeightMap.html">SmoothHeightMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents a smooth surface fit through a set of sampled points using bicubic patches to provide C2 continuity.  <a href="classSimTK_1_1ContactGeometry_1_1SmoothHeightMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1Sphere.html">Sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents a sphere centered at the origin.  <a href="classSimTK_1_1ContactGeometry_1_1Sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1Torus.html">Torus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents a torus centered at the origin with the axial direction aligned to the z-axis.  <a href="classSimTK_1_1ContactGeometry_1_1Torus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html">TriangleMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> subclass represents an arbitrary shape described by a mesh of triangular faces.  <a href="classSimTK_1_1ContactGeometry_1_1TriangleMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a791b5ea965151a689f6f071163b043a3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3">NearestPointOnLineResult</a> { <br />
&#160;&#160;<a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3ada5418b1eb4e80d05f2c1c7c4fa1b6ec">Converged</a>
, <br />
&#160;&#160;<a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3a005f9fae8e493a652536060c5f49636c">MaxIterationsExceeded</a>
, <br />
&#160;&#160;<a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3a92a75622947060f4ca29b4b06ffd6946">PointFallsBelowSurface</a>
<br />
 }</td></tr>
<tr class="memdesc:a791b5ea965151a689f6f071163b043a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit flag returned by calcNearestPointOnLineImplicitly.  <a href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3">More...</a><br /></td></tr>
<tr class="separator:a791b5ea965151a689f6f071163b043a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8fb7742035ba957d61c9e1b96379eb2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a8fb7742035ba957d61c9e1b96379eb2c">ContactGeometry</a> ()</td></tr>
<tr class="memdesc:a8fb7742035ba957d61c9e1b96379eb2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class default constructor creates an empty handle.  <a href="classSimTK_1_1ContactGeometry.html#a8fb7742035ba957d61c9e1b96379eb2c">More...</a><br /></td></tr>
<tr class="separator:a8fb7742035ba957d61c9e1b96379eb2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa642e845dd9f30b956af41f9531dbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a8aa642e845dd9f30b956af41f9531dbf">ContactGeometry</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;src)</td></tr>
<tr class="memdesc:a8aa642e845dd9f30b956af41f9531dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor makes a deep copy.  <a href="classSimTK_1_1ContactGeometry.html#a8aa642e845dd9f30b956af41f9531dbf">More...</a><br /></td></tr>
<tr class="separator:a8aa642e845dd9f30b956af41f9531dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc513cdb28da4f1964c2edae11e36ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#afc513cdb28da4f1964c2edae11e36ab5">operator=</a> (const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;src)</td></tr>
<tr class="memdesc:afc513cdb28da4f1964c2edae11e36ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment makes a deep copy.  <a href="classSimTK_1_1ContactGeometry.html#afc513cdb28da4f1964c2edae11e36ab5">More...</a><br /></td></tr>
<tr class="separator:afc513cdb28da4f1964c2edae11e36ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2f8d53493d9b837bc4663bb96bb25f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a4b2f8d53493d9b837bc4663bb96bb25f">~ContactGeometry</a> ()</td></tr>
<tr class="memdesc:a4b2f8d53493d9b837bc4663bb96bb25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class destructor deletes the implementation object. Note that this is not virtual; handles should consist of just a pointer to the implementation.  <a href="classSimTK_1_1ContactGeometry.html#a4b2f8d53493d9b837bc4663bb96bb25f">More...</a><br /></td></tr>
<tr class="separator:a4b2f8d53493d9b837bc4663bb96bb25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a19393f98ce54aa06b2c7484345808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a29a19393f98ce54aa06b2c7484345808">createDecorativeGeometry</a> () const</td></tr>
<tr class="memdesc:a29a19393f98ce54aa06b2c7484345808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a <a class="el" href="classSimTK_1_1DecorativeGeometry.html" title="This is the client-side interface to an implementation-independent representation of &quot;Decorations&quot; su...">DecorativeGeometry</a> that matches the shape of this <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a>.  <a href="classSimTK_1_1ContactGeometry.html#a29a19393f98ce54aa06b2c7484345808">More...</a><br /></td></tr>
<tr class="separator:a29a19393f98ce54aa06b2c7484345808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31443066ea0c856ed54287ab907a52a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a31443066ea0c856ed54287ab907a52a8">isSurfaceDefined</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a31443066ea0c856ed54287ab907a52a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks to see if a point is within the defined bounds of this particular <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a>.  <a href="classSimTK_1_1ContactGeometry.html#a31443066ea0c856ed54287ab907a52a8">More...</a><br /></td></tr>
<tr class="separator:a31443066ea0c856ed54287ab907a52a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d72b5b0d0b2b534abafe1f7d63266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a4d7d72b5b0d0b2b534abafe1f7d63266">findNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;position, bool &amp;inside, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a4d7d72b5b0d0b2b534abafe1f7d63266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point, find the nearest point on the surface of this object.  <a href="classSimTK_1_1ContactGeometry.html#a4d7d72b5b0d0b2b534abafe1f7d63266">More...</a><br /></td></tr>
<tr class="separator:a4d7d72b5b0d0b2b534abafe1f7d63266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9804dd155c59290d7c06a0672eba9ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9804dd155c59290d7c06a0672eba9ccb">projectDownhillToNearestPoint</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointQ) const</td></tr>
<tr class="memdesc:a9804dd155c59290d7c06a0672eba9ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a query point Q, find the nearest point P on the surface of this object, looking only down the local gradient.  <a href="classSimTK_1_1ContactGeometry.html#a9804dd155c59290d7c06a0672eba9ccb">More...</a><br /></td></tr>
<tr class="separator:a9804dd155c59290d7c06a0672eba9ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f6290140efb148474bd35294ad34b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a57f6290140efb148474bd35294ad34b6">trackSeparationFromLine</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointOnLine, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;directionOfLine, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;startingGuessForClosestPoint, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;newClosestPointOnSurface, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;closestPointOnLine, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;height) const</td></tr>
<tr class="memdesc:a57f6290140efb148474bd35294ad34b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the closest point between this implicit surface and a given line, or the point of deepest penetration if the line intersects the surface.  <a href="classSimTK_1_1ContactGeometry.html#a57f6290140efb148474bd35294ad34b6">More...</a><br /></td></tr>
<tr class="separator:a57f6290140efb148474bd35294ad34b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b88432ffcdefe56057c876b6066c5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3">NearestPointOnLineResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a5b88432ffcdefe56057c876b6066c5e6">calcNearestPointOnLineImplicitly</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointA, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;pointB, int maxIterations, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> tolerance, <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;nearestPointOnLine) const</td></tr>
<tr class="memdesc:a5b88432ffcdefe56057c876b6066c5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the nearest point on the line spanned by points pA-pB to the surface.  <a href="classSimTK_1_1ContactGeometry.html#a5b88432ffcdefe56057c876b6066c5e6">More...</a><br /></td></tr>
<tr class="separator:a5b88432ffcdefe56057c876b6066c5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b665e9ef6e190a88c13665a222e8ad5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a6b665e9ef6e190a88c13665a222e8ad5">intersectsRay</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;origin, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;distance, <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;normal) const</td></tr>
<tr class="memdesc:a6b665e9ef6e190a88c13665a222e8ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this object intersects a ray, and if so, find the intersection point.  <a href="classSimTK_1_1ContactGeometry.html#a6b665e9ef6e190a88c13665a222e8ad5">More...</a><br /></td></tr>
<tr class="separator:a6b665e9ef6e190a88c13665a222e8ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7407d10f6c12ea2584ca9620c666c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1a7407d10f6c12ea2584ca9620c666c0">getBoundingSphere</a> (<a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;center, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;radius) const</td></tr>
<tr class="memdesc:a1a7407d10f6c12ea2584ca9620c666c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bounding sphere which completely encloses this object.  <a href="classSimTK_1_1ContactGeometry.html#a1a7407d10f6c12ea2584ca9620c666c0">More...</a><br /></td></tr>
<tr class="separator:a1a7407d10f6c12ea2584ca9620c666c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ec4a215693e39d3225411c4b7a58d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a506ec4a215693e39d3225411c4b7a58d">isSmooth</a> () const</td></tr>
<tr class="memdesc:a506ec4a215693e39d3225411c4b7a58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this is a smooth surface, meaning that it can provide meaningful curvature information and continuous derivatives with respect to its parameterization.  <a href="classSimTK_1_1ContactGeometry.html#a506ec4a215693e39d3225411c4b7a58d">More...</a><br /></td></tr>
<tr class="separator:a506ec4a215693e39d3225411c4b7a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5ef5f86ba50c0767b6e10249fc107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1dc5ef5f86ba50c0767b6e10249fc107">calcCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;curvature, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;orientation) const</td></tr>
<tr class="memdesc:a1dc5ef5f86ba50c0767b6e10249fc107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the principal curvatures and their directions, and the surface normal, at a given point on a smooth surface.  <a href="classSimTK_1_1ContactGeometry.html#a1dc5ef5f86ba50c0767b6e10249fc107">More...</a><br /></td></tr>
<tr class="separator:a1dc5ef5f86ba50c0767b6e10249fc107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c7cf706c65a63f56c0d5cd8c2b0b47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSimTK.html#a0802d357d8b06888b8a1bc35a78c715c">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a32c7cf706c65a63f56c0d5cd8c2b0b47">getImplicitFunction</a> () const</td></tr>
<tr class="memdesc:a32c7cf706c65a63f56c0d5cd8c2b0b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our smooth surfaces define a function f(P)=0 that provides an implicit representation of the surface.  <a href="classSimTK_1_1ContactGeometry.html#a32c7cf706c65a63f56c0d5cd8c2b0b47">More...</a><br /></td></tr>
<tr class="separator:a32c7cf706c65a63f56c0d5cd8c2b0b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add690900c2e6be0482b133fe8ad8a921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#add690900c2e6be0482b133fe8ad8a921">calcSurfaceValue</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:add690900c2e6be0482b133fe8ad8a921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#add690900c2e6be0482b133fe8ad8a921">More...</a><br /></td></tr>
<tr class="separator:add690900c2e6be0482b133fe8ad8a921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a00c2b0e3dc15fdf4661b3cf41d064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a11a00c2b0e3dc15fdf4661b3cf41d064">calcSurfaceUnitNormal</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a11a00c2b0e3dc15fdf4661b3cf41d064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the implicit surface outward facing unit normal at the given point.  <a href="classSimTK_1_1ContactGeometry.html#a11a00c2b0e3dc15fdf4661b3cf41d064">More...</a><br /></td></tr>
<tr class="separator:a11a00c2b0e3dc15fdf4661b3cf41d064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b950a7f4bafa6509425a0fb8a2ad29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29">calcSurfaceGradient</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a44b950a7f4bafa6509425a0fb8a2ad29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29">More...</a><br /></td></tr>
<tr class="separator:a44b950a7f4bafa6509425a0fb8a2ad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533a7ba51866683ef8c4d0b5678818b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7533a7ba51866683ef8c4d0b5678818b">calcSurfaceHessian</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a7533a7ba51866683ef8c4d0b5678818b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the hessian of the implicit surface function, at a given point.  <a href="classSimTK_1_1ContactGeometry.html#a7533a7ba51866683ef8c4d0b5678818b">More...</a><br /></td></tr>
<tr class="separator:a7533a7ba51866683ef8c4d0b5678818b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ab9554de594636a6d6d15f96e5277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7a4ab9554de594636a6d6d15f96e5277">calcGaussianCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;gradient, const <a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> &amp;Hessian) const</td></tr>
<tr class="memdesc:a7a4ab9554de594636a6d6d15f96e5277"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface, return the Gaussian curvature at the point p whose implicit surface function gradient g(p) and Hessian H(p) are supplied.  <a href="classSimTK_1_1ContactGeometry.html#a7a4ab9554de594636a6d6d15f96e5277">More...</a><br /></td></tr>
<tr class="separator:a7a4ab9554de594636a6d6d15f96e5277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902cdbf3bd8aecf82958c61de9b17c91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a902cdbf3bd8aecf82958c61de9b17c91">calcGaussianCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point) const</td></tr>
<tr class="memdesc:a902cdbf3bd8aecf82958c61de9b17c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature is for convenience; use the other one to save time if you already have the gradient and Hessian available for this point.  <a href="classSimTK_1_1ContactGeometry.html#a902cdbf3bd8aecf82958c61de9b17c91">More...</a><br /></td></tr>
<tr class="separator:a902cdbf3bd8aecf82958c61de9b17c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516845833a62bc3fcad6619a54585a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ac516845833a62bc3fcad6619a54585a9">calcSurfaceCurvatureInDirection</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction) const</td></tr>
<tr class="memdesc:ac516845833a62bc3fcad6619a54585a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface, return the curvature k of the surface at a given point p in a given direction tp.  <a href="classSimTK_1_1ContactGeometry.html#ac516845833a62bc3fcad6619a54585a9">More...</a><br /></td></tr>
<tr class="separator:ac516845833a62bc3fcad6619a54585a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694c84f36889d2268a11a438cf30900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a4694c84f36889d2268a11a438cf30900">calcSurfaceTorsionInDirection</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;direction) const</td></tr>
<tr class="memdesc:a4694c84f36889d2268a11a438cf30900"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface, return the geodesic torsion tau of the surface at a given point p in a given direction tp.  <a href="classSimTK_1_1ContactGeometry.html#a4694c84f36889d2268a11a438cf30900">More...</a><br /></td></tr>
<tr class="separator:a4694c84f36889d2268a11a438cf30900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48cf8ac6a47aef3c70779f12c99004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aac48cf8ac6a47aef3c70779f12c99004">calcSurfacePrincipalCurvatures</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;point, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;curvature, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP) const</td></tr>
<tr class="memdesc:aac48cf8ac6a47aef3c70779f12c99004"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an implicit surface at a given point p, return the principal curvatures and principal curvature directions, using only the implicit function and its derivatives.  <a href="classSimTK_1_1ContactGeometry.html#aac48cf8ac6a47aef3c70779f12c99004">More...</a><br /></td></tr>
<tr class="separator:aac48cf8ac6a47aef3c70779f12c99004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f54e083249ea3cd0e2a91c68e74a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a09f54e083249ea3cd0e2a91c68e74a4e">isConvex</a> () const</td></tr>
<tr class="memdesc:a09f54e083249ea3cd0e2a91c68e74a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this surface is known to be convex.  <a href="classSimTK_1_1ContactGeometry.html#a09f54e083249ea3cd0e2a91c68e74a4e">More...</a><br /></td></tr>
<tr class="separator:a09f54e083249ea3cd0e2a91c68e74a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756676e69c6fba68114b4f427c951a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a756676e69c6fba68114b4f427c951a72">calcSupportPoint</a> (<a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> direction) const</td></tr>
<tr class="memdesc:a756676e69c6fba68114b4f427c951a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a direction expressed in the surface's frame S, return the point P on the surface that is the furthest in that direction (or one of those points if there is more than one).  <a href="classSimTK_1_1ContactGeometry.html#a756676e69c6fba68114b4f427c951a72">More...</a><br /></td></tr>
<tr class="separator:a756676e69c6fba68114b4f427c951a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae853e413043e89d59f19edcf903862ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimTK_1_1ContactGeometryTypeId.html">ContactGeometryTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ae853e413043e89d59f19edcf903862ca">getTypeId</a> () const</td></tr>
<tr class="memdesc:ae853e413043e89d59f19edcf903862ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSimTK_1_1ContactTrackerSubsystem.html" title="This subsystem identifies and tracks potential contacts between the mobilized bodies of a multibody s...">ContactTrackerSubsystem</a> uses this id for fast identification of specific surface shapes.  <a href="classSimTK_1_1ContactGeometry.html#ae853e413043e89d59f19edcf903862ca">More...</a><br /></td></tr>
<tr class="separator:ae853e413043e89d59f19edcf903862ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac648a4888974dc91db4c67ee3c21ef72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ac648a4888974dc91db4c67ee3c21ef72">ContactGeometry</a> (ContactGeometryImpl *<a class="el" href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">impl</a>)</td></tr>
<tr class="memdesc:ac648a4888974dc91db4c67ee3c21ef72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#ac648a4888974dc91db4c67ee3c21ef72">More...</a><br /></td></tr>
<tr class="separator:ac648a4888974dc91db4c67ee3c21ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa335794fd91bf6ed25be4d1c6a5fc527"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aa335794fd91bf6ed25be4d1c6a5fc527">isOwnerHandle</a> () const</td></tr>
<tr class="memdesc:aa335794fd91bf6ed25be4d1c6a5fc527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#aa335794fd91bf6ed25be4d1c6a5fc527">More...</a><br /></td></tr>
<tr class="separator:aa335794fd91bf6ed25be4d1c6a5fc527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959dc355f4f7f04f5d5eb9a3daf95b3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a959dc355f4f7f04f5d5eb9a3daf95b3d">isEmptyHandle</a> () const</td></tr>
<tr class="memdesc:a959dc355f4f7f04f5d5eb9a3daf95b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a959dc355f4f7f04f5d5eb9a3daf95b3d">More...</a><br /></td></tr>
<tr class="separator:a959dc355f4f7f04f5d5eb9a3daf95b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3712ed3c23bf8fc01874be710d3f077a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a3712ed3c23bf8fc01874be710d3f077a">hasImpl</a> () const</td></tr>
<tr class="memdesc:a3712ed3c23bf8fc01874be710d3f077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a3712ed3c23bf8fc01874be710d3f077a">More...</a><br /></td></tr>
<tr class="separator:a3712ed3c23bf8fc01874be710d3f077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b135711e8d5966b36a954f0c3cc5d0e"><td class="memItemLeft" align="right" valign="top">const ContactGeometryImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9b135711e8d5966b36a954f0c3cc5d0e">getImpl</a> () const</td></tr>
<tr class="memdesc:a9b135711e8d5966b36a954f0c3cc5d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a9b135711e8d5966b36a954f0c3cc5d0e">More...</a><br /></td></tr>
<tr class="separator:a9b135711e8d5966b36a954f0c3cc5d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bbdd8a3d084c2030b29d9618b64a28"><td class="memItemLeft" align="right" valign="top">ContactGeometryImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#af1bbdd8a3d084c2030b29d9618b64a28">updImpl</a> ()</td></tr>
<tr class="memdesc:af1bbdd8a3d084c2030b29d9618b64a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#af1bbdd8a3d084c2030b29d9618b64a28">More...</a><br /></td></tr>
<tr class="separator:af1bbdd8a3d084c2030b29d9618b64a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geodesic Evaluators</div></td></tr>
<tr class="memitem:af2a15eaf1f2184a1323e6661f63e6a34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#af2a15eaf1f2184a1323e6661f63e6a34">initGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xSP, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:af2a15eaf1f2184a1323e6661f63e6a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two points, find a geodesic curve connecting them.  <a href="classSimTK_1_1ContactGeometry.html#af2a15eaf1f2184a1323e6661f63e6a34">More...</a><br /></td></tr>
<tr class="separator:af2a15eaf1f2184a1323e6661f63e6a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6209f9ddb1e339dac2ddf89d56c30a20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a6209f9ddb1e339dac2ddf89d56c30a20">isAnalyticFormAvailable</a> () const</td></tr>
<tr class="memdesc:a6209f9ddb1e339dac2ddf89d56c30a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function to determine if you can compute a geodesic analytically using shootGeodesicInDirectionAnalytically.  <a href="classSimTK_1_1ContactGeometry.html#a6209f9ddb1e339dac2ddf89d56c30a20">More...</a><br /></td></tr>
<tr class="separator:a6209f9ddb1e339dac2ddf89d56c30a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d3b2886a56c8c3a5825d5653814803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#af2d3b2886a56c8c3a5825d5653814803">shootGeodesicInDirectionAnalytically</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;initialPointApprox, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;initialTangentApprox, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> finalArcLength, int numberOfKnotPoints, const std::function&lt; void(const <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html">ContactGeometry::GeodesicKnotPoint</a> &amp;)&gt; &amp;geodesicKnotPointsSink) const</td></tr>
<tr class="memdesc:af2d3b2886a56c8c3a5825d5653814803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an approximate initial point and an approximate initial tangent direction compute the geodesic of given arc length analytically.  <a href="classSimTK_1_1ContactGeometry.html#af2d3b2886a56c8c3a5825d5653814803">More...</a><br /></td></tr>
<tr class="separator:af2d3b2886a56c8c3a5825d5653814803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa790468c4b2ac9dd6e16721b84daf548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aa790468c4b2ac9dd6e16721b84daf548">shootGeodesicInDirectionImplicitly</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;initialPointApprox, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;initialTangentApprox, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> finalArcLength, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> initialIntegratorStepSize, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> integratorAccuracy, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> constraintTolerance, int maxIterations, const std::function&lt; void(const <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html">ContactGeometry::GeodesicKnotPoint</a> &amp;)&gt; &amp;geodesicKnotPointsSink) const</td></tr>
<tr class="memdesc:aa790468c4b2ac9dd6e16721b84daf548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an approximate initial point and an approximate initial tangent direction compute the geodesic of given arc length implicitly.  <a href="classSimTK_1_1ContactGeometry.html#aa790468c4b2ac9dd6e16721b84daf548">More...</a><br /></td></tr>
<tr class="separator:aa790468c4b2ac9dd6e16721b84daf548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a03a49e77241257d018405e30dcb49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a88a03a49e77241257d018405e30dcb49">continueGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;prevGeod, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a88a03a49e77241257d018405e30dcb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the current positions of two points P and Q moving on this surface, and the previous geodesic curve G' connecting prior locations P' and Q' of those same two points, return the geodesic G between P and Q that is closest in length to the previous one.  <a href="classSimTK_1_1ContactGeometry.html#a88a03a49e77241257d018405e30dcb49">More...</a><br /></td></tr>
<tr class="separator:a88a03a49e77241257d018405e30dcb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936a25de7017a330823f93104fb24859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a936a25de7017a330823f93104fb24859">makeStraightLineGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;defaultDirectionIfNeeded, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a936a25de7017a330823f93104fb24859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a straight-line approximation to the (presumably short) geodesic between two points on this implicit surface.  <a href="classSimTK_1_1ContactGeometry.html#a936a25de7017a330823f93104fb24859">More...</a><br /></td></tr>
<tr class="separator:a936a25de7017a330823f93104fb24859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b672c233d2437c421408a121da4c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a990b672c233d2437c421408a121da4c8">shootGeodesicInDirectionUntilLengthReached</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;terminatingLength, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a990b672c233d2437c421408a121da4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length.  <a href="classSimTK_1_1ContactGeometry.html#a990b672c233d2437c421408a121da4c8">More...</a><br /></td></tr>
<tr class="separator:a990b672c233d2437c421408a121da4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad1de0db758a5bc13c5160951e66f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2bad1de0db758a5bc13c5160951e66f5">calcGeodesicReverseSensitivity</a> (<a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geodesic, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;initSensitivity=<a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(0, 1)) const</td></tr>
<tr class="memdesc:a2bad1de0db758a5bc13c5160951e66f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an already-calculated geodesic on this surface connecting points P and Q, fill in the sensitivity of point P with respect to a change of tangent direction at Q.  <a href="classSimTK_1_1ContactGeometry.html#a2bad1de0db758a5bc13c5160951e66f5">More...</a><br /></td></tr>
<tr class="separator:a2bad1de0db758a5bc13c5160951e66f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d2b533f1c69f6c9b4c5ea22371f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ab46d2b533f1c69f6c9b4c5ea22371f27">shootGeodesicInDirectionUntilPlaneHit</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;terminatingPlane, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:ab46d2b533f1c69f6c9b4c5ea22371f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane.  <a href="classSimTK_1_1ContactGeometry.html#ab46d2b533f1c69f6c9b4c5ea22371f27">More...</a><br /></td></tr>
<tr class="separator:ab46d2b533f1c69f6c9b4c5ea22371f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c08e2a56fb38546efdb48f1cda079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a765c08e2a56fb38546efdb48f1cda079">calcGeodesic</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tQhint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a765c08e2a56fb38546efdb48f1cda079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to find geodesic between P and Q using split geodesic method with initial shooting directions tPhint and -tQhint.  <a href="classSimTK_1_1ContactGeometry.html#a765c08e2a56fb38546efdb48f1cda079">More...</a><br /></td></tr>
<tr class="separator:a765c08e2a56fb38546efdb48f1cda079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b44f8a2e2daa2e09341ad3085ba4eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a0b44f8a2e2daa2e09341ad3085ba4eae">calcGeodesicUsingOrthogonalMethod</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> lengthHint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a0b44f8a2e2daa2e09341ad3085ba4eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to find geodesic between P and Q using the orthogonal method, with initial direction tPhint and initial length lengthHint.  <a href="classSimTK_1_1ContactGeometry.html#a0b44f8a2e2daa2e09341ad3085ba4eae">More...</a><br /></td></tr>
<tr class="separator:a0b44f8a2e2daa2e09341ad3085ba4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fdde7022416b8d88bc1735cab1e224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a01fdde7022416b8d88bc1735cab1e224">calcGeodesicUsingOrthogonalMethod</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a01fdde7022416b8d88bc1735cab1e224"><td class="mdescLeft">&#160;</td><td class="mdescRight">This signature makes a guess at the initial direction and length and then calls the other signature.  <a href="classSimTK_1_1ContactGeometry.html#a01fdde7022416b8d88bc1735cab1e224">More...</a><br /></td></tr>
<tr class="separator:a01fdde7022416b8d88bc1735cab1e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9af982b24f430502bac9c545c9abdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2d9af982b24f430502bac9c545c9abdc">calcSplitGeodError</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;Q, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *geod=0) const</td></tr>
<tr class="memdesc:a2d9af982b24f430502bac9c545c9abdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ.  <a href="classSimTK_1_1ContactGeometry.html#a2d9af982b24f430502bac9c545c9abdc">More...</a><br /></td></tr>
<tr class="separator:a2d9af982b24f430502bac9c545c9abdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754766a3425583c7e8342f7216ee6ce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a754766a3425583c7e8342f7216ee6ce2">shootGeodesicInDirectionUntilLengthReachedAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;terminatingLength, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a754766a3425583c7e8342f7216ee6ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length.  <a href="classSimTK_1_1ContactGeometry.html#a754766a3425583c7e8342f7216ee6ce2">More...</a><br /></td></tr>
<tr class="separator:a754766a3425583c7e8342f7216ee6ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f489bb3134725a7d1a9e584fb9da903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a9f489bb3134725a7d1a9e584fb9da903">shootGeodesicInDirectionUntilPlaneHitAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;terminatingPlane, const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;options, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a9f489bb3134725a7d1a9e584fb9da903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane.  <a href="classSimTK_1_1ContactGeometry.html#a9f489bb3134725a7d1a9e584fb9da903">More...</a><br /></td></tr>
<tr class="separator:a9f489bb3134725a7d1a9e584fb9da903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12e31eb56f265f70c682554c471649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a3c12e31eb56f265f70c682554c471649">calcGeodesicAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xP, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;xQ, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tPhint, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;tQhint, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;geod) const</td></tr>
<tr class="memdesc:a3c12e31eb56f265f70c682554c471649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to analytically find geodesic between P and Q with initial shooting directions tPhint and tQhint.  <a href="classSimTK_1_1ContactGeometry.html#a3c12e31eb56f265f70c682554c471649">More...</a><br /></td></tr>
<tr class="separator:a3c12e31eb56f265f70c682554c471649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1393837d0460e675354885666fff43ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a1393837d0460e675354885666fff43ea">calcSplitGeodErrorAnalytical</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;Q, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tP, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;tQ, <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *geod=0) const</td></tr>
<tr class="memdesc:a1393837d0460e675354885666fff43ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to analytically calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ.  <a href="classSimTK_1_1ContactGeometry.html#a1393837d0460e675354885666fff43ea">More...</a><br /></td></tr>
<tr class="separator:a1393837d0460e675354885666fff43ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geodesic-related Debugging</div></td></tr>
<tr class="memitem:a2bcf119352496ba829cf6783c9fb3e1c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2bcf119352496ba829cf6783c9fb3e1c">getPlane</a> () const</td></tr>
<tr class="memdesc:a2bcf119352496ba829cf6783c9fb3e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler <br  />
  <a href="classSimTK_1_1ContactGeometry.html#a2bcf119352496ba829cf6783c9fb3e1c">More...</a><br /></td></tr>
<tr class="separator:a2bcf119352496ba829cf6783c9fb3e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b64dde0ca2dfcd094b0b6204f4a21b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a2b64dde0ca2dfcd094b0b6204f4a21b6">setPlane</a> (const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;plane) const</td></tr>
<tr class="memdesc:a2b64dde0ca2dfcd094b0b6204f4a21b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the plane associated with the geodesic hit plane event handler <br  />
  <a href="classSimTK_1_1ContactGeometry.html#a2b64dde0ca2dfcd094b0b6204f4a21b6">More...</a><br /></td></tr>
<tr class="separator:a2b64dde0ca2dfcd094b0b6204f4a21b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25147aeb5d31211fbf031a0dac23132"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aa25147aeb5d31211fbf031a0dac23132">getGeodP</a> () const</td></tr>
<tr class="memdesc:aa25147aeb5d31211fbf031a0dac23132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geodesic for access by visualizer.  <a href="classSimTK_1_1ContactGeometry.html#aa25147aeb5d31211fbf031a0dac23132">More...</a><br /></td></tr>
<tr class="separator:aa25147aeb5d31211fbf031a0dac23132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdaf2ca0c1905728867539f33765133"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#aecdaf2ca0c1905728867539f33765133">getGeodQ</a> () const</td></tr>
<tr class="memdesc:aecdaf2ca0c1905728867539f33765133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geodesic for access by visualizer.  <a href="classSimTK_1_1ContactGeometry.html#aecdaf2ca0c1905728867539f33765133">More...</a><br /></td></tr>
<tr class="separator:aecdaf2ca0c1905728867539f33765133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194ad90ea8cba0a176b5e0982d2b1997"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a194ad90ea8cba0a176b5e0982d2b1997">getNumGeodesicsShot</a> () const</td></tr>
<tr class="memdesc:a194ad90ea8cba0a176b5e0982d2b1997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler <br  />
  <a href="classSimTK_1_1ContactGeometry.html#a194ad90ea8cba0a176b5e0982d2b1997">More...</a><br /></td></tr>
<tr class="separator:a194ad90ea8cba0a176b5e0982d2b1997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4542caabc4680f44e5a696caf303e86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#ae4542caabc4680f44e5a696caf303e86">addVizReporter</a> (<a class="el" href="classSimTK_1_1ScheduledEventReporter.html">ScheduledEventReporter</a> *reporter) const</td></tr>
<tr class="memdesc:ae4542caabc4680f44e5a696caf303e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the plane associated with the geodesic hit plane event handler <br  />
  <a href="classSimTK_1_1ContactGeometry.html#ae4542caabc4680f44e5a696caf303e86">More...</a><br /></td></tr>
<tr class="separator:ae4542caabc4680f44e5a696caf303e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a990797bf74d949e5eb6fe6ccc02d56db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a990797bf74d949e5eb6fe6ccc02d56db">evalParametricCurvature</a> (const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;P, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;nn, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;dPdu, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;dPdv, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdu2, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdv2, const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;d2Pdudv, <a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;X_EP)</td></tr>
<tr class="memdesc:a990797bf74d949e5eb6fe6ccc02d56db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate surface curvature at a point using differential geometry as suggested by Harris 2006, "Curvature of ellipsoids and other surfaces" Ophthal.  <a href="classSimTK_1_1ContactGeometry.html#a990797bf74d949e5eb6fe6ccc02d56db">More...</a><br /></td></tr>
<tr class="separator:a990797bf74d949e5eb6fe6ccc02d56db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d96a97f8100e4a46194654f0bdf22d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4">combineParaboloids</a> (const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP1, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k1, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;x2, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k2, <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k)</td></tr>
<tr class="memdesc:a7d96a97f8100e4a46194654f0bdf22d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces in contact, in a way that is useful for later application of Hertz compliant contact theory for generating forces.  <a href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4">More...</a><br /></td></tr>
<tr class="separator:a7d96a97f8100e4a46194654f0bdf22d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a0968761d422b1f0bf0045416fef16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a15a0968761d422b1f0bf0045416fef16">combineParaboloids</a> (const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;R_SP1, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k1, const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;x2, const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k2, <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;k)</td></tr>
<tr class="memdesc:a15a0968761d422b1f0bf0045416fef16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a much faster version of <a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4" title="This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces...">combineParaboloids()</a> for when you just need the curvatures of the difference paraboloid, but not the directions of those curvatures.  <a href="classSimTK_1_1ContactGeometry.html#a15a0968761d422b1f0bf0045416fef16">More...</a><br /></td></tr>
<tr class="separator:a15a0968761d422b1f0bf0045416fef16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a03ff2fddea5008e383fa7588bb813837"><td class="memItemLeft" align="right" valign="top">ContactGeometryImpl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">impl</a></td></tr>
<tr class="memdesc:a03ff2fddea5008e383fa7588bb813837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal use only.  <a href="classSimTK_1_1ContactGeometry.html#a03ff2fddea5008e383fa7588bb813837">More...</a><br /></td></tr>
<tr class="separator:a03ff2fddea5008e383fa7588bb813837"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a> object describes the shape of all or part of the boundary of a solid object, for the purpose of modeling with Simbody physical effects that occur at the surface of that object, such as contact and wrapping forces. </p>
<p>Surfaces may be finite or infinite (e.g. a halfspace). Surfaces may be smooth or discrete (polyhedral). Smooth surfaces are defined implicitly as f(P)=0 (P=[px,py,pz]), and optionally may provide a surface parameterization P=f(u,v). An implicit representation is valid for any P; parametric representations may have limited validity, singular points, or may be defined only in a local neighborhood.</p>
<p>A variety of operators are implemented by each specific surface type. Some of these are designed to support efficient implementation of higher-level algorithms that deal in pairs of interacting objects, such as broad- and narrow-phase contact and minimum-distance calculations.</p>
<p>The idea here is to collect all the important knowledge about a particular kind of geometric shape in one place, adding operators as needed to support new algorithms from time to time.</p>
<p>All surfaces provide these operations:</p><ul>
<li>find closest point to a given point</li>
<li>find intersection with a given ray</li>
<li>find most extreme point in a given direction</li>
<li>return the outward-facing surface normal at a point</li>
<li>generate a polygonal mesh that approximates the surface</li>
<li>return a unique integer id that may be used to quickly determine the concrete type of a generic surface</li>
</ul>
<p>Finite surfaces provide</p><ul>
<li>a bounding sphere that encloses the entire surface</li>
<li>a bounding volume hierarchy with tight-fitting leaf nodes containing only simple primitives</li>
</ul>
<p>Smooth surfaces provide</p><ul>
<li>Min/max curvatures and directions</li>
<li>Calculate a geodesic between two points on the surface, or starting at a point for a given direction and length</li>
</ul>
<p>Individual surface types generally support additional operations that may be used by specialized algorithms that know they are working with that particular kind of surface. For example, an algorithm for determining ellipsoid-halfspace contact is likely to take advantage of special properties of both surfaces.</p>
<p>We do not require detailed solid geometry, but neither can the surface be treated without some information about the solid it bounds. For example, for contact we must know which side of the surface is the "inside". However, we don't need a fully consistent treatment of the solid; for ease of modeling we require only that the surface behave properly in those locations at which it is evaluated at run time. The required behavior may vary depending on the algorithm using it.</p>
<p>This is the base class for surface handles; user code will typically reference one of the local classes it defines instead for specific shapes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a791b5ea965151a689f6f071163b043a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b5ea965151a689f6f071163b043a3">&#9670;&nbsp;</a></span>NearestPointOnLineResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3">SimTK::ContactGeometry::NearestPointOnLineResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exit flag returned by calcNearestPointOnLineImplicitly. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a791b5ea965151a689f6f071163b043a3ada5418b1eb4e80d05f2c1c7c4fa1b6ec"></a>Converged&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a791b5ea965151a689f6f071163b043a3a005f9fae8e493a652536060c5f49636c"></a>MaxIterationsExceeded&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a791b5ea965151a689f6f071163b043a3a92a75622947060f4ca29b4b06ffd6946"></a>PointFallsBelowSurface&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8fb7742035ba957d61c9e1b96379eb2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb7742035ba957d61c9e1b96379eb2c">&#9670;&nbsp;</a></span>ContactGeometry() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::ContactGeometry::ContactGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base class default constructor creates an empty handle. </p>

</div>
</div>
<a id="a8aa642e845dd9f30b956af41f9531dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa642e845dd9f30b956af41f9531dbf">&#9670;&nbsp;</a></span>ContactGeometry() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::ContactGeometry::ContactGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor makes a deep copy. </p>

</div>
</div>
<a id="a4b2f8d53493d9b837bc4663bb96bb25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2f8d53493d9b837bc4663bb96bb25f">&#9670;&nbsp;</a></span>~ContactGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::ContactGeometry::~ContactGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class destructor deletes the implementation object. Note that this is not virtual; handles should consist of just a pointer to the implementation. </p>

</div>
</div>
<a id="ac648a4888974dc91db4c67ee3c21ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac648a4888974dc91db4c67ee3c21ef72">&#9670;&nbsp;</a></span>ContactGeometry() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::ContactGeometry::ContactGeometry </td>
          <td>(</td>
          <td class="paramtype">ContactGeometryImpl *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc513cdb28da4f1964c2edae11e36ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc513cdb28da4f1964c2edae11e36ab5">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a>&amp; SimTK::ContactGeometry::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment makes a deep copy. </p>

</div>
</div>
<a id="a29a19393f98ce54aa06b2c7484345808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a19393f98ce54aa06b2c7484345808">&#9670;&nbsp;</a></span>createDecorativeGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1DecorativeGeometry.html">DecorativeGeometry</a> SimTK::ContactGeometry::createDecorativeGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a <a class="el" href="classSimTK_1_1DecorativeGeometry.html" title="This is the client-side interface to an implementation-independent representation of &quot;Decorations&quot; su...">DecorativeGeometry</a> that matches the shape of this <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a>. </p>

</div>
</div>
<a id="a31443066ea0c856ed54287ab907a52a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31443066ea0c856ed54287ab907a52a8">&#9670;&nbsp;</a></span>isSurfaceDefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isSurfaceDefined </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks to see if a point is within the defined bounds of this particular <a class="el" href="classSimTK_1_1ContactGeometry.html" title="A ContactGeometry object describes the shape of all or part of the boundary of a solid object,...">ContactGeometry</a>. </p>
<p>Attempting to invoke <a class="el" href="classSimTK_1_1ContactGeometry.html#add690900c2e6be0482b133fe8ad8a921" title="Calculate the value of the implicit surface function, at a given point.">calcSurfaceValue()</a>, <a class="el" href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29" title="Calculate the gradient of the implicit surface function, at a given point.">calcSurfaceGradient()</a> etc, on an out-of-range point will raise an exception; use this method to check first if you are not sure. </p>

</div>
</div>
<a id="a4d7d72b5b0d0b2b534abafe1f7d63266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7d72b5b0d0b2b534abafe1f7d63266">&#9670;&nbsp;</a></span>findNearestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::findNearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point, find the nearest point on the surface of this object. </p>
<p>If multiple points on the surface are equally close to the specified point, this may return any of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The point in question. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inside</td><td>On exit, this is set to true if the specified point is inside this object, false otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>On exit, this contains the surface normal at the returned point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point on the surface of the object which is closest to the specified point. </dd></dl>

</div>
</div>
<a id="a9804dd155c59290d7c06a0672eba9ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9804dd155c59290d7c06a0672eba9ccb">&#9670;&nbsp;</a></span>projectDownhillToNearestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::projectDownhillToNearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pointQ</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a query point Q, find the nearest point P on the surface of this object, looking only down the local gradient. </p>
<p>Thus we cannot guarantee that P is the globally nearest point; if you need that use the <a class="el" href="classSimTK_1_1ContactGeometry.html#a4d7d72b5b0d0b2b534abafe1f7d63266" title="Given a point, find the nearest point on the surface of this object.">findNearestPoint()</a> method. However, this method is extremely fast since it only needs to find the locally nearest point. It is best suited for use when you know P is not too far from the surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointQ</td><td>The query point Q, assumed to be somewhere not too far from the surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point P on the surface, at which the surface normal is aligned with the line from P to Q.</dd></dl>
<p>This method is very cheap if query point Q is already on the surface to within a very tight tolerance; in that case it will simply return P=Q. </p>

</div>
</div>
<a id="a57f6290140efb148474bd35294ad34b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f6290140efb148474bd35294ad34b6">&#9670;&nbsp;</a></span>trackSeparationFromLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::trackSeparationFromLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pointOnLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>directionOfLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>startingGuessForClosestPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>newClosestPointOnSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>closestPointOnLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track the closest point between this implicit surface and a given line, or the point of deepest penetration if the line intersects the surface. </p>
<p>We are given a guess at the closest point, and search only downhill from that guess so we can't guarantee we actually are returning the globally closest. However, the method does run very fast and is well suited to continuous tracking where nothing dramatic happens from call to call.</p>
<p>If the line intersects the surface, we return the closest perpendicular point, <em>not</em> one of the intersection points. The perpendicular point will be the point of <em>most</em> separation rather than least. This behavior makes the signed separation distance a smooth function that passes through zero as the line approaches, contacts, and penetrates the surface. We return that signed distance as the <em>height</em> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointOnLine</td><td>Any point through which the line passes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">directionOfLine</td><td>A unit vector giving the direction of the line. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startingGuessForClosestPoint</td><td>A point on the implicit surface that is a good guess for the closest (or most deeply penetrated) point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newClosestPointOnSurface</td><td>This is the point of least distance to the line if the surface and line are separated; the point of most distance to the line if the line intersects the surface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closestPointOnLine</td><td>The is the corresponding point on the line that is the closest (furthest) from <em>newClosestPointOnSurface</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">height</td><td>This is the signed height of the closest point on the line over the surface tangent plane at <em>newClosestPointOnSurface</em>. This is positive when <em>closestPointOnLine</em> is in the direction of the outward normal, negative if it is in the opposite direction. If we successfully found the point we sought, a negative height means the extreme point on the line is inside the object bounded by this surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it succeeds in finding a point that meets the criteria to a strict tolerance. Otherwise the method has gotten stuck in a local minimum meaning the initial guess wasn't good enough.</dd></dl>
<p>In case we fail to find a good point, we'll still return <em>some</em> points on the surface and the line that reduced the error function. Sometimes those are useful for visualizing what went wrong.</p>
<h3>Theory</h3>
<p>We are looking for a point P on the surface where a line N passing through P parallel to the normal at P intersects the given line L and is perpendicular to L there. Thus there are two degrees of freedom (location of P on the surface), and there are two equations to solve. Let Q and R be the closest approach points of the lines N and L respectively. We require that the following two conditions hold:</p><ul>
<li>lines N and L are perpendicular</li>
<li>points Q and R are coincident</li>
</ul>
<p>To be precise we solve the following nonlinear system of three equations: </p><pre>
err(P) = 0
where
err(P) = [     n . l       ]
         [ (R-Q) . (n X l) ]
         [      f(P)       ]
In the above n is the unit normal vector at P, l is a unit vector aligned with
the query line L, and f(P) is the implicit surface function that keeps P on the
surface.
</pre> 
</div>
</div>
<a id="a5b88432ffcdefe56057c876b6066c5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b88432ffcdefe56057c876b6066c5e6">&#9670;&nbsp;</a></span>calcNearestPointOnLineImplicitly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometry.html#a791b5ea965151a689f6f071163b043a3">NearestPointOnLineResult</a> SimTK::ContactGeometry::calcNearestPointOnLineImplicitly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pointA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>pointB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>nearestPointOnLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the nearest point on the line spanned by points pA-pB to the surface. </p>
<p>This function exits early if the point lies below the surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointA</td><td>Line origin point. </td></tr>
    <tr><td class="paramname">pointB</td><td>Line termination point. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>Maximum number of solver iterations. </td></tr>
    <tr><td class="paramname">tolerance</td><td>If the stepsize falls below this value stop iterating </td></tr>
    <tr><td class="paramname">nearestPointOnLine</td><td>The computed nearest point on the line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The NearestPointOnLineResult signifying the result status upon exit.</dd></dl>
<h3>Theory</h3>
<p>Computing the point is done by searching for a maximum of the surface constraint value <code>c=f(p)</code>, along the line. The point on the line <code>pL</code> can be expressed with one unknown scalar alpha as: </p><pre>
pL = pA + alpha * (pB-pA)  with 0 &lt;= alpha &lt;= 1.
</pre><p> This gives the optimization problem as: </p><pre>
max f(alpha), s.t. 0 &lt;= alpha &lt;= 1
</pre><p> The constraint <code>f(alpha)</code> can be approximated using the gradient <code>g</code>, and hessian <code>H</code>: </p><pre>
f(alpha) = c + g * (pB - pA) * alpha + 1/2 * ~(pB - pA) * H * (pB - pA) * alpha^2 + ...
</pre><p> Update alpha as: </p><pre>
alpha += g * (pB-pA) / ( ~(pB-pA) * H * (pB-pA) )
</pre><p> The search is terminated when either the step size falls below given tolerance, or the max number of iterations is exceeded, or if the point falls below the surface. </p>

</div>
</div>
<a id="a6b665e9ef6e190a88c13665a222e8ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b665e9ef6e190a88c13665a222e8ad5">&#9670;&nbsp;</a></span>intersectsRay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::intersectsRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this object intersects a ray, and if so, find the intersection point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The position at which the ray begins. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>The ray direction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>If an intersection is found, the distance from the ray origin to the intersection point is stored in this. Otherwise, it is left unchanged. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normal</td><td>If an intersection is found, the surface normal of the intersection point is stored in this. Otherwise, it is left unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an intersection is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1a7407d10f6c12ea2584ca9620c666c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7407d10f6c12ea2584ca9620c666c0">&#9670;&nbsp;</a></span>getBoundingSphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::getBoundingSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a bounding sphere which completely encloses this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">center</td><td>On exit, this contains the location of the center of the bounding sphere. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">radius</td><td>On exit, this contains the radius of the bounding sphere. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a506ec4a215693e39d3225411c4b7a58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506ec4a215693e39d3225411c4b7a58d">&#9670;&nbsp;</a></span>isSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this is a smooth surface, meaning that it can provide meaningful curvature information and continuous derivatives with respect to its parameterization. </p>

</div>
</div>
<a id="a1dc5ef5f86ba50c0767b6e10249fc107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5ef5f86ba50c0767b6e10249fc107">&#9670;&nbsp;</a></span>calcCurvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcCurvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the principal curvatures and their directions, and the surface normal, at a given point on a smooth surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td><br  />
 A point at which to compute the curvature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curvature</td><td><br  />
 On return, this will contain the maximum (curvature[0]) and minimum (curvature[1]) curvatures of the surface at the point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">orientation</td><td><br  />
 On return, this will contain the orientation of the surface at the given point as follows: the x axis along the direction of maximum curvature, the y axis along the direction of minimum curvature, and the z axis along the surface normal. These vectors are expressed in the surface's coordinate frame.</td></tr>
  </table>
  </dd>
</dl>
<p>Non-smooth surfaces will not implement this method and will throw an exception if you call it. </p>

</div>
</div>
<a id="a32c7cf706c65a63f56c0d5cd8c2b0b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c7cf706c65a63f56c0d5cd8c2b0b47">&#9670;&nbsp;</a></span>getImplicitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSimTK.html#a0802d357d8b06888b8a1bc35a78c715c">Function</a>&amp; SimTK::ContactGeometry::getImplicitFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Our smooth surfaces define a function f(P)=0 that provides an implicit representation of the surface. </p>
<p>P=(x,y,z) is any point in space expressed in the surface's coordinate frame S (that is, given by a vector P-So, expressed in S). The function is positive inside the object, 0 on the surface, and negative outside the object. The returned Function object supports first and second partial derivatives with respect to the three function arguments x, y, and z. Evaluation of the function and its derivatives is cheap.</p>
<p>Non-smooth surfaces will not implement this method and will throw an exception if you call it. </p>

</div>
</div>
<a id="add690900c2e6be0482b133fe8ad8a921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add690900c2e6be0482b133fe8ad8a921">&#9670;&nbsp;</a></span>calcSurfaceValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::calcSurfaceValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the value of the implicit surface function, at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>A point at which to compute the surface value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the implicit surface function at the point. </dd></dl>

</div>
</div>
<a id="a11a00c2b0e3dc15fdf4661b3cf41d064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a00c2b0e3dc15fdf4661b3cf41d064">&#9670;&nbsp;</a></span>calcSurfaceUnitNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> SimTK::ContactGeometry::calcSurfaceUnitNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the implicit surface outward facing unit normal at the given point. </p>
<p>This is determined using the implicit surface function gradient so is undefined if the point is at a singular point of the implicit function. An example is a point along the center line of a cylinder. Rather than return a NaN unit normal in these cases, which would break many algorithms that are searching around for valid points, we'll return the normal from a nearby, hopefully non-singular point. If that doesn't work, we'll return an arbitrary direction. If you want to know whether you're at a singular point, obtain the gradient directly with <a class="el" href="classSimTK_1_1ContactGeometry.html#a44b950a7f4bafa6509425a0fb8a2ad29" title="Calculate the gradient of the implicit surface function, at a given point.">calcSurfaceGradient()</a> and check its length. </p>

</div>
</div>
<a id="a44b950a7f4bafa6509425a0fb8a2ad29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b950a7f4bafa6509425a0fb8a2ad29">&#9670;&nbsp;</a></span>calcSurfaceGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::calcSurfaceGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the gradient of the implicit surface function, at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>A point at which to compute the surface gradient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The gradient of the implicit surface function at the point. </dd></dl>

</div>
</div>
<a id="a7533a7ba51866683ef8c4d0b5678818b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7533a7ba51866683ef8c4d0b5678818b">&#9670;&nbsp;</a></span>calcSurfaceHessian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> SimTK::ContactGeometry::calcSurfaceHessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the hessian of the implicit surface function, at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>A point at which to compute the surface Hessian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Hessian of the implicit surface function at the point. </dd></dl>

</div>
</div>
<a id="a7a4ab9554de594636a6d6d15f96e5277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4ab9554de594636a6d6d15f96e5277">&#9670;&nbsp;</a></span>calcGaussianCurvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::calcGaussianCurvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gabde2b49f04b17aea4826466c0f0e34b3">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>Hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an implicit surface, return the Gaussian curvature at the point p whose implicit surface function gradient g(p) and Hessian H(p) are supplied. </p>
<p>It is not required that p is on the surface but the results will be meaningless if the gradient and Hessian were not calculated at the same point.</p>
<p>Here is the formula: </p><pre>
        ~grad(f) * Adjoint(H) * grad(f)
   Kg = --------------------------------
                |grad(f)|^4
</pre><p> where grad(f) is Df/Dx, Hessian H is D grad(f)/Dx and Adjoint is a 3x3 matrix A where A(i,j)=determinant(H with row i and column j removed). Ref: Goldman, R. "Curvature formulas for implicit curves and surfaces", Comp. Aided Geometric Design 22 632-658 (2005).</p>
<p>Gaussian curvature is the product of the two principal curvatures, Kg=k1*k2. So for example, the Gaussian curvature anywhere on a sphere is 1/r^2. Note that despite the name, Gaussian curvature has units of 1/length^2 rather than curvature units of 1/length.</p>
<p>Here is what the (symmetric) adjoint matrix looks like: </p><pre>
adjH  =  [ fyy*fzz - fyz^2, fxz*fyz - fxy*fzz, fxy*fyz - fxz*fyy  ]
         [      (1,2),      fxx*fzz - fxz^2,   fxy*fxz - fxx*fyz  ]
         [      (1,3),           (2,3),        fxx*fyy - fxy^2    ]
</pre> 
</div>
</div>
<a id="a902cdbf3bd8aecf82958c61de9b17c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902cdbf3bd8aecf82958c61de9b17c91">&#9670;&nbsp;</a></span>calcGaussianCurvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::calcGaussianCurvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This signature is for convenience; use the other one to save time if you already have the gradient and Hessian available for this point. </p>
<p>See the other signature for documentation. </p>

</div>
</div>
<a id="ac516845833a62bc3fcad6619a54585a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516845833a62bc3fcad6619a54585a9">&#9670;&nbsp;</a></span>calcSurfaceCurvatureInDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::calcSurfaceCurvatureInDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an implicit surface, return the curvature k of the surface at a given point p in a given direction tp. </p>
<p>Make sure the point is on the surface and the direction vector lies in the tangent plane and has unit length |tp| = 1. Then </p><pre>
k = ~tp * H * tp / |g|,
</pre><p> where H is the Hessian matrix evaluated at p. </p>

</div>
</div>
<a id="a4694c84f36889d2268a11a438cf30900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694c84f36889d2268a11a438cf30900">&#9670;&nbsp;</a></span>calcSurfaceTorsionInDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> SimTK::ContactGeometry::calcSurfaceTorsionInDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an implicit surface, return the geodesic torsion tau of the surface at a given point p in a given direction tp. </p>
<p>Make sure the point is on the surface and the direction vector lies in the tangent plane. Then </p><pre>
tau = - ( H * tp ) . ( g % tp ) / |g|^2
</pre><p> where H is the Hessian matrix, and g is the gradient vector, evaluated at p. </p>

</div>
</div>
<a id="aac48cf8ac6a47aef3c70779f12c99004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac48cf8ac6a47aef3c70779f12c99004">&#9670;&nbsp;</a></span>calcSurfacePrincipalCurvatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcSurfacePrincipalCurvatures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>R_SP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For an implicit surface at a given point p, return the principal curvatures and principal curvature directions, using only the implicit function and its derivatives. </p>
<p>The curvatures are returned as a Vec2 (kmax,kmin), and the directions are returned as the x,y axes of a frame whose z axis is the outward unit normal at p, x is the maximum curvature direction, and y is the minimum curvature direction. Point p is given in the surface frame S, and the returned axes are given in S via the Rotation matrix R_SP. </p>

</div>
</div>
<a id="a09f54e083249ea3cd0e2a91c68e74a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f54e083249ea3cd0e2a91c68e74a4e">&#9670;&nbsp;</a></span>isConvex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isConvex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this surface is known to be convex. </p>
<p>This can be true for smooth or polygonal surfaces. </p>

</div>
</div>
<a id="a756676e69c6fba68114b4f427c951a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756676e69c6fba68114b4f427c951a72">&#9670;&nbsp;</a></span>calcSupportPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> SimTK::ContactGeometry::calcSupportPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a>&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a direction expressed in the surface's frame S, return the point P on the surface that is the furthest in that direction (or one of those points if there is more than one). </p>
<p>This will be the point such that dot(P-So, direction) is maximal for the surface (where So is the origin of the surface). This is particularly useful for convex surfaces and should be very fast for them. </p>

</div>
</div>
<a id="ae853e413043e89d59f19edcf903862ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae853e413043e89d59f19edcf903862ca">&#9670;&nbsp;</a></span>getTypeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimTK_1_1ContactGeometryTypeId.html">ContactGeometryTypeId</a> SimTK::ContactGeometry::getTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classSimTK_1_1ContactTrackerSubsystem.html" title="This subsystem identifies and tracks potential contacts between the mobilized bodies of a multibody s...">ContactTrackerSubsystem</a> uses this id for fast identification of specific surface shapes. </p>

</div>
</div>
<a id="a990797bf74d949e5eb6fe6ccc02d56db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990797bf74d949e5eb6fe6ccc02d56db">&#9670;&nbsp;</a></span>evalParametricCurvature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> SimTK::ContactGeometry::evalParametricCurvature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>nn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>dPdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>dPdv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>d2Pdu2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>d2Pdv2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>d2Pdudv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#acc6561664fcf612c22f175dbf41c196e">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>X_EP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate surface curvature at a point using differential geometry as suggested by Harris 2006, "Curvature of ellipsoids and other surfaces" Ophthal. </p>
<p>Physiol. Opt. 26:497-501, although the equations here come directly from Harris' reference Struik 1961, Lectures on Classical Differential Geometry, 2nd ed. republished by Dover 1988. Equation and page numbers below are from Struik.</p>
<p>This method works for any smooth surface for which there is a local (u,v) surface parameterization; it is not restricted to ellipsoids or convex shapes, and (u,v) must be distinct but do not have to be perpendicular. Both must be perpendicular to the surface normal.</p>
<p>First fundamental form: I = E du^2 + 2F dudv + G dv^2 </p><pre>   E = dxdu^2, F = ~dxdu * dxdv, G=dxdv^2  </pre><p>Second fundamental form: II = e du^2 + 2f dudv + g dv^2 </p><pre>   e = - ~d2xdu2 * nn, f = - ~d2xdudv * nn, g = - ~d2xdv2 * nn </pre><p>Given a direction t=dv/du, curvature k is </p><pre>
         II   e + 2f t + g t^2
     k = -- = ----------------   (eq. 6-3)
         I    E + 2F t + G t^2
</pre><p>We want minimum and maximum values for k to get principal curvatures. We can find those as the solutions to dk/dt=0. </p><pre>   dk/dt = (E + 2Ft + Gt^2)(f+gt) - (e + 2ft + gt^2)(F+Gt) </pre><p>When dk/dt=0, k =(f+gt)/(F+Gt) = (e+ft)/(E+Ft) (eq. 6-4). That provides a quadratic equation for the two values of t: </p><pre>   A t^2 + B t + C = 0     </pre><p> where A=Fg-Gf, B=Eg-Ge, C=Ef-Fe (eq. 6-5a).</p>
<p>In case the u and v tangent directions are the min and max curvature directions (on a sphere, for example), they must be perpendicular so F=f=0 (eq. 6-6). Then the curvatures are ku = e/E and kv = g/G (eq. 6-8).</p>
<p>We're going to return principal curvatures kmax and kmin such that kmax &gt;= kmin, along with the perpendicular tangent unit directions dmax,dmin that are the corresponding principal curvature directions, oriented so that (dmax,dmin,nn) form a right-handed coordinate frame.</p>
<p>Cost: given a point P, normalized normal nn, unnormalized u,v tangents and second derivatives </p><pre>
    curvatures: ~115 flops
    directions:  ~50 flops
                ----
                ~165 flops
</pre> 
</div>
</div>
<a id="a7d96a97f8100e4a46194654f0bdf22d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d96a97f8100e4a46194654f0bdf22d4">&#9670;&nbsp;</a></span>combineParaboloids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::ContactGeometry::combineParaboloids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>R_SP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>R_SP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces in contact, in a way that is useful for later application of Hertz compliant contact theory for generating forces. </p>
<p>We assume that contact points Q1 on surface1 and Q2 on surface2 have been determined with the following properties:</p><ul>
<li>the surface normals are aligned but opposite</li>
<li>points Q1 and Q2 are separated only along the normal (no tangential separation)</li>
</ul>
<p>Then the local regions near Q1 and Q2 may be fit with paraboloids P1 and P2 that have their origins at Q1 and Q2, and have the same normals and curvatures at the origins as do the original surfaces. We will behave here as though Q1 and Q2 are coincident in space at a point Q; imagine sliding them along the normal until that happens. Now we define the equations of P1 and P2 in terms of the maximum and minimum curvatures of surface1 and surface2 at Q:</p><pre>
    P1: -2z = kmax1 x1^2 + kmin1 y1^2
    P2:  2z = kmax2 x2^2 + kmin2 y2^2  
</pre><p> Although the origin Q and z direction are shared, the x,y directions for the two paraboloids, though in the same plane z=0, are relatively rotated. Note that the kmins might be negative; the surfaces do not have to be convex.</p>
<p>For Hertz contact, we need to know the difference (relative) surface between the two paraboloids. The difference is a paraboloid P with equation </p><pre>
    P: -2z = kmax x^2 + kmin y^2
</pre><p> It shares the origin Q and z direction (oriented as for P1), but has its own principal directions x,y which are coplanar with x1,y1 and x2,y2 but rotated into some unknown composite orientation. The purpose of this method is to calculate kmax and kmin, and optionally (depending which signature you call), x and y, the directions of maximum and minimum curvature (resp.). The curvature directions are also the principal axes of the contact ellipse formed by the deformed surfaces, so are necessary (for example) if you want to draw that ellipse.</p>
<p>Cost is about 220 flops. If you don't need the curvature directions, call the other overloaded signature which returns only kmax and kmin and takes only about 1/3 as long.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_SP1</td><td><br  />
 The orientation of the P1 paraboloid's frame, expressed in some frame S (typically the frame of the surface to which P1 is fixed). R_SP1.x() is the direction of maximum curvature; y() is minimum curvature; z is the contact normal pointing away from surface 1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k1</td><td><br  />
 The maximum (k1[0]) and minimum (k1[1]) curvatures for P1 at the contact point Q1 on surface1. Negative curvatures are handled correctly here but may cause trouble for your force model if the resulting contact is conforming. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x2</td><td><br  />
 The direction of maximum curvature for paraboloid P2. <em>x2</em> must be in the x1,y1 plane provided in <em>R_SP1</em> and expressed in the S frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k2</td><td><br  />
 The maximum (k2[0]) and minimum (k2[1]) curvatures for P2 at the contact point Q2 on surface2. Negative curvatures are handled correctly here but may cause trouble for your force model if the resulting contact is conforming. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R_SP</td><td><br  />
 The orientation of the difference paraboloid P's frame, expressed in the same S frame as was used for P1. R_SP.x() is the direction of maximum curvature of P at the contact point; y() is the minimum curvature direction; z() is the unchanged contact normal pointing away from surface1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">k</td><td><br  />
 The maximum (k[0]) and minimum(k[1]) curvatures for the difference paraboloid P at the contact point Q. If either of these is negative or zero then the surfaces are conforming and you can't use a point contact force model. Note that if k1&gt;0 and k2&gt;0 (i.e. surfaces are convex at Q) then k&gt;0 too. If some of the surface curvatures are concave, it is still possible that k&gt;0, depending on the relative curvatures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The other signature for <a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4" title="This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces...">combineParaboloids()</a> that is much cheaper if you just need the curvatures <em>k</em> but not the directions <em>R_SP</em>. </dd></dl>

</div>
</div>
<a id="a15a0968761d422b1f0bf0045416fef16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a0968761d422b1f0bf0045416fef16">&#9670;&nbsp;</a></span>combineParaboloids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimTK::ContactGeometry::combineParaboloids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a028f32537d08269e2de2f2f4aa99e5ac">Rotation</a> &amp;&#160;</td>
          <td class="paramname"><em>R_SP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a much faster version of <a class="el" href="classSimTK_1_1ContactGeometry.html#a7d96a97f8100e4a46194654f0bdf22d4" title="This utility method is useful for characterizing the relative geometry of two locally-smooth surfaces...">combineParaboloids()</a> for when you just need the curvatures of the difference paraboloid, but not the directions of those curvatures. </p>
<p>Cost is about 70 flops. See the other overload of this method for details. </p>

</div>
</div>
<a id="af2a15eaf1f2184a1323e6661f63e6a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a15eaf1f2184a1323e6661f63e6a34">&#9670;&nbsp;</a></span>initGeodesic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::initGeodesic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xSP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two points, find a geodesic curve connecting them. </p>
<p>If a preferred starting point is provided, find the geodesic curve that is closest to that point. Otherwise, find the shortest length geodesic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of starting point P, in S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xQ</td><td>Coordinates of ending point Q, in S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSP</td><td>(Optional) Coordinates of a preferred point for the geodesic to be near </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters related to geodesic calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains a geodesic between P and Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6209f9ddb1e339dac2ddf89d56c30a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6209f9ddb1e339dac2ddf89d56c30a20">&#9670;&nbsp;</a></span>isAnalyticFormAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isAnalyticFormAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this function to determine if you can compute a geodesic analytically using shootGeodesicInDirectionAnalytically. </p>

</div>
</div>
<a id="af2d3b2886a56c8c3a5825d5653814803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d3b2886a56c8c3a5825d5653814803">&#9670;&nbsp;</a></span>shootGeodesicInDirectionAnalytically()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionAnalytically </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialPointApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialTangentApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>finalArcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfKnotPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html">ContactGeometry::GeodesicKnotPoint</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>geodesicKnotPointsSink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an approximate initial point and an approximate initial tangent direction compute the geodesic of given arc length analytically. </p>
<p>This method is only available for a few surfaces for which an analytic description actually exists. Use <a class="el" href="classSimTK_1_1ContactGeometry.html#a6209f9ddb1e339dac2ddf89d56c30a20" title="Use this function to determine if you can compute a geodesic analytically using shootGeodesicInDirect...">ContactGeometry::isAnalyticFormAvailable</a> to check if you do not know. The initial point will be projected to the surface, and the initial tangent projected to the normal plane before computing the geodesic. The resulting geodesic is written to the provided sink as GeodesicKnotPoints.</p>
<p>Since the geodesic is computed analytically the final <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html" title="The state of a geodesic at a (knot) point along the geodesic.">GeodesicKnotPoint</a> could be computed directly after the initial <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html" title="The state of a geodesic at a (knot) point along the geodesic.">GeodesicKnotPoint</a>, resulting in only two knots being computed. However, it is often useful to obtain some intermediate knots as well (e.g. for visualization purposes), which is why the numberOfKnotPoints is a parameter. If you do not need any intermediate knots, set this equal to 2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialPointApprox</td><td>Coordinates of starting point in local surface coordinates. This point will be projected to the surface. </td></tr>
    <tr><td class="paramname">initialTangentApprox</td><td>Direction of geodesic at start, in local surface coordinates. This vector will be projected to the normal plane, and normalized. </td></tr>
    <tr><td class="paramname">finalArcLength</td><td>Length of the computed geodesic. </td></tr>
    <tr><td class="paramname">numberOfKnotPoints</td><td>The total number of knot points used to describe the geodesic. Must be larger or equal to 2. </td></tr>
    <tr><td class="paramname">geodesicKnotPointsSink</td><td>The resulting geodesic is written to this sink as knot points at equal length intervals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa790468c4b2ac9dd6e16721b84daf548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa790468c4b2ac9dd6e16721b84daf548">&#9670;&nbsp;</a></span>shootGeodesicInDirectionImplicitly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionImplicitly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialPointApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>initialTangentApprox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>finalArcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>initialIntegratorStepSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>integratorAccuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>constraintTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structSimTK_1_1ContactGeometry_1_1GeodesicKnotPoint.html">ContactGeometry::GeodesicKnotPoint</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>geodesicKnotPointsSink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an approximate initial point and an approximate initial tangent direction compute the geodesic of given arc length implicitly. </p>
<p>The initial point will be projected to the surface, and the initial tangent projected to the normal plane before computing the geodesic. The geodesic is computed by numerical integration, and each GeodesciKnotPoint point is written to the provided sink.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialPointApprox</td><td>Coordinates of starting point in local surface coordinates. This point will be projected to the surface. </td></tr>
    <tr><td class="paramname">initialTangentApprox</td><td>Direction of geodesic at start, in local surface coordinates. This vector will be projected to the normal plane, and normalized. </td></tr>
    <tr><td class="paramname">finalArcLength</td><td>Length of the computed geodesic. </td></tr>
    <tr><td class="paramname">initialIntegratorStepSize</td><td>Initial step size used by the numerical integrator. </td></tr>
    <tr><td class="paramname">integratorAccuracy</td><td>Numerical integrator accuracy (controls the integration step size). </td></tr>
    <tr><td class="paramname">constraintTolerance</td><td>Surface constraint tolerance at the integrator knot points. </td></tr>
    <tr><td class="paramname">maxIterations</td><td>TODO not connected. </td></tr>
    <tr><td class="paramname">geodesicKnotPointsSink</td><td>The resulting geodesic is written to this sink as computed integrator knot points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88a03a49e77241257d018405e30dcb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a03a49e77241257d018405e30dcb49">&#9670;&nbsp;</a></span>continueGeodesic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::continueGeodesic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>prevGeod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the current positions of two points P and Q moving on this surface, and the previous geodesic curve G' connecting prior locations P' and Q' of those same two points, return the geodesic G between P and Q that is closest in length to the previous one. </p>
<p>If multiple equal-length geodesics are possible (rare; between poles of a sphere, for example) then the one best matching the direction of the previous geodesic is selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of starting point P, in S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xQ</td><td>Coordinates of ending point Q, in S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevGeod</td><td>The previous geodesic to which the new one should be similar. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters controlling the computation of the new geodesic. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains a geodesic between P and Q.</td></tr>
  </table>
  </dd>
</dl>
<h3>Algorithm</h3>
<p>The handling of continuity here enforces our desire to have the length of a geodesic change smoothly as its end points move over the surface. This also permits us to accelerate geodesic finding by using starting guesses that are extrapolated from the previous result. If we find that the new geodesic has changed length substantially from the previous one, we will flag the result as uncertain and the caller should reduce the integration step size.</p>
<p>First, classify the previous geodesic G' as "direct" or "indirect". Direct means that both tangents tP' and tQ' are approximately aligned with the vector r_PQ'. Note that as points P and Q get close together, as occurs prior to a cable liftoff, the geodesic between them always becomes direct and in fact just prior to liftoff it is the straight line from P to Q.</p>
<p>If G' was indirect, then G is the geodesic connecting P and Q that has tP closest to tP' and about the same length as G'. We use G' data to initialize our computation of G and perform a local search to find the closest match.</p>
<p>If G' was direct, then we look at the direction of r_PQ. If it is still aligned with the previous tP', then we calculate G from P to Q starting in direction tP', with roughly length s'. If it is anti-aligned, P and Q have swapped positions, presumably because they should have lifted off. In that case we calculate G from P to Q in direction -tP', and report that the geodesic has flipped. In that case you can consider the length s to be negative and use the value of s as an event witness for liftoff events. </p>

</div>
</div>
<a id="a936a25de7017a330823f93104fb24859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936a25de7017a330823f93104fb24859">&#9670;&nbsp;</a></span>makeStraightLineGeodesic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::makeStraightLineGeodesic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultDirectionIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a straight-line approximation to the (presumably short) geodesic between two points on this implicit surface. </p>
<p>We do not check here whether it is reasonable to treat this geodesic as a straight line; we assume the caller has made that determination.</p>
<p>We are given points P and Q and choose P' and Q' as the nearest downhill points on the surface to the given points. Then the returned geodesic line runs from P' to Q'. The <a class="el" href="classSimTK_1_1Geodesic.html" title="This class stores a geodesic curve after it has been determined.">Geodesic</a> object will contain only the start and end points of the geodesic, with all the necessary information filled in. The normals nP and nQ are calculated from the surface points P' and Q'. The binormal direction is calculated using a preferred direction vector d (see below) as bP=normalize(d X nP) and bQ=normalize(d X nQ). Then the tangents are tP=nP X bP and tQ=nQ X bQ.</p>
<p>The preferred direction d is calculated as follows: if P' and Q' are numerically indistinguishable (as defined by <a class="el" href="classSimTK_1_1Geo_1_1Point__.html#abdcd93886ac3fb0203916f5e2da270d2" title="Determine whether two points whose locations are known to an accuracy tol are numerically indistingui...">Geo::Point::pointsAreNumericallyCoincident()</a>), we'll use the given <em>defaultDirection</em> if there is one, otherwise d is an arbitrary perpendicular to nP. If P' and Q' are numerically distinguishable, we instead set d = normalize(Q-P).</p>
<p>When P' and Q' are <em>numerically</em> coincident, we will shift both of them to the midpoint (P'+Q')/2 so that the geodesic end points become <em>exactly</em> coincident and the resulting geodesic has exactly zero length. There will still be two points returned in the <a class="el" href="classSimTK_1_1Geodesic.html" title="This class stores a geodesic curve after it has been determined.">Geodesic</a> object but they will be identical. </p>

</div>
</div>
<a id="a990b672c233d2437c421408a121da4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990b672c233d2437c421408a121da4c8">&#9670;&nbsp;</a></span>shootGeodesicInDirectionUntilLengthReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionUntilLengthReached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>terminatingLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of the starting point for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tP</td><td>The starting tangent direction for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminatingLength</td><td>The length that the resulting geodesic should have. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters related to geodesic calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains the calculated geodesic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bad1de0db758a5bc13c5160951e66f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bad1de0db758a5bc13c5160951e66f5">&#9670;&nbsp;</a></span>calcGeodesicReverseSensitivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcGeodesicReverseSensitivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geodesic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>initSensitivity</em> = <code><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a>(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an already-calculated geodesic on this surface connecting points P and Q, fill in the sensitivity of point P with respect to a change of tangent direction at Q. </p>
<p>If there are interior points stored with the geodesic, then we'll calculate the interior sensitivities also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">geodesic</td><td>An already-calculated geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initSensitivity</td><td>Initial conditions for the Jacobi field calculation. If this is the whole geodesic then the initial conditions are (0,1) for the sensitivity and its arc length derivative. However, if we are continuing from another geodesic, then the end sensitivity for that geodesic is the initial conditions for this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab46d2b533f1c69f6c9b4c5ea22371f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46d2b533f1c69f6c9b4c5ea22371f27">&#9670;&nbsp;</a></span>shootGeodesicInDirectionUntilPlaneHit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionUntilPlaneHit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>terminatingPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of the starting point for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tP</td><td>The starting tangent direction for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminatingPlane</td><td>The plane in which the end point of the resulting geodesic should lie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters related to geodesic calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains the calculated geodesic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a765c08e2a56fb38546efdb48f1cda079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c08e2a56fb38546efdb48f1cda079">&#9670;&nbsp;</a></span>calcGeodesic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcGeodesic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tPhint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tQhint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to find geodesic between P and Q using split geodesic method with initial shooting directions tPhint and -tQhint. </p>

</div>
</div>
<a id="a0b44f8a2e2daa2e09341ad3085ba4eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b44f8a2e2daa2e09341ad3085ba4eae">&#9670;&nbsp;</a></span>calcGeodesicUsingOrthogonalMethod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcGeodesicUsingOrthogonalMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tPhint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a>&#160;</td>
          <td class="paramname"><em>lengthHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to find geodesic between P and Q using the orthogonal method, with initial direction tPhint and initial length lengthHint. </p>

</div>
</div>
<a id="a01fdde7022416b8d88bc1735cab1e224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fdde7022416b8d88bc1735cab1e224">&#9670;&nbsp;</a></span>calcGeodesicUsingOrthogonalMethod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcGeodesicUsingOrthogonalMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This signature makes a guess at the initial direction and length and then calls the other signature. </p>

</div>
</div>
<a id="a2d9af982b24f430502bac9c545c9abdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9af982b24f430502bac9c545c9abdc">&#9670;&nbsp;</a></span>calcSplitGeodError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> SimTK::ContactGeometry::calcSplitGeodError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *&#160;</td>
          <td class="paramname"><em>geod</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ. </p>
<p>We optionally return the resulting "kinked" geodesic in case anyone wants it; if the returned error is below tolerance then that geodesic is the good one. </p>

</div>
</div>
<a id="a754766a3425583c7e8342f7216ee6ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754766a3425583c7e8342f7216ee6ce2">&#9670;&nbsp;</a></span>shootGeodesicInDirectionUntilLengthReachedAnalytical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionUntilLengthReachedAnalytical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#ac8a16de2becf1c1eb28fa6ef2c2e5ff1">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>terminatingLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating at the given length. </p>
<p>Only possible for a few simple shapes, such as spheres and cylinders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of the starting point for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tP</td><td>The starting tangent direction for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminatingLength</td><td>The length that the resulting geodesic should have. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters related to geodesic calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains the calculated geodesic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f489bb3134725a7d1a9e584fb9da903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f489bb3134725a7d1a9e584fb9da903">&#9670;&nbsp;</a></span>shootGeodesicInDirectionUntilPlaneHitAnalytical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::shootGeodesicInDirectionUntilPlaneHitAnalytical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>terminatingPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1GeodesicOptions.html">GeodesicOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analytically compute a geodesic curve starting at the given point, starting in the given direction, and terminating when it hits the given plane. </p>
<p>Only possible for a few simple shapes, such as spheres and cylinders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xP</td><td>Coordinates of the starting point for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tP</td><td>The starting tangent direction for the geodesic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminatingPlane</td><td>The plane in which the end point of the resulting geodesic should lie. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Parameters related to geodesic calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geod</td><td>On exit, this contains the calculated geodesic </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c12e31eb56f265f70c682554c471649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c12e31eb56f265f70c682554c471649">&#9670;&nbsp;</a></span>calcGeodesicAnalytical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::calcGeodesicAnalytical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>xQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tPhint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tQhint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> &amp;&#160;</td>
          <td class="paramname"><em>geod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to analytically find geodesic between P and Q with initial shooting directions tPhint and tQhint. </p>
<p>Only possible for a few simple shapes, such as spheres and cylinders. </p>

</div>
</div>
<a id="a1393837d0460e675354885666fff43ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1393837d0460e675354885666fff43ea">&#9670;&nbsp;</a></span>calcSplitGeodErrorAnalytical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MatVecTypedefs.html#ga2a20abe30c8427eb7a51af21a21de82e">Vec2</a> SimTK::ContactGeometry::calcSplitGeodErrorAnalytical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__MatVecTypedefs.html#gae91357250892ce29d39ebf17e2aa85da">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSimTK.html#a880c082e02fe87b78798e9f75d4d2ae5">UnitVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>tQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a> *&#160;</td>
          <td class="paramname"><em>geod</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to analytically calculate the "geodesic error" between one geodesic shot from P in the direction tP and another geodesic shot from Q in the direction tQ. </p>
<p>We optionally return the resulting "kinked" geodesic in case anyone wants it; if the returned error is below tolerance then that geodesic is the good one. Only possible for a few simple shapes, such as spheres and cylinders. </p>

</div>
</div>
<a id="a2bcf119352496ba829cf6783c9fb3e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcf119352496ba829cf6783c9fb3e1c">&#9670;&nbsp;</a></span>getPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a>&amp; SimTK::ContactGeometry::getPlane </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the plane associated with the geodesic hit plane event handler <br  />
 </p>

</div>
</div>
<a id="a2b64dde0ca2dfcd094b0b6204f4a21b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b64dde0ca2dfcd094b0b6204f4a21b6">&#9670;&nbsp;</a></span>setPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::setPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSimTK_1_1Plane.html">Plane</a> &amp;&#160;</td>
          <td class="paramname"><em>plane</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the plane associated with the geodesic hit plane event handler <br  />
 </p>

</div>
</div>
<a id="aa25147aeb5d31211fbf031a0dac23132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25147aeb5d31211fbf031a0dac23132">&#9670;&nbsp;</a></span>getGeodP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a>&amp; SimTK::ContactGeometry::getGeodP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the geodesic for access by visualizer. </p>

</div>
</div>
<a id="aecdaf2ca0c1905728867539f33765133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdaf2ca0c1905728867539f33765133">&#9670;&nbsp;</a></span>getGeodQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSimTK_1_1Geodesic.html">Geodesic</a>&amp; SimTK::ContactGeometry::getGeodQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the geodesic for access by visualizer. </p>

</div>
</div>
<a id="a194ad90ea8cba0a176b5e0982d2b1997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194ad90ea8cba0a176b5e0982d2b1997">&#9670;&nbsp;</a></span>getNumGeodesicsShot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int SimTK::ContactGeometry::getNumGeodesicsShot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the plane associated with the geodesic hit plane event handler <br  />
 </p>

</div>
</div>
<a id="ae4542caabc4680f44e5a696caf303e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4542caabc4680f44e5a696caf303e86">&#9670;&nbsp;</a></span>addVizReporter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimTK::ContactGeometry::addVizReporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimTK_1_1ScheduledEventReporter.html">ScheduledEventReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the plane associated with the geodesic hit plane event handler <br  />
 </p>

</div>
</div>
<a id="aa335794fd91bf6ed25be4d1c6a5fc527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa335794fd91bf6ed25be4d1c6a5fc527">&#9670;&nbsp;</a></span>isOwnerHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isOwnerHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<a id="a959dc355f4f7f04f5d5eb9a3daf95b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959dc355f4f7f04f5d5eb9a3daf95b3d">&#9670;&nbsp;</a></span>isEmptyHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::isEmptyHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<a id="a3712ed3c23bf8fc01874be710d3f077a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3712ed3c23bf8fc01874be710d3f077a">&#9670;&nbsp;</a></span>hasImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SimTK::ContactGeometry::hasImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<a id="a9b135711e8d5966b36a954f0c3cc5d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b135711e8d5966b36a954f0c3cc5d0e">&#9670;&nbsp;</a></span>getImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ContactGeometryImpl&amp; SimTK::ContactGeometry::getImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<a id="af1bbdd8a3d084c2030b29d9618b64a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bbdd8a3d084c2030b29d9618b64a28">&#9670;&nbsp;</a></span>updImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContactGeometryImpl&amp; SimTK::ContactGeometry::updImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a03ff2fddea5008e383fa7588bb813837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ff2fddea5008e383fa7588bb813837">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContactGeometryImpl* SimTK::ContactGeometry::impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal use only. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ContactGeometry_8h_source.html">ContactGeometry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSimTK.html">SimTK</a></li><li class="navelem"><a class="el" href="classSimTK_1_1ContactGeometry.html">ContactGeometry</a></li>
    <li class="footer">Generated on Sat May 17 2025 15:42:32 for Simbody by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
